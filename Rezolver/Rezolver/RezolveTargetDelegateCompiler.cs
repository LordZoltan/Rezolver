using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

namespace Rezolver
{
	public class RezolveTargetDelegateCompiler : IRezolveTargetCompiler
	{
		public static readonly IRezolveTargetCompiler Default = new RezolveTargetDelegateCompiler();

		public class DelegatingCompiledRezolveTarget : ICompiledRezolveTarget
		{
			private readonly Func<RezolveContext, object> _getObjectDelegate;

			public DelegatingCompiledRezolveTarget(Func<RezolveContext, object> getObjectDelegate)
			{
				_getObjectDelegate = getObjectDelegate;
			}

			public object GetObject(RezolveContext context)
			{
				return _getObjectDelegate(context);
			}
		}

		public ICompiledRezolveTarget CompileTarget(IRezolveTarget target, CompileContext context)
		{
			context = new CompileContext(context, typeof(object), false);
			var toBuild = target.CreateExpression(context);

			//if we have shared conditionals, then we want to try and reorder them as the intention
			//of the use of shared expressions is to consolidate them into one.  We do this on the boolean
			//expressions that might be used as tests for conditionals
			var sharedConditionalTests = context.SharedExpressions.Where(e => e.Type == typeof(Boolean)).ToArray();
			if (sharedConditionalTests.Length != 0)
				toBuild = new ConditionalRewriter(toBuild, sharedConditionalTests).Rewrite();

			toBuild = toBuild.Optimise();
			
			//shared locals are local variables generated by targets that would normally be duplicated
			//if multiple targets of the same type are used in one compiled target.  By sharing them,
			//they reduce the size of the stack required for any generated code, but in turn 
			//the compiler is required to lift them out and add them to an all-encompassing BlockExpression
			//surrounding all the code - otherwise they won't be in scope.
			var sharedLocals = context.SharedExpressions.OfType<ParameterExpression>().ToArray();
			if (sharedLocals.Length != 0)
				toBuild = Expression.Block(toBuild.Type, sharedLocals, toBuild);
#if DEBUG
			var expression =
				Expression.Lambda<Func<RezolveContext, object>>(toBuild, context.RezolveContextParameter);
			Debug.WriteLine("Compiling Func<RezolveContext, object> from static lambda {0} for target type {1}", expression, "System.Object");
			return new DelegatingCompiledRezolveTarget(expression.Compile());
#else
			return new DelegatingCompiledRezolveTarget(
				Expression.Lambda<Func<RezolveContext, object>>(toBuild, context.RezolveContextParameter).Compile());
#endif
		}
	}
}