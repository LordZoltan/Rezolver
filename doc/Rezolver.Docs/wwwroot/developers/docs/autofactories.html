<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
  	<meta charset="utf-8">
  	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  	<title>Autofactories | Rezolver IOC </title>
  	<meta name="viewport" content="width=device-width">
  	<meta name="title" content="Autofactories | Rezolver IOC ">
  	<meta name="generator" content="docfx 2.43.2.0">
  	<meta name="description" content="Rezolver is an open-source IOC container framework for .Net Core">
  	<link rel="shortcut icon" href="../favicon.ico">
  	<link rel="stylesheet" href="../styles/docfx.vendor.css">
  	<link rel="stylesheet" href="../styles/docfx.css">
  	<link rel="stylesheet" href="../styles/main.css">
  	<meta property="docfx:navrel" content="../toc.html">
  	<meta property="docfx:tocrel" content="toc.html">
  	
  	<meta property="docfx:rel" content="../">
  	
  		<link rel="apple-touch-icon" sizes="57x57" href="../../apple-touch-icon-57x57.png">
  		<link rel="apple-touch-icon" sizes="60x60" href="../../apple-touch-icon-60x60.png">
  		<link rel="apple-touch-icon" sizes="72x72" href="../../apple-touch-icon-72x72.png">
  		<link rel="apple-touch-icon" sizes="76x76" href="../../apple-touch-icon-76x76.png">
  		<link rel="apple-touch-icon" sizes="114x114" href="../../apple-touch-icon-114x114.png">
  		<link rel="apple-touch-icon" sizes="120x120" href="../../apple-touch-icon-120x120.png">
  		<link rel="apple-touch-icon" sizes="144x144" href="../../apple-touch-icon-144x144.png">
  		<link rel="apple-touch-icon" sizes="152x152" href="../../apple-touch-icon-152x152.png">
  		<link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon-180x180.png">
  		<link rel="icon" type="image/png" href="../../favicon-32x32.png" sizes="32x32">
  		<link rel="icon" type="image/png" href="../../android-chrome-192x192.png" sizes="192x192">
  		<link rel="icon" type="image/png" href="../../favicon-96x96.png" sizes="96x96">
  		<link rel="icon" type="image/png" href="../../favicon-16x16.png" sizes="16x16">
  		<link rel="manifest" href="../../manifest.json">
  		<link rel="mask-icon" href="../../safari-pinned-tab.svg" color="#5bbad5">
  		<meta name="msapplication-TileColor" content="#da532c">
  		<meta name="msapplication-TileImage" content="../../mstile-144x144.png">
  		<meta name="theme-color" content="#ffffff">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container-fluid">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../../images/rz_square_white_on_orange_48x48.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
        		<p class="navbar-text navbar-right github-link"><a href="http://github.com/ZolutionSoftware/Rezolver" target="_blank" title="See this project on Github"><span class="fa fa-github"></span></a></p>
        		<form class="navbar-form navbar-right" role="search" id="search">
        		<div class="form-group">
        			<input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
        		</div>
        		</form>
        		<p class="navbar-text navbar-right">
        			<a href="https://www.nuget.org/packages/Rezolver" target="_blank"><img src="//img.shields.io/nuget/v/Rezolver.svg?style=plastic&amp;maxage=480" title="Get the Nuget Package"></a>
        		</p>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container-fluid hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container-fluid body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-9">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="autofactories">Autofactories</h1>

<p>Framework authors frequently need to be able to create instances of other developers&#39; objects on-demand.  When an application is 
configured to run via an IOC container, this often means one of two things:</p>
<ul>
<li>Taking a dependency on an instance of the IOC container<ul>
<li><em>This can be achieved in Rezolver either by injecting an instance of <a class="xref" href="../api/Rezolver.ResolveContext.html">ResolveContext</a> or <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.iserviceprovider">IServiceProvider</a></em></li>
</ul>
</li>
<li>Taking a dependency on a factory delegate</li>
</ul>
<p>The second of these two approaches is something that can be set up in Rezolver manually as follows:</p>
<pre><code class="lang-csharp" name="DelegateExamples.cs">container.RegisterType&lt;MyService1&gt;();
container.RegisterType&lt;MyService2&gt;();
container.RegisterDelegate(context =&gt; new Func&lt;Type, object&gt;(t =&gt; context.Resolve(t)));

var factory = container.Resolve&lt;Func&lt;Type, object&gt;&gt;();

var service1 = factory(typeof(MyService1));
var service2 = factory(typeof(MyService2));

Assert.IsType&lt;MyService1&gt;(service1);
Assert.IsType&lt;MyService2&gt;(service2);
</code></pre><p>This creates a registration that will provide a general-purpose factory to resolve any type - in a way that honours the current scope - 
back through the container, but without exposing the container to the calling code.</p>
<p>However, this isn&#39;t terribly nice to work with at runtime (the factory delegate is far too &#39;open&#39; - most of the time we&#39;d want to 
limit the types that could be passed) and if we want to have more focused factories (e.g. <code>Func&lt;MyService&gt;</code>) then we would need 
a registration like this for each individual type that we&#39;d want to create instances of - which defeats the point.</p>
<h1 id="examples">Examples</h1>
<h2 id="basic-functionality">Basic functionality</h2>
<p>Starting with Rezolver 1.4, however, Rezolver makes this kind of registration trivial, and also gives you some extra power.</p>
<p>The <a class="xref" href="../api/Rezolver.RootTargetContainerExtensions.html#Rezolver_RootTargetContainerExtensions_RegisterAutoFunc_">RegisterAutoFunc</a> overload provides a simple way to enable Rezolver to automatically
inject a <a class="xref" href="https://docs.microsoft.com/dotnet/api/system.func-1">Func&lt;TResult&gt;</a> or one of its related types, using its own registrations as the source of the object that is produced by that
factory when it is executed.</p>
<pre><code class="lang-csharp" name="AutoFactoryExamples.cs">var container = new Container();
container.RegisterType&lt;MyService1, IMyService&gt;();
container.RegisterAutoFunc&lt;IMyService&gt;();

var factory = container.Resolve&lt;Func&lt;IMyService&gt;&gt;();
var instance = factory();

Assert.IsType&lt;MyService1&gt;(instance);
</code></pre><p>It also supports enumerables - either as the created type:</p>
<pre><code class="lang-csharp" name="AutoFactoryExamples.cs">container.RegisterType&lt;MyService1, IMyService&gt;();
container.RegisterType&lt;MyService2, IMyService&gt;();
container.RegisterType&lt;MyService3, IMyService&gt;();
container.RegisterAutoFunc&lt;IEnumerable&lt;IMyService&gt;&gt;();

var factory = container.Resolve&lt;Func&lt;IEnumerable&lt;IMyService&gt;&gt;&gt;();
var instances = factory();  // will contain three instances
</code></pre><p>Or to resolve an enumerable of factories</p>
<pre><code class="lang-csharp" name="AutoFactoryExamples.cs">container.RegisterAutoFunc&lt;IMyService&gt;();

// will contain three funcs, one for each registration compatible with
// IMyService, thanks to enumerable covariance.
var factories = container.ResolveMany&lt;Func&lt;IMyService&gt;&gt;();
var instances = factories.Select(f =&gt; f());
</code></pre><p>All of the above works for custom delegate types, too (so long as they have a non-<code>void</code> return type), via the 
<a class="xref" href="../api/Rezolver.RootTargetContainerExtensions.html#Rezolver_RootTargetContainerExtensions_RegisterAutoFactory_">RegisterAutoFactory</a> overload:</p>
<pre><code class="lang-csharp" name="AutoFactoryExamples.cs">public delegate IMyService MyServiceFactory();
</code></pre><pre><code class="lang-csharp" name="AutoFactoryExamples.cs">container.RegisterAutoFactory&lt;MyServiceFactory&gt;();

var factories = container.ResolveMany&lt;MyServiceFactory&gt;();
var instances = factories.Select(f =&gt; f());
</code></pre><h2 id="using-arguments-for-dependencies">Using arguments for dependencies</h2>
<p>So far, all the delegates we&#39;ve been building are nullary - that is, they have no parameters.  After all, what could Rezolver
possibly do with the arguments that you supply?  Well, the answer is that it can use them to fulfil any dependencies that are
required by any of the registrations used to by the delegate it creates:</p>
<pre><code class="lang-csharp" name="AutoFactoryExamples.cs">container.RegisterType&lt;MyService1, IMyService&gt;();
container.RegisterType&lt;RequiresIMyService, IRequiresIMyService&gt;();
container.RegisterAutoFunc&lt;IMyService, IRequiresIMyService&gt;();

var factory = container.Resolve&lt;Func&lt;IMyService, IRequiresIMyService&gt;&gt;();
var myService2 = new MyService2();

var instance = factory(myService2);

Assert.Same(instance.Service, myService2);
</code></pre><div class="WARNING"><h5>Warning</h5><p>All parameter types <strong><em>must</em></strong> be unique otherwise the registration call will fail!</p>
</div>
<div class="TIP"><h5>Tip</h5><p>Argument values are matched by <strong><em>type</em></strong> to dependencies which are being satisfied internally by the <a class="xref" href="../api/Rezolver.Targets.ResolvedTarget.html">ResolvedTarget</a>
when the delegate return type is resolved normally.  Most typically, this means arguments for constructor parameters.</p>
<p>This overriding of dependencies flows all the way down through all registrations which are used to satisfy a particular
factory&#39;s output type - so if an argument type appears in the constructor of, save, five objects which are all built as part
of a particular request, then all five constructor calls will receive the argument instead of an instance produced by the container.</p>
</div>
<p>This also works even if no registrations exist for the dependency type - shown below where we omit the registration
of the <code>IMyService</code> implementation:</p>
<pre><code class="lang-csharp" name="AutoFactoryExamples.cs">container.RegisterType&lt;RequiresIMyService, IRequiresIMyService&gt;();
container.RegisterAutoFunc&lt;IMyService, IRequiresIMyService&gt;();

var factory = container.Resolve&lt;Func&lt;IMyService, IRequiresIMyService&gt;&gt;();
var myService2 = new MyService2();

var instance = factory(myService2);
</code></pre><p>This functionality is particularly powerful in generic scenarios where you have a component which is responsible for handling
user-supplied objects at runtime that you can&#39;t inject via the container.</p>
<p>Again, all of this works with custom delegate types, too.</p>
<h2 id="scopes-and-factories">Scopes and factories</h2>
<p>The objects produced by Autofactories are tied to the scope that created the autofactory:</p>
<pre><code class="lang-csharp" name="AutoFactoryExamples.cs">container.RegisterScoped&lt;MyService, IMyService&gt;();
container.RegisterType&lt;DisposableType&gt;();
container.RegisterAutoFunc&lt;IMyService&gt;();
container.RegisterAutoFunc&lt;DisposableType&gt;();

DisposableType outerDisposable, innerDisposable;

using (var scope = container.CreateScope())
{
    // get two funcs for IMyService
    var f1 = scope.Resolve&lt;Func&lt;IMyService&gt;&gt;();
    var f2 = scope.Resolve&lt;Func&lt;IMyService&gt;&gt;();
    var f3 = scope.Resolve&lt;Func&lt;DisposableType&gt;&gt;();

    // different funcs...
    Assert.NotSame(f1, f2);

    var service1 = f1();
    var service2 = f2();

    //... but same instances because MyService was registered as Scoped.
    Assert.Same(service1, service2); 

    outerDisposable = f3();

    using(var childScope = scope.CreateScope())
    {
        var f4 = childScope.Resolve&lt;Func&lt;DisposableType&gt;&gt;();
        innerDisposable = f4();
    }

    Assert.True(innerDisposable.Disposed);
    Assert.False(outerDisposable.Disposed);
}
Assert.True(outerDisposable.Disposed);
</code></pre><div class="WARNING"><h5>Warning</h5><p>Executing a factory which was produced from a scope that is now disposed will result in an <code>ObjectDisposedException</code>
being thrown.</p>
</div>
<h2 id="generics">Generics</h2>
<p>With the <a class="xref" href="../api/Rezolver.RootTargetContainerExtensions.html#Rezolver_RootTargetContainerExtensions_RegisterAutoFactory_">RegisterAutoFactory</a> method, Rezolver is also capable of injecting
delegates whose result is an open generic.  When requested, Rezolver will build a delegate of the closed version of that
generic:</p>
<pre><code class="lang-csharp" name="AutoFactoryExamples.cs">public interface IWrapper&lt;T&gt;
{
    T InnerValue { get; }
}

public class Wrapper&lt;T&gt; : IWrapper&lt;T&gt;
{
    public Wrapper(T innerValue)
    {
        InnerValue = innerValue;
    }

    public T InnerValue { get; }
}
</code></pre><pre><code class="lang-csharp" name="AutoFactoryExamples.cs">container.RegisterObject(10);
container.RegisterObject(&quot;hello world&quot;);
container.RegisterType(typeof(Wrapper&lt;&gt;), typeof(IWrapper&lt;&gt;));
container.RegisterAutoFactory(typeof(Func&lt;&gt;).MakeGenericType(typeof(IWrapper&lt;&gt;)));

var f1 = container.Resolve&lt;Func&lt;IWrapper&lt;int&gt;&gt;&gt;();
var f2 = container.Resolve&lt;Func&lt;IWrapper&lt;string&gt;&gt;&gt;();

var w1 = f1();
var w2 = f2();

Assert.Equal(10, w1.InnerValue);
Assert.Equal(&quot;hello world&quot;, w2.InnerValue);
</code></pre><p><a name="automatic"></a></p>
<h1 id="automatic-functreturn-injection">Automatic <code>Func&lt;TReturn&gt;</code> Injection</h1>
<p>By default, all autofactory injection is <em>opt-in</em> using the registration functions shown on this page.</p>
<p>It is possible, however, to configure a Rezolver container to be able to automatically inject <code>Func&lt;TReturn&gt;</code> delegates,
with the <a class="xref" href="../api/Rezolver.Options.EnableAutoFuncInjection.html">EnableAutoFuncInjection</a> option.  As with all options in Rezolver, you have two main ways of
configuring this.</p>
<p>The first, and easiest, is to modify the <a class="xref" href="../api/Rezolver.TargetContainer.html#Rezolver_TargetContainer_DefaultConfig">DefaultConfig</a> like this:</p>
<pre><code class="lang-csharp" name="AutoFactoryExamples.cs">TargetContainer
    .DefaultConfig
    .ConfigureOption&lt;EnableAutoFuncInjection&gt;(true);

var container = new Container();
container.RegisterObject(&quot;Hello world&quot;);

var f1 = container.Resolve&lt;Func&lt;string&gt;&gt;();

Assert.Equal(&quot;Hello world&quot;, f1());
</code></pre><p>The other way is to <em>clone</em> the default configuration, apply the option on the new instance and then explictly
create the <a class="xref" href="../api/Rezolver.IRootTargetContainer.html">IRootTargetContainer</a> that your <a class="xref" href="../api/Rezolver.Container.html">Container</a> (or <a class="xref" href="../api/Rezolver.ScopedContainer.html">ScopedContainer</a>) will
use to source its registrations:</p>
<pre><code class="lang-csharp" name="AutoFactoryExamples.cs">var config = TargetContainer
    .DefaultConfig
    .Clone()    // clone the configuration
    .ConfigureOption&lt;EnableAutoFuncInjection&gt;(true);

// create the container but pass a new TargetContainer 
// to it which has been passed the configuration.
var container = new Container(new TargetContainer(config));

container.RegisterObject(&quot;Hello world&quot;);

var f1 = container.Resolve&lt;Func&lt;string&gt;&gt;(); // f1() == &quot;Hello World&quot;
</code></pre><p>Where possible, you should try to opt for the second solution.  Indeed, if you are using the 
<a href="nuget-packages/rezolver.microsoft.aspnetcore.hosting.html">Asp.Net Core</a> or 
<a href="nuget-packages/rezolver.microsoft.extensions.hosting.html">Generic Host</a> integration packages then you can supply a callback
to the <a class="xref" href="../api/Microsoft.AspNetCore.Hosting.RezolverServiceProviderWebHostBuilderExtensions.html#Microsoft_AspNetCore_Hosting_RezolverServiceProviderWebHostBuilderExtensions_UseRezolver_"><code>IWebHostBuilder.UseRezolver</code> extension method</a>
or the <a class="xref" href="../api/Microsoft.Extensions.Hosting.RezolverHostBuilderExtensions.html#Microsoft_Extensions_Hosting_RezolverHostBuilderExtensions_UseRezolver_"><code>IHostBuilder.UseRezolver</code> extension methods</a>
which give you the opportunity to modify the <a class="xref" href="../api/Rezolver.CombinedTargetContainerConfig.html">CombinedTargetContainerConfig</a> before the target container is created.</p>
<hr>
<h1 id="see-also">See also</h1>
<p><a href="lazy.html">Automatic Lazy Injection</a> is a feature which builds on the topics discussed here to enable the automatic injection
of <code>Lazy&lt;T&gt;</code>.</p>
</article>
          </div>
          <div class="hidden-sm col-md-3" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/ZolutionSoftware/Rezolver/blob/master/doc/Rezolver.Docs/_docfx_proj/docs/autofactories.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>Copyright &copy;2014 onwards <a href="http://www.zolution.co.uk" target="_blank">Zolution Software Ltd</a><br>Generated by <a href="https://dotnet.github.io/docfx/" target="_blank">DocFX</a>, with the Rezolver theme</span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
