<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
  	<meta charset="utf-8">
  	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  	<title>Automatic Enumerable Injection | Rezolver IOC </title>
  	<meta name="viewport" content="width=device-width">
  	<meta name="title" content="Automatic Enumerable Injection | Rezolver IOC ">
  	<meta name="generator" content="docfx 2.40.2.0">
  	<meta name="description" content="Rezolver is the portable open-source IOC container framework for .Net - built from the ground up for .Net Core, Asp.Net Core, and also optimised for the 'full .Net' :)">
  	<link rel="shortcut icon" href="../favicon.ico">
  	<link rel="stylesheet" href="../styles/docfx.vendor.css">
  	<link rel="stylesheet" href="../styles/docfx.css">
  	<link rel="stylesheet" href="../styles/main.css">
  	<meta property="docfx:navrel" content="../toc.html">
  	<meta property="docfx:tocrel" content="toc.html">
  	
  	<meta property="docfx:rel" content="../">
  	
  		<link rel="apple-touch-icon" sizes="57x57" href="../../apple-touch-icon-57x57.png">
  		<link rel="apple-touch-icon" sizes="60x60" href="../../apple-touch-icon-60x60.png">
  		<link rel="apple-touch-icon" sizes="72x72" href="../../apple-touch-icon-72x72.png">
  		<link rel="apple-touch-icon" sizes="76x76" href="../../apple-touch-icon-76x76.png">
  		<link rel="apple-touch-icon" sizes="114x114" href="../../apple-touch-icon-114x114.png">
  		<link rel="apple-touch-icon" sizes="120x120" href="../../apple-touch-icon-120x120.png">
  		<link rel="apple-touch-icon" sizes="144x144" href="../../apple-touch-icon-144x144.png">
  		<link rel="apple-touch-icon" sizes="152x152" href="../../apple-touch-icon-152x152.png">
  		<link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon-180x180.png">
  		<link rel="icon" type="image/png" href="../../favicon-32x32.png" sizes="32x32">
  		<link rel="icon" type="image/png" href="../../android-chrome-192x192.png" sizes="192x192">
  		<link rel="icon" type="image/png" href="../../favicon-96x96.png" sizes="96x96">
  		<link rel="icon" type="image/png" href="../../favicon-16x16.png" sizes="16x16">
  		<link rel="manifest" href="../../manifest.json">
  		<link rel="mask-icon" href="../../safari-pinned-tab.svg" color="#5bbad5">
  		<meta name="msapplication-TileColor" content="#da532c">
  		<meta name="msapplication-TileImage" content="../../mstile-144x144.png">
  		<meta name="theme-color" content="#ffffff">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../../images/rz_square_white_on_orange_48x48.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
        		<p class="navbar-text navbar-right github-link"><a href="http://github.com/ZolutionSoftware/Rezolver" target="_blank" title="See this project on Github"><span class="fa fa-github"></span></a></p>
        		<form class="navbar-form navbar-right" role="search" id="search">
        		<div class="form-group">
        			<input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
        		</div>
        		</form>
        		<p class="navbar-text navbar-right">
        			<a href="https://www.nuget.org/packages/Rezolver" target="_blank"><img src="//img.shields.io/nuget/v/Rezolver.svg?style=plastic&amp;maxage=480" title="Get the Nuget Package"></a>
        			<a href="http://waffle.io/ZolutionSoftware/Rezolver" title="Open the Waffleboard for this project" target="_blank"><img alt="Work in Progress" src="https://badge.waffle.io/ZolutionSoftware/Rezolver.png?label=in%20progress&title=In%20Progress"></a>
        			<!-- <a href="http://waffle.io/ZolutionSoftware/Rezolver" title="Open the Waffleboard for this project" target="_blank"><img alt="Work prepared" src="https://badge.waffle.io/ZolutionSoftware/Rezolver.png?label=ready&title=Ready"></img></a> -->
        		</p>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="automatic-enumerable-injection">Automatic Enumerable Injection</h1>

<p>By default, a <a class="xref" href="../api/Rezolver.TargetContainer.html">TargetContainer</a> (the default <a class="xref" href="../api/Rezolver.ITargetContainer.html">ITargetContainer</a> used by all containers in the 
Rezolver framework) is configured to allow any <a class="xref" href="../api/Rezolver.ContainerBase.html">ContainerBase</a> derivative to resolve an <code>IEnumerable&lt;Service&gt;</code>.</p>
<p>The contents of this enumerable will depend on how many times the <a class="xref" href="../api/Rezolver.ITargetContainer.html#Rezolver_ITargetContainer_Register_">Register</a>
method has been called against the target type <code>Service</code>:</p>
<ul>
<li>If no target has been registered against the type, then the enumerable will be empty</li>
<li>Otherwise, the enumerable will contain instances obtained from each <a class="xref" href="../api/Rezolver.ITarget.html">ITarget</a> that was registered
against that type, or any type compatible with it, in the order they were registered.</li>
</ul>
<div class="NOTE"><h5>Note</h5><p>The functionality described here depends on two target container options: <a class="xref" href="../api/Rezolver.Options.AllowMultiple.html">AllowMultiple</a> 
and <a class="xref" href="../api/Rezolver.Options.EnableEnumerableInjection.html">EnableEnumerableInjection</a> - which are both configured to be equivalent to <code>true</code> by 
default for all <a class="xref" href="../api/Rezolver.ITargetContainer.html">ITargetContainer</a> instances.</p>
</div>
<p>You are not restricted in the targets you use to produce instances for an enumerable (e.g. <a class="xref" href="../api/Rezolver.Targets.ObjectTarget.html">ObjectTarget</a>,
<a class="xref" href="../api/Rezolver.Targets.ConstructorTarget.html">ConstructorTarget</a> or <a class="xref" href="../api/Rezolver.Targets.DelegateTarget.html">DelegateTarget</a>), and each one can have its
own lifetime (scoped/singleton etc).</p>
<div class="TIP"><h5>Tip</h5><p>By default, Rezolver will build &#39;lazy&#39; enumerables, but can be configured to build &#39;eager&#39; enumerables - for
more on this, read the topic <a href="enumerables/lazy-vs-eager.html">Lazy vs Eager Enumerables</a></p>
</div>
<div class="WARNING"><h5>Warning</h5><p>In an Asp.Net Core 2.0 application, however, eager enumerables are the default until the fix for 
<a href="https://github.com/aspnet/DependencyInjection/issues/589">this issue in the aspnet/DependencyInjection repo</a>
has been pushed to an official package release.</p>
</div>
<h2 id="order-of-enumerables">Order of enumerables</h2>
<p>The order that Rezolver&#39;s automatic enumerables return their items is <strong>always</strong> equal to the order in which 
the underlying registrations were made.</p>
<h2 id="resolving-enumerables">Resolving enumerables</h2>
<p>To resolve an enumerable from a container or through a scope, you can simply use <code>IEnumerable&lt;Foo&gt;</code> as the input
type for a <a class="xref" href="../api/Rezolver.IContainer.html#Rezolver_IContainer_Resolve_">Resolve</a> call:</p>
<pre><code class="lang-cs">var enumerable = container.Resolve&lt;IEnumerable&lt;Foo&gt;&gt;();
</code></pre><p>However, the <code>ResolveMany</code> extension methods (see <a class="xref" href="../api/Rezolver.ContainerResolveExtensions.html#Rezolver_ContainerResolveExtensions_ResolveMany_">ResolveMany</a>
and <a class="xref" href="../api/Rezolver.ContainerScopeResolveExtensions.html#Rezolver_ContainerScopeResolveExtensions_ResolveMany_">ResolveMany</a>) provide a shortcut which allow you to pass
just the element type of the enumerable to reduce the &#39;angle-bracket percent&#39; of code which directly resolves
enumerables (which of course you won&#39;t be doing because you&#39;re not using &#39;service location&#39; are you!? <span class="emoji" shortcode="wink">😉</span> ):</p>
<pre><code class="lang-cs">// this is equivalent to resolving IEnumerable&lt;Foo&gt;
var enumerable2 = container.ResolveMany&lt;Foo&gt;();
</code></pre><p>Most, if not all, the examples in this section use this shortcut - but it&#39;s worth noting that the two methods are
absolutely equivalent.</p>
<h2 id="empty-enumerable">Empty enumerable</h2>
<p>By default, you don&#39;t need to register anything against a particular type in order to be able to inject an enumerable
of that type.  If there are no registrations, then an empty enumerable will be injected instead.</p>
<p>Here&#39;s an example where we only register the service we&#39;re going to create, which has a single constructor that requires
an <code>IEnumerable&lt;IMyService&gt;</code>.</p>
<p>First, the type <code>RequiresEnumerableOfServices</code>:</p>
<pre><code class="lang-csharp" name="RequiresEnumerableOfServices.cs">public class RequiresEnumerableOfServices
{
    public IEnumerable&lt;IMyService&gt; Services { get; }
    public RequiresEnumerableOfServices(IEnumerable&lt;IMyService&gt; services)
    {
        Services = services;
    }
}
</code></pre><p>And then the test:</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
container.RegisterType&lt;RequiresEnumerableOfServices&gt;();

var result = container.Resolve&lt;RequiresEnumerableOfServices&gt;();
Assert.Empty(result.Services);
</code></pre><h2 id="multiple-new-objects">Multiple new objects</h2>
<p>Here, we associate three types (created by constructor injection) to a common service type, which are all then included
in the auto-injected enumerable:</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
var expectedTypes = new[] {
    typeof(MyService1), typeof(MyService2), typeof(MyService3)
};

foreach (var t in expectedTypes)
{
    container.RegisterType(t, typeof(IMyService));
}
container.RegisterType&lt;RequiresEnumerableOfServices&gt;();

var result = container.Resolve&lt;RequiresEnumerableOfServices&gt;();
Assert.Equal(3, result.Services.Count());
Assert.All(
    result.Services.Zip(
        expectedTypes,
        (s, t) =&gt; (service: s, expectedType: t)
    ),
    t =&gt; Assert.IsType(t.expectedType, t.service));
</code></pre><h2 id="mixed-itarget-types">Mixed <code>ITarget</code> types</h2>
<p>This time, we&#39;re mixing it up a bit by registering multiple different target types (a constructor target, a delegate
target and an object target), <em>and</em> we&#39;re also using a delegate to create the <code>RequiresEnumerableOfServices</code> just
to show that the enumerable can be injected into a delegate as you&#39;d expect:</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
container.RegisterType&lt;MyService1, IMyService&gt;();
container.RegisterDelegate&lt;IMyService&gt;(() =&gt; new MyService2());
container.RegisterObject&lt;IMyService&gt;(new MyService3());

// shows also that injection of IEnumerables holds wherever injection
// is normally supported - such as here, with delegate argument injection
container.RegisterDelegate((IEnumerable&lt;IMyService&gt; services) =&gt;
{
    // if MyService4 is missing, add it to the enumerable
    if (!services.OfType&lt;MyService4&gt;().Any())
        services = services.Concat(new[] { new MyService4() });
    return new RequiresEnumerableOfServices(services);
});

var result = container.Resolve&lt;RequiresEnumerableOfServices&gt;();

Assert.Equal(4, result.Services.Count());
// just check they&#39;re all different types this time.
Assert.Equal(4, result.Services.Select(s =&gt; s.GetType()).Distinct().Count());
</code></pre><h2 id="mixed-lifetimes">Mixed lifetimes</h2>
<p>When registering targets, you have three lifetimes at your disposal:</p>
<ul>
<li>Transient (a new object created for every <a class="xref" href="../api/Rezolver.IContainer.html#Rezolver_IContainer_Resolve_">Resolve</a> call)</li>
<li>Singleton (only one object is ever created)</li>
<li>Scoped (one object created per <a class="xref" href="../api/Rezolver.IContainerScope.html">IContainerScope</a>)</li>
</ul>
<div class="NOTE"><h5>Note</h5><p>Of course, the <a class="xref" href="../api/Rezolver.Targets.ObjectTarget.html">ObjectTarget</a> (see <a href="objects.html">objects as services</a>) is technically a singleton, also,
but that&#39;s because it wraps a constant reference supplied by you.</p>
</div>
<p>If you register multiple targets for the same type, <strong><em>and</em></strong> those targets have different lifetimes, then those lifetimes are
honoured if the container injects an <code>IEnumerable&lt;&gt;</code>.</p>
<p>The following example registers three implementations for <code>IMyService</code> again which will appear in the enumerables in the 
following positions:</p>
<ul>
<li><code>[0]</code>: A singleton </li>
<li><code>[1]</code>: A scoped object</li>
<li><code>[2]</code>: A transient</li>
</ul>
<p>It then resolves <code>IEnumerable&lt;IMyService&gt;</code> multiple times - twice from the root container (which
is a <a class="xref" href="../api/Rezolver.ScopedContainer.html">ScopedContainer</a> so that the scoped <code>MyService2</code> registration has a scope to &#39;live&#39; in) and then
twice again from a child scope:</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">// since we&#39;re using a scoped registration here,
// we&#39;ll use the ScopedContainer, which establishes
// a root scope.
var container = new ScopedContainer();

container.RegisterSingleton&lt;MyService1, IMyService&gt;();
container.RegisterScoped&lt;MyService2, IMyService&gt;();
container.RegisterType&lt;MyService3, IMyService&gt;();

// So - each enumerable will contain, in order:
// 1) Singleton IMyService
// 2) Scoped IMyService
// 3) Transient IMyService

var fromRoot1 = container.ResolveMany&lt;IMyService&gt;().ToArray();
var fromRoot2 = container.ResolveMany&lt;IMyService&gt;().ToArray();

Assert.Same(fromRoot1[0], fromRoot2[0]);
// both scoped objects should be the same because we&#39;ve resolved
// from the root scope
Assert.Same(fromRoot1[1], fromRoot2[1]);
Assert.NotSame(fromRoot1[2], fromRoot2[2]);

using (var childScope = container.CreateScope())
{
    var fromChildScope1 = childScope.ResolveMany&lt;IMyService&gt;().ToArray();
    // singleton should be the same as before, but 
    // the scoped object will be different
    Assert.Same(fromRoot1[0], fromChildScope1[0]);
    Assert.NotSame(fromRoot1[1], fromChildScope1[1]);
    Assert.NotSame(fromRoot1[2], fromChildScope1[2]);

    var fromChildScope2 = childScope.ResolveMany&lt;IMyService&gt;().ToArray();
    // the scoped object will be the same as above
    Assert.Same(fromChildScope1[0], fromChildScope2[0]);
    Assert.Same(fromChildScope1[1], fromChildScope2[1]);
    Assert.NotSame(fromChildScope1[2], fromChildScope2[2]);
}
</code></pre><p>To summarise:</p>
<ul>
<li><code>[0]</code> is <em>always</em> the same reference</li>
<li><code>[1]</code> is created once per enclosing scope (remember - the container itself is a scope in this example)</li>
<li><code>[2]</code> is created once per call</li>
</ul>
<hr>
<h2 id="automatic-covariance">Automatic Covariance</h2>
<p>Since the <code>T</code> type parameter in <code>IEnumerable&lt;T&gt;</code> is a covariant, Rezolver automatically resolves all types
which are reference compatible with the <code>T</code> that you specify.  So, resolving an <code>IEnumerable&lt;IFoo&gt;</code> will 
result in an enumerable containing <em>all</em> objects produced from registrations made against types which 
implement <code>IFoo</code> (the registrations do not need to have been made explicitly against the <code>IFoo</code> interface).</p>
<p>A concrete example of this can be found in the <a href="variance/covariance.html#enumerables">section on covariance</a>.</p>
<hr>
<h2 id="decorators-and-enumerables">Decorators and Enumerables</h2>
<p><a href="decorators.html">Decorators</a> that have been registered against the <strong>element type</strong> of an enumerable will be applied to all 
instances that the container produces for the enumerable.  This also applies to stacked decorators (where multiple 
decorators are applied on top of one other).</p>
<p>So, we have two decorator types for <code>IMyService</code>:</p>
<pre><code class="lang-csharp" name="MyServiceDecorators.cs">public class MyServiceDecorator1 : IMyService
{
    public IMyService Inner { get; }
    public MyServiceDecorator1(IMyService inner)
    {
        Inner = inner;
    }
}

public class MyServiceDecorator2 : IMyService
{
    public IMyService Inner { get; }
    public MyServiceDecorator2(IMyService inner)
    {
        Inner = inner;
    }
}
</code></pre><p>And in this example we&#39;ll have one of those decorators being used to decorate three registrations:</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
// register the decorator up front.  Note - it doesn&#39;t actually matter when it&#39;s registered
container.RegisterDecorator&lt;MyServiceDecorator1, IMyService&gt;();
container.RegisterType&lt;MyService, IMyService&gt;();
container.RegisterType&lt;MyService2, IMyService&gt;();
container.RegisterType&lt;MyService3, IMyService&gt;();

// create the container with these targets
var result = container.ResolveMany&lt;IMyService&gt;().ToArray();

// make sure each item in the enumerable is an instance of our decorator.
// then make sure the decorated services are correct.
Assert.All(result, r =&gt; Assert.IsType&lt;MyServiceDecorator1&gt;(r));
Assert.IsType&lt;MyService&gt;(((MyServiceDecorator1)result[0]).Inner);
Assert.IsType&lt;MyService2&gt;(((MyServiceDecorator1)result[1]).Inner);
Assert.IsType&lt;MyService3&gt;(((MyServiceDecorator1)result[2]).Inner);
</code></pre><p>If more decorators were added, of course - then each element would be &#39;re-decorated&#39; accordingly.</p>
<div class="TIP"><h5>Tip</h5><p>You can also decorate instances of<code>IEnumerable&lt;T&gt;</code>, <code>IList&lt;T&gt;</code>, <code>ICollection&lt;T&gt;</code> - plus any other supported
collection types.  <a href="decorators/collections.html">Read about this now</a>.</p>
</div>
<hr>
<h2 id="explicit-ienumerablet-registrations">Explicit <code>IEnumerable&lt;T&gt;</code> registrations</h2>
<p>Although you get <code>IEnumerable&lt;T&gt;</code> handling automatically when the <a class="xref" href="../api/Rezolver.Configuration.InjectEnumerables.html">InjectEnumerables</a> configuration 
is applied (and not also disabled by the @Rezolver.Options.EnumerableInjection option being set to <code>false</code>), it doesn&#39;t 
prevent you from manually adding registrations for specific <code>IEnumerable&lt;&gt;</code> types which override the default behaviour.</p>
<p>For example, let&#39;s say that you have two registrations for services which share a common interface, but they have only
been registered against their concrete type (perhaps it&#39;s historical code you can&#39;t risk changing). Your code 
now wants an enumerable of that common interface.  Well, assuming you know what the specific registrations are - you can
use delegate registrations (note, there are <em>lots</em> of ways, this is just the most illustrative):</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
container.RegisterType&lt;MyService1&gt;();
container.RegisterType&lt;MyService2&gt;();

// reversing the &#39;normal&#39; order that would usually be 
// produced by the default IEnumerable functionality, to show
// that it&#39;s this enumerable that we resolve
container.RegisterDelegate&lt;IEnumerable&lt;IMyService&gt;&gt;(
    rc =&gt; new IMyService[] { rc.Resolve&lt;MyService2&gt;(), rc.Resolve&lt;MyService1&gt;() }
);

var result = container.ResolveMany&lt;IMyService&gt;().ToArray();

Assert.Equal(2, result.Length);
Assert.IsType&lt;MyService2&gt;(result[0]);
Assert.IsType&lt;MyService1&gt;(result[1]);
</code></pre><div class="WARNING"><h5>Warning</h5><p>As soon as you create a manual registration for a particular <code>IEnumerable&lt;T&gt;</code> type, Rezolver no longer has any control
over how that particular enumerable is produced - so none of the enumerable-related options demonstrated in this documentation 
will be honoured.</p>
</div>
<hr>
<h2 id="disabling-enumerable-injection">Disabling Enumerable Injection</h2>
<p>As with much of the built-in functionality in Rezolver, you can control whether enumerables are automatically 
built or not through the use of options and configuration.</p>
<p>In the case of enumerable injection, it is a feature that is enabled by an <a class="xref" href="../api/Rezolver.ITargetContainerConfig.html">ITargetContainerConfig</a>
that is added by default to a set of configuration objects in the <a class="xref" href="../api/Rezolver.TargetContainer.html#Rezolver_TargetContainer_DefaultConfig">DefaultConfig</a> 
collection which is applied, by default, to all new instances of the <a class="xref" href="../api/Rezolver.TargetContainer.html">TargetContainer</a> class (which
is, in turn, used by both the main container types - <a class="xref" href="../api/Rezolver.Container.html">Container</a> and <a class="xref" href="../api/Rezolver.ScopedContainer.html">ScopedContainer</a>).</p>
<p>This means that, to disable it, you have to either remove that config (it&#39;s the 
<a class="xref" href="../api/Rezolver.Configuration.InjectEnumerables.html">InjectEnumerables</a> configuration singleton) from the collection, or set the 
<a class="xref" href="../api/Rezolver.Options.EnableEnumerableInjection.html">EnableEnumerableInjection</a> option to <code>false</code> on the target container before the configuration
is applied.</p>
<p>You also have another choice, in that you can either do this directly on the <a class="xref" href="../api/Rezolver.TargetContainer.html#Rezolver_TargetContainer_DefaultConfig">DefaultConfig</a>
collection, which will affect <em>all</em> instances of <a class="xref" href="../api/Rezolver.TargetContainer.html">TargetContainer</a>, or you can 
<a class="xref" href="../api/Rezolver.CombinedTargetContainerConfig.html#Rezolver_CombinedTargetContainerConfig_Clone_">Clone</a> the collection and apply it only to a single target container.</p>
<p>It&#39;s the second of these options that the example shows, below:</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">var config = TargetContainer.DefaultConfig.Clone();
config.ConfigureOption&lt;Options.EnableEnumerableInjection&gt;(false);

// pass our custom config to a new target container which, in turn,
// we pass to the constructor of the Container class
var container = new Container(new TargetContainer(config));

Assert.Throws&lt;InvalidOperationException&gt;(() =&gt; container.ResolveMany&lt;int&gt;());
</code></pre><p>Notice that we&#39;re explicitly creating a <a class="xref" href="../api/Rezolver.TargetContainer.html">TargetContainer</a> and passing a cloned config to it; passing
the result to the <a class="xref" href="../api/Rezolver.Container.html">Container</a> constructor.</p>
<div class="TIP"><h5>Tip</h5><p>Many other examples throughout this documentation show options simply being set directly on the container.
In those cases, it&#39;s because the options are used by logic within Rezolver to make decisions.
Enumerable injection, however, is configured at the point a new <a class="xref" href="../api/Rezolver.TargetContainer.html">TargetContainer</a> is <em>created</em>, 
because the configuration is applied by one of its constructors; hence the different approach is required in
order to ensure the option is set <em>before</em> the configuration gets applied.  The 
<a class="xref" href="../api/Rezolver.Configuration.InjectEnumerables.html">InjectEnumerables</a> configuration looks for the <a class="xref" href="../api/Rezolver.Options.EnableEnumerableInjection.html">EnableEnumerableInjection</a>
option and, if it&#39;s <code>false</code> it disables itself.</p>
</div>
<div class="WARNING"><h5>Warning</h5><p>If you disable automatic enumerable injection then the other 
<a href="arrays-lists-collections/index.html">automatic collection-type injection behaviour</a> will only work when you 
explicitly register the correct <code>IEnumerable&lt;T&gt;</code> for it.</p>
</div>
<hr>
<h1 id="next-steps">Next steps</h1>
<ul>
<li>Read about how Rezolver handles building <a href="enumerables/generics.html">enumerables of generics</a> from open and closed
generic registrations.</li>
<li>Learn about Rezolver&#39;s support for <a href="enumerables/lazy-vs-eager.html">lazy and eager enumerables</a> (note: all auto-generated enumerables are lazily 
evaluated by default)</li>
<li><strong>New in 1.3.2</strong> - Learn how to setup <a href="enumerables/projections.html">enumerable projections</a> which allow you to
instruct the container to build an enumerable of one type from an enumerable of another type.</li>
<li>Rezolver also supports <a href="arrays-lists-collections/index.html">arrays, lists and collection injection</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/ZolutionSoftware/Rezolver/blob/autofactories/doc/Rezolver.Docs/_docfx_proj/docs/enumerables.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>Copyright &copy;2014 onwards <a href="http://www.zolution.co.uk" target="_blank">Zolution Software Ltd</a><br>Generated by <a href="https://dotnet.github.io/docfx/" target="_blank">DocFX</a>, with the Rezolver theme</span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
