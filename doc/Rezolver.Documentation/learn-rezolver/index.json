{
  "rezolver-api/Rezolver.OptionalParameterTarget.html": {
    "href": "rezolver-api/Rezolver.OptionalParameterTarget.html",
    "title": "Class OptionalParameterTarget",
    "keywords": "Class OptionalParameterTarget Used specifically when binding arguments to method parameters when a parameter is optional and its default value is to be used when binding to it. Inheritance Object TargetBase OptionalParameterTarget Inherited Members TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class OptionalParameterTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors OptionalParameterTarget(ParameterInfo) Constructs a new instance of the OptionalParameterTarget class. Declaration public OptionalParameterTarget(ParameterInfo methodParameter) Parameters Name Type Description methodParameter ParameterInfo Required - parameter to which this target will be bound. Its property must be true otherwise an ArgumentException is thrown. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Always returns the of the MethodParameter Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> MethodParameter The parameter to which this target is bound. Declaration public ParameterInfo MethodParameter { get; } Property Value Type Description ParameterInfo <!-- .classchild --> SuppressScopeTracking Possibly going to be removed or at least changed. Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides TargetBase.SuppressScopeTracking <!-- .classchild --> UseFallback Always returns true, since using a default argument of a parameter is always considered to be a last-resort. Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides TargetBase.UseFallback <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.OverridingContainer.html": {
    "href": "rezolver-api/Rezolver.OverridingContainer.html",
    "title": "Class OverridingContainer",
    "keywords": "Class OverridingContainer An IContainer which can override the resolve operations of another. This is useful when you have a core application-wide container, with some objects being customised based on some ambient information, e.g. configuration, MVC Area/Controller, Brand (in a multi-tenant application for example) or more. The scoping version of this is called OverridingScopedContainer . Inheritance Object ContainerBase CachingContainerBase Container OverridingContainer Inherited Members CachingContainerBase.GetCompiledRezolveTarget(ResolveContext) ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Compiler ContainerBase.Targets ContainerBase.Resolve(ResolveContext) ContainerBase.TryResolve(ResolveContext, Object) ContainerBase.CreateLifetimeScope() ContainerBase.FetchCompiled(ResolveContext) Rezolver.ContainerBase.System.IServiceProvider.GetService(System.Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.Fetch(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.FetchAll(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer, System.Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class OverridingContainer : Container, IContainer, IServiceProvider, ITargetContainer Remarks When overriding another IContainer , you are overriding the ICompiledTarget objects that will be returned when FetchCompiled(ResolveContext) is called on that container and, therefore, the compiled target which is executed when the Resolve(ResolveContext) method is called. This has the side effect of overriding automatically resolved arguments (bound to a RezolvedTarget ) compiled in the overridden container by virtue of the fact that the overriding container is a different reference, because the RezolvedTarget expects a check to be performed, at resolve-time, that the Container is the same container as the one that was active when it was originally compiled. In essence, when resolving an instance as a dependency the RezolvedTarget does something like this: resolveContext.Container == compileContext.Container ? (execute compile-time target) : resolveContext.Container.Resolve(type) <!-- <hr class=\"typeSectionDivider\" /> --> Constructors OverridingContainer(IContainer, ITargetContainer, ITargetCompiler) Creates a new instance of the OverridingContainer Declaration public OverridingContainer(IContainer inner, ITargetContainer targets = null, ITargetCompiler compiler = null) Parameters Name Type Description inner IContainer Required. The inner container that this one combines with. Any dependencies not served by the new combined container's own targets will be sought from this container. Equally, any targets in the base which are resolved when the overriding container is the root container for a resolve operation, will resolve their dependencies from this container. targets ITargetContainer Optional. A specific target container to be used for this container's own registrations. compiler ITargetCompiler Optional. A compiler to be used to create ICompiledTarget instances from this container's registrations. If this is not provided, then the default is used ( Default ) <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CanResolve(ResolveContext) Called to determine if this container is able to resolve the type specified in the passed context . Declaration public override bool CanResolve(ResolveContext context) Parameters Name Type Description context ResolveContext Required. The ResolveContext . Returns Type Description Boolean Overrides ContainerBase.CanResolve(ResolveContext) <!-- .classchild --> GetFallbackCompiledRezolveTarget(ResolveContext) Overrides the base implementation to pass the lookup for an ITarget to the inner container - this is how dependency chaining from this container to the inner container is achieved. Declaration protected override ICompiledTarget GetFallbackCompiledRezolveTarget(ResolveContext context) Parameters Name Type Description context ResolveContext Required. The ResolveContext . Returns Type Description ICompiledTarget Overrides ContainerBase.GetFallbackCompiledRezolveTarget(ResolveContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.OverridingScopedContainer.html": {
    "href": "rezolver-api/Rezolver.OverridingScopedContainer.html",
    "title": "Class OverridingScopedContainer",
    "keywords": "Class OverridingScopedContainer Not sure if this is sticking around anyway. Think the scoping stuff needs a bit of a rethink. Inheritance Object ContainerBase CachingContainerBase Container OverridingContainer OverridingScopedContainer Inherited Members OverridingContainer.CanResolve(ResolveContext) OverridingContainer.GetFallbackCompiledRezolveTarget(ResolveContext) CachingContainerBase.GetCompiledRezolveTarget(ResolveContext) ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Compiler ContainerBase.Targets ContainerBase.Resolve(ResolveContext) ContainerBase.TryResolve(ResolveContext, Object) ContainerBase.CreateLifetimeScope() ContainerBase.FetchCompiled(ResolveContext) Rezolver.ContainerBase.System.IServiceProvider.GetService(System.Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.Fetch(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.FetchAll(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer, System.Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class OverridingScopedContainer : OverridingContainer, ITargetContainer, IScopedContainer, IContainer, IServiceProvider, IDisposable <!-- <hr class=\"typeSectionDivider\" /> --> Constructors OverridingScopedContainer(IScopedContainer, IContainer, ITargetContainer, ITargetCompiler) Constructs a new instance of the CombinedLifetimeScopeRezolver class. Declaration public OverridingScopedContainer(IScopedContainer parentScope, IContainer inner = null, ITargetContainer builder = null, ITargetCompiler compiler = null) Parameters Name Type Description parentScope IScopedContainer Can be null, but if it is, then inner must be supplied inner IContainer Can be null, but if it is, then parentScope must be supplied builder ITargetContainer compiler ITargetCompiler <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties ParentScope Declaration public IScopedContainer ParentScope { get; } Property Value Type Description IScopedContainer Implements IScopedContainer.ParentScope <!-- .classchild --> TrackedObjects Declaration protected IEnumerable<object> TrackedObjects { get; } Property Value Type Description IEnumerable < Object > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods AddToScope(Object, ResolveContext) Declaration public virtual void AddToScope(object obj, ResolveContext context = null) Parameters Name Type Description obj Object context ResolveContext Implements IScopedContainer.AddToScope(Object, ResolveContext) <!-- .classchild --> Dispose() Declaration public void Dispose() Implements IDisposable.Dispose() <!-- .classchild --> Dispose(Boolean) Declaration protected virtual void Dispose(bool disposing) Parameters Name Type Description disposing Boolean <!-- .classchild --> GetFromScope(ResolveContext) Declaration public virtual IEnumerable<object> GetFromScope(ResolveContext context) Parameters Name Type Description context ResolveContext Returns Type Description IEnumerable < Object > Implements IScopedContainer.GetFromScope(ResolveContext) <!-- .classchild --> OnDisposed() Declaration protected void OnDisposed() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Events Disposed Declaration public event EventHandler Disposed Event Type Type Description EventHandler Implements IScopedContainer.Disposed <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ParameterBinding.html": {
    "href": "rezolver-api/Rezolver.ParameterBinding.html",
    "title": "Class ParameterBinding",
    "keywords": "Class ParameterBinding Represents a binding between a method parameter and an ITarget Inheritance Object ParameterBinding Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ParameterBinding <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ParameterBinding(ParameterInfo, ITarget) Constructs a new instance of the ParameterBinding class. Declaration public ParameterBinding(ParameterInfo parameter, ITarget target = null) Parameters Name Type Description parameter ParameterInfo Required - the parameter being bound target ITarget Optional - the argument supplied for the parameter. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Fields None Represents an empty parameter bindings array. Declaration public static readonly ParameterBinding[] None Field Value Type Description ParameterBinding [] <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties IsValid Gets a boolean indicating whether the parameter binding is valid Ultimately, this returns true if Target is non-null. Declaration public bool IsValid { get; } Property Value Type Description Boolean <!-- .classchild --> Parameter The parameter to be bound Declaration public ParameterInfo Parameter { get; } Property Value Type Description ParameterInfo <!-- .classchild --> Target The initial target that was bound to this parameter. Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods BindMethod(MethodBase, IDictionary<String, ITarget>) Matches named targets in args to parameters on the passed method , creating default ParameterBinding s for any parameters for which named targets cannot be found. Declaration public static ParameterBinding[] BindMethod(MethodBase method, IDictionary<string, ITarget> args) Parameters Name Type Description method MethodBase args IDictionary < String , ITarget > Returns Type Description ParameterBinding [] <!-- .classchild --> BindOverload(MethodBase[], IDictionary<String, ITarget>, out MethodBase) Searches for a method in the methods collection whose parameters can be filled by the targets provided in the args dictionary, returning the parameter bindings, and passing out the resolved target method in resolvedMethod if found. Note - if no match can be found, or if more than one method could be bound, then an InvalidOperationException will occur. Declaration public static ParameterBinding[] BindOverload(MethodBase[] methods, IDictionary<string, ITarget> args, out MethodBase resolvedMethod) Parameters Name Type Description methods MethodBase [] The methods. args IDictionary < String , ITarget > The arguments. resolvedMethod MethodBase The resolved method. Returns Type Description ParameterBinding [] ParameterBinding[]. <!-- .classchild --> BindWithRezolvedArguments(MethodBase) Creates parameter bindings for each parameter in the passed method where each value will be resolved. For any optional parameters - their default values will be used as a fallback if the RezolvedTarget cannot either resolve a target at compile time or from the IContainer at resolve-time. Declaration public static ParameterBinding[] BindWithRezolvedArguments(MethodBase method) Parameters Name Type Description method MethodBase Returns Type Description ParameterBinding [] <!-- .classchild --> Resolve(ICompileContext) Fetch the target that would be bound to this parameter given the passed ICompileContext Declaration public virtual ITarget Resolve(ICompileContext context) Parameters Name Type Description context ICompileContext The current compile context - a new one is created for the Parameter type Returns Type Description ITarget The target that should be used for the parameter, or null if no target could be found. Note that if the returned target's UseFallback property is set to true , then it means either the parameter's default value is being used, or that the target fetched from the target container in the context is a stub (e.g. empty enumerable) Remarks During compilation - you should not use the target returned by this function as a direct part of your expression tree - you should <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.PropertyOrFieldBinding.html": {
    "href": "rezolver-api/Rezolver.PropertyOrFieldBinding.html",
    "title": "Class PropertyOrFieldBinding",
    "keywords": "Class PropertyOrFieldBinding Inheritance Object PropertyOrFieldBinding Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class PropertyOrFieldBinding <!-- <hr class=\"typeSectionDivider\" /> --> Constructors PropertyOrFieldBinding(MemberInfo, ITarget) Declaration public PropertyOrFieldBinding(MemberInfo member, ITarget target) Parameters Name Type Description member MemberInfo target ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Fields None Declaration public static readonly PropertyOrFieldBinding[] None Field Value Type Description PropertyOrFieldBinding [] <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Member Declaration public MemberInfo Member { get; } Property Value Type Description MemberInfo <!-- .classchild --> MemberType Declaration public Type MemberType { get; } Property Value Type Description Type <!-- .classchild --> Target Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateMemberBinding(CompileContext) Method for creating a Linq Expression MemberBinding object for the Member , to the expression produced by the Target object's Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) method. Declaration public MemberBinding CreateMemberBinding(CompileContext context) Parameters Name Type Description context CompileContext The CompileContext under which the generated expression will be compiled. Returns Type Description MemberBinding <!-- .classchild --> DeriveAutoPropertyBinding(Type, Boolean) Static factory method that creates bindings for all publicly writable instance properties (and, optionally, fields) of the given type. Each property/field is bound to a RezolvedTarget instance - meaning that, at runtime, values for those properties or fields will be resolved from the container by type. Declaration public static PropertyOrFieldBinding[] DeriveAutoPropertyBinding(Type type, bool includeFields = false) Parameters Name Type Description type Type The type whose properties (and, optionally, publicly writable fields) are to be bound. includeFields Boolean If true, then publicly writable fields will be bound. Returns Type Description PropertyOrFieldBinding [] <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RegisterTypeDictionaryExtensions.html": {
    "href": "rezolver-api/Rezolver.RegisterTypeDictionaryExtensions.html",
    "title": "Class RegisterTypeDictionaryExtensions",
    "keywords": "Class RegisterTypeDictionaryExtensions Extensions for ITargetContainer to provide shortcuts for the simplest cases of registering ConstructorTarget and GenericConstructorTarget targets. Inheritance Object RegisterTypeDictionaryExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class RegisterTypeDictionaryExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Registers an instance of objectType (optionally for the service type serviceType ) to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IPropertyBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The target container on which the registration is to be performed. objectType Type The type of the object that is to be constructed when resolved. serviceType Type Optional. The type against which the registration will be performed, if different from objectType . objectType must be compatible with this type, if it's provided. propertyBindingBehaviour IPropertyBindingBehaviour Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Rezolver.ConstructorTarget.Auto(System.Type,Rezolver.IPropertyBindingBehaviour) or Rezolver.GenericConstructorTarget.Auto(System.Type,Rezolver.IPropertyBindingBehaviour) static methods and then registering it against the type serviceType or objectType . <!-- .classchild --> RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) Registers an instance of TObject to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IPropertyBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType<TObject>(this ITargetContainer targetContainer, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The target container on which the registration is to be performed. propertyBindingBehaviour IPropertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Rezolver.ConstructorTarget.Auto``1(Rezolver.IPropertyBindingBehaviour) or Rezolver.GenericConstructorTarget.Auto``1(Rezolver.IPropertyBindingBehaviour) static methods and then registering it. <!-- .classchild --> RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Registers an instance of TObject for the service type TService to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IPropertyBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType<TObject, TService>(this ITargetContainer targetContainer, IPropertyBindingBehaviour propertyBindingBehaviour = null)where TObject : TService Parameters Name Type Description targetContainer ITargetContainer The target container on which the registration is to be performed. propertyBindingBehaviour IPropertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. TService The type against which the registration will be performed. TObject must be compatible with this type. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Rezolver.ConstructorTarget.Auto``1(Rezolver.IPropertyBindingBehaviour) or Rezolver.GenericConstructorTarget.Auto``1(Rezolver.IPropertyBindingBehaviour) static methods and then registering it against the type TService . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RegisterTypeTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.RegisterTypeTargetContainerExtensions.html",
    "title": "Class RegisterTypeTargetContainerExtensions",
    "keywords": "Class RegisterTypeTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for the simplest cases of registering ConstructorTarget and GenericConstructorTarget targets. Inheritance Object RegisterTypeTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class RegisterTypeTargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) Registers an instance of objectType (optionally for the service type serviceType ) to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The target container on which the registration is to be performed. objectType Type The type of the object that is to be constructed when resolved. serviceType Type Optional. The type against which the registration will be performed, if different from objectType . objectType must be compatible with this type, if it's provided. propertyBindingBehaviour IMemberBindingBehaviour Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto(Type, IMemberBindingBehaviour) or Auto(Type, IMemberBindingBehaviour) static methods and then registering it against the type serviceType or objectType . <!-- .classchild --> RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) Registers an instance of TObject to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType<TObject>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The target container on which the registration is to be performed. propertyBindingBehaviour IMemberBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto<T>(IMemberBindingBehaviour) or Auto<TGeneric>(IMemberBindingBehaviour) static methods and then registering it. <!-- .classchild --> RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) Registers an instance of TObject for the service type TService to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType<TObject, TService>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null)where TObject : TService Parameters Name Type Description targetContainer ITargetContainer The target container on which the registration is to be performed. propertyBindingBehaviour IMemberBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. TService The type against which the registration will be performed. TObject must be compatible with this type. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto<T>(IMemberBindingBehaviour) or Auto<TGeneric>(IMemberBindingBehaviour) static methods and then registering it against the type TService . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ResolveContext.html": {
    "href": "rezolver-api/Rezolver.ResolveContext.html",
    "title": "Class ResolveContext",
    "keywords": "Class ResolveContext Captures the state for a call to Resolve(ResolveContext) , including the container on which the operation is invoked, any IScopedContainer that might be active for the call (if different), and the type which is being resolved from the IContainer . Inheritance Object ResolveContext Inherited Members Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ResolveContext : IEquatable<ResolveContext> <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ResolveContext(IContainer, Type) Declaration public ResolveContext(IContainer container, Type requestedType) Parameters Name Type Description container IContainer requestedType Type <!-- .classchild --> ResolveContext(IContainer, Type, IScopedContainer) Declaration public ResolveContext(IContainer container, Type requestedType, IScopedContainer scope) Parameters Name Type Description container IContainer requestedType Type scope IScopedContainer <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Fields EmptyContext Declaration public static readonly ResolveContext EmptyContext Field Value Type Description ResolveContext <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Container The container for this context. Declaration public IContainer Container { get; } Property Value Type Description IContainer <!-- .classchild --> RequestedType Declaration public Type RequestedType { get; } Property Value Type Description Type <!-- .classchild --> Scope Declaration public IScopedContainer Scope { get; } Property Value Type Description IScopedContainer <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateNew(IContainer) Declaration public ResolveContext CreateNew(IContainer container) Parameters Name Type Description container IContainer Returns Type Description ResolveContext <!-- .classchild --> CreateNew(IContainer, IScopedContainer) Declaration public ResolveContext CreateNew(IContainer container, IScopedContainer scope) Parameters Name Type Description container IContainer scope IScopedContainer Returns Type Description ResolveContext <!-- .classchild --> CreateNew(IContainer, Type) Declaration public ResolveContext CreateNew(IContainer container, Type requestedType) Parameters Name Type Description container IContainer requestedType Type Returns Type Description ResolveContext <!-- .classchild --> CreateNew(IContainer, Type, IScopedContainer) Declaration public ResolveContext CreateNew(IContainer container, Type requestedType, IScopedContainer scope) Parameters Name Type Description container IContainer requestedType Type scope IScopedContainer Returns Type Description ResolveContext <!-- .classchild --> CreateNew(IScopedContainer) Declaration public ResolveContext CreateNew(IScopedContainer scope) Parameters Name Type Description scope IScopedContainer Returns Type Description ResolveContext <!-- .classchild --> CreateNew(Type) Returns a clone of this context, but replaces the type, establishing the root context relationship also, either by inheriting this one's root context, or setting this as the root context. Declaration public ResolveContext CreateNew(Type requestedType) Parameters Name Type Description requestedType Type Returns Type Description ResolveContext <!-- .classchild --> CreateNew(Type, IScopedContainer) Declaration public ResolveContext CreateNew(Type requestedType, IScopedContainer scope) Parameters Name Type Description requestedType Type scope IScopedContainer Returns Type Description ResolveContext <!-- .classchild --> Equals(ResolveContext) Declaration public virtual bool Equals(ResolveContext other) Parameters Name Type Description other ResolveContext Returns Type Description Boolean Implements IEquatable<ResolveContext>.Equals(ResolveContext) <!-- .classchild --> Equals(Object) Declaration public override bool Equals(object obj) Parameters Name Type Description obj Object Returns Type Description Boolean Overrides Object.Equals(Object) <!-- .classchild --> GetHashCode() Declaration public override int GetHashCode() Returns Type Description Int32 Overrides Object.GetHashCode() <!-- .classchild --> ToString() Declaration public override string ToString() Returns Type Description String Overrides Object.ToString() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Operators Equality(ResolveContext, ResolveContext) Declaration public static bool operator ==(ResolveContext left, ResolveContext right) Parameters Name Type Description left ResolveContext right ResolveContext Returns Type Description Boolean <!-- .classchild --> Inequality(ResolveContext, ResolveContext) Declaration public static bool operator !=(ResolveContext left, ResolveContext right) Parameters Name Type Description left ResolveContext right ResolveContext Returns Type Description Boolean <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolveContext.html": {
    "href": "rezolver-api/Rezolver.RezolveContext.html",
    "title": "Class RezolveContext",
    "keywords": "Class RezolveContext Context of a call to an IRezolver's Resolve method. The container is included in the context to allow code generated from Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) to refer back to the container. This also allows us to retarget compiled targets at other containers (e.g. OverridingContainer s that override existing registrations or define new ones). Inheritance Object RezolveContext Inherited Members Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolveContext : IEquatable<RezolveContext> <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RezolveContext(IContainer, Type) Declaration public RezolveContext(IContainer container, Type requestedType) Parameters Name Type Description container IContainer requestedType Type <!-- .classchild --> RezolveContext(IContainer, Type, IScopedContainer) Declaration public RezolveContext(IContainer container, Type requestedType, IScopedContainer scope) Parameters Name Type Description container IContainer requestedType Type scope IScopedContainer <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Fields EmptyContext Declaration public static readonly RezolveContext EmptyContext Field Value Type Description RezolveContext <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Container The container for this context. Declaration public IContainer Container { get; } Property Value Type Description IContainer <!-- .classchild --> RequestedType Declaration public Type RequestedType { get; } Property Value Type Description Type <!-- .classchild --> Scope Declaration public IScopedContainer Scope { get; } Property Value Type Description IScopedContainer <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateNew(IContainer) Declaration public RezolveContext CreateNew(IContainer container) Parameters Name Type Description container IContainer Returns Type Description RezolveContext <!-- .classchild --> CreateNew(IContainer, IScopedContainer) Declaration public RezolveContext CreateNew(IContainer container, IScopedContainer scope) Parameters Name Type Description container IContainer scope IScopedContainer Returns Type Description RezolveContext <!-- .classchild --> CreateNew(IContainer, Type) Declaration public RezolveContext CreateNew(IContainer container, Type requestedType) Parameters Name Type Description container IContainer requestedType Type Returns Type Description RezolveContext <!-- .classchild --> CreateNew(IContainer, Type, IScopedContainer) Declaration public RezolveContext CreateNew(IContainer container, Type requestedType, IScopedContainer scope) Parameters Name Type Description container IContainer requestedType Type scope IScopedContainer Returns Type Description RezolveContext <!-- .classchild --> CreateNew(IScopedContainer) Declaration public RezolveContext CreateNew(IScopedContainer scope) Parameters Name Type Description scope IScopedContainer Returns Type Description RezolveContext <!-- .classchild --> CreateNew(Type) Returns a clone of this context, but replaces the type, establishing the root context relationship also, either by inheriting this one's root context, or setting this as the root context. Declaration public RezolveContext CreateNew(Type requestedType) Parameters Name Type Description requestedType Type Returns Type Description RezolveContext <!-- .classchild --> CreateNew(Type, IScopedContainer) Declaration public RezolveContext CreateNew(Type requestedType, IScopedContainer scope) Parameters Name Type Description requestedType Type scope IScopedContainer Returns Type Description RezolveContext <!-- .classchild --> Equals(RezolveContext) Declaration public virtual bool Equals(RezolveContext other) Parameters Name Type Description other RezolveContext Returns Type Description Boolean Implements IEquatable<RezolveContext>.Equals(RezolveContext) <!-- .classchild --> Equals(Object) Declaration public override bool Equals(object obj) Parameters Name Type Description obj Object Returns Type Description Boolean Overrides Object.Equals(Object) <!-- .classchild --> GetHashCode() Declaration public override int GetHashCode() Returns Type Description Int32 Overrides Object.GetHashCode() <!-- .classchild --> ToString() Declaration public override string ToString() Returns Type Description String Overrides Object.ToString() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Operators Equality(RezolveContext, RezolveContext) Declaration public static bool operator ==(RezolveContext left, RezolveContext right) Parameters Name Type Description left RezolveContext right RezolveContext Returns Type Description Boolean <!-- .classchild --> Inequality(RezolveContext, RezolveContext) Declaration public static bool operator !=(RezolveContext left, RezolveContext right) Parameters Name Type Description left RezolveContext right RezolveContext Returns Type Description Boolean <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolveContextExpressionHelper.html": {
    "href": "rezolver-api/Rezolver.RezolveContextExpressionHelper.html",
    "title": "Class RezolveContextExpressionHelper",
    "keywords": "Class RezolveContextExpressionHelper Wraps a rezolve context for expression building - used principally in the ConstruuctorTarget class, but others are free to use it also. Inheritance Object RezolveContext RezolveContextExpressionHelper Inherited Members RezolveContext.EmptyContext RezolveContext.RequestedType RezolveContext.Container RezolveContext.Scope RezolveContext.ToString() RezolveContext.GetHashCode() RezolveContext.Equals(Object) RezolveContext.Equals(RezolveContext) RezolveContext.CreateNew(Type) RezolveContext.CreateNew(IContainer, Type) RezolveContext.CreateNew(Type, IScopedContainer) RezolveContext.CreateNew(IContainer, Type, IScopedContainer) RezolveContext.CreateNew(IContainer) RezolveContext.CreateNew(IScopedContainer) RezolveContext.CreateNew(IContainer, IScopedContainer) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolveContextExpressionHelper : RezolveContext, IEquatable<RezolveContext> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Resolve<T>() Declaration public T Resolve<T>() Returns Type Description T Type Parameters Name Description T <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolveContextPlaceholderExpression.html": {
    "href": "rezolver-api/Rezolver.RezolveContextPlaceholderExpression.html",
    "title": "Class RezolveContextPlaceholderExpression",
    "keywords": "Class RezolveContextPlaceholderExpression wraps an expression that represents reading or otherwise manipulating the RezolveContext that's passed into a Resolve call. Inheritance Object RezolveContextPlaceholderExpression Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolveContextPlaceholderExpression : Expression <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RezolveContextPlaceholderExpression(Expression) Declaration public RezolveContextPlaceholderExpression(Expression rezolveContextExpression) Parameters Name Type Description rezolveContextExpression Expression <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties CanReduce Declaration public override bool CanReduce { get; } Property Value Type Description Boolean <!-- .classchild --> NodeType Declaration public override ExpressionType NodeType { get; } Property Value Type Description ExpressionType <!-- .classchild --> RezolveContextExpression Declaration public Expression RezolveContextExpression { get; } Property Value Type Description Expression <!-- .classchild --> Type Declaration public override Type Type { get; } Property Value Type Description Type <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolvedTarget.html": {
    "href": "rezolver-api/Rezolver.RezolvedTarget.html",
    "title": "Class RezolvedTarget",
    "keywords": "Class RezolvedTarget Represents a target that is rezolved statically at compile time via the ICompileContext , or dynamically (at 'resolve time') from the IContainer that is attached to the current ResolveContext when Resolve(ResolveContext) is called. This is the most common way that we bind constructor parameters, for example - i.e. 'I want an IService instance - go get it'. Inheritance Object TargetBase RezolvedTarget Inherited Members TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolvedTarget : TargetBase, ITarget Remarks The concept of compile-time resolving is what is typically implemented by most other IOC containers - at compile time, a target is resolved for a given type and, if found, its expression is used. If it's not found, then an error occurs. Rezolver does this, but goes further when the target can't be resolved at compile-time - in this case, it will emit a call back into the current ResolveContext 's IContainer to try and dynamically resolve the value that is required. Furthermore, the code it produces in either case also checks that the IContainer that is active at resolve-time is the same one (if applicable) that was active during compile-time. If it isn't, then it'll automatically defer resolving of the value to that container <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RezolvedTarget(Type, ITarget) Creates a new RezolvedTarget for the given type which will attempt to resolve a value at compile time and/or resolve-time and, if it can't, will either use the fallbackTarget or will throw an exception. Declaration public RezolvedTarget(Type type, ITarget fallbackTarget = null) Parameters Name Type Description type Type Required. The type to be resolved fallbackTarget ITarget Optional. The target to be used if the value cannot be resolved at either compile time or resolve-time. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType The type that will be resolved Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> FallbackTarget Gets the target that this RezolvedTarget will fallback to if a satisfactory target cannot be found at compile time. Declaration public ITarget FallbackTarget { get; } Property Value Type Description ITarget Remarks The UseFallback property is also used to determine whether this will be used. If the target resolved from the ICompileContext has its UseFallback property set to true, and this property is non-null for this target, then this target will be used. Note also that extension containers such as OverridingContainer also have the ability to override the use of this fallback if they successfully resolve the type. <!-- .classchild --> SuppressScopeTracking Always returns true - we never wrap calls to a container inside a scope tracking expression. Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides TargetBase.SuppressScopeTracking <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Resolve(ICompileContext) Attempts to obtain the target that this RezolvedTarget resolves to for the given ICompileContext . Used in the implementation of but also available to consumers to enable checking of RezolvedTargets to see if they'll succeed at compile time (useful when late-binding overloaded constructors, for example). Declaration public virtual ITarget Resolve(ICompileContext context) Parameters Name Type Description context ICompileContext The context from which a target is to be resolved. Returns Type Description ITarget The target resolved by this target - could be the FallbackTarget , could be null. Remarks The target that is returned depends both on the context passed and also whether a FallbackTarget has been provided to this target. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.DelegateTargetContainerExtensions.html",
    "title": "Class DelegateTargetContainerExtensions",
    "keywords": "Class DelegateTargetContainerExtensions Extension methods for ITargetContainer designed to simplify the registration of DelegateTarget and its numerous generic variants. Inheritance Object DelegateTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class DelegateTargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterDelegate(ITargetContainer, Delegate, Type) Constructs a DelegateTarget from the passed factory delegate (optionally with the given declaredType ) and registers it in the target container. Declaration public static void RegisterDelegate(this ITargetContainer targetContainer, Delegate factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Delegate declaredType Type <!-- .classchild --> RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) Creates a DelegateTarget<TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<TResult>(this ITargetContainer targetContainer, Func<TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <TResult> declaredType Type Type Parameters Name Description TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) T15 The type of the 15th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) Creates a DelegateTarget<T, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T, TResult>(this ITargetContainer targetContainer, Func<T, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T, TResult> declaredType Type Type Parameters Name Description T The type of the 1st delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) Creates a DelegateTarget<T1, T2, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, TResult>(this ITargetContainer targetContainer, Func<T1, T2, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, T8, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTargetDelegateExtensions.html": {
    "href": "rezolver-api/Rezolver.DelegateTargetDelegateExtensions.html",
    "title": "Class DelegateTargetDelegateExtensions",
    "keywords": "Class DelegateTargetDelegateExtensions Extension methods for the Delegate type to aid in the construction of DelegateTarget . Inheritance Object DelegateTargetDelegateExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class DelegateTargetDelegateExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods AsDelegateTarget(Delegate, Type) Creates a DelegateTarget from the factory which can be registered in an ITargetContainer to resolve an instance of a type compatible with the delegate's return type and, optionally, with the declaredType Declaration public static DelegateTarget AsDelegateTarget(this Delegate factory, Type declaredType = null) Parameters Name Type Description factory Delegate The delegate to be used as a factory. declaredType Type Optional type to set as the DeclaredType of the target, if not passed, then the return type of the delegate will be used. Returns Type Description DelegateTarget <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTargetExtensions.html": {
    "href": "rezolver-api/Rezolver.DelegateTargetExtensions.html",
    "title": "Class DelegateTargetExtensions",
    "keywords": "Class DelegateTargetExtensions Extension methods for creating DelegateTarget<TResult> instances. Inheritance Object DelegateTargetExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class DelegateTargetExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods AsDelegateTarget<T>(Func<T>, Type) Creates a DelegateTarget<TResult> using the delegate as the factory method to be executed. Declaration public static DelegateTarget<T> AsDelegateTarget<T>(this Func<T> factory, Type declaredType = null) Parameters Name Type Description factory Func <T> The factory. declaredType Type Optional override for the type exposed by the DelegateTarget<TResult> . See the DelegateTarget(Func<TResult>, Type) constructor for more. Returns Type Description DelegateTarget <T> Type Parameters Name Description T The type returned by the factory when executed. <!-- .classchild --> AsDelegateTarget<T>(Func<RezolveContext, T>, Type) Creates a DelegateTarget<TResult> using the delegate as the factory method to be executed. Declaration public static DelegateTarget<T> AsDelegateTarget<T>(this Func<RezolveContext, T> factory, Type declaredType = null) Parameters Name Type Description factory Func < RezolveContext , T> The factory. declaredType Type Optional override for the type exposed by the DelegateTarget<TResult> . See the Rezolver.DelegateTarget`1.#ctor(System.Func{Rezolver.RezolveContext,`0},System.Type) constructor for more. Returns Type Description DelegateTarget <T> Type Parameters Name Description T The type returned by the factory when executed. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget`1.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget`1.html",
    "title": "Class DelegateTarget<T>",
    "keywords": "Class DelegateTarget<T> Implements IRezolveTarget using factory function delegates. Inheritance Object TargetBase DelegateTarget<T> Inherited Members SuppressScopeTracking UseFallback Rezolver.TargetBase.CreateScopeTrackingExpression(Rezolver.CompileContext, Expression) Rezolver.TargetBase.CreateRezolveContextExpressionForScopeAddCall(Rezolver.CompileContext, Expression) Rezolver.TargetBase.CreateScopeSelectionExpression(Rezolver.CompileContext, Expression) SupportsType(Type) Rezolver.TargetBase.CreateExpression(Rezolver.CompileContext) ToString() Equals(Object) Equals(Object, Object) ReferenceEquals(Object, Object) GetHashCode() GetType() MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T> : TargetBase, ITarget Type Parameters Name Description T <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T>, Type) Declaration public DelegateTarget(Func<T> factory, Type declaredType = null) Parameters Name Type Description factory Func <T> declaredType Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateExpressionBase(CompileContext) Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides Rezolver.TargetBase.CreateExpressionBase(Rezolver.CompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.EnumerableTargetBuilderExtensions.html": {
    "href": "rezolver-api/Rezolver.EnumerableTargetBuilderExtensions.html",
    "title": "Class EnumerableTargetBuilderExtensions",
    "keywords": "Class EnumerableTargetBuilderExtensions Houses an extension method which enables native resolving of IEnumerables of services on ITargetContainer containers which, in turn, enables it for any ContainerBase containers which use that target container. Inheritance Object EnumerableTargetBuilderExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class EnumerableTargetBuilderExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods EnableEnumerableResolving(TargetContainer) Enables resolving of enumerables of services on the target container. After calling this, you can immediately request a target for IEnumerable<T> of any type and you will receive a ListTarget (with AsArray set to true) which contains all the targets which have previously been registered for the type T , in the order they were registered. If a service has not been registered, then the returned ListTarget will be empty and its UseFallback property will be true . Declaration public static void EnableEnumerableResolving(this TargetContainer builder) Parameters Name Type Description builder TargetContainer The builder. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ExceptionResources.html": {
    "href": "rezolver-api/Rezolver.ExceptionResources.html",
    "title": "Class ExceptionResources",
    "keywords": "Class ExceptionResources A strongly-typed resource class, for looking up localized strings, etc. Inheritance Object ExceptionResources Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ExceptionResources <!-- <hr class=\"typeSectionDivider\" /> --> Properties _MOVETOSHAREDPROJECT Looks up a localized string similar to REMINDER TO MOVE THIS TO THE SHARED PROJECT AND MARK AS INTERNAL WHEN YOU FINALY CAN. Declaration public static string _MOVETOSHAREDPROJECT { get; } Property Value Type Description String <!-- .classchild --> Culture Overrides the current thread's CurrentUICulture property for all resource lookups using this strongly typed resource class. Declaration public static CultureInfo Culture { get; set; } Property Value Type Description CultureInfo <!-- .classchild --> CyclicDependencyDetectedInTargetFormat Looks up a localized string similar to Cyclic dependency detected in targets - current target of type {0} with DeclaredType of {1} has tried to include itself in its expression.. Declaration public static string CyclicDependencyDetectedInTargetFormat { get; } Property Value Type Description String <!-- .classchild --> DeclaredTypeIsNotCompatible_Format Looks up a localized string similar to The declared type {0} is not compatible with the type {1}. Declaration public static string DeclaredTypeIsNotCompatible_Format { get; } Property Value Type Description String <!-- .classchild --> LambdaBodyIsNotNewExpressionFormat Looks up a localized string similar to The body of the lambda \"{0}\" is not a NewExpression. Declaration public static string LambdaBodyIsNotNewExpressionFormat { get; } Property Value Type Description String <!-- .classchild --> LambdaBodyNewExpressionIsWrongTypeFormat Looks up a localized string similar to The expression {0} does not represent calling a constructor of the type {1}. Declaration public static string LambdaBodyNewExpressionIsWrongTypeFormat { get; } Property Value Type Description String <!-- .classchild --> MoreThanOneBestConstructorFormat Looks up a localized string similar to More than one constructor for {0} found that could be bound from the current context. Possible candidates: {1}. Declaration public static string MoreThanOneBestConstructorFormat { get; } Property Value Type Description String <!-- .classchild --> MoreThanOneConstructorFormat Looks up a localized string similar to More than one constructor for {0} qualifies as a target for Auto construction. Declaration public static string MoreThanOneConstructorFormat { get; } Property Value Type Description String <!-- .classchild --> MoreThanOneObjectFoundInScope Looks up a localized string similar to More than one matching object was found in the scope. Declaration public static string MoreThanOneObjectFoundInScope { get; } Property Value Type Description String <!-- .classchild --> NoApplicableConstructorForContextFormat Looks up a localized string similar to No constructor found on the type {0} which can be satisfied by the CompileContext. Declaration public static string NoApplicableConstructorForContextFormat { get; } Property Value Type Description String <!-- .classchild --> NoConstructorSetOnNewExpression Looks up a localized string similar to No constructor has been set on the NewExpression - this is not allowed.. Declaration public static string NoConstructorSetOnNewExpression { get; } Property Value Type Description String <!-- .classchild --> NoDefaultOrAllOptionalConstructorFormat Looks up a localized string similar to The type {0} has no default constructor, nor any constructors where all the parameters are optional.. Declaration public static string NoDefaultOrAllOptionalConstructorFormat { get; } Property Value Type Description String <!-- .classchild --> NoPublicConstructorsDefinedFormat Looks up a localized string similar to No public constructors declared on the type {0}. Declaration public static string NoPublicConstructorsDefinedFormat { get; } Property Value Type Description String <!-- .classchild --> NotRuntimeMethod Looks up a localized string similar to This method is not to be called at run-time - it is only used for static expression analysis in creating IRezolveTargets for an IRezolveBuilder. Declaration public static string NotRuntimeMethod { get; } Property Value Type Description String <!-- .classchild --> PathIsAtEnd Looks up a localized string similar to path's Next must not be null - pass path as null once it's reached the last item. Declaration public static string PathIsAtEnd { get; } Property Value Type Description String <!-- .classchild --> PathIsInvalid Looks up a localized string similar to The path {0} is invalid. All path steps must contain non-whitespace characters and be at least one character in length. Declaration public static string PathIsInvalid { get; } Property Value Type Description String <!-- .classchild --> ResourceManager Returns the cached ResourceManager instance used by this class. Declaration public static ResourceManager ResourceManager { get; } Property Value Type Description ResourceManager <!-- .classchild --> RezolverTargetEntryHasBeenRealised Looks up a localized string similar to No more targets can be added to this entry. Declaration public static string RezolverTargetEntryHasBeenRealised { get; } Property Value Type Description String <!-- .classchild --> ScopedSingletonRequiresAScope Looks up a localized string similar to A lifetime scope is required for a scoped singleton. Declaration public static string ScopedSingletonRequiresAScope { get; } Property Value Type Description String <!-- .classchild --> TargetDoesntSupportType_Format Looks up a localized string similar to The target does not support the type {0}. Declaration public static string TargetDoesntSupportType_Format { get; } Property Value Type Description String <!-- .classchild --> TargetIsNullButTypeIsNotNullable_Format Looks up a localized string similar to The type {0} is not a nullable type. Declaration public static string TargetIsNullButTypeIsNotNullable_Format { get; } Property Value Type Description String <!-- .classchild --> TargetReturnedNullExpressionFormat Looks up a localized string similar to Target of type {0} returned a null expression for context {1} - implementation is invalid, targets must never return a null expression.. Declaration public static string TargetReturnedNullExpressionFormat { get; } Property Value Type Description String <!-- .classchild --> TypeIsAlreadyRegistered Looks up a localized string similar to The type {0} has already been registered. Declaration public static string TypeIsAlreadyRegistered { get; } Property Value Type Description String <!-- .classchild --> UnableToResolveTypeFromBuilderFormat Looks up a localized string similar to Unable to resolve type {0} from builder. Declaration public static string UnableToResolveTypeFromBuilderFormat { get; } Property Value Type Description String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ExpressionCompilerTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.ExpressionCompilerTargetContainerExtensions.html",
    "title": "Class ExpressionCompilerTargetContainerExtensions",
    "keywords": "Class ExpressionCompilerTargetContainerExtensions Inheritance Object ExpressionCompilerTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ExpressionCompilerTargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods UseExpressionCompiler(ITargetContainer, ExpressionCompiler) Declaration public static ITargetContainer UseExpressionCompiler(this ITargetContainer targets, ExpressionCompiler compiler = null) Parameters Name Type Description targets ITargetContainer compiler ExpressionCompiler Returns Type Description ITargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ExpressionHelper.html": {
    "href": "rezolver-api/Rezolver.ExpressionHelper.html",
    "title": "Class ExpressionHelper",
    "keywords": "Class ExpressionHelper This static class contains methods and properties to aid in building expressions in an implementation of the Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) method. Inheritance Object ExpressionHelper Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ExpressionHelper <!-- <hr class=\"typeSectionDivider\" /> --> Fields DynamicRezolverParam This parameter expression is to be used by all targets and rezolvers in this library by default to perform late binding to a container provided at run time when a caller is trying to resolve something through code built from a target. Declaration public static readonly ParameterExpression DynamicRezolverParam Field Value Type Description ParameterExpression <!-- .classchild --> RezolveContextParameterExpression The default RezolveContext parameter expression to be used during code generation in an implementation of Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) Declaration public static readonly ParameterExpression RezolveContextParameterExpression Field Value Type Description ParameterExpression <!-- .classchild --> Scope_GetOrAddGenericMethod A MethodInfo object representing the generic definition Declaration public static readonly MethodInfo Scope_GetOrAddGenericMethod Field Value Type Description MethodInfo <!-- .classchild --> Scope_GetScopeRootMethod A MethodInfo object representing the GetScopeRoot(IScopedContainer) method - to aid in code generation where the target scope for tracking an object is the root scope, not the current scope. Declaration public static readonly MethodInfo Scope_GetScopeRootMethod Field Value Type Description MethodInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetLambdaBodyForTarget(ITarget, CompileContext) Provides a standard way to create the method body for a lambda that, when compiled (with the correct signature) will execute code that will produce the object represented by the target. Some rewriting optimisations are applied to the expression tree, the resulting expression tree will be able to be compiled straight to a method if passed into a LambdaExpression. Declaration public static Expression GetLambdaBodyForTarget(ITarget target, CompileContext context) Parameters Name Type Description target ITarget context CompileContext Returns Type Description Expression Remarks Note that the TargetCompilerBase abstract class uses this method to get the expression tree for a target that is to be compiled, and the TargetDelegateCompiler uses that expression tree as-is. Note, however, that some compilers might override this behaviour, or rewrite the generated expression more - in which case this code wouldn't be suitable for those compilers. This method, therefore, is exposed to provide a surefire way to generate a whole lambda that can be compiled into an in-memory delegate for re-use in other targets and scenarios. The SingletonTarget, for example, uses this method during its own Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) implementation to get a nested lambda for the wrapped target, so that it can dynamically construct a Lazy whose factory method is the code we'd normally produce for a target. <!-- .classchild --> GetResolveLambdaForTarget(ITarget, CompileContext) First gets the lambda body using GetLambdaBodyForTarget(ITarget, CompileContext) , then passes that as the body for the returned expression, using also the RezolveContextExpression from the context parameter as the expression for the RezolveContext that's passed to the compiled method when invoked. Declaration public static Expression<Func<RezolveContext, object>> GetResolveLambdaForTarget(ITarget target, CompileContext context) Parameters Name Type Description target ITarget context CompileContext Returns Type Description Expression < Func < RezolveContext , Object >> <!-- .classchild --> Make_Scope_GetOrAddCallExpression(CompileContext, Type, LambdaExpression, Expression) Makes an expression which represents calling the GetOrAdd<T>(IScopedContainer, RezolveContext, Func<RezolveContext, T>, Boolean) function for the passed objectType . Used automatically by the built-in scope tracking behaviour, but can also be used by your own custom target if you want to take control of its scope tracking behaviour. Declaration public static Expression Make_Scope_GetOrAddCallExpression(CompileContext context, Type objectType, LambdaExpression factoryExpression, Expression iDisposableOnly = null) Parameters Name Type Description context CompileContext The compile context. objectType Type Type of the object to be stored or retrieved. factoryExpression LambdaExpression Lambda which should be executed to obtain a new instance if a matching object is not already in scope. iDisposableOnly Expression Expected to be a boolean expression indicating whether only IDisposables should be tracked in the scope. The default (if not provided) then will be set to 'true'. Returns Type Description Expression <!-- .classchild --> Make_Scope_GetScopeRootCallExpression(CompileContext) Returns an expression that represents a call to the Scope_GetScopeRootMethod extension method on the scope of the RezolveContext passed to a compiled object target. Declaration public static Expression Make_Scope_GetScopeRootCallExpression(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ExpressionTarget.html": {
    "href": "rezolver-api/Rezolver.ExpressionTarget.html",
    "title": "Class ExpressionTarget",
    "keywords": "Class ExpressionTarget A generic target for all expressions not explicitly supported by a particular target. Enables more complex behaviours to be registered and used with the more formal ITarget implementations. Inheritance Object TargetBase ExpressionTarget Inherited Members TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ExpressionTarget : TargetBase, ITarget Remarks Note to compiler implementers: This class can be used to represent simple expressions such as constants, constructor calls and so on; but can also contain whole lambda expressions with parameters. In the latter case, expression parameters are expected to receive injected arguments and, therefore, some rewriting of the expression is likely to be required. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ExpressionTarget(Expression, Type) Initializes a new instance of the ExpressionTarget class. Declaration public ExpressionTarget(Expression expression, Type declaredType = null) Parameters Name Type Description expression Expression Required. The static expression which should be used by compilers. declaredType Type Declared type of the target to be created (used when registering without an explicit type or when this target is used as a value inside another target). Remarks declaredType will automatically be determined if not provided by examining the type of the expression . For lambdas, the type will be derived from the Type of the lambda's body. For all other expressions, the type is taken directly from the Type property of the expression itself. <!-- .classchild --> ExpressionTarget(Func<ICompileContext, Expression>, Type) Initializes a new instance of the ExpressionTarget class. Declaration public ExpressionTarget(Func<ICompileContext, Expression> expressionFactory, Type declaredType) Parameters Name Type Description expressionFactory Func < ICompileContext , Expression > Required. The factory delegate that a compiler should call to get the expression to use when compiling this target. declaredType Type Required. Static type of all expressions that will be returned by expressionFactory . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Gets the type of Expression or the type that all expressions returned by the ExpressionFactory are expected to be equal to. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> Expression Gets the static expression represented by this target - if null , then a factory is being used to produce the expression, which is available from the ExpressionFactory property. Declaration public Expression Expression { get; } Property Value Type Description Expression <!-- .classchild --> ExpressionFactory Gets a factory which will be executed to obtain an expression given a particular ICompileContext . If null , then a static expression will be used instead and is available from the Expression property. Declaration public Func<ICompileContext, Expression> ExpressionFactory { get; } Property Value Type Description Func < ICompileContext , Expression > <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ExpressionTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.ExpressionTargetContainerExtensions.html",
    "title": "Class ExpressionTargetContainerExtensions",
    "keywords": "Class ExpressionTargetContainerExtensions Contains numerous generic overloads of the RegisterExpression extension method for ITargetContainer All of these extensions act as proxies for the RegisterExpression(ITargetContainer, Expression, Type) extension method. Inheritance Object ExpressionTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ExpressionTargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterExpression(ITargetContainer, Expression, Type) Registers the expression. Declaration public static void RegisterExpression(this ITargetContainer targetContainer, Expression expression, Type type) Parameters Name Type Description targetContainer ITargetContainer The target container. expression Expression The expression. type Type The type. <!-- .classchild --> RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<TResult>(this ITargetContainer targetContainer, Expression<Func<TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < ResolveContext , TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) T15 The type of the 15th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) T15 The type of the 15th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T, TResult>(this ITargetContainer targetContainer, Expression<Func<T, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T The type of the 1st lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < ResolveContext , T, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T The type of the 2nd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < ResolveContext , T2, T3, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < ResolveContext , T2, T3, T4, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < ResolveContext , T2, T3, T4, T5, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < ResolveContext , T2, T3, T4, T5, T6, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression, Type type = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, TResult>> The lambda expression that is to be converted into a target and registered type Type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Functions.html": {
    "href": "rezolver-api/Rezolver.Functions.html",
    "title": "Class Functions",
    "keywords": "Class Functions This type is only used when using expressions as targets (via the ExpressionTarget type) - it's functions server no actual purpose other than to act as hooks to create specific ITarget objects in place of static code. For example, the Resolve<T>() function is used to trigger the creation of a RezolvedTarget in its place - thus allowing expressions to leverage the full power of the Rezolver API all through a simple method call. Inheritance Object Functions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class Functions <!-- <hr class=\"typeSectionDivider\" /> --> Methods Resolve<T>() Translated to a RezolvedTarget with T being the type that will be resolved in this function's place. Declaration public static T Resolve<T>() Returns Type Description T Type Parameters Name Description T The type to be resolved. Exceptions Type Condition NotImplementedException Always. The method is not intended to be used outside of an expression. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.GenericConstructorTarget.html": {
    "href": "rezolver-api/Rezolver.GenericConstructorTarget.html",
    "title": "Class GenericConstructorTarget",
    "keywords": "Class GenericConstructorTarget Equivalent of ConstructorTarget but for open generic types. So, this will handle the open generic MyType<,>, for example, whereas ConstructorTarget would handle the closed type MyType<int, string>. Inheritance Object TargetBase GenericConstructorTarget Inherited Members TargetBase.SuppressScopeTracking TargetBase.UseFallback Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class GenericConstructorTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors GenericConstructorTarget(Type, IMemberBindingBehaviour) Constructs a new instance of the GenericConstructorTarget for the given open generic type, which will utilise the optional memberBindingBehaviour when it constructs its ConstructorTarget when Bind(ICompileContext) is called. Declaration public GenericConstructorTarget(Type genericType, IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Name Type Description genericType Type The type of the object that is to be built (open generic of course) memberBindingBehaviour IMemberBindingBehaviour Optional. The IMemberBindingBehaviour to be used for binding properties and/or fields on the ConstructorTarget that is generated. If null, then no property or fields will be bound on construction. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Implementation of the abstract base property. Will retrn the unbound generic type passed to this object on construction. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> GenericType Gets the generic type definition from which generic types are to be built and instances of which will be constructed. Declaration public Type GenericType { get; } Property Value Type Description Type <!-- .classchild --> MemberBindingBehaviour Gets the member binding behaviour to be used when creating an instance. Declaration public IMemberBindingBehaviour MemberBindingBehaviour { get; } Property Value Type Description IMemberBindingBehaviour The member binding behaviour. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Auto(Type, IMemberBindingBehaviour) Equivalent of Auto(Type, IMemberBindingBehaviour) but for open generic types. Declaration public static ITarget Auto(Type type, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description type Type The type. propertyBindingBehaviour IMemberBindingBehaviour The property binding behaviour. Returns Type Description ITarget Exceptions Type Condition ArgumentException The passed type must be an open generic type or The passed type must a non-abstract class <!-- .classchild --> Auto<TGeneric>(IMemberBindingBehaviour) Equivalent of Auto<T>(IMemberBindingBehaviour) but for open generic types. Declaration public static ITarget Auto<TGeneric>(IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description propertyBindingBehaviour IMemberBindingBehaviour Optional behaviour controlling which properties and fields, if any, receive injected values. Returns Type Description ITarget Type Parameters Name Description TGeneric The open generic type from which a closed generic will be created when this target is called upon to create an instance. <!-- .classchild --> Bind(ICompileContext) Obtains an ITarget (usually a ConstructorTarget ) which will create an instance of a generic type (whose definition is equal to GenericType ) with generic arguments set correctly according to the TargetType of the context . Declaration public ITarget Bind(ICompileContext context) Parameters Name Type Description context ICompileContext The context. Returns Type Description ITarget Remarks The process of binding a requested type to the concrete type can be a very complex process, when inheritance chains and interface implementation maps are taken into account. At the simplest end of the spectrum, if GenericType is MyGeneric<> and the context 's TargetType is MyGeneric<int> , then this function merely has to insert the int type as the generic parameter to the MyGeneric<> type definition, bake a new type and create an auto-bound ConstructorTarget . Consider what happens, however, when the inheritance chain is more complex: interface IMyInterfaceCore<T, U> { } class MyBaseClass<T, U> : IMyInterfaceCore<U, T> { } class MyDerivedClass<T, U> : MyBaseClass<U, T> { } A GenericConstructorTarget bound to the generic type definition MyDerivedClass<,> can create instances not only of any generic type based on that definition, but also any generic type based on the definitions of either it's immediate base, or that base's interface. In order to do so, however, the parameters must be mapped between the generic type definitions so that if an instance of MyBaseClass<string, int> is requested, then an instance of MyDerivedClass<int, string> (note the arguments are reversed) is actually created. Similarly, if an instance of IMyInterface<string, int> is requested, we actually need to create an instance of MyDerivedClass<string, int> - because the generic arguments are reversed first through the base class inheritance, and then again by the base class' implementation of the interface. Note that a GenericConstructorTarget can only bind to the context's target type if there is enough information in order to deduce the generic type arguments for GenericType . This means, in general, that the requested type will almost always need to be a generic type with at least as many type arguments as the GenericType . <!-- .classchild --> SupportsType(Type) Override - introduces additional logic to cope with generic types not generally supported by the majority of other targets. Declaration public override bool SupportsType(Type type) Parameters Name Type Description type Type Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.GenericTargetContainer.html": {
    "href": "rezolver-api/Rezolver.GenericTargetContainer.html",
    "title": "Class GenericTargetContainer",
    "keywords": "Class GenericTargetContainer A special type of ITargetContainerOwner which stores targets (and potentially other containers) which are specifically keyed either to a particular open generic type or a closed generic built from it. Inheritance Object TargetDictionaryContainer GenericTargetContainer Inherited Members TargetDictionaryContainer.FetchContainer(Type) TargetDictionaryContainer.RegisterContainer(Type, ITargetContainer) TargetDictionaryContainer.CreateContainer(Type, ITarget) TargetDictionaryContainer.CombineWith(ITargetContainer, Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class GenericTargetContainer : TargetDictionaryContainer, ITargetContainerOwner, ITargetContainer Remarks You don't typically use this container directly - it is implicitly added to an ITargetContainer when generic types are registered. Indeed the TargetContainer and DecoratingTargetContainer booth create instances of this; and the Rezolver.EnumerableTargetContainer (understandably) inherits from it. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors GenericTargetContainer(Type) Initializes a new instance of the GenericTargetContainer class. Declaration public GenericTargetContainer(Type genericType) Parameters Name Type Description genericType Type Required. The generic type definition that all targets and subcontainers will be grouped under. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties GenericType Gets the open generic type definition which is common to all targets and containers within this container. Declaration public Type GenericType { get; } Property Value Type Description Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Fetch(Type) Gets the target which can be used to build an instance of type . Declaration public override ITarget Fetch(Type type) Parameters Name Type Description type Type Required. The type for which a target is to be obtained. Because of the restrictions placed on the DeclaredType of the targets that can actually be registered into this container, the function will only ever return anything if type is a closed generic type whose definition equals GenericType . Returns Type Description ITarget Overrides TargetDictionaryContainer.Fetch(Type) Remarks Targets which have been registered specifically against the exact closed generic type represented by type take precedence over any targets which have been registered against the open generic type GenericType . <!-- .classchild --> FetchAll(Type) Implementation of FetchAll(Type) Declaration public override IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type Type The type whose targets are to be retrieved. Returns Type Description IEnumerable < ITarget > Overrides TargetDictionaryContainer.FetchAll(Type) <!-- .classchild --> Register(ITarget, Type) Overrides the Register(ITarget, Type) method to support registering both targets against the open generic type GenericType and against specific closed versions of that open generic type. Declaration public override void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget The target to be registered serviceType Type Service type against which the registration will be made. If null, then it will be assumed to be equal to GenericType . Only types equal to GenericType or generic types whose generic type definition is equal to GenericType are supported. Overrides TargetDictionaryContainer.Register(ITarget, Type) Remarks Notes to overriders: When serviceType is a closed generic type, this function creates an ITargetContainer for that serviceType by calling the protected method CreateContainer(Type, ITarget) if one doesn't exist (it calls FetchContainer(Type) to check for existence), and then chains to its Register(ITarget, Type) method. Exceptions Type Condition ArgumentException If serviceType is not equal to GenericType or is not a closed generic type whose generic type definition is GenericType . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IChildTargetContainer.html": {
    "href": "rezolver-api/Rezolver.IChildTargetContainer.html",
    "title": "Interface IChildTargetContainer",
    "keywords": "Interface IChildTargetContainer An ITargetContainer that inherits all registrations from a ( Parent ) target container. If it cannot resolve a target for a particular type, will defer to its parent for fallback. Inherited Members ITargetContainer.Register(ITarget, Type) ITargetContainer.Fetch(Type) ITargetContainer.FetchAll(Type) ITargetContainer.CombineWith(ITargetContainer, Type) Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IChildTargetContainer : ITargetContainer Remarks Note that the framework does not require that enumerables of targets (retrieved by calling FetchAll(Type) are merged between a child and parent container. Typically, as soon as one registration exists in a child container for the same type as in the parent, it overrides all registrations in the parent for that same type. <!-- <hr class=\"typeSectionDivider\" /> --> Properties Parent Gets the parent target container. Declaration ITargetContainer Parent { get; } Property Value Type Description ITargetContainer The parent. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ICompiledTarget.html": {
    "href": "rezolver-api/Rezolver.ICompiledTarget.html",
    "title": "Interface ICompiledTarget",
    "keywords": "Interface ICompiledTarget Provides an abstraction for creating objects based on a given ResolveContext - this is the ultimate target of all Resolve(ResolveContext) calls in the standard container implementations within the Rezolver framework. Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ICompiledTarget Remarks In the standard implementations of IContainer (e.g. Container ), a ITargetCompiler creates instances of this from ITarget s which are registered in an ITargetContainer . When the container is then called upon to resolve an instance of a particular type, the ICompiledTarget is first obtained, and then the responsibility for creating the object is delegated to its GetObject(ResolveContext) method. <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetObject(ResolveContext) Called to get/create an object, potentially using the passed context to resolve additional dependencies (via its Container ), or interact with any lifetime scope which is 'active' for that request (through Scope ). Declaration object GetObject(ResolveContext context) Parameters Name Type Description context ResolveContext The current rezolve context. Returns Type Description Object The object that is constructed. The return value can legitimately be null. Exceptions Type Condition InvalidOperationException If the target fails to create the object Exception Any other application-level exception could be raised by this operation <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IContainer.html": {
    "href": "rezolver-api/Rezolver.IContainer.html",
    "title": "Interface IContainer",
    "keywords": "Interface IContainer The primary IOC container interface in the Rezolver framework. Inherited Members IServiceProvider.GetService(Type) Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IContainer : IServiceProvider Remarks Instances of objects (typically known as 'services' in IOC-speak) are resolved via the Resolve(ResolveContext) or TryResolve(ResolveContext, out Object) methods. You can introspect the container to check in advance whether a given type can be resolved through the CanResolve(ResolveContext) method. Lifetime scoping (where IDisposable objects are created within a scope and destroyed when that scope is destroyed) can be achieved by obtaining a new scope through the CreateLifetimeScope() method; although a container might also implement the IScopedContainer interface, in which case the container itself is a lifetime scope. Many of the functions which accept a ResolveContext also have alternatives (in the form of extension methods) in the IContainerRezolveExtensions class. If you're looking for the 'traditional' IOC container methods (e.g. Resolve<TObject>(IContainer) , that's where you'll find them. Note that while the standard implementation of this interface supplied by the framework ( ContainerBase and its derivatives) all utilitise the ITargetContainer to actually locate registrations for types which are ultimately requested from the container; the interface doesn't actually mandate that pattern. <!-- <hr class=\"typeSectionDivider\" /> --> Methods CanResolve(ResolveContext) Returns true if a resolve operation for the given context will succeed. If you're going to be calling Resolve(ResolveContext) immediately afterwards, consider using the TryResolve(ResolveContext, out Object) method instead, which allows you to check and obtain the result at the same time. Declaration bool CanResolve(ResolveContext context) Parameters Name Type Description context ResolveContext The resolve context. Returns Type Description Boolean true if this instance can resolve a type for the specified context; otherwise, false . <!-- .classchild --> CreateLifetimeScope() Called to create an IScopedContainer which can resolve the same objects as this container, but which will track, and dispose of, any disposable objects that it creates. Declaration IScopedContainer CreateLifetimeScope() Returns Type Description IScopedContainer Remarks If the container on which this is called also implements the IScopedContainer interface, then the newly created scope's lifetime will be tied to that parent container. <!-- .classchild --> FetchCompiled(ResolveContext) Fetches the ICompiledTarget for the given context, whose GetObject(ResolveContext) method would ultimately be called if the same context was passed to Resolve(ResolveContext) or TryResolve(ResolveContext, out Object) . Declaration ICompiledTarget FetchCompiled(ResolveContext context) Parameters Name Type Description context ResolveContext The context. Returns Type Description ICompiledTarget Remarks This is not typically a method that you're likely to use as the consumer of an IContainer . It's more typically used by implementations of ITargetCompiler or implementations of IContainer when communicating with other containers. As such, its use at an application level is limited. <!-- .classchild --> Resolve(ResolveContext) Called to resolve a reference to an object for the given context (which provides the RequestedType of the object that is required, among other things). Declaration object Resolve(ResolveContext context) Parameters Name Type Description context ResolveContext The context. Returns Type Description Object The resolved object, if successful. Exceptions Type Condition InvalidOperationException If the requested type cannot be resolved. <!-- .classchild --> TryResolve(ResolveContext, out Object) Merges the CanResolve(ResolveContext) and Resolve(ResolveContext) operations into one operation. Declaration bool TryResolve(ResolveContext context, out object result) Parameters Name Type Description context ResolveContext The context. result Object Receives the resultant resolved object if the operation succeeds. Returns Type Description Boolean true if the operation succeeded (the resolved object will be set into the result parameter); false otherwise. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IContainerRezolveExtensions.html": {
    "href": "rezolver-api/Rezolver.IContainerRezolveExtensions.html",
    "title": "Class IContainerRezolveExtensions",
    "keywords": "Class IContainerRezolveExtensions Extension methods for IContainer which provide shortcuts for the Resolve(ResolveContext) operation. Inheritance Object IContainerRezolveExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class IContainerRezolveExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods Resolve(IContainer, Type) Resolves an object of the given type Declaration public static object Resolve(this IContainer container, Type type) Parameters Name Type Description container IContainer The container. type Type The type to be resolved. Returns Type Description Object An instance of the type . <!-- .classchild --> Resolve(IContainer, Type, IScopedContainer) Resolves an object of the given type , using the given lifetime scope for lifetime management. Declaration public static object Resolve(this IContainer container, Type type, IScopedContainer scope) Parameters Name Type Description container IContainer The container. type Type Type to be resolved. scope IScopedContainer The lifetime scope - can be a different instance to container (or the object on which the method is invoked if invoked as an extension method), e.g. when a master container instance is used to create a child 'scope' which has a different lifetime to that of the master. Returns Type Description Object An instance of the requested type . <!-- .classchild --> Resolve<TObject>(IContainer) Resolves an object of type TObject Declaration public static TObject Resolve<TObject>(this IContainer container) Parameters Name Type Description container IContainer The container. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject The type to be resolved. <!-- .classchild --> Resolve<TObject>(IContainer, IScopedContainer) Resolves an object of the type TObject , using the given lifetime scope for lifetime management. Declaration public static TObject Resolve<TObject>(this IContainer container, IScopedContainer scope) Parameters Name Type Description container IContainer The container. scope IScopedContainer The lifetime scope - can be a different instance to container (or the object on which the method is invoked if invoked as an extension method), e.g. when a master container instance is used to create a child 'scope' which has a different lifetime to that of the master. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject Type to be resolved. <!-- .classchild --> TryResolve(IContainer, Type, IScopedContainer, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer container, Type type, IScopedContainer scope, out object result) Parameters Name Type Description container IContainer The container. type Type The type to be resolved. scope IScopedContainer The lifetime scope - can be a different instance to container (or the object on which the method is invoked if invoked as an extension method), e.g. when a master container instance is used to create a child 'scope' which has a different lifetime to that of the master. result Object Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type, IScopedContainer) overloads <!-- .classchild --> TryResolve(IContainer, Type, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer container, Type type, out object result) Parameters Name Type Description container IContainer The container. type Type The type to be resolved. result Object Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type) overloads <!-- .classchild --> TryResolve<TObject>(IContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer container, out TObject result) Parameters Name Type Description container IContainer The container. result TObject Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved. <!-- .classchild --> TryResolve<TObject>(IContainer, IScopedContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer container, IScopedContainer scope, out TObject result) Parameters Name Type Description container IContainer The container. scope IScopedContainer The lifetime scope - can be a different instance to container (or the object on which the method is invoked if invoked as an extension method), e.g. when a master container instance is used to create a child 'scope' which has a different lifetime to that of the master. result TObject Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IMemberBindingBehaviour.html": {
    "href": "rezolver-api/Rezolver.IMemberBindingBehaviour.html",
    "title": "Interface IMemberBindingBehaviour",
    "keywords": "Interface IMemberBindingBehaviour Describes a type which discovers and creates property/field bindings, typically for use when creating a new instance. Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IMemberBindingBehaviour Remarks The default implementation of this is DefaultMemberBindingBehaviour , which always binds all publicly writable instance properties and publicly accessible instance fields to auto-generated RezolvedTarget targets. <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetMemberBindings(ICompileContext, Type) Retrieves the property and/or field bindings for the given type based on the given context . Declaration MemberBinding[] GetMemberBindings(ICompileContext context, Type type) Parameters Name Type Description context ICompileContext The current compilation context (will be used to look up ITarget references from its implementation of ITargetContainer type Type The type whose writable members are to be probed. Returns Type Description MemberBinding [] Zero or more bindings for the members of the type . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IPropertyBindingBehaviour.html": {
    "href": "rezolver-api/Rezolver.IPropertyBindingBehaviour.html",
    "title": "Interface IPropertyBindingBehaviour",
    "keywords": "Interface IPropertyBindingBehaviour Describes a type which discovers property/field bindings Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IPropertyBindingBehaviour <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetPropertyBindings(CompileContext, Type) Retrieves the property and/or field bindings for the given type based on the given CompileContext Declaration PropertyOrFieldBinding[] GetPropertyBindings(CompileContext context, Type type) Parameters Name Type Description context CompileContext type Type Returns Type Description PropertyOrFieldBinding [] <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IRezolverExtensions.html": {
    "href": "rezolver-api/Rezolver.IRezolverExtensions.html",
    "title": "Class IRezolverExtensions",
    "keywords": "Class IRezolverExtensions Inheritance Object IRezolverExtensions Inherited Members ToString() Equals(Object) Equals(Object, Object) ReferenceEquals(Object, Object) GetHashCode() GetType() MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class IRezolverExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods Register(IContainer, ITarget, Type) Wrapper for the Register(ITarget, Type) method of the rezolver argument's Rezolver.IContainer.Builder Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void Register(this IContainer rezolver, ITarget target, Type type = null) Parameters Name Type Description rezolver IContainer target ITarget type Type <!-- .classchild --> RegisterAll(IContainer, ITarget[]) Parameter array version of the RegisterAll method. Declaration public static void RegisterAll(this IContainer rezolver, params ITarget[] targets) Parameters Name Type Description rezolver IContainer The rezolver. targets ITarget [] The targets. <!-- .classchild --> RegisterAll(IContainer, IEnumerable<ITarget>) Batch-registers multiple targets with different contracts. Basically, this is like calling Register(IRezolveTarget) multiple times, but with an enumerable. Declaration public static void RegisterAll(this IContainer rezolver, IEnumerable<ITarget> targets) Parameters Name Type Description rezolver IContainer targets IEnumerable < ITarget > <!-- .classchild --> RegisterExpression<T>(IContainer, Expression<Func<RezolveContextExpressionHelper, T>>, Type, ITargetAdapter) Wrapper for the , please see that method for the reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterExpression<T>(this IContainer rezolver, Expression<Func<RezolveContextExpressionHelper, T>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description rezolver IContainer The rezolver. expression Expression < Func < RezolveContextExpressionHelper , T>> type Type adapter ITargetAdapter Type Parameters Name Description T <!-- .classchild --> RegisterMultiple(IContainer, IEnumerable<ITarget>, Type) Wrapper for the RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterMultiple(this IContainer rezolver, IEnumerable<ITarget> targets, Type commonServiceType = null) Parameters Name Type Description rezolver IContainer The rezolver. targets IEnumerable < ITarget > commonServiceType Type <!-- .classchild --> RegisterObject<T>(IContainer, T, Type, Boolean) Wrapper for the RegisterObject<T>(ITargetContainer, T, Type, Boolean) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterObject<T>(this IContainer rezolver, T obj, Type type = null, bool suppressScopeTracking = true) Parameters Name Type Description rezolver IContainer The rezolver. obj T type Type suppressScopeTracking Boolean Type Parameters Name Description T <!-- .classchild --> RegisterScoped(IContainer, Type, Type, IPropertyBindingBehaviour) Wrapper for the , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterScoped(this IContainer rezolver, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description rezolver IContainer objectType Type serviceType Type propertyBindingBehaviour IPropertyBindingBehaviour <!-- .classchild --> RegisterScoped<TObject>(IContainer, IPropertyBindingBehaviour) Wrapper for the RegisterScoped<TObject>(ITargetContainer, IPropertyBindingBehaviour) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterScoped<TObject>(this IContainer rezolver, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description rezolver IContainer propertyBindingBehaviour IPropertyBindingBehaviour Type Parameters Name Description TObject <!-- .classchild --> RegisterScoped<TObject, TService>(IContainer, IPropertyBindingBehaviour) Wrapper for the RegisterScoped<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterScoped<TObject, TService>(this IContainer rezolver, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description rezolver IContainer propertyBindingBehaviour IPropertyBindingBehaviour Type Parameters Name Description TObject TService <!-- .classchild --> RegisterType(IContainer, Type, Type, IPropertyBindingBehaviour) Wrapper for the RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterType(this IContainer rezolver, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description rezolver IContainer objectType Type serviceType Type propertyBindingBehaviour IPropertyBindingBehaviour <!-- .classchild --> RegisterType<TObject>(IContainer, IPropertyBindingBehaviour) Wrapper for the RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterType<TObject>(this IContainer rezolver, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description rezolver IContainer The rezolver. propertyBindingBehaviour IPropertyBindingBehaviour The property binding behaviour. Type Parameters Name Description TObject Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via their 'Auto' static methods and then registering them. <!-- .classchild --> RegisterType<TObject, TService>(IContainer, IPropertyBindingBehaviour) Wrapper for the , please see that method for reference for the parameters Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterType<TObject, TService>(this IContainer rezolver, IPropertyBindingBehaviour propertyBindingBehaviour = null)where TObject : TService Parameters Name Type Description rezolver IContainer propertyBindingBehaviour IPropertyBindingBehaviour Type Parameters Name Description TObject TService <!-- .classchild --> Resolve(IContainer, Type) Resolves an object of the given type Declaration public static object Resolve(this IContainer rezolver, Type type) Parameters Name Type Description rezolver IContainer The rezolver. type Type The type to be resolved. Returns Type Description Object An instance of the type . <!-- .classchild --> Resolve(IContainer, Type, IScopedContainer) Resolves an object of the given type , using the given lifetime scope for lifetime management. Declaration public static object Resolve(this IContainer rezolver, Type type, IScopedContainer scope) Parameters Name Type Description rezolver IContainer The rezolver. type Type Type to be resolved. scope IScopedContainer The lifetime scope - can be a different instance to rezolver (or the object on which the method is invoked if invoked as an extension method), e.g. when a master rezolver instance is used to create a child 'scope' which has a different lifetime to that of the master. Returns Type Description Object An instance of the requested type . <!-- .classchild --> Resolve<TObject>(IContainer) Resolves an object of type TObject Declaration public static TObject Resolve<TObject>(this IContainer rezolver) Parameters Name Type Description rezolver IContainer The rezolver. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject The type to be resolved. <!-- .classchild --> Resolve<TObject>(IContainer, IScopedContainer) Resolves an object of the type TObject , using the given lifetime scope for lifetime management. Declaration public static TObject Resolve<TObject>(this IContainer rezolver, IScopedContainer scope) Parameters Name Type Description rezolver IContainer The rezolver. scope IScopedContainer The lifetime scope - can be a different instance to rezolver (or the object on which the method is invoked if invoked as an extension method), e.g. when a master rezolver instance is used to create a child 'scope' which has a different lifetime to that of the master. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject Type to be resolved. <!-- .classchild --> TryResolve(IContainer, Type, IScopedContainer, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer rezolver, Type type, IScopedContainer scope, out object result) Parameters Name Type Description rezolver IContainer The rezolver. type Type The type to be resolved. scope IScopedContainer The lifetime scope - can be a different instance to rezolver (or the object on which the method is invoked if invoked as an extension method), e.g. when a master rezolver instance is used to create a child 'scope' which has a different lifetime to that of the master. result Object Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type, IScopedContainer) overloads <!-- .classchild --> TryResolve(IContainer, Type, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer rezolver, Type type, out object result) Parameters Name Type Description rezolver IContainer The rezolver. type Type The type to be resolved. result Object Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type) overloads <!-- .classchild --> TryResolve<TObject>(IContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer rezolver, out TObject result) Parameters Name Type Description rezolver IContainer The rezolver. result TObject Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved. <!-- .classchild --> TryResolve<TObject>(IContainer, IScopedContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer rezolver, IScopedContainer scope, out TObject result) Parameters Name Type Description rezolver IContainer The rezolver. scope IScopedContainer The lifetime scope - can be a different instance to rezolver (or the object on which the method is invoked if invoked as an extension method), e.g. when a master rezolver instance is used to create a child 'scope' which has a different lifetime to that of the master. result TObject Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IRezolveTargetScopingExtensions.html": {
    "href": "rezolver-api/Rezolver.IRezolveTargetScopingExtensions.html",
    "title": "Class IRezolveTargetScopingExtensions",
    "keywords": "Class IRezolveTargetScopingExtensions Extension method(s) to convert targets into scoped targets. Inheritance Object IRezolveTargetScopingExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class IRezolveTargetScopingExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods Scoped(ITarget) Creates a ScopedTarget from the target on which this method is invoked. Declaration public static ScopedTarget Scoped(this ITarget target) Parameters Name Type Description target ITarget Returns Type Description ScopedTarget <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IRezolveTargetSingletonExtensions.html": {
    "href": "rezolver-api/Rezolver.IRezolveTargetSingletonExtensions.html",
    "title": "Class IRezolveTargetSingletonExtensions",
    "keywords": "Class IRezolveTargetSingletonExtensions Extension method(s) to convert targets into singleton targets. Inheritance Object IRezolveTargetSingletonExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class IRezolveTargetSingletonExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods Singleton(ITarget) Constructs a SingletonTarget that wraps the target on which the method is invoked. Declaration public static SingletonTarget Singleton(this ITarget target) Parameters Name Type Description target ITarget Returns Type Description SingletonTarget <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IScopedContainer.html": {
    "href": "rezolver-api/Rezolver.IScopedContainer.html",
    "title": "Interface IScopedContainer",
    "keywords": "Interface IScopedContainer A container that's also a lifetime scope - that is, it's disposable, and will dispose of any disposable instances that it creates when it's disposed. Also, any subsequent lifetime scopes that it, or any child, creates will be disposed of when this scope is disposed. Note that while a lifetime scope can track objects of any types, it only automatically tracks disposable objects. To force a scope to track an instance, regardless of whether it's dispoable or not, you can call AddToScope(Object, ResolveContext) . This is how the default ScopedSingletonTarget works - if an object with this lifetime isn't a disposable, it is explicitly added to the scope passed to it at runtime, and then when an instance is subsequently requested, the code compiled by the scoped singleton will search the current scope, for an existing instance, before creating one. Inherited Members IContainer.CanResolve(ResolveContext) IContainer.Resolve(ResolveContext) IContainer.TryResolve(ResolveContext, Object) IContainer.CreateLifetimeScope() IContainer.FetchCompiled(ResolveContext) IServiceProvider.GetService(Type) IDisposable.Dispose() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IScopedContainer : IContainer, IServiceProvider, IDisposable <!-- <hr class=\"typeSectionDivider\" /> --> Properties ParentScope If this lifetime scope is a child of another, this will be non-null. Declaration IScopedContainer ParentScope { get; } Property Value Type Description IScopedContainer <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods AddToScope(Object, ResolveContext) Registers an instance to this scope which, if disposable, will then be disposed when this scope is disposed. Declaration void AddToScope(object obj, ResolveContext context = null) Parameters Name Type Description obj Object The object; if null, then no operation is performed. Doesn't have to be IDisposable, but if it is, then it will be tracked for disposal. context ResolveContext Optional - a rezolve context representing the conditions under which the object should be returned in the enumerable returned from a call to GetFromScope <!-- .classchild --> GetFromScope(ResolveContext) Retrieves all objects from this scope that were previously added through a call to AddToScope(Object, ResolveContext) with RezolveContexts that match the one passed. The method never returns null. Declaration IEnumerable<object> GetFromScope(ResolveContext context) Parameters Name Type Description context ResolveContext Required - the context whose properties will be used to find matching objects. Returns Type Description IEnumerable < Object > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Events Disposed This event is fired before the scope disposes This is primarily for infrastructure purposes, and not intended to be used from your code. Declaration event EventHandler Disposed Event Type Type Description EventHandler <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITarget.html": {
    "href": "rezolver-api/Rezolver.ITarget.html",
    "title": "Interface ITarget",
    "keywords": "Interface ITarget Represents an action to be performed in order to obtain an object to satisfy a call to Resolve(ResolveContext) , when the standard implementations of IContainer are used (e.g. Container ). Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITarget Remarks As mentioned in the summary, the role of this interface is largely determined by the framework's own standard implementations of the IContainer interface - all of which use an ITargetContainer to store service registrations which, when Resolve(ResolveContext) is called, is queried to obtain one or more targets which will have been registered for the requested type. After obtaining a target, an ITargetCompiler is then used to compile the target(s) into an ICompiledTarget whose GetObject(ResolveContext) method will ultimately then be called to 'resolve' the instance. The role of the target, then, is to act as a description of the action that is to be performed by that compiled target that is built from it. The interface doesn't describe the type of target in hand - it only provides the core data required to query the static type of the target (the type of object that the target will produce) and to determine compatibility with a request for a particular type. The framework's many implementations of this interface - e.g. ConstructorTarget , SingletonTarget , RezolvedTarget plus many others - then define the behaviour and any additional data required in order for a compiler to produce an ICompiledTarget which matches the target's intent. E.g, the ConstructorTarget , which represents creating a new instance via a constructor, provides all the necessary information to bind to the correct constructor (including parameter bindings etc) - and the compiler's job is to translate that into an ICompiledTarget which executes that constructor, returning the result. <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Gets the static type of the object produced from this target. For example, if this target represents executing a constructor on a type, then this property should equal the type to which that constructor belongs. Declaration Type DeclaredType { get; } Property Value Type Description Type <!-- .classchild --> UseFallback If true , then the consumer should consider falling back to a more suitable target if available, as the object produced from this target is most likely a default of some kind - e.g. empty enumerable, default parameter value. Declaration bool UseFallback { get; } Property Value Type Description Boolean <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods SupportsType(Type) Returns a boolean indicating whether the target is able to produce an instance of, or an instance that is compatible with, the passed type . Declaration bool SupportsType(Type type) Parameters Name Type Description type Type The type. Returns Type Description Boolean true if type is supported, false otherwise. Remarks It is strongly suggested that you use this method to check whether the target can construct an instance of a given type rather than performing any type checking yourself on the DeclaredType , because an ITarget might be able to support a much wider range of types other than just those which are directly compatible with its DeclaredType . For example, the GenericConstructorTarget is statically bound to an open generic, so therefore traditional type checks on the DeclaredType do not work. That class' implementation of this method, however, contains the complex logic necessary to determine if the open generic can be closed into a generic type which is compatible with the given type . Implementations of ITargetCompiler should always consult this function in their implementation of CompileTarget(ITarget, ICompileContext) to determine if the target is compatible with the TargetType of the CompileContext <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITargetAdapter.html": {
    "href": "rezolver-api/Rezolver.ITargetAdapter.html",
    "title": "Interface ITargetAdapter",
    "keywords": "Interface ITargetAdapter Interface for an object that can convert Expressions into ITarget s suitable for registration in an ITargetContainer Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITargetAdapter Remarks If you are considering manually creating an ExpressionTarget for an expression, then you should consider instead using an implementation of this interface to produce an ITarget for that expression. For example, the TargetAdapter class supplied by the framework, has the ability to convert some common code constructs into specific types of targets so as to properly leverage the power of the Rezolver framework at runtime. That class also has the ability to translate a whole lambda expression into a target, including converting any parameters for that lambda into injected variables. <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateTarget(Expression) Declaration ITarget CreateTarget(Expression expression) Parameters Name Type Description expression Expression Returns Type Description ITarget <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITargetCompiler.html": {
    "href": "rezolver-api/Rezolver.ITargetCompiler.html",
    "title": "Interface ITargetCompiler",
    "keywords": "Interface ITargetCompiler An object that produces ICompiledTarget s from ITarget s given a particular CompileContext . Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITargetCompiler <!-- <hr class=\"typeSectionDivider\" /> --> Methods CompileTarget(ITarget, CompileContext) Create the ICompiledTarget for the given target using the context to inform the type of object that is to be built, and for compile-time dependency resolution. Declaration ICompiledTarget CompileTarget(ITarget target, CompileContext context) Parameters Name Type Description target ITarget Required. The target to be compiled. context CompileContext Required. The current compilation context. Returns Type Description ICompiledTarget A compiled target which can then be used to get produce objects represented by the target . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITargetContainer.html": {
    "href": "rezolver-api/Rezolver.ITargetContainer.html",
    "title": "Interface ITargetContainer",
    "keywords": "Interface ITargetContainer Stores and retrieves ITarget instances, keyed by the type of service that the targets are registered against. This is where all your service registrations will ultimately go. Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITargetContainer Remarks You do not resolve objects from a target container, instead, it holds the ITarget s which will later be compiled to produce the objects. A target container is considered mutable for its entire lifetime, because it's only a glorified dictionary of targets from which multiple IContainer objects can be built (when using the types provided in the framework). As an example, the Container class uses this as the source of the registrations that it uses to resolve objects in its Resolve(ResolveContext) implementation. Note that there are multiple implementations of this interface in the framework, however the two you will use most commonly are TargetContainer and ChildTargetContainer . <!-- <hr class=\"typeSectionDivider\" /> --> Methods CombineWith(ITargetContainer, Type) If supported by the implementation, this gets the container built from combining this container with an existing container as part of a registration inside another ITargetContainerOwner . Declaration ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer The existing ITargetContainer instance that this instance is to be combined with type Type The type that the combined container owner will be registered under. Returns Type Description ITargetContainer Remarks Used most frequently in implementations of RegisterContainer(Type, ITargetContainer) when a container owner is already registered against the type, and a new container owner is then registered against the same type. This behaviour is used to implement open generics and decorators, and can be used to implement more besides. Exceptions Type Condition NotSupportedException If this container doesn't support being combined with another. <!-- .classchild --> Fetch(Type) Retrieves a target for a particular type, or null if no target is registered against that type. Declaration ITarget Fetch(Type type) Parameters Name Type Description type Type Required. The type for which an ITarget is to be retrieved. Returns Type Description ITarget The target for the given type , or null if no target is found. Remarks The target you receive from this method depends entirely on the implementation. It could be the last target to be registered against the type or the first, or another target entirely. As mentioned in the documentation for the Register(ITarget, Type) method - the only guarantee is that if at least one target has been registered for the same type, then this method should return a valid target. <!-- .classchild --> FetchAll(Type) Retrieves an enumerable of all targets that have been registered for a particular type . Declaration IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type Type Required. The type for which the ITarget s are to be retrieved. Returns Type Description IEnumerable < ITarget > An enumerable containing all the targets that have been registered against the given type , or, an empty enumerable if no targets have been registered. Remarks As with Fetch(Type) , the only guarantee is that if a target has been registered for the type through a call to Register(ITarget, Type) , then the returned enumerable will contain at least one valid target. <!-- .classchild --> Register(ITarget, Type) Registers a target, either for the serviceType specified or, if null, the DeclaredType of the target . Declaration void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget Required. The target to be registered serviceType Type Optional. The type the target is to be registered against, if different from the DeclaredType of the target . If provided, then the target must be compatible with this type. Remarks The interface does not define the behaviour for when multiple targets are registered against the same type - although the default behaviour of the framework (via the TargetContainer class) is to allow this, with the last registered target being treated as the 'default' for that type. The only guarantee expected by the framework from implementations of this interface is that if a target is registered against a given type with this method, then a Fetch(Type) operation with the same type should return a valid target, and a FetchAll(Type) operation should return a non-empty enumerable of targets. Exceptions Type Condition ArgumentException If serviceType is non-null and the target 's SupportsType(Type) method returns false for that type. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapter.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapter.html",
    "title": "Class ConfigurationAdapter",
    "keywords": "Class ConfigurationAdapter Standard implementation of the IConfigurationAdapter interface. Inheritance Object ConfigurationAdapter Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationAdapter : IConfigurationAdapter <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConfigurationAdapter(IConfigurationAdapterContextFactory) Creates a new instance of the ConfigurationAdapter class. Declaration public ConfigurationAdapter(IConfigurationAdapterContextFactory contextFactory = null) Parameters Name Type Description contextFactory IConfigurationAdapterContextFactory The factory that is, by default, used to create a new context to be used while transforming an IConfiguration instance. If you pass null, then the DefaultContextFactory will be used. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties ContextFactory Declaration protected IConfigurationAdapterContextFactory ContextFactory { get; } Property Value Type Description IConfigurationAdapterContextFactory <!-- .classchild --> DefaultContextFactory Gets or sets the default context factory. The uninitialised default is Instance . Note - this can never be a null reference. Declaration public static IConfigurationAdapterContextFactory DefaultContextFactory { get; set; } Property Value Type Description IConfigurationAdapterContextFactory The default context factory. Exceptions Type Condition ArgumentNullException If you try to set the property to null. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods AppendInstructions(ConfigurationAdapterContext) Called to add instructions into the context from the configuration entries in the configuration within the passed context. Declaration protected virtual void AppendInstructions(ConfigurationAdapterContext context) Parameters Name Type Description context ConfigurationAdapterContext The context for this operation - provides access to the configuration whose entries are to be processed, and acts as the target for the processing instructions. <!-- .classchild --> CreateBuilderInstance(IConfiguration) Called to construct the instance of the ITargetContainer into which registrations are to be loaded. Declaration protected virtual ITargetContainer CreateBuilderInstance(IConfiguration configuration) Parameters Name Type Description configuration IConfiguration The configuration instance for which a builder is to be created. Returns Type Description ITargetContainer Remarks No parsing of the configuration is to be done here (except, perhaps, if the actual implementation of ITargetContainer that is used is dependant upon, say, the type of configuration object. The base behaviour is simply to create an instance of TargetContainer . <!-- .classchild --> CreateContext(IConfiguration) Creates the context that will be used while the passed configuration is processed. The default implementation forwards this call onto the context factory that was supplied on construction. Declaration protected virtual ConfigurationAdapterContext CreateContext(IConfiguration configuration) Parameters Name Type Description configuration IConfiguration Returns Type Description ConfigurationAdapterContext <!-- .classchild --> CreateTargetContainer(IConfiguration) Attempts to create an IRezolveTargetContainer instance from the passed configuration object. If the operation succeeds, then a builder will be returned, which you can then use to construct a new Rezolver. If the operation fails, then a ConfigurationException will be thrown. Declaration public virtual ITargetContainer CreateTargetContainer(IConfiguration configuration) Parameters Name Type Description configuration IConfiguration The parsed configuration to be loaded. Returns Type Description ITargetContainer An IRezolveTargetContainer instance ready to be used to construct a new IRezolver. Implements IConfigurationAdapter.CreateTargetContainer(IConfiguration) Exceptions Type Condition ConfigurationException If any part of the passed configuration is invalid (e.g. bad type references) or cannot be handled by this adapter (e.g. custom IConfigurationEntry instances or custom IRezolveTargetMetadata instances). <!-- .classchild --> TransformAssemblyReferenceEntry(IConfigurationEntry, ConfigurationAdapterContext) Transforms an IConfigurationEntry with a Type of AssemblyReference by attempting to convert the entry to an IAssemblyReferenceEntry , and then passing that to the current context as an assembly reference to be added. Declaration protected virtual RezolverBuilderInstruction TransformAssemblyReferenceEntry(IConfigurationEntry entry, ConfigurationAdapterContext context) Parameters Name Type Description entry IConfigurationEntry The entry to be processed. context ConfigurationAdapterContext The context for the operation Returns Type Description RezolverBuilderInstruction The default implementation returns null Remarks The default behaviour of this method is not to return anything - instead the entry is passed to the context to be treated as an Assembly Reference. The function signature still allows the returning of an instruction, however, in case derived classes want to tie this operation to an action being performed on the ITargetContainer later on. <!-- .classchild --> TransformEntry(IConfigurationEntry, ConfigurationAdapterContext) Called to transform a configuration entry into an instruction that will later be performed on the builder that is constructed by the configuration adapter. Declaration protected virtual RezolverBuilderInstruction TransformEntry(IConfigurationEntry entry, ConfigurationAdapterContext context) Parameters Name Type Description entry IConfigurationEntry The entry to be transformed into an instruction. context ConfigurationAdapterContext The context for the operation. Returns Type Description RezolverBuilderInstruction An instance of RezolverBuilderInstruction if successful, otherwise null. If errors occur, they are added to the context. <!-- .classchild --> TransformTypeRegistrationEntry(IConfigurationEntry, ConfigurationAdapterContext) Transforms an IConfigurationEntry with a Type of TypeRegistration into a RezolverBuilderInstruction . Declaration protected virtual RezolverBuilderInstruction TransformTypeRegistrationEntry(IConfigurationEntry entry, ConfigurationAdapterContext context) Parameters Name Type Description entry IConfigurationEntry The entry to be transformed. context ConfigurationAdapterContext The context for the operation. Returns Type Description RezolverBuilderInstruction If the entry can be converted into a RezolverBuilderInstruction , then an instance of that type, otherwise null. Remarks The default behaviour is to: Attempt to convert the entry to an ITypeRegistrationEntry Parsing its type references in Types Constructing an ITarget from the entry's TargetMetadata through a call to its CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) method. If that returns a non-null target, then a RegisterInstruction is created and returned. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContext.UnresolvedType.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContext.UnresolvedType.html",
    "title": "Class ConfigurationAdapterContext.UnresolvedType",
    "keywords": "Class ConfigurationAdapterContext.UnresolvedType Used as a sentinel type by the ResolveType(String, Nullable<Int32>) method when the type search fails. Inheritance Object ConfigurationAdapterContext.UnresolvedType Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax protected class UnresolvedType"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContext.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContext.html",
    "title": "Class ConfigurationAdapterContext",
    "keywords": "Class ConfigurationAdapterContext This class is used to store the intermediate state for the default IConfigurationAdapter implementation's ( ConfigurationAdapter ) parsing operation on an IConfiguration instance. If you are extending the default adapter you might need also to extend this class to ensure any additional state you require is maintained. Inheritance Object ConfigurationAdapterContext Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationAdapterContext <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConfigurationAdapterContext(IConfigurationAdapter, IConfiguration, IEnumerable<Assembly>) Constructs a new instance of the ConfigurationAdapterContext class. Declaration public ConfigurationAdapterContext(IConfigurationAdapter adapter, IConfiguration configuration, IEnumerable<Assembly> defaultAssemblyReferences = null) Parameters Name Type Description adapter IConfigurationAdapter The adapter that will create the ITargetContainer from the configuration. configuration IConfiguration Required. The configuration that is being processed by the adapter for which this context is being constructed defaultAssemblyReferences IEnumerable < Assembly > Optional. Default set of assemblies that are to be searched for types when type references are processed. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Adapter Declaration public IConfigurationAdapter Adapter { get; } Property Value Type Description IConfigurationAdapter <!-- .classchild --> Configuration Gets the configuration that is being processed by the adapter that is working within this context. Declaration public IConfiguration Configuration { get; } Property Value Type Description IConfiguration The configuration. <!-- .classchild --> ErrorCount Retrieves the number of errors currently in the Errors enumerable. Declaration public int ErrorCount { get; } Property Value Type Description Int32 <!-- .classchild --> Errors Retrieves a snapshot of the current errors list. If further errors are added while you are enumerating the enumerable returned by this property, no exception will occur, and the newly added items will not be included. Declaration public IEnumerable<IConfigurationError> Errors { get; } Property Value Type Description IEnumerable < IConfigurationError > <!-- .classchild --> Instructions Retrieves a snapshot of the instructions currently present in the context. Declaration public IEnumerable<RezolverBuilderInstruction> Instructions { get; } Property Value Type Description IEnumerable < RezolverBuilderInstruction > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods AddAssemblyReference(Assembly) Called to add an assembly reference to this context - the assembly will then be included in the search for types that are not fully qualified. Declaration public void AddAssemblyReference(Assembly assembly) Parameters Name Type Description assembly Assembly Required - the assembly to be added as a reference. <!-- .classchild --> AddAssemblyReference(IAssemblyReferenceEntry) Adds an assembly reference from an IAssemblyReferenceEntry obtained directly from an IConfiguration instance. The default behaviour is to attempt to load an assembly with the given name and, if found, add that using the overload that accepts an Assembly reference. Declaration public virtual void AddAssemblyReference(IAssemblyReferenceEntry entry) Parameters Name Type Description entry IAssemblyReferenceEntry <!-- .classchild --> AddAssemblyReferenceBase(Assembly) The core method for adding an assembly reference. The method will never be called (by the base at least) with a null argument. Declaration protected virtual void AddAssemblyReferenceBase(Assembly assembly) Parameters Name Type Description assembly Assembly <!-- .classchild --> AddAssemblyReferences(IEnumerable<Assembly>) Declaration public virtual void AddAssemblyReferences(IEnumerable<Assembly> assemblies) Parameters Name Type Description assemblies IEnumerable < Assembly > <!-- .classchild --> AddError(IConfigurationError) Declaration public void AddError(IConfigurationError error) Parameters Name Type Description error IConfigurationError <!-- .classchild --> AddErrors(IEnumerable<IConfigurationError>) Declaration public void AddErrors(IEnumerable<IConfigurationError> errors) Parameters Name Type Description errors IEnumerable < IConfigurationError > <!-- .classchild --> AppendInstruction(RezolverBuilderInstruction) Declaration public void AppendInstruction(RezolverBuilderInstruction instruction) Parameters Name Type Description instruction RezolverBuilderInstruction <!-- .classchild --> GetNamespacePrefixedTypeNames(String) Declaration protected IEnumerable<string> GetNamespacePrefixedTypeNames(string typeName) Parameters Name Type Description typeName String Returns Type Description IEnumerable < String > <!-- .classchild --> GetReferencedAssemblies() Gets an enumerable of all the assemblies that are referenced by this configuration file. This is used when resolving types. Declaration protected virtual IEnumerable<Assembly> GetReferencedAssemblies() Returns Type Description IEnumerable < Assembly > <!-- .classchild --> GetUsingNamespaces() Gets an enumerable of strings of all the namespaces (using dotted separators) that are imported for the configuration. This is used, by default, to project a list of type names to search for during type resolution. Declaration protected virtual IEnumerable<string> GetUsingNamespaces() Returns Type Description IEnumerable < String > <!-- .classchild --> InsertAfter(RezolverBuilderInstruction, RezolverBuilderInstruction) Allows for explicit ordering of instructions Declaration public void InsertAfter(RezolverBuilderInstruction instruction, RezolverBuilderInstruction after) Parameters Name Type Description instruction RezolverBuilderInstruction after RezolverBuilderInstruction <!-- .classchild --> InsertBefore(RezolverBuilderInstruction, RezolverBuilderInstruction) Allows for explicit ordering of instructions Declaration public void InsertBefore(RezolverBuilderInstruction instruction, RezolverBuilderInstruction before) Parameters Name Type Description instruction RezolverBuilderInstruction before RezolverBuilderInstruction <!-- .classchild --> InsertRangeAfter(IEnumerable<RezolverBuilderInstruction>, RezolverBuilderInstruction) Declaration public void InsertRangeAfter(IEnumerable<RezolverBuilderInstruction> instructions, RezolverBuilderInstruction after) Parameters Name Type Description instructions IEnumerable < RezolverBuilderInstruction > after RezolverBuilderInstruction <!-- .classchild --> InsertRangeBefore(IEnumerable<RezolverBuilderInstruction>, RezolverBuilderInstruction) Declaration public void InsertRangeBefore(IEnumerable<RezolverBuilderInstruction> instructions, RezolverBuilderInstruction before) Parameters Name Type Description instructions IEnumerable < RezolverBuilderInstruction > before RezolverBuilderInstruction <!-- .classchild --> ResolveType(String, Nullable<Int32>) Resolves a particular type name given this context's assembly references and, potentially, any namespace imports. This is designed to be used by a configuration adapter during the process of creating a container builder from a set of configuration entries. Declaration public virtual Type ResolveType(string typeName, int ? genericParameterCount = null) Parameters Name Type Description typeName String The typename genericParameterCount Nullable < Int32 > Used as a hint when multiple versions of the same type exist with open generic parameters and potentially with no generic parameters. Null means that either a generic or non-generic type can match. Zero means that only a non-generic type (or a closed generic type) can match. Any other positive value means that only an open generic type with that exact number of parameters can match. Returns Type Description Type A Type reference if the type is located, otherwise null. Exceptions Type Condition AmbiguousMatchException If more than one type could be matched with the given name, typically due to namespace imports being used and more than type being available which has the same <!-- .classchild --> TryParseTypeReference(ITypeReference, out Type) Attempts to convert the passed typeReference into a Type . Errors are added to this context's Errors if the method returns false. Declaration public virtual bool TryParseTypeReference(ITypeReference typeReference, out Type type) Parameters Name Type Description typeReference ITypeReference The type reference. type Type The type that is identified, if successful. Returns Type Description Boolean true if the type reference is successfully parsed, false otherwise (with errors being added to the Errors collection). <!-- .classchild --> TryParseTypeReferences(IEnumerable<ITypeReference>, out Type[]) Tries to parse all type references, returning an overall success flag, with successfully parsed types being added to a list that is returned in the types output parameter. Declaration public bool TryParseTypeReferences(IEnumerable<ITypeReference> typeReferences, out Type[] types) Parameters Name Type Description typeReferences IEnumerable < ITypeReference > The type references. types Type [] Receives the types that are parsed. Note that if the method returns true, then this list will contain the same number of types as there are references in typeReferences , in the same order. If the method returns false, however, then the number of results in this list is undefined and you will not be able to marry up the input type reference to its output type. Returns Type Description Boolean true if all type references could be parsed, otherwise false . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContextFactory.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContextFactory.html",
    "title": "Class ConfigurationAdapterContextFactory",
    "keywords": "Class ConfigurationAdapterContextFactory The standard Singleton implementation of the IConfigurationAdapterContextFactory interface, and one which you can use as the starting point of your own factory. By default, it creates a new instance of the ConfigurationAdapterContext class (using the virtual method CreateContext(ConfigurationAdapter, IConfiguration) , and then instructs it to add its default assembly references. Inheritance Object ConfigurationAdapterContextFactory Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationAdapterContextFactory : IConfigurationAdapterContextFactory <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConfigurationAdapterContextFactory() Creation of new instances of this class, outside of the Instance instance, is only through inheritance. Declaration protected ConfigurationAdapterContextFactory() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Instance The one and only instance of this context factory. Note that this is also the default application-wide context factory that is used by the standard ConfigurationAdapter class when converting configuration data into rezolvers (by virtue of the DefaultContextFactory property, which you can change). Declaration public static ConfigurationAdapterContextFactory Instance { get; } Property Value Type Description ConfigurationAdapterContextFactory <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateContext(ConfigurationAdapter, IConfiguration) Implements the IConfigurationAdapterContextFactory method of the same name. The base behaviour is to create an instance of the ConfigurationAdapterContext class, passing the configuration and the default set of assembly references returned by GetDefaultAssemblyReferences() . Declaration public virtual ConfigurationAdapterContext CreateContext(ConfigurationAdapter adapter, IConfiguration configuration) Parameters Name Type Description adapter ConfigurationAdapter The adapter. configuration IConfiguration The configuration. Returns Type Description ConfigurationAdapterContext Implements IConfigurationAdapterContextFactory.CreateContext(ConfigurationAdapter, IConfiguration) <!-- .classchild --> GetDefaultAssemblyReferences() Gets the assemblies that are to be used for new contexts as the default set of references. The base behaviour is to add mscorlib, System and System.Core although, depending on the target platform, the list might be less. Declaration protected virtual IEnumerable<Assembly> GetDefaultAssemblyReferences() Returns Type Description IEnumerable < Assembly > <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationEntryBase.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationEntryBase.html",
    "title": "Class ConfigurationEntryBase",
    "keywords": "Class ConfigurationEntryBase suggested starting point for implementing your own configuration entries. Inheritance Object ConfigurationEntryBase Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationEntryBase : IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConfigurationEntryBase(ConfigurationEntryType, IConfigurationLineInfo) Declaration protected ConfigurationEntryBase(ConfigurationEntryType type, IConfigurationLineInfo lineInfo) Parameters Name Type Description type ConfigurationEntryType lineInfo IConfigurationLineInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties EndLineNo Declaration public int ? EndLineNo { get; } Property Value Type Description Nullable < Int32 > Implements IConfigurationLineInfo.EndLineNo <!-- .classchild --> EndLinePos Declaration public int ? EndLinePos { get; } Property Value Type Description Nullable < Int32 > Implements IConfigurationLineInfo.EndLinePos <!-- .classchild --> StartLineNo Declaration public int ? StartLineNo { get; } Property Value Type Description Nullable < Int32 > Implements IConfigurationLineInfo.StartLineNo <!-- .classchild --> StartLinePos Declaration public int ? StartLinePos { get; } Property Value Type Description Nullable < Int32 > Implements IConfigurationLineInfo.StartLinePos <!-- .classchild --> Type Declaration public ConfigurationEntryType Type { get; } Property Value Type Description ConfigurationEntryType Implements IConfigurationEntry.Type <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationEntryType.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationEntryType.html",
    "title": "Enum ConfigurationEntryType",
    "keywords": "Enum ConfigurationEntryType Types of configuration entry that can be parsed from a configuration file Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public enum ConfigurationEntryType <!-- <hr class=\"typeSectionDivider\" /> --> Fields AssemblyReference An instruction to load one or more assemblies before any type registrations are processed Depending on the runtime environment, to be sure of the type binder finding namespace-qualified types mentioned in a configuration file, then any assemblies you might be referencing should be included in your configuration file. Equally, you can use this to load assemblies that wouldn't normally be found (e.g. a la unity) Note that types which would usually be found with a simple call to Type.GetType do not need their parent assemblies explicitly referenced. Declaration AssemblyReference = 1 Field Value Type Description ConfigurationEntryType <!-- .classchild --> Extension A custom entry - the instance should also have the interface IConfigurationExtensionEntry Declaration Extension = 2147483647 Field Value Type Description ConfigurationEntryType <!-- .classchild --> NamedBuilder An instruction to create a named builder in the target builder, within which further named builders or type registrations might be performed. Declaration NamedBuilder = 11 Field Value Type Description ConfigurationEntryType <!-- .classchild --> NamespaceImport Just like 'using' or 'import' in C# or VB, this allows you to specify namespaces that you will be using in your type names elsewhere in a configuration file. Declaration NamespaceImport = 2 Field Value Type Description ConfigurationEntryType <!-- .classchild --> TypeRegistration The most common type - an instruction to generate one or more type registrations in the target builder Declaration TypeRegistration = 10 Field Value Type Description ConfigurationEntryType <!-- .classchild --> Unknown Declaration Unknown = 0 Field Value Type Description ConfigurationEntryType <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationError.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationError.html",
    "title": "Class ConfigurationError",
    "keywords": "Class ConfigurationError Inheritance Object ConfigurationError Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationError : IConfigurationError <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConfigurationError(Exception, IConfigurationLineInfo) Declaration public ConfigurationError(Exception exception, IConfigurationLineInfo lineInfo) Parameters Name Type Description exception Exception lineInfo IConfigurationLineInfo <!-- .classchild --> ConfigurationError(String, IConfigurationLineInfo) Declaration public ConfigurationError(string errorMessage, IConfigurationLineInfo lineInfo) Parameters Name Type Description errorMessage String lineInfo IConfigurationLineInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties ErrorMessage Declaration public string ErrorMessage { get; } Property Value Type Description String Implements IConfigurationError.ErrorMessage <!-- .classchild --> ErrorMessageWithLineInfo Declaration public string ErrorMessageWithLineInfo { get; } Property Value Type Description String Implements IConfigurationError.ErrorMessageWithLineInfo <!-- .classchild --> Exception Declaration public Exception Exception { get; } Property Value Type Description Exception <!-- .classchild --> IsException Declaration public bool IsException { get; } Property Value Type Description Boolean <!-- .classchild --> LineInfo Declaration public IConfigurationLineInfo LineInfo { get; } Property Value Type Description IConfigurationLineInfo Implements IConfigurationError.LineInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods UnexpectedMetadataType(RezolveTargetMetadataType, Type, Type, IConfigurationLineInfo) Declaration public static ConfigurationError UnexpectedMetadataType(RezolveTargetMetadataType type, Type expected, Type actual, IConfigurationLineInfo lineInfo) Parameters Name Type Description type RezolveTargetMetadataType expected Type actual Type lineInfo IConfigurationLineInfo Returns Type Description ConfigurationError <!-- .classchild --> UnresolvedType(ITypeReference) Declaration public static ConfigurationError UnresolvedType(ITypeReference typeReference) Parameters Name Type Description typeReference ITypeReference Returns Type Description ConfigurationError <!-- .classchild --> UnresolvedType(String, IConfigurationLineInfo) Declaration public static ConfigurationError UnresolvedType(string typeName, IConfigurationLineInfo lineInfo) Parameters Name Type Description typeName String lineInfo IConfigurationLineInfo Returns Type Description ConfigurationError <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationException.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationException.html",
    "title": "Class ConfigurationException",
    "keywords": "Class ConfigurationException Inheritance Object Exception ConfigurationException Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.Data Exception.InnerException Exception.TargetSite Exception.StackTrace Exception.HelpLink Exception.Source Exception.HResult Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationException : Exception, ISerializable, _Exception <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConfigurationException(ConfigurationAdapterContext) Declaration public ConfigurationException(ConfigurationAdapterContext context) Parameters Name Type Description context ConfigurationAdapterContext <!-- .classchild --> ConfigurationException(IConfiguration, IEnumerable<IConfigurationError>) Declaration public ConfigurationException(IConfiguration configuration, IEnumerable<IConfigurationError> errors) Parameters Name Type Description configuration IConfiguration errors IEnumerable < IConfigurationError > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Message Declaration public override string Message { get; } Property Value Type Description String Overrides Exception.Message <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConstructorTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConstructorTargetMetadata.html",
    "title": "Class ConstructorTargetMetadata",
    "keywords": "Class ConstructorTargetMetadata Inheritance Object RezolveTargetMetadataBase ConstructorTargetMetadata Inherited Members RezolveTargetMetadataBase.Type RezolveTargetMetadataBase.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) RezolveTargetMetadataBase.Bind(ITypeReference[]) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConstructorTargetMetadata : RezolveTargetMetadataBase, IConstructorTargetMetadata, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConstructorTargetMetadata(ITypeReference[], ITypeReference[], IDictionary<String, IRezolveTargetMetadata>) Constructs a new instance of the ConstructorTargetMetadata class. Declaration public ConstructorTargetMetadata(ITypeReference[] typesToBuild, ITypeReference[] signatureTypes = null, IDictionary<string, IRezolveTargetMetadata> args = null) Parameters Name Type Description typesToBuild ITypeReference [] The types to build. signatureTypes ITypeReference [] The types of the parameters for the constructor that is to be bound. If null, then the constructor is to be sought by finding the best match based on the arguments (if provided). This is typically required if you have an ambiguity when matching purely by name. args IDictionary < String , IRezolveTargetMetadata > The arguments. Remarks Please note that although the typesToBuild parameter is an array, in practise only one type can ever be built. Multiple types are accepted to cover scenarios where a class, its bases and zero or more interfaces are all referenced as target registration types, and these types are passed directly to the constructor target. In building such a target from the metadata an adapter will typically find the most derived type of the group and bind to that only. Note that if one or more types are not related to the rest of the group, then an adapter is free to throw a runtime error. Exceptions Type Condition ArgumentNullException typesToBuild ArgumentException The array cannot be empty;typesToBuild or All entries in the array must be non-null;typesToBuild <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Arguments Declaration public IDictionary<string, IRezolveTargetMetadata> Arguments { get; } Property Value Type Description IDictionary < String , IRezolveTargetMetadata > Implements IConstructorTargetMetadata.Arguments <!-- .classchild --> DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides RezolveTargetMetadataBase.DeclaredType Implements IRezolveTargetMetadata.DeclaredType <!-- .classchild --> SignatureTypes Declaration public ITypeReference[] SignatureTypes { get; } Property Value Type Description ITypeReference [] Implements IConstructorTargetMetadata.SignatureTypes <!-- .classchild --> TypesToBuild Remember - the intention is that only one of these types will actually be bound on constructing the constructor target. Declaration public ITypeReference[] TypesToBuild { get; } Property Value Type Description ITypeReference [] Implements IConstructorTargetMetadata.TypesToBuild <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides RezolveTargetMetadataBase.BindBase(ITypeReference[]) <!-- .classchild --> CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description ITarget Overrides RezolveTargetMetadataBase.CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IAssemblyReferenceEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.IAssemblyReferenceEntry.html",
    "title": "Interface IAssemblyReferenceEntry",
    "keywords": "Interface IAssemblyReferenceEntry A configuration entry instructing the configuration adapter to load an assembly before resolving types. Inherited Members IConfigurationEntry.Type IConfigurationLineInfo.StartLineNo IConfigurationLineInfo.StartLinePos IConfigurationLineInfo.EndLineNo IConfigurationLineInfo.EndLinePos Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IAssemblyReferenceEntry : IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties AssemblyName Declaration string AssemblyName { get; } Property Value Type Description String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfiguration.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfiguration.html",
    "title": "Interface IConfiguration",
    "keywords": "Interface IConfiguration Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfiguration <!-- <hr class=\"typeSectionDivider\" /> --> Properties Entries Declaration IEnumerable<IConfigurationEntry> Entries { get; } Property Value Type Description IEnumerable < IConfigurationEntry > <!-- .classchild --> FileName Declaration string FileName { get; } Property Value Type Description String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationAdapter.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationAdapter.html",
    "title": "Interface IConfigurationAdapter",
    "keywords": "Interface IConfigurationAdapter Represents an object that is responsible for transforming configuration data into target containers. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationAdapter <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateTargetContainer(IConfiguration) Creates an ITargetContainer instance from an IConfiguration instance. Declaration ITargetContainer CreateTargetContainer(IConfiguration configuration) Parameters Name Type Description configuration IConfiguration Required - the configuration object that is to be used to build a container. Returns Type Description ITargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationAdapterContextFactory.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationAdapterContextFactory.html",
    "title": "Interface IConfigurationAdapterContextFactory",
    "keywords": "Interface IConfigurationAdapterContextFactory Used by this library's default implementation of IConfigurationAdapter, the ConfigurationAdapter class, to create an instance of the ConfigurationAdapterContext class for a given adapter that's processing a given configuration. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationAdapterContextFactory <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateContext(ConfigurationAdapter, IConfiguration) Declaration ConfigurationAdapterContext CreateContext(ConfigurationAdapter adapter, IConfiguration configuration) Parameters Name Type Description adapter ConfigurationAdapter configuration IConfiguration Returns Type Description ConfigurationAdapterContext <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationEntry.html",
    "title": "Interface IConfigurationEntry",
    "keywords": "Interface IConfigurationEntry Inherited Members IConfigurationLineInfo.StartLineNo IConfigurationLineInfo.StartLinePos IConfigurationLineInfo.EndLineNo IConfigurationLineInfo.EndLinePos Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationEntry : IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties Type Declaration ConfigurationEntryType Type { get; } Property Value Type Description ConfigurationEntryType <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationError.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationError.html",
    "title": "Interface IConfigurationError",
    "keywords": "Interface IConfigurationError Interface for an error that originates from a configuration file. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationError <!-- <hr class=\"typeSectionDivider\" /> --> Properties ErrorMessage The message Declaration string ErrorMessage { get; } Property Value Type Description String <!-- .classchild --> ErrorMessageWithLineInfo The message formatted with the start/end line and position for more accurate error reporting. Declaration string ErrorMessageWithLineInfo { get; } Property Value Type Description String <!-- .classchild --> LineInfo Start and (potentially) end position within the configuration file where this error originates. Declaration IConfigurationLineInfo LineInfo { get; } Property Value Type Description IConfigurationLineInfo <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationExtensionEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationExtensionEntry.html",
    "title": "Interface IConfigurationExtensionEntry",
    "keywords": "Interface IConfigurationExtensionEntry Inherited Members IConfigurationEntry.Type IConfigurationLineInfo.StartLineNo IConfigurationLineInfo.StartLinePos IConfigurationLineInfo.EndLineNo IConfigurationLineInfo.EndLinePos Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationExtensionEntry : IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties ExtensionType Declaration string ExtensionType { get; } Property Value Type Description String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationLineInfo.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationLineInfo.html",
    "title": "Interface IConfigurationLineInfo",
    "keywords": "Interface IConfigurationLineInfo Encapsulates information about where a particular object, parsed from a configuration file, can be found. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties EndLineNo Gets the line number within the configuration source that sees the end of the text from which this object was parsed. Used in conjunction with EndLinePos , it allows you to zero-in on the exact ending of this parsed object. Declaration int ? EndLineNo { get; } Property Value Type Description Nullable < Int32 > The end line number. <!-- .classchild --> EndLinePos Gets the position from the start of the line, indicated by EndLineNo , where the configuration text ends for this parsed object. Declaration int ? EndLinePos { get; } Property Value Type Description Nullable < Int32 > <!-- .classchild --> StartLineNo Gets the line number within the configuration source that contains the start of the text from which this object was parsed. Used in conjunction with StartLinePos , it allows you to zero-in on the exact starting point of this parsed object. Declaration int ? StartLineNo { get; } Property Value Type Description Nullable < Int32 > The start line number. <!-- .classchild --> StartLinePos Gets the position from the start of the line, indicated by StartLineNo , where the configuration text begins for this parsed object. Declaration int ? StartLinePos { get; } Property Value Type Description Nullable < Int32 > The start line position. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConstructorTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConstructorTargetMetadata.html",
    "title": "Interface IConstructorTargetMetadata",
    "keywords": "Interface IConstructorTargetMetadata Inherited Members IRezolveTargetMetadata.Type IRezolveTargetMetadata.DeclaredType IRezolveTargetMetadata.Bind(ITypeReference[]) IRezolveTargetMetadata.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConstructorTargetMetadata : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties Arguments Gets a dictionary of arguments that are to be supplied to the object's constructor Declaration IDictionary<string, IRezolveTargetMetadata> Arguments { get; } Property Value Type Description IDictionary < String , IRezolveTargetMetadata > The arguments. <!-- .classchild --> SignatureTypes Gets the types of the parameters for the specific constructor that is to be bound. Not required, and is mostly used when a suitable constructor cannot be found purely by matching parameter names and types to the Arguments . A common issue here being that some metadata types can build any type, therefore two constructors with identically named parameters that have different types could be matched by the same target metadata. If null, then no signature is specified. Declaration ITypeReference[] SignatureTypes { get; } Property Value Type Description ITypeReference [] The signature types. <!-- .classchild --> TypesToBuild One of these types will be selected to have its constructor bound. The rule is that multiple types passed here must represent types that all appear in an inheritance chain or interface list, and there must be one unambiguous most-derived type which will be the one whose constructor will be executed when an object is later dished out from the IRezolveTarget instance that is built from this metadata. Declaration ITypeReference[] TypesToBuild { get; } Property Value Type Description ITypeReference [] <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IListTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.IListTargetMetadata.html",
    "title": "Interface IListTargetMetadata",
    "keywords": "Interface IListTargetMetadata Configuration metadata for building a ListTarget in a RezolverBuilder. Inherited Members IRezolveTargetMetadata.Type IRezolveTargetMetadata.DeclaredType IRezolveTargetMetadata.Bind(ITypeReference[]) IRezolveTargetMetadata.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IListTargetMetadata : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties ElementType Gets the declared element type of the array or list that will be created from this metadata. Declaration ITypeReference ElementType { get; } Property Value Type Description ITypeReference The type of the element. <!-- .classchild --> IsArray Maps to the AsArray property. If true, then an array of ElementType will be created, otherwise a List< ElementType > will be created by the ListTarget created from this metadata. Declaration bool IsArray { get; } Property Value Type Description Boolean true if this instance represents a ListTarget that will create an array; otherwise, false . <!-- .classchild --> Items Gets the metadata for the targets that will be used for the items that'll be returned in the Array or List that will be created by the ListTarget created from this metadata. Declaration IRezolveTargetMetadataList Items { get; } Property Value Type Description IRezolveTargetMetadataList The elements. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IObjectTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.IObjectTargetMetadata.html",
    "title": "Interface IObjectTargetMetadata",
    "keywords": "Interface IObjectTargetMetadata Interface for metadata for constructing an ObjectTarget IRezolveTarget. Inherited Members IRezolveTargetMetadata.Type IRezolveTargetMetadata.DeclaredType IRezolveTargetMetadata.Bind(ITypeReference[]) IRezolveTargetMetadata.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IObjectTargetMetadata : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetObject(Type) Called to get the object that will be registered in the IRezolveTargetContainer to be returned when a caller requests one of its registered types. The method can construct an object anew everytime it is called, or it can always return the same instance; this behaviour is implementation-dependant. Declaration object GetObject(Type type) Parameters Name Type Description type Type The type of object that is desired. The implementation determines whether this parameter is required. If it is, and you pass null, then an ArgumentNullException will be thrown. If you pass an argument, the implementation is not bound to check or honour the type. Its purpose is to provide a hint only, not a guarantee that the object returned is compatible with the type. Returns Type Description Object An object. Note - if the operation returns null this is not an error. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadata.html",
    "title": "Interface IRezolveTargetMetadata",
    "keywords": "Interface IRezolveTargetMetadata Represents an instruction to create an IRezolveTarget from parsed configuration. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Gets the declared type of the object that will be created by an IRezolveTarget created by this metadata. Note - this isn't always known, or always fixed, since configuration systems will allow developers to avoid being specific about the types that are to be built. Declaration ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference The type of the declared. <!-- .classchild --> Type The type of rezolve target that is expected to be produced from this metadata Declaration RezolveTargetMetadataType Type { get; } Property Value Type Description RezolveTargetMetadataType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Bind(ITypeReference[]) Creates a new instance of this metadata (i.e. a clone) that is bound to the specified target types. This is invoked if DeclaredType represents the Unbound type reference. Declaration IRezolveTargetMetadata Bind(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] The target types. Ideally there'd only be one of these, but since type registrations can target multiple types - we need to be able to pass all of them. An implementation should seek the best possible type from the array, although in practise - given that there's no ConfigurationAdapterContext to aid in the parsing of the type names, the first type in the array is typically fine to use. Returns Type Description IRezolveTargetMetadata IRezolveTargetMetadata. <!-- .classchild --> CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Creates the rezolve target, optionally customised for the given target type(s), based on the given context. If the entry is passed, then it indicates the configuration entry for which the targets are being built. Declaration ITarget CreateRezolveTarget(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry = null) Parameters Name Type Description targetTypes Type [] Required. One or more target types that the returned target is expected to be compatible with (i.e. able to build an instance of). Generally, this will be the target types for the configuration entry that is passed in entry . context ConfigurationAdapterContext The current context - provides access to the builder currently being constructed, as well as methods for resolving type names from ITypeReference instances or strings (and more). entry IConfigurationEntry If provided, this is a reference to the configuration entry (typically an ITypeRegistrationEntry ) against which this target will be registered. Please note - this doesn't mean that the target that is returned will become the target of the registration. It might be that the target is one that is used by a parent target that will become the target of the registration. Returns Type Description ITarget <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadataExtension.html": {
    "href": "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadataExtension.html",
    "title": "Interface IRezolveTargetMetadataExtension",
    "keywords": "Interface IRezolveTargetMetadataExtension Inherited Members IRezolveTargetMetadata.Type IRezolveTargetMetadata.DeclaredType IRezolveTargetMetadata.Bind(ITypeReference[]) IRezolveTargetMetadata.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IRezolveTargetMetadataExtension : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties ExtensionType Declaration string ExtensionType { get; } Property Value Type Description String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadataList.html": {
    "href": "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadataList.html",
    "title": "Interface IRezolveTargetMetadataList",
    "keywords": "Interface IRezolveTargetMetadataList Represents a list of IRezolveTargetMetadata instances - for when you want to register multiple targets against a single type. Note - although the interface IRezolveTargetMetadata is included by this interface, instances are not expected to be able to create a single target through the CreateRezolveTarget method - because by definition, multiple targets are produced by this. Use the CreateRezolveTargets method instead. The Bind method, however, will be expected to produce a new instance of the implementing type if any underlying targets are not bound to a specific type. Inherited Members IRezolveTargetMetadata.Type IRezolveTargetMetadata.DeclaredType IRezolveTargetMetadata.Bind(ITypeReference[]) IRezolveTargetMetadata.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IRezolveTargetMetadataList : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties Targets Gets the list of targets that will be used to construct the array. Note - a list is used to allow for modification of the targets after initial creation. Declaration IList<IRezolveTargetMetadata> Targets { get; } Property Value Type Description IList < IRezolveTargetMetadata > The targets. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateRezolveTargets(Type[], ConfigurationAdapterContext, IConfigurationEntry) Replacement for IRezolveTargetMetadata for this interface. Creates the rezolve target, potentially customised for the given target type(s), based on the given context. If the entry is passed, then it indicates the configuration entry for which the targets are being built. Declaration IEnumerable<ITarget> CreateRezolveTargets(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] The target types for each of the returned target, generally, this will be the ultimate target types for the configuration entry that is passed in entry . An implementation is not bound to use these types at all, but it helps provide additional context that might be of use when generating the rezolve target. context ConfigurationAdapterContext The context. entry IConfigurationEntry If provided, this is a reference to the configuration entry for which this target is being built. Returns Type Description IEnumerable < ITarget > <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ISingletonTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.ISingletonTargetMetadata.html",
    "title": "Interface ISingletonTargetMetadata",
    "keywords": "Interface ISingletonTargetMetadata Interface for Singleton metadata. Inherited Members IRezolveTargetMetadata.Type IRezolveTargetMetadata.DeclaredType IRezolveTargetMetadata.Bind(ITypeReference[]) IRezolveTargetMetadata.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface ISingletonTargetMetadata : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties Inner Metadata representing the inner target for the singleton Declaration IRezolveTargetMetadata Inner { get; } Property Value Type Description IRezolveTargetMetadata <!-- .classchild --> Scoped If true, then the created singleton target should be a scoped singleton; i.e. with a lifetime tied to the lifetime of a parent ILifetimeScopeRezolver, not the whole application. Declaration bool Scoped { get; } Property Value Type Description Boolean <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ITypeReference.html": {
    "href": "rezolver-api/Rezolver.Configuration.ITypeReference.html",
    "title": "Interface ITypeReference",
    "keywords": "Interface ITypeReference Captures a reference to a type made in a configuration file. It does not guarantee that the type can be located, it simply provides a common interface for storing the type information written in a configuration file. An IConfigurationAdapter instance will need to resolve the actual runtime type from this when registering targets from a configuration file. Inherited Members IConfigurationLineInfo.StartLineNo IConfigurationLineInfo.StartLinePos IConfigurationLineInfo.EndLineNo IConfigurationLineInfo.EndLinePos Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface ITypeReference : IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties GenericArguments Any explicitly provided generic arguments are stored here. Note that it might turn out that the TypeName refers to a whole closed generic type, in which case the referenced type could still be generic even if this array is empty. It's also the case that arguments could be passed here when the root type name resolves to a non-generic type definition, in which case type resolution will likely fail. Declaration ITypeReference[] GenericArguments { get; } Property Value Type Description ITypeReference [] <!-- .classchild --> IsArray Gets a value indicating whether the type ultimately represented by this instance is an array of the type described by the rest of this instance's properties. Declaration bool IsArray { get; } Property Value Type Description Boolean true if this instance represents an array type; otherwise, false . <!-- .classchild --> IsOpenGenericTypeArgument True if this type represents an open generic argument - this is how to explicitly reference an open generic type in a type reference: you specify a base type, then have one or more open generic arguments specified in the GenericArguments array. If all are open generic arguments, then you have created a reference to the fully open generic type. You only need to provide all-open arguments if the base TypeName could be ambiguous between a non generic and generic type, or there are multiple generic types with the same base name. Equally, you can do this to create references to partially open generics, which may or may not be supported by the adapter or the target that is built. Declaration bool IsOpenGenericTypeArgument { get; } Property Value Type Description Boolean <!-- .classchild --> IsUnbound Gets a value indicating whether this instance represents a type that is to be late-bound for a specific target type. Declaration bool IsUnbound { get; } Property Value Type Description Boolean true if this instance is unbound; otherwise, false . <!-- .classchild --> TypeName The root type name. Declaration string TypeName { get; } Property Value Type Description String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ITypeRegistrationEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.ITypeRegistrationEntry.html",
    "title": "Interface ITypeRegistrationEntry",
    "keywords": "Interface ITypeRegistrationEntry Represents an instruction to register one or more targets in an ITargetContainer against one or more types. Think of it as wrapping a single call to one of the builder's Register methods. Inherited Members IConfigurationEntry.Type IConfigurationLineInfo.StartLineNo IConfigurationLineInfo.StartLinePos IConfigurationLineInfo.EndLineNo IConfigurationLineInfo.EndLinePos Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface ITypeRegistrationEntry : IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties IsMultipleRegistration Gets a value indicating whether this instance represents a multiple registration - i.e. that when one of the Types are resolved, it's expected that an enumerable of that type will be requested, returning one or more items rather than just one. Maps to the method call. Declaration bool IsMultipleRegistration { get; } Property Value Type Description Boolean true if this instance is multiple registration; otherwise, false . <!-- .classchild --> TargetMetadata Metadata for the target(s) that is/are to be registered. Declaration IRezolveTargetMetadata TargetMetadata { get; } Property Value Type Description IRezolveTargetMetadata <!-- .classchild --> Types The types for which the registration is to be made in the ITargetContainer that the entry is applied to. Declaration ITypeReference[] Types { get; } Property Value Type Description ITypeReference [] <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.AdvancedConfigurationAdapterContextFactory.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.AdvancedConfigurationAdapterContextFactory.html",
    "title": "Class AdvancedConfigurationAdapterContextFactory",
    "keywords": "Class AdvancedConfigurationAdapterContextFactory An advanced factory which automatically loads and references all assemblies that are deployed in the application's base directory and any subfolders determined by the AppDomain 's SetupInformation's PrivateBinBath. This is a singleton - accessed through the Instance property. Inheritance Object ConfigurationAdapterContextFactory AdvancedConfigurationAdapterContextFactory Inherited Members ConfigurationAdapterContextFactory.CreateContext(ConfigurationAdapter, IConfiguration) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class AdvancedConfigurationAdapterContextFactory : ConfigurationAdapterContextFactory, IConfigurationAdapterContextFactory Remarks The ConfigurationAdapterContextFactory has a very limited set of default assembly references, because it's a portable class, the AppDomain introspection APIs are not available. As a result, to simplify type references in a configuration file loaded in a portable environment, you need to add assembly references manually. This class, on the other hand, is targeted at environments where these APIs are available, and should effectively remove the need to add any references at all, meaning a configuration file can use shorter type names. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors AdvancedConfigurationAdapterContextFactory() Initializes a new instance of the AdvancedConfigurationAdapterContextFactory class. Class is creatable only through inheritance. Declaration protected AdvancedConfigurationAdapterContextFactory() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Instance Gets the one and only instance of the AdvancedConfigurationAdapterContextFactory . Declaration public static IConfigurationAdapterContextFactory Instance { get; } Property Value Type Description IConfigurationAdapterContextFactory The instance. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetDefaultAssemblyReferences() Gets the assemblies that are to be used for new contexts as the default set of references. This override gets all the assemblies that are deployed with the application. Note that this has the effect of pre-loading all those assemblies. Declaration protected override IEnumerable<Assembly> GetDefaultAssemblyReferences() Returns Type Description IEnumerable < System.Reflection.Assembly > IEnumerable<System.Reflection.Assembly>. Overrides ConfigurationAdapterContextFactory.GetDefaultAssemblyReferences() <!-- .classchild -->"
  },
  "rezolver-api/System.Collections.Generic.html": {
    "href": "rezolver-api/System.Collections.Generic.html",
    "title": "Namespace System.Collections.Generic",
    "keywords": "Namespace System.Collections.Generic Classes ReadOnlyEnumerableExtensions"
  },
  "rezolver-api/System.DelegateExtensions.html": {
    "href": "rezolver-api/System.DelegateExtensions.html",
    "title": "Class DelegateExtensions",
    "keywords": "Class DelegateExtensions Inheritance Object DelegateExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :System Assembly :cs.temp.dll.dll Syntax public static class DelegateExtensions"
  },
  "rezolver-api/System.Linq.Expressions.ExpressionExtensions.html": {
    "href": "rezolver-api/System.Linq.Expressions.ExpressionExtensions.html",
    "title": "Class ExpressionExtensions",
    "keywords": "Class ExpressionExtensions Inheritance Object ExpressionExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :System.Linq.Expressions Assembly :cs.temp.dll.dll Syntax public static class ExpressionExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods AsRezolveTarget(Expression, ITargetAdapter) Declaration public static ITarget AsRezolveTarget(this Expression expression, ITargetAdapter adapter = null) Parameters Name Type Description expression Expression adapter ITargetAdapter Returns Type Description ITarget <!-- .classchild -->"
  },
  "rezolver-api/System.Linq.Expressions.html": {
    "href": "rezolver-api/System.Linq.Expressions.html",
    "title": "Namespace System.Linq.Expressions",
    "keywords": "Namespace System.Linq.Expressions Classes ExpressionExtensions"
  },
  "rezolver-api/System.html": {
    "href": "rezolver-api/System.html",
    "title": "Namespace System",
    "keywords": "Namespace System Classes DelegateExtensions"
  },
  "rezolver-api/Rezolver.ITargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.ITargetContainerExtensions.html",
    "title": "Class ITargetContainerExtensions",
    "keywords": "Class ITargetContainerExtensions Extension methods for implementations of ITargetContainer . Inheritance Object ITargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ITargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterAlias(ITargetContainer, Type, Type) Registers an alias for one type to another type. The created entry will effectively represent a second Resolve call into the container for the aliased type. Declaration public static void RegisterAlias(this ITargetContainer builder, Type aliasType, Type aliasedType) Parameters Name Type Description builder ITargetContainer The builder in which the alias is to be registered aliasType Type The type to be registered as an alias aliasedType Type The type being aliased. Remarks Use this when it's important that a given target type is always served through the same compiled target, even when the consumer expects it to be of a different type. A very common scenario is when you have a singleton instance of the aliasedType , and need to serve that same instance for aliasType . If you register the same singleton for both types, you get two separate singletons for each type. <!-- .classchild --> RegisterAlias<TAlias, TAliased>(ITargetContainer) Generic version of , see that method for more. Declaration public static void RegisterAlias<TAlias, TAliased>(this ITargetContainer builder) Parameters Name Type Description builder ITargetContainer RegisterAlias<TAlias, TAliased>(ITargetContainer) Type Parameters Name Description TAlias Type being registered as an alias to another type TAliased The target type of the alias. <!-- .classchild --> RegisterAll(ITargetContainer, ITarget[]) Batch-registers multiple targets with different contracts. This is like calling multiple times, once for each of the targets in the array. Declaration public static void RegisterAll(this ITargetContainer builder, params ITarget[] targets) Parameters Name Type Description builder ITargetContainer The builder. targets ITarget [] The targets to be registered. <!-- .classchild --> RegisterAll(ITargetContainer, IEnumerable<ITarget>) Batch-registers multiple targets with different contracts. This is like calling multiple times, once for each of the targets in the enumerable. Declaration public static void RegisterAll(this ITargetContainer builder, IEnumerable<ITarget> targets) Parameters Name Type Description builder ITargetContainer The builder. targets IEnumerable < ITarget > The targets to be registered <!-- .classchild --> RegisterDecorator(ITargetContainerOwner, Type, Type) Declaration public static void RegisterDecorator(this ITargetContainerOwner builder, Type decoratorType, Type decoratedType) Parameters Name Type Description builder ITargetContainerOwner decoratorType Type decoratedType Type <!-- .classchild --> RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) Declaration public static void RegisterDecorator<TDecorator, TDecorated>(this ITargetContainerOwner builder) Parameters Name Type Description builder ITargetContainerOwner Type Parameters Name Description TDecorator TDecorated <!-- .classchild --> RegisterExpression<T>(ITargetContainer, Expression<Func<RezolveContextExpressionHelper, T>>, Type, ITargetAdapter) Registers an expression to be used as a factory for obtaining an instance when the registration matches a resolve request. Declaration public static void RegisterExpression<T>(this ITargetContainer builder, Expression<Func<RezolveContextExpressionHelper, T>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description builder ITargetContainer expression Expression < Func < RezolveContextExpressionHelper , T>> The expression to be analysed and used as a factory. The argument that is received by this expression can be used to emit explicit calls back into the resolver to indicate that a particular argument/property value or whatever should be resolved. type Type Optional. The type against which the registration is to be made, if different from T . adapter ITargetAdapter Optional. The adapter that will be used to convert the expression into an ITarget . This defaults to Default . Extending this is an advanced topic and shouldn't be required in most cases. Type Parameters Name Description T Remarks This is not the same as registering a factory delegate for creating objects - where the code you supply is already compiled and ready to go. The expression that is passed is analysed by the adapter (or the default) and rewritten according to the expressions container within. In general, there is a one to one mapping between the code you provide and the code that's produced, but it's not guaranteed. In particular, calls back to the resolver to resolve dependencies are identified and turned into a different representation internally, so that dependency resolution works inside your code in just the same way as it does when using the higher-level targets. <!-- .classchild --> RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) Called to register multiple rezolve targets against a shared contract, optionally replacing any existing registration(s) or extending them. It is analogous to calling Register(ITarget, Type) multiple times with the different targets. Declaration public static void RegisterMultiple(this ITargetContainer builder, IEnumerable<ITarget> targets, Type commonServiceType = null) Parameters Name Type Description builder ITargetContainer The builder in which the registration is to be performed. targets IEnumerable < ITarget > The targets to be registered - all must support a common service type (potentially passed in the commonServiceType argument. commonServiceType Type Optional - instead of determining the common service type automatically, you can provide it in advance through this parameter. Note that all targets must support this type. <!-- .classchild --> RegisterObject<T>(ITargetContainer, T, Type, Boolean) Registers a single instance (already created) to be used when resolving a particular service type. If using a scope, then the object will be tracked in the rootmost scope so that, if it's disposable, it will be disposed when the root scope is disposed. Declaration public static void RegisterObject<T>(this ITargetContainer builder, T obj, Type serviceType = null, bool suppressScopeTracking = true) Parameters Name Type Description builder ITargetContainer obj T The object to be returned when resolving. serviceType Type The service type against which this object is to be registered, if different from T . suppressScopeTracking Boolean Type Parameters Name Description T Type of the object - will be used as the service type for registration if serviceType is not provied. <!-- .classchild --> RegisterScoped(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Version of RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) that creates instances that are scoped to the active IScopedContainer at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) (or TryResolve(RezolveContext, Object) ) is called. Declaration public static void RegisterScoped(this ITargetContainer builder, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer objectType Type RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) serviceType Type RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) propertyBindingBehaviour IPropertyBindingBehaviour RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) <!-- .classchild --> RegisterScoped<TObject>(ITargetContainer, IPropertyBindingBehaviour) Version of RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) that creates instances that are scoped to the active IScopedContainer at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) (or TryResolve(RezolveContext, Object) ) is called. Declaration public static void RegisterScoped<TObject>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour See RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) <!-- .classchild --> RegisterScoped<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Version of RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) that creates instances that are scoped to the active IScopedContainer at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) (or TryResolve(RezolveContext, Object) ) is called. Declaration public static void RegisterScoped<TObject, TService>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) TService See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) <!-- .classchild --> RegisterSingleton(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Version of RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) that creates singleton instances that are also scoped to the root scope of the active IScopedContainer at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) (or TryResolve(RezolveContext, Object) ) is called. Declaration public static void RegisterSingleton(this ITargetContainer builder, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer objectType Type RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) serviceType Type RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) propertyBindingBehaviour IPropertyBindingBehaviour RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) <!-- .classchild --> RegisterSingleton<TObject>(ITargetContainer, IPropertyBindingBehaviour) Version of RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) that creates singleton instances that are also scoped to the root scope of the active IScopedContainer at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) (or TryResolve(RezolveContext, Object) ) is called. Declaration public static void RegisterSingleton<TObject>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour See RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) <!-- .classchild --> RegisterSingleton<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Version of RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) that creates singleton instances that are also scoped to the root scope of the active IScopedContainer at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) (or TryResolve(RezolveContext, Object) ) is called. Declaration public static void RegisterSingleton<TObject, TService>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) TService See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) <!-- .classchild --> RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Non-generic version of RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) . Declaration public static void RegisterType(this ITargetContainer targets, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targets ITargetContainer objectType Type Required. Type of object to be constructed serviceType Type See Register(ITarget, Type) propertyBindingBehaviour IPropertyBindingBehaviour RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) <!-- .classchild --> RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) Registers a type to be created by the Rezolver via construction. The registration will auto-bind a constructor (most greedy) on the type and optionally bind any properties/fields on the new object, depending on the IPropertyBindingBehaviour object passed. Note that this method supports open generics. Declaration public static void RegisterType<TObject>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour The property binding behaviour. If null, then no properties are bound. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via their 'Auto' static methods and then registering them. <!-- .classchild --> RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) This is the same as RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) , except the TService type parameter allows you to explicitly set the type against which the registration is to be made. Declaration public static void RegisterType<TObject, TService>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null)where TObject : TService Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) TService The type against which the registration is to be made in the builder. E.g. 'IFoo' when TObject is 'Foo'. Remarks Please note the generic parameter constraints on this method: TService must have TObject as a base or interface in order for your code to compile. Note that if you use the RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) overload, then this is not the case. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITargetContainerMSDIExtensions.html": {
    "href": "rezolver-api/Rezolver.ITargetContainerMSDIExtensions.html",
    "title": "Class ITargetContainerMSDIExtensions",
    "keywords": "Class ITargetContainerMSDIExtensions Inheritance Object ITargetContainerMSDIExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ITargetContainerMSDIExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods Populate(ITargetContainer, IServiceCollection) Declaration public static void Populate(this ITargetContainer targets, IServiceCollection services) Parameters Name Type Description targets ITargetContainer services IServiceCollection <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITargetContainerOwner.html": {
    "href": "rezolver-api/Rezolver.ITargetContainerOwner.html",
    "title": "Interface ITargetContainerOwner",
    "keywords": "Interface ITargetContainerOwner Interface for an ITargetContainer which also contains other target containers. It is not typically used by your application code since it's primarily an infrastructure interface - if you are extending the API, however, then you might need to work with it. Inherited Members ITargetContainer.Register(ITarget, Type) ITargetContainer.Fetch(Type) ITargetContainer.FetchAll(Type) ITargetContainer.CombineWith(ITargetContainer, Type) Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITargetContainerOwner : ITargetContainer Remarks This interface, its implementations and everything else associated with it, is at the heart of functionality such as open generics, automatic enumerables and decorators. <!-- <hr class=\"typeSectionDivider\" /> --> Methods FetchContainer(Type) Retrieves an existing container registered against the given type , or null if not found. Declaration ITargetContainer FetchContainer(Type type) Parameters Name Type Description type Type Returns Type Description ITargetContainer <!-- .classchild --> RegisterContainer(Type, ITargetContainer) Registers a container against a given type . If a container already exists against this type, then the existing container's CombineWith(ITargetContainer, Type) method is called with the container as the argument, and the resulting container will replace the existing one. Declaration void RegisterContainer(Type type, ITargetContainer container) Parameters Name Type Description type Type container ITargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.LifetimeScopeRezolverExtensions.html": {
    "href": "rezolver-api/Rezolver.LifetimeScopeRezolverExtensions.html",
    "title": "Class LifetimeScopeRezolverExtensions",
    "keywords": "Class LifetimeScopeRezolverExtensions Inheritance Object LifetimeScopeRezolverExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class LifetimeScopeRezolverExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetOrAdd<T>(IScopedContainer, RezolveContext, Func<RezolveContext, T>, Boolean) Declaration public static T GetOrAdd<T>(this IScopedContainer scope, RezolveContext context, Func<RezolveContext, T> factory, bool disposableOnly = true) Parameters Name Type Description scope IScopedContainer context RezolveContext factory Func < RezolveContext , T> disposableOnly Boolean Returns Type Description T Type Parameters Name Description T <!-- .classchild --> GetScopeRoot(IScopedContainer) As the name suggests - this grabs the root scope for the scope on which this method is invoked. Declaration public static IScopedContainer GetScopeRoot(this IScopedContainer scope) Parameters Name Type Description scope IScopedContainer The scope whose root scope is sought. If null, then the method also returns null. Returns Type Description IScopedContainer An IScopedContainer reference representing the top-level (root) scope for the passed scope. <!-- .classchild --> GetSingleFromScope(IScopedContainer, RezolveContext) Retrieves a single instance that was previously added to the scope (or, optionally parent scopes) through a call to AddToScope(Object, RezolveContext) with a RezolveContext matching the one passed. Note - if multiple matches are found in a single scope, an InvalidOperationException will be thrown. Declaration public static object GetSingleFromScope(this IScopedContainer scope, RezolveContext context) Parameters Name Type Description scope IScopedContainer Required. The scope to be searched and optionally whose parent scopes are to be searched. context RezolveContext Required. The context whose properties will be used to find the matching disposable. Returns Type Description Object <!-- .classchild --> TrackIfScopedAndDisposableAndReturn<T>(IScopedContainer, T) This is primarily used by the dynamic code generated by RezolveTargetBase - if the scope is non-null and the instance is an IDiposable, then the object will be added to the scope. The instance , either way, is returned to simplify the function's use in dynamic code produced from expression trees. Declaration public static T TrackIfScopedAndDisposableAndReturn<T>(this IScopedContainer scope, T instance) Parameters Name Type Description scope IScopedContainer instance T Returns Type Description T Type Parameters Name Description T <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ListTarget.html": {
    "href": "rezolver-api/Rezolver.ListTarget.html",
    "title": "Class ListTarget",
    "keywords": "Class ListTarget This target produces arrays ( AsArray = true ) or lists ( AsArray = false ) whose individual items are built by ITarget instances. Primarily used by the Rezolver.EnumerableTargetContainer and the configuration framework, but can also be used by your code. Inheritance Object TargetBase ListTarget Inherited Members TargetBase.SuppressScopeTracking TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ListTarget : TargetBase, ITarget Remarks The element type you feed on construction determines the type of array or the generic argument to List<T>. Each of the rezolve targets that you then pass must support that type. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ListTarget(Type, IEnumerable<ITarget>, Boolean) Initializes a new instance of the ListTarget class. Declaration public ListTarget(Type elementType, IEnumerable<ITarget> items, bool asArray = false) Parameters Name Type Description elementType Type Required. Type of the elements in the array or list. items IEnumerable < ITarget > Required. The targets that will create each the individual items. asArray Boolean A boolean indicating whether the target will build an array ( true ) or a list ( false ). Exceptions Type Condition ArgumentNullException elementType or items ArgumentException All targets in the items enumerable must be non-null;items or All targets in the items enumerable must support the element type elementType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties AsArray Gets a value indicating whether the target will build an array ( true ) or a list ( false ). Declaration public bool AsArray { get; } Property Value Type Description Boolean <!-- .classchild --> DeclaredType Implementation of the abstract property from the base. This will always return either a type equal to an array of ElementType , or List<T> with ElementType as the generic parameter. This is controlled by the AsArray property. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> ElementType Gets the declared type of each element in the array or list that will be constructed. The DeclaredType returned by this instance will either be ElementType[] or List<ElementType> depending on the value of AsArray . Declaration public Type ElementType { get; } Property Value Type Description Type The declared type of each element. <!-- .classchild --> Items Gets the rezolve targets that will build each individual item in the resulting list or array. Declaration public IEnumerable<ITarget> Items { get; } Property Value Type Description IEnumerable < ITarget > The items. <!-- .classchild --> ListConstructor Gets the list constructor to be invoked when AsArray is false. Declaration public ConstructorInfo ListConstructor { get; } Property Value Type Description ConstructorInfo The list constructor. Exceptions Type Condition InvalidOperationException Since this target is configured to build an array, getting the ListConstructor is not a valid operation. <!-- .classchild --> UseFallback Returns true if the Items enumerable is empty. Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides TargetBase.UseFallback <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.MemberBinding.html": {
    "href": "rezolver-api/Rezolver.MemberBinding.html",
    "title": "Class MemberBinding",
    "keywords": "Class MemberBinding Represents the binding of an ITarget to a property or field of a given type. Not to be confused with the type of the same name from the System.Linq.Expressions namespace, although they are technically equivalent. Inheritance Object MemberBinding Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class MemberBinding Remarks You typically don't create this type directly - instead, other targets such as ConstructorTarget will create it as needed through the use of an IMemberBindingBehaviour object. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors MemberBinding(MemberInfo, ITarget) Initializes a new instance of the MemberBinding class. Declaration public MemberBinding(MemberInfo member, ITarget target) Parameters Name Type Description member MemberInfo The member to be bound. target ITarget The target whose value will be written to the member. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Fields None Empty bindings. Declaration public static readonly MemberBinding[] None Field Value Type Description MemberBinding [] <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Member Gets the member against which this binding is to be applied. Declaration public MemberInfo Member { get; } Property Value Type Description MemberInfo The member. <!-- .classchild --> MemberType Gets the type of the Member . E.g. if the member represents a String property on the declaring type, then this will return the String type. If the member represents an integer field, this it will return the Int32 type. Declaration public Type MemberType { get; } Property Value Type Description Type The type of the member. <!-- .classchild --> Target Gets the target whose value when resolved will be written to the Member Declaration public ITarget Target { get; } Property Value Type Description ITarget The target. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.MethodBinding.html": {
    "href": "rezolver-api/Rezolver.MethodBinding.html",
    "title": "Class MethodBinding",
    "keywords": "Class MethodBinding Represents a binding to a method whose arguments will be supplied by ITarget instances. Inheritance Object MethodBinding Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class MethodBinding <!-- <hr class=\"typeSectionDivider\" /> --> Constructors MethodBinding(MethodBase, ParameterBinding[]) Initializes a new instance of the MethodBinding class. Declaration public MethodBinding(MethodBase method, ParameterBinding[] boundArgs = null) Parameters Name Type Description method MethodBase The method. boundArgs ParameterBinding [] Optional. The bound arguments. Can be null or empty. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties BoundArguments Gets the argument bindings for the method call. Never null but can be empty. Declaration public ParameterBinding[] BoundArguments { get; } Property Value Type Description ParameterBinding [] The bound arguments. <!-- .classchild --> Method Gets the method to be invoked. Declaration public MethodBase Method { get; } Property Value Type Description MethodBase The method. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.MethodCallExtractor.html": {
    "href": "rezolver-api/Rezolver.MethodCallExtractor.html",
    "title": "Class MethodCallExtractor",
    "keywords": "Class MethodCallExtractor Used to help grab method and constructor info from expressions (which is easier than writing long strings of reflection code). For example: MethodCallExtractor.ExtractCalledMethod(() => Console.WriteLine(\"foo\")) Will return the MethodInfo for the WriteLine method of the Console class. Inheritance Object MethodCallExtractor Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public sealed class MethodCallExtractor : ExpressionVisitor <!-- <hr class=\"typeSectionDivider\" /> --> Methods ExtractCalledMethod(Expression<Action>) Extracts the MethodInfo of the first method call found in the expression. Declaration public static MethodInfo ExtractCalledMethod(Expression<Action> expr) Parameters Name Type Description expr Expression < System.Action > The expression to be read Returns Type Description MethodInfo A MethodInfo representing the method - if the expression contains a method call; otherwise null <!-- .classchild --> ExtractCalledMethod<T>(Expression<Action<T>>) Extracts the MethodInfo of the first method call found in the expression. Declaration public static MethodInfo ExtractCalledMethod<T>(Expression<Action<T>> expr) Parameters Name Type Description expr Expression < System.Action <T>> The expression to be read Returns Type Description MethodInfo A MethodInfo representing the method - if the expression contains a method call; otherwise null Type Parameters Name Description T Allows the expression to declare a parameter to aid overload resolution, but doesn't actually have any material influence on the expression analysis. <!-- .classchild --> ExtractCalledMethod<TResult>(Expression<Func<TResult>>) Extracts the MethodInfo of the first method call found in the expression. Declaration public static MethodInfo ExtractCalledMethod<TResult>(Expression<Func<TResult>> expr) Parameters Name Type Description expr Expression < Func <TResult>> The expression to be read Returns Type Description MethodInfo A MethodInfo representing the method - if the expression contains a method call; otherwise null Type Parameters Name Description TResult Return type of the expression. Not actually used in any way, it's just here to allow overload resolution when an expression represents a non-void function call <!-- .classchild --> ExtractCalledMethod<TInstance, TResult>(Expression<Func<TInstance, TResult>>) Extracts the MethodInfo of the first method call found in the expression. Declaration public static MethodInfo ExtractCalledMethod<TInstance, TResult>(Expression<Func<TInstance, TResult>> expr) Parameters Name Type Description expr Expression < Func <TInstance, TResult>> The expression to be read Returns Type Description MethodInfo A MethodInfo representing the method - if the expression contains a method call; otherwise null Type Parameters Name Description TInstance Allows the expression to declare a parameter to aid overload resolution, but doesn't actually have any material influence on the expression analysis. TResult Return type of the expression. Not actually used in any way, it's just here to allow overload resolution when an expression represents a non-void function call <!-- .classchild --> ExtractConstructorCall(Expression<Action>) Extracts the ConstructorInfo of the first 'new' statement found in the expression Declaration public static ConstructorInfo ExtractConstructorCall(Expression<Action> expr) Parameters Name Type Description expr Expression < System.Action > The expression to be analysed. Returns Type Description ConstructorInfo A ConstructorInfo representing the constructor being called in the expression; otherwise null if not found. <!-- .classchild --> ExtractConstructorCall<T>(Expression<Action<T>>) Extracts the ConstructorInfo of the first 'new' statement found in the expression Declaration public static ConstructorInfo ExtractConstructorCall<T>(Expression<Action<T>> expr) Parameters Name Type Description expr Expression < System.Action <T>> The expression to be analysed. Returns Type Description ConstructorInfo A ConstructorInfo representing the constructor being called in the expression; otherwise null if not found. Type Parameters Name Description T Allows the expression to declare a parameter to aid overload resolution, but doesn't actually have any material influence on the expression analysis. <!-- .classchild --> ExtractConstructorCall<TResult>(Expression<Func<TResult>>) Extracts the ConstructorInfo of the first 'new' statement found in the expression Declaration public static ConstructorInfo ExtractConstructorCall<TResult>(Expression<Func<TResult>> expr) Parameters Name Type Description expr Expression < Func <TResult>> The expression to be analysed. Returns Type Description ConstructorInfo A ConstructorInfo representing the constructor being called in the expression; otherwise null if not found. Type Parameters Name Description TResult Return type of the expression. Not actually used in any way, it's just here to allow overload resolution when an expression represents a non-void function call <!-- .classchild --> ExtractConstructorCall<TInstance, TResult>(Expression<Func<TInstance, TResult>>) Extracts the ConstructorInfo of the first 'new' statement found in the expression Declaration public static ConstructorInfo ExtractConstructorCall<TInstance, TResult>(Expression<Func<TInstance, TResult>> expr) Parameters Name Type Description expr Expression < Func <TInstance, TResult>> The expression to be analysed. Returns Type Description ConstructorInfo A ConstructorInfo representing the constructor being called in the expression; otherwise null if not found. Type Parameters Name Description TInstance Allows the expression to declare a parameter to aid overload resolution, but doesn't actually have any material influence on the expression analysis. TResult Return type of the expression. Not actually used in any way, it's just here to allow overload resolution when an expression represents a non-void function call <!-- .classchild --> VisitMethodCall(MethodCallExpression) Visits the children of the MethodCallExpression . Declaration protected override Expression VisitMethodCall(MethodCallExpression node) Parameters Name Type Description node MethodCallExpression The expression to visit. Returns Type Description Expression <!-- .classchild --> VisitNew(NewExpression) Visits the children of the NewExpression . Declaration protected override Expression VisitNew(NewExpression node) Parameters Name Type Description node NewExpression The expression to visit. Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Microsoft.Extensions.DependencyInjection.RezolverRegistration.html": {
    "href": "rezolver-api/Rezolver.Microsoft.Extensions.DependencyInjection.RezolverRegistration.html",
    "title": "Class RezolverRegistration",
    "keywords": "Class RezolverRegistration Inheritance Object RezolverRegistration Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Microsoft.Extensions.DependencyInjection Assembly :cs.temp.dll.dll Syntax public static class RezolverRegistration <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateDefaultContainer(ITargetContainer) Declaration public static IContainer CreateDefaultContainer(ITargetContainer targetContainer) Parameters Name Type Description targetContainer ITargetContainer Returns Type Description IContainer <!-- .classchild --> Populate(ContainerBase, IServiceCollection) Declaration public static IServiceProvider Populate(this ContainerBase rezolver, IServiceCollection services) Parameters Name Type Description rezolver ContainerBase services IServiceCollection Returns Type Description IServiceProvider <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Microsoft.Extensions.DependencyInjection.html": {
    "href": "rezolver-api/Rezolver.Microsoft.Extensions.DependencyInjection.html",
    "title": "Namespace Rezolver.Microsoft.Extensions.DependencyInjection",
    "keywords": "Namespace Rezolver.Microsoft.Extensions.DependencyInjection Classes RezolverRegistration"
  },
  "rezolver-api/Rezolver.MSDIITargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.MSDIITargetContainerExtensions.html",
    "title": "Class MSDIITargetContainerExtensions",
    "keywords": "Class MSDIITargetContainerExtensions Inheritance Object MSDIITargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class MSDIITargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods Populate(ITargetContainer, IServiceCollection) Declaration public static void Populate(this ITargetContainer targets, IServiceCollection services) Parameters Name Type Description targets ITargetContainer services IServiceCollection <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.MultipleTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.MultipleTargetContainerExtensions.html",
    "title": "Class MultipleTargetContainerExtensions",
    "keywords": "Class MultipleTargetContainerExtensions Extensions for registering multiple targets individually and against the same type Inheritance Object MultipleTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class MultipleTargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterAll(ITargetContainer, ITarget[]) Performs the same operations as RegisterAll(ITargetContainer, IEnumerable<ITarget>) except via a variable number of ITarget arguments. Declaration public static void RegisterAll(this ITargetContainer targetContainer, params ITarget[] targets) Parameters Name Type Description targetContainer ITargetContainer The target container on which the registrations are to be performed. targets ITarget [] The targets to be registered. <!-- .classchild --> RegisterAll(ITargetContainer, IEnumerable<ITarget>) Batch-registers multiple targets against their DeclaredType . This is the same as calling Register(ITarget, Type) for each of the targets , except the type cannot be overriden from the target's DeclaredType. Declaration public static void RegisterAll(this ITargetContainer targetContainer, IEnumerable<ITarget> targets) Parameters Name Type Description targetContainer ITargetContainer The target container on which the registrations are to be performed. targets IEnumerable < ITarget > The targets to be registered <!-- .classchild --> RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) Called to register multiple targets against the same type. It is the same as calling Register(ITarget, Type) multiple times with the different targets. Declaration public static void RegisterMultiple(this ITargetContainer targetContainer, IEnumerable<ITarget> targets, Type commonServiceType = null) Parameters Name Type Description targetContainer ITargetContainer The container on which the registration is to be performed. targets IEnumerable < ITarget > The targets to be registered - all must support a common service type (potentially passed in the commonServiceType argument. commonServiceType Type Optional - if provided, then this will be used as the common service type for registration. If not provided, then the DeclaredType of the first target will be used. Remarks If the container has the capability to handle enumerables, then each target will be returned when an IEnumerable of the common service type is requested. This is an opt-in behaviour in Rezolver - implemented by the Rezolver.EnumerableTargetContainer and can be added to a target container with the extension method EnableEnumerableResolving(TargetContainer) . Note that default behaviour of TargetContainer is for this to be enabled. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ObjectTarget.html": {
    "href": "rezolver-api/Rezolver.ObjectTarget.html",
    "title": "Class ObjectTarget",
    "keywords": "Class ObjectTarget Implements ITarget by wrapping a single instance that's already been constructed by application code. Inheritance Object TargetBase ObjectTarget Inherited Members TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ObjectTarget : TargetBase, ITarget, ICompiledTarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ObjectTarget(Object, Type, Boolean) Creates a new instance of the ObjectTarget class. Declaration public ObjectTarget(object obj, Type declaredType = null, bool suppressScopeTracking = true) Parameters Name Type Description obj Object The object to be returned by this target when resolved. declaredType Type Optional. The declared type of this target, if different from the absolute type of the obj suppressScopeTracking Boolean Optional. Controls whether the instance will be added to a scope when resolved. If true (the default) then no scope tracking is performed, and you will have to dispose of the object, if disposable. If false, then the object will be tracked by the ROOT scope of the first scope the object is resolved from. Remarks Please note - if you enable scope tracking, but the object is never resolved, then the object will not be disposed and you will need to ensure you dispose of it. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Gets the declared type of object that is returned by this target. Might be different from the type of Value if explicitly defined when this target was constructed. Declaration public override Type DeclaredType { get; } Property Value Type Description Type The type of the declared. Overrides TargetBase.DeclaredType <!-- .classchild --> SuppressScopeTracking Overrides SuppressScopeTracking Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides TargetBase.SuppressScopeTracking <!-- .classchild --> Value Gets the value that will be exposed by expressions built by this instance. Declaration public object Value { get; } Property Value Type Description Object The value. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Explicit Interface Implementations ICompiledTarget.GetObject(ResolveContext) Declaration object ICompiledTarget.GetObject(ResolveContext context) Parameters Name Type Description context ResolveContext Returns Type Description Object Implements ICompiledTarget.GetObject(ResolveContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ObjectTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.ObjectTargetContainerExtensions.html",
    "title": "Class ObjectTargetContainerExtensions",
    "keywords": "Class ObjectTargetContainerExtensions Extensions for ITargetContainer relating to registering concrete instances via the ObjectTarget target. Inheritance Object ObjectTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ObjectTargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterObject<T>(ITargetContainer, T, Type, Boolean) Registers a single instance (already created) to be used when resolving a particular service type. Declaration public static void RegisterObject<T>(this ITargetContainer targetContainer, T obj, Type serviceType = null, bool suppressScopeTracking = true) Parameters Name Type Description targetContainer ITargetContainer The target container which will receive the registration. obj T The instance that will be resolved when the service type is requested. serviceType Type The service type against which this object is to be registered, if different from T . suppressScopeTracking Boolean If true (the default), then the object will not be tracked and disposed of by any IScopedContainer that might be active when the object is first resolved. In theory this should always be left as true because otherwise the object will not be usable after the first scope its contained within is disposed. Type Parameters Name Description T Type of the object - will be used as the service type for registration if serviceType is not provied. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ObjectTargetExtensions.html": {
    "href": "rezolver-api/Rezolver.ObjectTargetExtensions.html",
    "title": "Class ObjectTargetExtensions",
    "keywords": "Class ObjectTargetExtensions Extension method(s) to help create the ObjectTarget target. Inheritance Object ObjectTargetExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ObjectTargetExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods AsObjectTarget<T>(T, Type, Boolean) Wraps the instance on which this is invoked as an ObjectTarget that can be registered into an ITargetContainer . The parameters are direct analogues of the parameters on the type's constructor (see ObjectTarget(Object, Type, Boolean) ). Declaration public static ObjectTarget AsObjectTarget<T>(this T obj, Type declaredType = null, bool suppressScopeTracking = true) Parameters Name Type Description obj T the object being wrapped declaredType Type Optional. The type which is to be set as the DeclaredType of the created target. suppressScopeTracking Boolean Probably going to be removed or changed. Returns Type Description ObjectTarget A new object target that wraps the object obj . Type Parameters Name Description T The type of object being wrapped <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolveTargetAdapterExtensions.html": {
    "href": "rezolver-api/Rezolver.RezolveTargetAdapterExtensions.html",
    "title": "Class RezolveTargetAdapterExtensions",
    "keywords": "Class RezolveTargetAdapterExtensions Inheritance Object RezolveTargetAdapterExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class RezolveTargetAdapterExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateTarget<T>(ITargetAdapter, Expression<Func<T>>) Declaration public static ITarget CreateTarget<T>(this ITargetAdapter adapter, Expression<Func<T>> expression) Parameters Name Type Description adapter ITargetAdapter expression Expression < Func <T>> Returns Type Description ITarget Type Parameters Name Description T <!-- .classchild --> CreateTarget<T>(ITargetAdapter, Expression<Func<RezolveContextExpressionHelper, T>>) Declaration public static ITarget CreateTarget<T>(this ITargetAdapter adapter, Expression<Func<RezolveContextExpressionHelper, T>> expression) Parameters Name Type Description adapter ITargetAdapter expression Expression < Func < RezolveContextExpressionHelper , T>> Returns Type Description ITarget Type Parameters Name Description T <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolveTargetExpression.html": {
    "href": "rezolver-api/Rezolver.RezolveTargetExpression.html",
    "title": "Class RezolveTargetExpression",
    "keywords": "Class RezolveTargetExpression Makes it possible to mix expressions and targets. Inheritance Object RezolveTargetExpression Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolveTargetExpression : Expression <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RezolveTargetExpression(ITarget) Declaration public RezolveTargetExpression(ITarget target) Parameters Name Type Description target ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties CanReduce Declaration public override bool CanReduce { get; } Property Value Type Description Boolean <!-- .classchild --> NodeType Declaration public override ExpressionType NodeType { get; } Property Value Type Description ExpressionType <!-- .classchild --> Target Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> Type Declaration public override Type Type { get; } Property Value Type Description Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Reduce() Declaration public override Expression Reduce() Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ScopedContainer.html": {
    "href": "rezolver-api/Rezolver.ScopedContainer.html",
    "title": "Class ScopedContainer",
    "keywords": "Class ScopedContainer Extends the Container to implement lifetime scoping. If you want your root container to act as a lifetime scope, then you should use this class instead of using Container Inheritance Object ContainerBase CachingContainerBase Container ScopedContainer Inherited Members CachingContainerBase.GetCompiledRezolveTarget(ResolveContext) ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Compiler ContainerBase.Targets ContainerBase.Resolve(ResolveContext) ContainerBase.TryResolve(ResolveContext, Object) ContainerBase.CreateLifetimeScope() ContainerBase.FetchCompiled(ResolveContext) ContainerBase.CanResolve(ResolveContext) ContainerBase.GetFallbackCompiledRezolveTarget(ResolveContext) Rezolver.ContainerBase.System.IServiceProvider.GetService(System.Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.Fetch(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.FetchAll(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer, System.Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ScopedContainer : Container, ITargetContainer, IScopedContainer, IContainer, IServiceProvider, IDisposable Remarks The implementation of this class is very similar to the OverridingScopedContainer , The main difference being that that class can accept additional registrations independent of those in the container that it's created from, whereas with this class, it is the container. This type is therefore suited only for standalone Rezolvers for which you want lifetime scoping and disposable handling; whereas the OverridingScopedContainer is primarily suited for use as a child lifetime scope for another container. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ScopedContainer(ITargetContainer, ITargetCompiler) Declaration public ScopedContainer(ITargetContainer builder = null, ITargetCompiler compiler = null) Parameters Name Type Description builder ITargetContainer compiler ITargetCompiler <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties ParentScope Declaration public IScopedContainer ParentScope { get; } Property Value Type Description IScopedContainer Implements IScopedContainer.ParentScope <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods AddToScope(Object, ResolveContext) Declaration public virtual void AddToScope(object obj, ResolveContext context = null) Parameters Name Type Description obj Object context ResolveContext Implements IScopedContainer.AddToScope(Object, ResolveContext) <!-- .classchild --> Dispose() Declaration public void Dispose() Implements IDisposable.Dispose() <!-- .classchild --> Dispose(Boolean) Declaration protected virtual void Dispose(bool disposing) Parameters Name Type Description disposing Boolean <!-- .classchild --> GetFromScope(ResolveContext) Declaration public virtual IEnumerable<object> GetFromScope(ResolveContext context) Parameters Name Type Description context ResolveContext Returns Type Description IEnumerable < Object > Implements IScopedContainer.GetFromScope(ResolveContext) <!-- .classchild --> OnDisposed() Declaration protected void OnDisposed() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Events Disposed Declaration public event EventHandler Disposed Event Type Type Description EventHandler Implements IScopedContainer.Disposed <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ScopedContainerScopeExtensions.html": {
    "href": "rezolver-api/Rezolver.ScopedContainerScopeExtensions.html",
    "title": "Class ScopedContainerScopeExtensions",
    "keywords": "Class ScopedContainerScopeExtensions Contains extension methods for the IScopedContainer interface which provide some additional shortucts for getting or adding objects from/to scopes. Inheritance Object ScopedContainerScopeExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ScopedContainerScopeExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetOrAdd(IScopedContainer, ResolveContext, Func<ResolveContext, Object>, Boolean) Retrieves an object from scope or adds it (by calling the factory before returning it. Declaration public static object GetOrAdd(this IScopedContainer scope, ResolveContext context, Func<ResolveContext, object> factory, bool disposableOnly = true) Parameters Name Type Description scope IScopedContainer The scope. context ResolveContext The context. factory Func < ResolveContext , Object > The factory. disposableOnly Boolean if set to true then object only gets added to the scope if it's has the IDisposable interface.. Returns Type Description Object <!-- .classchild --> GetOrAdd<T>(IScopedContainer, ResolveContext, Func<ResolveContext, T>, Boolean) Retrieves an object from scope or adds it (by calling the factory before returning it. Declaration public static T GetOrAdd<T>(this IScopedContainer scope, ResolveContext context, Func<ResolveContext, T> factory, bool disposableOnly = true) Parameters Name Type Description scope IScopedContainer The scope. context ResolveContext The context. factory Func < ResolveContext , T> The factory. disposableOnly Boolean if set to true then object only gets added to the scope if it's has the IDisposable interface.. Returns Type Description T Type Parameters Name Description T Type of object being created and/or retrieved from the scope. <!-- .classchild --> GetScopeRoot(IScopedContainer) As the name suggests - this grabs the root scope for the scope on which this method is invoked. Declaration public static IScopedContainer GetScopeRoot(this IScopedContainer scope) Parameters Name Type Description scope IScopedContainer The scope whose root scope is sought. If null, then the method also returns null. Returns Type Description IScopedContainer An IScopedContainer reference representing the top-level (root) scope for the passed scope. <!-- .classchild --> GetSingleFromScope(IScopedContainer, ResolveContext) Retrieves a single instance that was previously added to the scope (or, optionally parent scopes) through a call to AddToScope(Object, ResolveContext) with a ResolveContext matching the one passed. Note - if multiple matches are found in a single scope, an InvalidOperationException will be thrown. Declaration public static object GetSingleFromScope(this IScopedContainer scope, ResolveContext context) Parameters Name Type Description scope IScopedContainer Required. The scope to be searched and optionally whose parent scopes are to be searched. context ResolveContext Required. The context whose properties will be used to find the matching disposable. Returns Type Description Object <!-- .classchild --> TrackIfScopedAndDisposableAndReturn<T>(IScopedContainer, T) This is primarily used by the dynamic code generated by RezolveTargetBase - if the scope is non-null and the instance is an IDiposable, then the object will be added to the scope. The instance , either way, is returned to simplify the function's use in dynamic code produced from expression trees. Declaration public static T TrackIfScopedAndDisposableAndReturn<T>(this IScopedContainer scope, T instance) Parameters Name Type Description scope IScopedContainer instance T Returns Type Description T Type Parameters Name Description T <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ScopedTarget.html": {
    "href": "rezolver-api/Rezolver.ScopedTarget.html",
    "title": "Class ScopedTarget",
    "keywords": "Class ScopedTarget A target that produces a single instance of an object within a lifetime scope. Inheritance Object TargetBase ScopedTarget Inherited Members TargetBase.UseFallback Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ScopedTarget : TargetBase, ITarget Remarks On its own, this target doesn't do anything - it's designed to wrap another target such that the code generated from the expression it produces is executed only once for each lifetime scope. Outside of that, the target generates wrapper code that forcibly caches the instance that is produced (whether it's IDiposable or not) into the current scope's cache (using AddToScope(Object, ResolveContext) ) and retrieves previous instances from that scope (using GetFromScope(ResolveContext) . <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ScopedTarget(ITarget) Declaration public ScopedTarget(ITarget innerTarget) Parameters Name Type Description innerTarget ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> InnerTarget Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget <!-- .classchild --> SuppressScopeTracking Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides TargetBase.SuppressScopeTracking <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods SupportsType(Type) Declaration public override bool SupportsType(Type type) Parameters Name Type Description type Type Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ScopedTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.ScopedTargetContainerExtensions.html",
    "title": "Class ScopedTargetContainerExtensions",
    "keywords": "Class ScopedTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for registering constructor-injected types whose lifetimes are slaved to that of a parent IScopedContainer . All of the extension methods ultimately create a ScopedTarget Inheritance Object ScopedTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ScopedTargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) Registers an explicitly instance of objectType (optionally for the service type serviceType ) to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterScoped(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The target container on which the registration is to be performed. objectType Type The type of the object that is to be constructed when resolved. serviceType Type Optional. The type against which the registration will be performed, if different from objectType . objectType must be compatible with this type, if it's provided. propertyBindingBehaviour IMemberBindingBehaviour Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto(Type, IMemberBindingBehaviour) or Auto(Type, IMemberBindingBehaviour) static methods, wrapping it with a ScopedTarget and then registering it against the type serviceType or objectType . <!-- .classchild --> RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) Registers an explicitly scoped instance of TObject to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterScoped<TObject>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The target container on which the registration is to be performed. propertyBindingBehaviour IMemberBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto<T>(IMemberBindingBehaviour) or Auto<TGeneric>(IMemberBindingBehaviour) static methods, wrapping it with a ScopedTarget and registering it. <!-- .classchild --> RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) Registers an explicitly scoped instance of TObject for the service type TService to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterScoped<TObject, TService>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The target container on which the registration is to be performed. propertyBindingBehaviour IMemberBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. TService The type against which the registration will be performed. TObject must be compatible with this type. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto<T>(IMemberBindingBehaviour) or Auto<TGeneric>(IMemberBindingBehaviour) static methods, wrapping it with a ScopedTarget and then registering it against the type TService . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.SingletonTarget.html": {
    "href": "rezolver-api/Rezolver.SingletonTarget.html",
    "title": "Class SingletonTarget",
    "keywords": "Class SingletonTarget A target which applies the singleton pattern to any ITarget . The inner target is available from the InnerTarget property. Inheritance Object TargetBase SingletonTarget Inherited Members TargetBase.UseFallback Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class SingletonTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors SingletonTarget(ITarget) Constructs a new instance of the SingletonTarget class. Declaration public SingletonTarget(ITarget innerTarget) Parameters Name Type Description innerTarget ITarget The target whose result (when compiled) is to be used as the singleton instance. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Override of DeclaredType - always returns the DeclaredType of the InnerTarget Declaration public override Type DeclaredType { get; } Property Value Type Description Type The type of the declared. Overrides TargetBase.DeclaredType <!-- .classchild --> InnerTarget Gets the inner target for this singleton. Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget <!-- .classchild --> SuppressScopeTracking Overrides the base class to ensure that automatic generation of the scope tracking code by TargetBase is disabled. For the singleton, it's important that the scope tracking call occurs within the lazy's callback. Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides TargetBase.SuppressScopeTracking <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetOrAddInitialiser(Type, Func<Type, ICompiledTarget>) Used to support compiled versions of this singleton - note this concept is something that probably needs to move out of this type, into a more generic TargetState object or something like that. Declaration public ICompiledTarget GetOrAddInitialiser(Type declaredType, Func<Type, ICompiledTarget> initialiserFactory) Parameters Name Type Description declaredType Type Type of object. initialiserFactory Func < Type , ICompiledTarget > The initialiser factory. Returns Type Description ICompiledTarget <!-- .classchild --> SupportsType(Type) Called to check whether a target can create an expression that builds an instance of the given type . The base implementation always passes the call on to the InnerTarget Declaration public override bool SupportsType(Type type) Parameters Name Type Description type Type Required Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.SingletonTargetDictionaryExtensions.html": {
    "href": "rezolver-api/Rezolver.SingletonTargetDictionaryExtensions.html",
    "title": "Class SingletonTargetDictionaryExtensions",
    "keywords": "Class SingletonTargetDictionaryExtensions Extension methods for the ITargetContainer interface which simplify the registration of singletons. Inheritance Object SingletonTargetDictionaryExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class SingletonTargetDictionaryExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) Registers the type objectType as a singleton ( SingletonTarget ) in the target container using either objectType as the service type, or serviceType instead - if it's provided. The instance will be built automatically with constructor injection (and, optionally, property injection if a propertyBindingBehaviour is passed) by leveraging the ConstructorTarget or GenericConstructorTarget targets. Declaration public static void RegisterSingleton(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The container on which the registrations will be made. objectType Type Required. The type of object to be created. serviceType Type Optional. The type against which the target will be registered in the targetContainer propertyBindingBehaviour IMemberBindingBehaviour Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. <!-- .classchild --> RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) Registers the type TObject as a singleton ( SingletonTarget ) in the target container. The instance will be built automatically with constructor injection (and, optionally, property injection if a propertyBindingBehaviour is passed) by leveraging the ConstructorTarget or GenericConstructorTarget targets. Declaration public static void RegisterSingleton<TObject>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The container on which the registrations will be made. propertyBindingBehaviour IMemberBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type to be created, and the type against which the registration will be made <!-- .classchild --> RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) Registers the type TObject as a singleton ( SingletonTarget ) in the target container for the service type TService . The instance will be built automatically with constructor injection (and, optionally, property injection if a propertyBindingBehaviour is passed) by leveraging the ConstructorTarget or GenericConstructorTarget targets. Declaration public static void RegisterSingleton<TObject, TService>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The container on which the registrations will be made. propertyBindingBehaviour IMemberBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of object to be created. TService The type against which the target will be registered in the targetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetAdapter.html": {
    "href": "rezolver-api/Rezolver.TargetAdapter.html",
    "title": "Class TargetAdapter",
    "keywords": "Class TargetAdapter Default implementation of the ITargetAdapter interface. Also an ExpressionVisitor. Also, its Default property serves as the reference to the default adapter used by the system to convert expressions into IRezolveTarget instances. This class cannot be created directly - it is a singleton accessed through the Instance property. You can inherit from this class, however, to serve as the basis for your own implementation of ITargetAdapter . Inheritance Object TargetAdapter Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetAdapter : ExpressionVisitor, ITargetAdapter <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TargetAdapter() Protected constructor ensuring that new instances can only be created through inheritance. Declaration protected TargetAdapter() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Default The default IRezolveTargetAdapter to be used in converting expressions to IRezolveTarget instances. By default, this is initialised to a single instance of the TargetAdapter class. Declaration public static ITargetAdapter Default { get; set; } Property Value Type Description ITargetAdapter <!-- .classchild --> Instance The one and only instance of the RezolveTargetAdapter class Declaration public static ITargetAdapter Instance { get; } Property Value Type Description ITargetAdapter <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateTarget(Expression) Creates the target. Declaration public ITarget CreateTarget(Expression expression) Parameters Name Type Description expression Expression The expression. Returns Type Description ITarget Implements ITargetAdapter.CreateTarget(Expression) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetAdapterCreateExtensions.html": {
    "href": "rezolver-api/Rezolver.TargetAdapterCreateExtensions.html",
    "title": "Class TargetAdapterCreateExtensions",
    "keywords": "Class TargetAdapterCreateExtensions Inheritance Object TargetAdapterCreateExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class TargetAdapterCreateExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateTarget<TResult>(ITargetAdapter, Expression<Func<TResult>>) Declaration public static ITarget CreateTarget<TResult>(this ITargetAdapter adapter, Expression<Func<TResult>> expression) Parameters Name Type Description adapter ITargetAdapter expression Expression < Func <TResult>> Returns Type Description ITarget Type Parameters Name Description TResult <!-- .classchild --> CreateTarget<TResult>(ITargetAdapter, Expression<Func<RezolveContext, TResult>>) Declaration public static ITarget CreateTarget<TResult>(this ITargetAdapter adapter, Expression<Func<RezolveContext, TResult>> expression) Parameters Name Type Description adapter ITargetAdapter expression Expression < Func < RezolveContext , TResult>> Returns Type Description ITarget Type Parameters Name Description TResult <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetAdapterGenericRegisterExpressionExtensions.html": {
    "href": "rezolver-api/Rezolver.TargetAdapterGenericRegisterExpressionExtensions.html",
    "title": "Class TargetAdapterGenericRegisterExpressionExtensions",
    "keywords": "Class TargetAdapterGenericRegisterExpressionExtensions Contains numerous generic overloads of the RegisterExpression extension method for ITargetContainer All of these extensions act as proxies for the RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) extension method. Inheritance Object TargetAdapterGenericRegisterExpressionExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class TargetAdapterGenericRegisterExpressionExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<TResult>(this ITargetContainer targetContainer, Expression<Func<TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<TResult>(ITargetContainer, Expression<Func<RezolveContext, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) T15 The type of the 15th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) T15 The type of the 15th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T, TResult>(this ITargetContainer targetContainer, Expression<Func<T, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T The type of the 1st lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<RezolveContext, T, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T The type of the 2nd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetAdapterRegisterExpressionExtensions.html": {
    "href": "rezolver-api/Rezolver.TargetAdapterRegisterExpressionExtensions.html",
    "title": "Class TargetAdapterRegisterExpressionExtensions",
    "keywords": "Class TargetAdapterRegisterExpressionExtensions Extensions for to simplify registering expressions in an ITargetContainer . Inheritance Object TargetAdapterRegisterExpressionExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class TargetAdapterRegisterExpressionExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) Registers the expression. Declaration public static void RegisterExpression(this ITargetContainer targetContainer, Expression expression, Type type, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The target container. expression Expression The expression. type Type The type. adapter ITargetAdapter The adapter. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetAssemblyCompiler.html": {
    "href": "rezolver-api/Rezolver.TargetAssemblyCompiler.html",
    "title": "Class TargetAssemblyCompiler",
    "keywords": "Class TargetAssemblyCompiler Implementation of the ITargetCompiler which compiles dynamic code to an assembly (which can, potentially, be saved to disk). Suitable for environments that support the full .Net profile. Generally, the performance of a container built using this compiler will be better than one that uses the TargetDelegateCompiler . Inheritance Object TargetAssemblyCompiler Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetAssemblyCompiler : ITargetCompiler <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TargetAssemblyCompiler() Initializes a new instance of the TargetAssemblyCompiler class. Declaration public TargetAssemblyCompiler() <!-- .classchild --> TargetAssemblyCompiler(AssemblyBuilder) Initializes a new instance of the TargetAssemblyCompiler class. Declaration public TargetAssemblyCompiler(AssemblyBuilder assemblyBuilder) Parameters Name Type Description assemblyBuilder AssemblyBuilder The assembly builder into which the dynamically generated code will be compiled. Exceptions Type Condition ArgumentNullException assemblyBuilder is null <!-- .classchild --> TargetAssemblyCompiler(ModuleBuilder) Initializes a new instance of the TargetAssemblyCompiler class. Declaration public TargetAssemblyCompiler(ModuleBuilder moduleBuilder) Parameters Name Type Description moduleBuilder ModuleBuilder The module builder - if the assembly builder is already being used for something else and you want the dynamic code for the container to be compiled into a specific module within that assembly. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties AssemblyBuilder Gets the assembly builder whose dynamic assembly is receiving the dynamically generated code. Declaration public AssemblyBuilder AssemblyBuilder { get; } Property Value Type Description AssemblyBuilder The assembly builder. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CompileTarget(ITarget, CompileContext) Creates and builds a compiled target for the passed rezolve target which can then be used to create/obtain the object(s) it produces. Declaration public ICompiledTarget CompileTarget(ITarget target, CompileContext context) Parameters Name Type Description target ITarget The target to be compiled. context CompileContext The current compilation context. Returns Type Description ICompiledTarget A compiled target that produces the object represented by target . Implements ITargetCompiler.CompileTarget(ITarget, CompileContext) <!-- .classchild --> CreateAssemblyBuilder(AssemblyBuilderAccess, String) Shortcut method for creating an assembly builder that is suitable for use with an TargetAssemblyCompiler , but with the supplied access settings (e.g. if you want to be able to save the assembly). Declaration public static AssemblyBuilder CreateAssemblyBuilder(AssemblyBuilderAccess assemblyBuilderAccess = null, string dir = null) Parameters Name Type Description assemblyBuilderAccess AssemblyBuilderAccess The assembly builder access. dir String If supplied, then it's the base directory that will be used when saving the dynamic dll. Returns Type Description AssemblyBuilder An AssemblyBuilder instance that can be passed to the TargetAssemblyCompiler constructor. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetBase.html": {
    "href": "rezolver-api/Rezolver.TargetBase.html",
    "title": "Class TargetBase",
    "keywords": "Class TargetBase Abstract base class, suggested as a starting point for implementations of ITarget . Inheritance Object TargetBase Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public abstract class TargetBase : ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Gets the declared type of object that is constructed by this target. Declaration public abstract Type DeclaredType { get; } Property Value Type Description Type Implements ITarget.DeclaredType <!-- .classchild --> SuppressScopeTracking this is probably going to be removed or at least changed. Declaration protected virtual bool SuppressScopeTracking { get; } Property Value Type Description Boolean <!-- .classchild --> UseFallback Implementation of UseFallback Base version always returns false . Declaration public virtual bool UseFallback { get; } Property Value Type Description Boolean Implements ITarget.UseFallback <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods SupportsType(Type) Called to check whether a target can create an expression that builds an instance of the given type . Declaration public virtual bool SupportsType(Type type) Parameters Name Type Description type Type Required Returns Type Description Boolean true if this target supports the given type, false otherwise. Implements ITarget.SupportsType(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetCompiler.html": {
    "href": "rezolver-api/Rezolver.TargetCompiler.html",
    "title": "Class TargetCompiler",
    "keywords": "Class TargetCompiler Holds a reference to the default compiler for this application. By default this is set to the TargetDelegateCompiler - which is a general purpose compiler that should work on any platform which supports linq expression trees. Inheritance Object TargetCompiler Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class TargetCompiler <!-- <hr class=\"typeSectionDivider\" /> --> Properties Default The default compiler to be used by rezolvers when they are not explicitly provided one. Declaration public static ITargetCompiler Default { get; set; } Property Value Type Description ITargetCompiler <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetCompilerBase.html": {
    "href": "rezolver-api/Rezolver.TargetCompilerBase.html",
    "title": "Class TargetCompilerBase",
    "keywords": "Class TargetCompilerBase Inheritance Object TargetCompilerBase Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public abstract class TargetCompilerBase : ITargetCompiler <!-- <hr class=\"typeSectionDivider\" /> --> Methods CompileTarget(ITarget, CompileContext) Declaration public virtual ICompiledTarget CompileTarget(ITarget target, CompileContext context) Parameters Name Type Description target ITarget context CompileContext Returns Type Description ICompiledTarget Implements ITargetCompiler.CompileTarget(ITarget, CompileContext) <!-- .classchild --> CompileTargetBase(ITarget, Expression, CompileContext) Called to create an ICompiledTarget instance from the passed expression produced by the passed target for the passed context. The expression passed into this method is constructed by a call to GetLambdaBody(ITarget, CompileContext) Declaration protected abstract ICompiledTarget CompileTargetBase(ITarget target, Expression toCompile, CompileContext context) Parameters Name Type Description target ITarget The target from which the expression toCompile was built. Note - this expression will have been optimised and potentially rewritten ready for compilation, and will likely not be equal to the expression originally produced by its own Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) method. toCompile Expression The expression built from target by this instance's own GetLambdaBody(ITarget, CompileContext) methodd. context CompileContext The context for which the compilation is being performed. Returns Type Description ICompiledTarget <!-- .classchild --> GetLambdaBody(ITarget, CompileContext) Produces the lambda body for the target. The base class uses the method GetLambdaBodyForTarget(ITarget, CompileContext) to get the expression tree that will be compiled. Declaration protected virtual Expression GetLambdaBody(ITarget target, CompileContext context) Parameters Name Type Description target ITarget context CompileContext Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetCompilerHelper.RedundantConvertRemover.html": {
    "href": "rezolver-api/Rezolver.TargetCompilerHelper.RedundantConvertRemover.html",
    "title": "Class TargetCompilerHelper.RedundantConvertRemover",
    "keywords": "Class TargetCompilerHelper.RedundantConvertRemover Inheritance Object TargetCompilerHelper.RedundantConvertRemover Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RedundantConvertRemover : ExpressionVisitor <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RedundantConvertRemover() Declaration public RedundantConvertRemover() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods VisitUnary(UnaryExpression) Declaration protected override Expression VisitUnary(UnaryExpression node) Parameters Name Type Description node UnaryExpression Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetCompilerHelper.html": {
    "href": "rezolver-api/Rezolver.TargetCompilerHelper.html",
    "title": "Class TargetCompilerHelper",
    "keywords": "Class TargetCompilerHelper Inheritance Object TargetCompilerHelper Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class TargetCompilerHelper <!-- <hr class=\"typeSectionDivider\" /> --> Methods Optimise(Expression, IEnumerable<Func<Expression, Expression>>) Declaration public static Expression Optimise(this Expression expression, IEnumerable<Func<Expression, Expression>> additionalOptimisations = null) Parameters Name Type Description expression Expression additionalOptimisations IEnumerable < Func < Expression , Expression >> Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetContainer.html": {
    "href": "rezolver-api/Rezolver.TargetContainer.html",
    "title": "Class TargetContainer",
    "keywords": "Class TargetContainer Root container for ITarget s that can be used as the backing for the standard IContainer classes - Container and ScopedContainer . Stores and retrieves registrations of ITarget s, is also Generic type aware, unlike its base class - TargetDictionaryContainer . Inheritance Object TargetDictionaryContainer TargetContainer Inherited Members TargetDictionaryContainer.Fetch(Type) TargetDictionaryContainer.FetchAll(Type) TargetDictionaryContainer.CombineWith(ITargetContainer, Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetContainer : TargetDictionaryContainer, ITargetContainerOwner, ITargetContainer Remarks This is the type used by default for the Targets of all the standard containers in the core framework, e.g. Container , ScopedContainer etc, when you don't supply an instance of an ITargetContainer explicitly on construction. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TargetContainer(Boolean) Constructs a new instance of the TargetContainer class Declaration public TargetContainer(bool autoRezolveIEnumerable = true) Parameters Name Type Description autoRezolveIEnumerable Boolean If true, then IEnumerable<T> will be automatically resolved as a concatenation of all the ITarget s that are registered against a particular type. Note - this parameter might be removed in a future version - you can achieve the same thing by using the extension method EnableEnumerableResolving(TargetContainer) <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateContainer(Type, ITarget) Called to create and register a container for the given serviceType and target . This class overrides the base version ( CreateContainer(Type, ITarget) ) to create a specialised container for generic types ( GenericTargetContainer ) if serviceType if a generic type or generic type definition. Declaration protected override ITargetContainer CreateContainer(Type serviceType, ITarget target) Parameters Name Type Description serviceType Type The type for which a container is to be created and registered. target ITarget Optional. The target that will be added to the container that is returned. Returns Type Description ITargetContainer An ITargetContainer in which the passed target will be registered. Overrides TargetDictionaryContainer.CreateContainer(Type, ITarget) Remarks The main caller for this method will be the base Register method, which will create a new container for a target that's being registered against a new type. It is, however, also called by this class' implementation of RegisterContainer(Type, ITargetContainer) when the type is a generic type - as all generics must have a container registered against their generic type definitions as a starting point. <!-- .classchild --> CreateGenericTypeDefContainer(Type, ITarget) Called by CreateContainer(Type, ITarget) to create a container suitable for handling targets that are registered against generic types. Declaration protected virtual ITargetContainer CreateGenericTypeDefContainer(Type genericTypeDefinition, ITarget target) Parameters Name Type Description genericTypeDefinition Type Will be an open generic type (generic type definition) target ITarget Optional. The initial target for which the container is being constructed Returns Type Description ITargetContainer The base implementation always creates an instance of CreateGenericTypeDefContainer(Type, ITarget) <!-- .classchild --> FetchContainer(Type) Retrieves Declaration public override ITargetContainer FetchContainer(Type type) Parameters Name Type Description type Type Returns Type Description ITargetContainer Overrides TargetDictionaryContainer.FetchContainer(Type) <!-- .classchild --> Register(ITarget, Type) Overrides the base method to block registration if the target does not support the serviceType (checked by calling the target's SupportsType(Type) method). Declaration public override void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget The target to be registered. serviceType Type Optional - the type against which the target is to be registered, if different from the target's DeclaredType . Overrides TargetDictionaryContainer.Register(ITarget, Type) <!-- .classchild --> RegisterContainer(Type, ITargetContainer) Overrides the base method so that if type is a generic type, then the container will be registered inside another which will be registered for the generic type definition first. Declaration public override void RegisterContainer(Type type, ITargetContainer container) Parameters Name Type Description type Type container ITargetContainer Overrides TargetDictionaryContainer.RegisterContainer(Type, ITargetContainer) <!-- .classchild --> RegisterContainerDirect(Type, ITargetContainer) Version of RegisterContainer(Type, ITargetContainer) which does not interrogate the type to see if it's generic - simply registers the passed container directly against the passed type (it just chains through directly to the RegisterContainer(Type, ITargetContainer) method non-virtually. Declaration protected virtual void RegisterContainerDirect(Type type, ITargetContainer container) Parameters Name Type Description type Type container ITargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetDelegateCompiler.DelegatingCompiledRezolveTarget.html": {
    "href": "rezolver-api/Rezolver.TargetDelegateCompiler.DelegatingCompiledRezolveTarget.html",
    "title": "Class TargetDelegateCompiler.DelegatingCompiledRezolveTarget",
    "keywords": "Class TargetDelegateCompiler.DelegatingCompiledRezolveTarget Inheritance Object TargetDelegateCompiler.DelegatingCompiledRezolveTarget Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegatingCompiledRezolveTarget : ICompiledTarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegatingCompiledRezolveTarget(Func<RezolveContext, Object>) Declaration public DelegatingCompiledRezolveTarget(Func<RezolveContext, object> getObjectDelegate) Parameters Name Type Description getObjectDelegate Func < RezolveContext , Object > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetObject(RezolveContext) Declaration public object GetObject(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description Object Implements Rezolver.ICompiledTarget.GetObject(Rezolver.RezolveContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetDelegateCompiler.html": {
    "href": "rezolver-api/Rezolver.TargetDelegateCompiler.html",
    "title": "Class TargetDelegateCompiler",
    "keywords": "Class TargetDelegateCompiler The default compiler for ITarget instances - takes the expression tree(s) produced by an ITarget and simply compiles it to an anonymous delegate. Inheritance Object TargetCompilerBase TargetDelegateCompiler Inherited Members TargetCompilerBase.CompileTarget(ITarget, CompileContext) TargetCompilerBase.GetLambdaBody(ITarget, CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetDelegateCompiler : TargetCompilerBase, ITargetCompiler <!-- <hr class=\"typeSectionDivider\" /> --> Fields Default Declaration public static readonly ITargetCompiler Default Field Value Type Description ITargetCompiler <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CompileTargetBase(ITarget, Expression, CompileContext) Declaration protected override ICompiledTarget CompileTargetBase(ITarget target, Expression toCompile, CompileContext context) Parameters Name Type Description target ITarget toCompile Expression context CompileContext Returns Type Description ICompiledTarget Overrides TargetCompilerBase.CompileTargetBase(ITarget, Expression, CompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetDictionaryContainer.html": {
    "href": "rezolver-api/Rezolver.TargetDictionaryContainer.html",
    "title": "Class TargetDictionaryContainer",
    "keywords": "Class TargetDictionaryContainer An ITargetContainerOwner implementation that stores and retrieves ITarget and ITargetContainer by type. Inheritance Object TargetDictionaryContainer Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetDictionaryContainer : ITargetContainerOwner, ITargetContainer Remarks This type is not thread-safe Note that for generic type, a special container is registered first against the open generic version of the type, with concrete (closed) generics being registered within that. <!-- <hr class=\"typeSectionDivider\" /> --> Methods CombineWith(ITargetContainer, Type) Always adds this container into the existing container as a child. Declaration public virtual ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer type Type Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) <!-- .classchild --> CreateContainer(Type, ITarget) Called by Register(ITarget, Type) to create and register the container instance most suited for the passed target. The base implementation always creates a TargetListContainer , capable of storing multiple targets against a single type. Declaration protected virtual ITargetContainer CreateContainer(Type serviceType, ITarget target) Parameters Name Type Description serviceType Type target ITarget The initial target for which the container is being created. Can be null. Note - the function is not expected to add this target to the new container. Returns Type Description ITargetContainer <!-- .classchild --> Fetch(Type) Implementation of Fetch(Type) . Declaration public virtual ITarget Fetch(Type type) Parameters Name Type Description type Type The type whose default target is to be retrieved. Returns Type Description ITarget A single target representing the last target registered against the type , or, null if no target is found. Implements ITargetContainer.Fetch(Type) Remarks Note - in scenarios where you are chaining multiple containers, then you should consult the return value's UseFallback property if the method returns non-null because, if true, then it's an instruction to use a parent container's result for the same type. <!-- .classchild --> FetchAll(Type) Implementation of FetchAll(Type) Declaration public virtual IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type Type The type whose targets are to be retrieved. Returns Type Description IEnumerable < ITarget > A non-null enumerable containing the targets that match the type, or an empty enumerable if the type is not registered. Implements ITargetContainer.FetchAll(Type) <!-- .classchild --> FetchContainer(Type) Obtains a child container that was previously registered by the passed type . Returns null if no entry is found. Declaration public virtual ITargetContainer FetchContainer(Type type) Parameters Name Type Description type Type Returns Type Description ITargetContainer Implements ITargetContainerOwner.FetchContainer(Type) <!-- .classchild --> Register(ITarget, Type) Implementation of Register(ITarget, Type) . Declaration public virtual void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget The target to be registered serviceType Type Implements ITargetContainer.Register(ITarget, Type) Remarks This implementation creates an ITargetContainer for the serviceType with a call to the protected method CreateContainer(Type, ITarget) if one doesn't exist (it calls FetchContainer(Type) to check for existence), and then chains to its Register(ITarget, Type) method. <!-- .classchild --> RegisterContainer(Type, ITargetContainer) Implementation of RegisterContainer(Type, ITargetContainer) Declaration public virtual void RegisterContainer(Type type, ITargetContainer container) Parameters Name Type Description type Type container ITargetContainer Implements ITargetContainerOwner.RegisterContainer(Type, ITargetContainer) Remarks This container implementation actually stores containers against the types that targets are registered against, rather than simply storing a dictionary of targets. This method allows you to add your own containers against type (instead of the default, which is TargetListContainer ) so you can plug in some advanced behaviour into this container. For example, decorators are not actually ITarget implementations but specialised ITargetContainer instances into which the 'standard' targets are registered. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetExpression.html": {
    "href": "rezolver-api/Rezolver.TargetExpression.html",
    "title": "Class TargetExpression",
    "keywords": "Class TargetExpression An expression which represents an ITarget that can be baked into any type of expression during code generation. Used by the TargetAdapter extensively. Inheritance Object TargetExpression Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetExpression : Expression <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TargetExpression(ITarget) Initializes a new instance of the TargetExpression class. Declaration public TargetExpression(ITarget target) Parameters Name Type Description target ITarget The target. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties CanReduce Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form. Declaration public override bool CanReduce { get; } Property Value Type Description Boolean true if this instance can reduce; otherwise, false . Remarks The implementation always returns true ; although the Reduce() methodd is not implemented. <!-- .classchild --> NodeType Gets the node type of this . Declaration public override ExpressionType NodeType { get; } Property Value Type Description ExpressionType Always returns . <!-- .classchild --> Target Gets the target whose expression (obtained from Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) ) will be subsituted for this TargetExpression in the final expression tree. Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> Type Gets the static type of the expression that this represents. Declaration public override Type Type { get; } Property Value Type Description Type Remarks Always returns the type referenced by the DeclaredType property of Target . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Reduce() Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced. Declaration public override Expression Reduce() Returns Type Description Expression Exceptions Type Condition NotSupportedException RezolveTargetExpression must be rewritten as a bona-fide expression before walking the expression tree for any other purpose <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetExpressionRewriter.html": {
    "href": "rezolver-api/Rezolver.TargetExpressionRewriter.html",
    "title": "Class TargetExpressionRewriter",
    "keywords": "Class TargetExpressionRewriter Used by TargetBase (and potentially your own targets) to convert TargetExpression instances which have been baked into expression trees (most likely by a TargetAdapter ) into expressions for a given CompileContext . Inheritance Object TargetExpressionRewriter Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetExpressionRewriter : ExpressionVisitor Remarks The TargetBase class always pushes expressions it receives from its Rezolver.TargetBase.CreateExpressionBase(Rezolver.CompileContext) abstract method through a rewrite - because if there are any non-standard expressions left, then compilation will not be possible. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TargetExpressionRewriter(CompileContext) Initializes a new instance of the TargetExpressionRewriter class for the given context Declaration public TargetExpressionRewriter(CompileContext context) Parameters Name Type Description context CompileContext The compilation context. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Visit(Expression) Dispatches the expression to one of the more specialized visit methods in this class. Declaration public override Expression Visit(Expression node) Parameters Name Type Description node Expression The expression to visit. Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetListContainer.html": {
    "href": "rezolver-api/Rezolver.TargetListContainer.html",
    "title": "Class TargetListContainer",
    "keywords": "Class TargetListContainer An ITargetContainer that stores multiple targets in a list. This is not a type that you would typically use directly in your code, unless you are writing custom logic/behaviour for ITarget registration. Inheritance Object TargetListContainer Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetListContainer : ITargetContainer Remarks This type is not thread-safe, nor does it perform any type checking on the targets that are added to it. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TargetListContainer(Type, ITarget[]) Declaration public TargetListContainer(Type registeredType, params ITarget[] targets) Parameters Name Type Description registeredType Type targets ITarget [] <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Count Declaration public int Count { get; } Property Value Type Description Int32 <!-- .classchild --> DefaultTarget Declaration public ITarget DefaultTarget { get; } Property Value Type Description ITarget <!-- .classchild --> Item[Int32] Declaration public ITarget this[int index] { get; } Parameters Name Type Description index Int32 Property Value Type Description ITarget <!-- .classchild --> RegisteredType Declaration public Type RegisteredType { get; } Property Value Type Description Type <!-- .classchild --> Targets Declaration public IEnumerable<ITarget> Targets { get; } Property Value Type Description IEnumerable < ITarget > <!-- .classchild --> TargetsList Provides deriving classes a means to manipulate the underlying list. Declaration protected List<ITarget> TargetsList { get; } Property Value Type Description List < ITarget > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CombineWith(ITargetContainer, Type) Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer type Type Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) <!-- .classchild --> Fetch(Type) Declaration public virtual ITarget Fetch(Type type) Parameters Name Type Description type Type Returns Type Description ITarget Implements ITargetContainer.Fetch(Type) <!-- .classchild --> FetchAll(Type) Declaration public virtual IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type Type Returns Type Description IEnumerable < ITarget > Implements ITargetContainer.FetchAll(Type) <!-- .classchild --> Register(ITarget, Type) Declaration public virtual void Register(ITarget target, Type registeredType = null) Parameters Name Type Description target ITarget registeredType Type Implements ITargetContainer.Register(ITarget, Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.html": {
    "href": "rezolver-api/Rezolver.html",
    "title": "Namespace Rezolver",
    "keywords": "Namespace Rezolver Classes AliasTargetContainerExtensions Contains extension methods for ITargetContainer to create targets which alias others by different types. CachingContainerBase Builds on the ContainerBase base class to introduce thread-safe caching of compiled targets so they are only compiled once per requested type. Only creatable through inheritance. ChangeTypeTarget This target is specifically used for explicitly casting the result of one target to another type. Its use is rare, since the framework already caters for downcasting the result of targets to base types. ChildTargetContainer A version of TargetContainer which overrides the registrations of another (the Parent ). ConstructorBinding Represents a binding specifically to a class constructor, optionally with an additional set of MemberBindings to be used to initialise a new instance's properties or fields directly. ConstructorTarget A target that binds to a type's constructor with zero or more arguments supplied by other ITarget s and, optionally binding to the new instance's writeable properties. The target supports en explicitly supplied constructor, as well as just-in-time lookups for the best available constructor based on the available services and/or any named arguments which might been provided up front. Container The standard IOC container class in Rezolver. ContainerBase Starting point for implementations of IContainer - only creatable through inheritance. ContainerBase.DirectResolveCompiledTarget Used when an ITarget is also of the same type as the one for which it is returned by the Fetch(Type) method of the Targets container. In this case, the target is not compiled, but instead is simply returned as the desired object. ContainerBase.MissingCompiledTarget Used as a sentinel type when a type cannot be resolved by a ContainerBase instance. Instead of returning a null ICompiledTarget instance, the container will construct an instance of this type (typically through GetMissingTarget(Type) , which caches singleton instances of this class on a per-type basis) which can then be used just as if the lookup succeeded. DecoratingTargetContainer Implements service decoration in an ITargetContainer , producing instances of the DecoratorTarget when Fetch(Type) or FetchAll(Type) are called. The best way to add a decorator to your target container is to use the extension method RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) or its non-generic equivalent. DecoratorTarget Represents the action of implementing a common DecoratedType by decorating one instance (produced by DecoratedTarget ) with another ( Target , which will create an instance of DecoratorType ). NOTE - You shouldn't register or otherwise create instances of this target unless you absolutely know what you're doing. Rather, decorators should be registered using the extension method RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) or its non-generic alternative because the target needs a DecoratingTargetContainer to work properly (the creation of which is automatically handled by these extension methods). DecoratorTargetContainerExtensions Extensions for ITargetContainerOwner which simplify the registration of decorators (via the DecoratingTargetContainer pseudo-target) DefaultMemberBindingBehaviour The default implementation of IMemberBindingBehaviour when you are creating a ConstructorTarget or GenericConstructorTarget and you want publicly writable properties and public fields to be assigned values obtained from the container. If you do not require properties or fields to be bound from the container, then use a null IMemberBindingBehaviour . DefaultTarget A target that simply creates a default instance of a given type. I.e. the same as doing default(type) in C#. DelegateTarget An ITarget which resolve objects by executing a delegate with argument injection. DelegateTarget <TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, T8, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTargetContainerExtensions Extension methods for ITargetContainer designed to simplify the registration of DelegateTarget and its numerous generic variants. DelegateTargetDelegateExtensions Extension methods for the Delegate type to aid in the construction of DelegateTarget . EnumerableTargetBuilderExtensions Houses an extension method which enables native resolving of IEnumerables of services on ITargetContainer containers which, in turn, enables it for any ContainerBase containers which use that target container. ExceptionResources A strongly-typed resource class, for looking up localized strings, etc. ExpressionCompilerTargetContainerExtensions ExpressionTarget A generic target for all expressions not explicitly supported by a particular target. Enables more complex behaviours to be registered and used with the more formal ITarget implementations. ExpressionTargetContainerExtensions Contains numerous generic overloads of the RegisterExpression extension method for ITargetContainer All of these extensions act as proxies for the RegisterExpression(ITargetContainer, Expression, Type) extension method. Functions This type is only used when using expressions as targets (via the ExpressionTarget type) - it's functions server no actual purpose other than to act as hooks to create specific ITarget objects in place of static code. For example, the Resolve<T>() function is used to trigger the creation of a RezolvedTarget in its place - thus allowing expressions to leverage the full power of the Rezolver API all through a simple method call. GenericConstructorTarget Equivalent of ConstructorTarget but for open generic types. So, this will handle the open generic MyType<,>, for example, whereas ConstructorTarget would handle the closed type MyType<int, string>. GenericTargetContainer A special type of ITargetContainerOwner which stores targets (and potentially other containers) which are specifically keyed either to a particular open generic type or a closed generic built from it. IContainerRezolveExtensions Extension methods for IContainer which provide shortcuts for the Resolve(ResolveContext) operation. IRezolveTargetScopingExtensions Extension method(s) to convert targets into scoped targets. IRezolveTargetSingletonExtensions Extension method(s) to convert targets into singleton targets. ListTarget This target produces arrays ( AsArray = true ) or lists ( AsArray = false ) whose individual items are built by ITarget instances. Primarily used by the Rezolver.EnumerableTargetContainer and the configuration framework, but can also be used by your code. MemberBinding Represents the binding of an ITarget to a property or field of a given type. Not to be confused with the type of the same name from the System.Linq.Expressions namespace, although they are technically equivalent. MethodBinding Represents a binding to a method whose arguments will be supplied by ITarget instances. MethodCallExtractor Used to help grab method and constructor info from expressions (which is easier than writing long strings of reflection code). For example: MethodCallExtractor.ExtractCalledMethod(() => Console.WriteLine(\"foo\")) Will return the MethodInfo for the WriteLine method of the Console class. MultipleTargetContainerExtensions Extensions for registering multiple targets individually and against the same type ObjectTarget Implements ITarget by wrapping a single instance that's already been constructed by application code. ObjectTargetContainerExtensions Extensions for ITargetContainer relating to registering concrete instances via the ObjectTarget target. ObjectTargetExtensions Extension method(s) to help create the ObjectTarget target. OptionalParameterTarget Used specifically when binding arguments to method parameters when a parameter is optional and its default value is to be used when binding to it. OverridingContainer An IContainer which can override the resolve operations of another. This is useful when you have a core application-wide container, with some objects being customised based on some ambient information, e.g. configuration, MVC Area/Controller, Brand (in a multi-tenant application for example) or more. The scoping version of this is called OverridingScopedContainer . OverridingScopedContainer Not sure if this is sticking around anyway. Think the scoping stuff needs a bit of a rethink. ParameterBinding Represents a binding between a method parameter and an ITarget RegisterTypeTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for the simplest cases of registering ConstructorTarget and GenericConstructorTarget targets. ResolveContext Captures the state for a call to Resolve(ResolveContext) , including the container on which the operation is invoked, any IScopedContainer that might be active for the call (if different), and the type which is being resolved from the IContainer . RezolvedTarget Represents a target that is rezolved statically at compile time via the ICompileContext , or dynamically (at 'resolve time') from the IContainer that is attached to the current ResolveContext when Resolve(ResolveContext) is called. This is the most common way that we bind constructor parameters, for example - i.e. 'I want an IService instance - go get it'. ScopedContainer Extends the Container to implement lifetime scoping. If you want your root container to act as a lifetime scope, then you should use this class instead of using Container ScopedContainerScopeExtensions Contains extension methods for the IScopedContainer interface which provide some additional shortucts for getting or adding objects from/to scopes. ScopedTarget A target that produces a single instance of an object within a lifetime scope. ScopedTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for registering constructor-injected types whose lifetimes are slaved to that of a parent IScopedContainer . All of the extension methods ultimately create a ScopedTarget SingletonTarget A target which applies the singleton pattern to any ITarget . The inner target is available from the InnerTarget property. SingletonTargetDictionaryExtensions Extension methods for the ITargetContainer interface which simplify the registration of singletons. TargetBase Abstract base class, suggested as a starting point for implementations of ITarget . TargetContainer Root container for ITarget s that can be used as the backing for the standard IContainer classes - Container and ScopedContainer . Stores and retrieves registrations of ITarget s, is also Generic type aware, unlike its base class - TargetDictionaryContainer . TargetDictionaryContainer An ITargetContainerOwner implementation that stores and retrieves ITarget and ITargetContainer by type. TargetListContainer An ITargetContainer that stores multiple targets in a list. This is not a type that you would typically use directly in your code, unless you are writing custom logic/behaviour for ITarget registration. Interfaces IChildTargetContainer An ITargetContainer that inherits all registrations from a ( Parent ) target container. If it cannot resolve a target for a particular type, will defer to its parent for fallback. ICompiledTarget Provides an abstraction for creating objects based on a given ResolveContext - this is the ultimate target of all Resolve(ResolveContext) calls in the standard container implementations within the Rezolver framework. IContainer The primary IOC container interface in the Rezolver framework. IMemberBindingBehaviour Describes a type which discovers and creates property/field bindings, typically for use when creating a new instance. IScopedContainer A container that's also a lifetime scope - that is, it's disposable, and will dispose of any disposable instances that it creates when it's disposed. Also, any subsequent lifetime scopes that it, or any child, creates will be disposed of when this scope is disposed. Note that while a lifetime scope can track objects of any types, it only automatically tracks disposable objects. To force a scope to track an instance, regardless of whether it's dispoable or not, you can call AddToScope(Object, ResolveContext) . This is how the default ScopedSingletonTarget works - if an object with this lifetime isn't a disposable, it is explicitly added to the scope passed to it at runtime, and then when an instance is subsequently requested, the code compiled by the scoped singleton will search the current scope, for an existing instance, before creating one. ITarget Represents an action to be performed in order to obtain an object to satisfy a call to Resolve(ResolveContext) , when the standard implementations of IContainer are used (e.g. Container ). ITargetContainer Stores and retrieves ITarget instances, keyed by the type of service that the targets are registered against. This is where all your service registrations will ultimately go. ITargetContainerOwner Interface for an ITargetContainer which also contains other target containers. It is not typically used by your application code since it's primarily an infrastructure interface - if you are extending the API, however, then you might need to work with it."
  },
  "rezolver-api/System.Collections.Generic.ReadOnlyEnumerableExtensions.html": {
    "href": "rezolver-api/System.Collections.Generic.ReadOnlyEnumerableExtensions.html",
    "title": "Class ReadOnlyEnumerableExtensions",
    "keywords": "Class ReadOnlyEnumerableExtensions Inheritance Object ReadOnlyEnumerableExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :System.Collections.Generic Assembly :cs.temp.dll.dll Syntax public static class ReadOnlyEnumerableExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods AsReadOnly<T>(IEnumerable<T>) Declaration public static IList<T> AsReadOnly<T>(this IEnumerable<T> range) Parameters Name Type Description range IEnumerable <T> Returns Type Description IList <T> Type Parameters Name Description T <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.ConfigurationEntryConverter.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.ConfigurationEntryConverter.html",
    "title": "Class ConfigurationEntryConverter",
    "keywords": "Class ConfigurationEntryConverter JSON converter for IConfigurationEntry The converter defaults to looking for type registrations; to enable it to look for a different entry type, you must instruct Json.Net to create an instance of it using the constructor that accepts a ConfigurationEntryType Inheritance Object ConfigurationEntryConverter Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class ConfigurationEntryConverter : JsonConverter <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConfigurationEntryConverter() Declaration public ConfigurationEntryConverter() <!-- .classchild --> ConfigurationEntryConverter(ConfigurationEntryType) Declaration public ConfigurationEntryConverter(ConfigurationEntryType expectedType) Parameters Name Type Description expectedType ConfigurationEntryType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties CanWrite Declaration public override bool CanWrite { get; } Property Value Type Description Boolean <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CanConvert(Type) Declaration public override bool CanConvert(Type objectType) Parameters Name Type Description objectType Type Returns Type Description Boolean <!-- .classchild --> ReadJson(JsonReader, Type, Object, JsonSerializer) Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Name Type Description reader JsonReader objectType Type existingValue Object serializer JsonSerializer Returns Type Description Object <!-- .classchild --> WriteJson(JsonWriter, Object, JsonSerializer) Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Name Type Description writer JsonWriter value Object serializer JsonSerializer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.JsonConfiguration.JsonConfigurationConverter.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.JsonConfiguration.JsonConfigurationConverter.html",
    "title": "Class JsonConfiguration.JsonConfigurationConverter",
    "keywords": "Class JsonConfiguration.JsonConfigurationConverter Class for loading JsonConfiguration from Json through Json.Net. Inheritance Object JsonConfiguration.JsonConfigurationConverter Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class JsonConfigurationConverter : JsonConverter <!-- <hr class=\"typeSectionDivider\" /> --> Properties CanWrite Gets a value indicating whether this Newtonsoft.Json.JsonConverter can write JSON. Declaration public override bool CanWrite { get; } Property Value Type Description Boolean true if this Newtonsoft.Json.JsonConverter can write JSON; otherwise, false . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CanConvert(Type) Determines whether this instance can convert the specified object type. Declaration public override bool CanConvert(Type objectType) Parameters Name Type Description objectType Type Type of the object. Returns Type Description Boolean true if this instance can convert the specified object type; otherwise, false . <!-- .classchild --> ReadJson(JsonReader, Type, Object, JsonSerializer) Reads the JSON representation of the object. Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Name Type Description reader JsonReader The Newtonsoft.Json.JsonReader to read from. objectType Type Type of the object. existingValue Object The existing value of object being read. serializer JsonSerializer The calling serializer. Returns Type Description Object The object value. <!-- .classchild --> WriteJson(JsonWriter, Object, JsonSerializer) Writes the JSON representation of the object. Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Name Type Description writer JsonWriter The Newtonsoft.Json.JsonWriter to write to. value Object The value. serializer JsonSerializer The calling serializer. Exceptions Type Condition NotImplementedException <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.JsonConfiguration.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.JsonConfiguration.html",
    "title": "Class JsonConfiguration",
    "keywords": "Class JsonConfiguration Class JsonConfiguration. Inheritance Object JsonConfiguration Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class JsonConfiguration : IConfiguration <!-- <hr class=\"typeSectionDivider\" /> --> Fields UnboundType The typename to use on a type entry when you want to register a constructor target directly for the type that is registered. E.g. { 'MyNamespace.Foo' : { 'type' : \"$auto' } } Which registers MyNamespace.Foo with a constructor target that binds to the same type. Is also used - where supported - to refer to a type from a parent object which you want to reference, but without having to specify the whole typename. Declaration public const string UnboundType = \"$auto\" Field Value Type Description String <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Entries Gets the entries. Declaration public IEnumerable<IConfigurationEntry> Entries { get; } Property Value Type Description IEnumerable < IConfigurationEntry > The entries. Implements IConfiguration.Entries <!-- .classchild --> FileName Gets the name of the file. Declaration public string FileName { get; } Property Value Type Description String The name of the file. Implements IConfiguration.FileName <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.JsonConfigurationException.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.JsonConfigurationException.html",
    "title": "Class JsonConfigurationException",
    "keywords": "Class JsonConfigurationException Thrown when a Json container configuration file is invalid. Inheritance Object Exception JsonConfigurationException Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.Data Exception.InnerException Exception.TargetSite Exception.StackTrace Exception.HelpLink Exception.Source Exception.HResult Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class JsonConfigurationException : Exception, ISerializable, _Exception <!-- <hr class=\"typeSectionDivider\" /> --> Constructors JsonConfigurationException(JsonToken, JsonReader) Constructs a new instance of the JsonConfigurationException class which reports that the token at the current location of the file was not expected. Declaration public JsonConfigurationException(JsonToken expectedTokenType, JsonReader reader) Parameters Name Type Description expectedTokenType JsonToken reader JsonReader <!-- .classchild --> JsonConfigurationException(String, JsonReader) Constructs a new instance of the JsonConfigurationException class. Note, if you supply a JsonReader, then the current line and column will be reported automatically at the end of the exception message. Declaration public JsonConfigurationException(string message, JsonReader reader) Parameters Name Type Description message String reader JsonReader <!-- .classchild --> JsonConfigurationException(String, JToken) Constructs a new instance of the JsonConfigurationException class. Note, if you supply a JObject, then the starting line and column of that object from the original source text will be reported automatically at the end of the exception message. Declaration public JsonConfigurationException(string message, JToken jToken) Parameters Name Type Description message String jToken JToken <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Message Declaration public override string Message { get; } Property Value Type Description String Overrides Exception.Message <!-- .classchild --> Reader If not null, then this is a reader whose position should be at the place where the error occurs. Declaration public JsonReader Reader { get; } Property Value Type Description JsonReader <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.JsonConfigurationParser.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.JsonConfigurationParser.html",
    "title": "Class JsonConfigurationParser",
    "keywords": "Class JsonConfigurationParser Inheritance Object JsonConfigurationParser Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class JsonConfigurationParser <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateJsonSerializerSettings() Declaration public virtual JsonSerializerSettings CreateJsonSerializerSettings() Returns Type Description JsonSerializerSettings <!-- .classchild --> CreateSerializer(JsonSerializerSettings) Declaration public virtual JsonSerializer CreateSerializer(JsonSerializerSettings settings) Parameters Name Type Description settings JsonSerializerSettings Returns Type Description JsonSerializer <!-- .classchild --> Parse(String) Declaration public IConfiguration Parse(string json) Parameters Name Type Description json String Returns Type Description IConfiguration <!-- .classchild --> Parse(String, JsonSerializer) Declaration public virtual IConfiguration Parse(string json, JsonSerializer jsonSerializer) Parameters Name Type Description json String jsonSerializer JsonSerializer Returns Type Description IConfiguration <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.LazyJsonObjectTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.LazyJsonObjectTargetMetadata.html",
    "title": "Class LazyJsonObjectTargetMetadata",
    "keywords": "Class LazyJsonObjectTargetMetadata Special version of IObjectTargetMetadata which creates an instance of the requested type from a JToken. Some more work might be required here to Inheritance Object RezolveTargetMetadataBase ObjectTargetMetadataBase LazyJsonObjectTargetMetadata Inherited Members ObjectTargetMetadataBase.CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) RezolveTargetMetadataBase.Type RezolveTargetMetadataBase.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) RezolveTargetMetadataBase.Bind(ITypeReference[]) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class LazyJsonObjectTargetMetadata : ObjectTargetMetadataBase, IObjectTargetMetadata, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides RezolveTargetMetadataBase.DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides RezolveTargetMetadataBase.BindBase(ITypeReference[]) <!-- .classchild --> GetObject(Type) Declaration public override object GetObject(Type type) Parameters Name Type Description type Type Returns Type Description Object Overrides ObjectTargetMetadataBase.GetObject(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.RezolveTargetMetadataConverter.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.RezolveTargetMetadataConverter.html",
    "title": "Class RezolveTargetMetadataConverter",
    "keywords": "Class RezolveTargetMetadataConverter This converter is registered against the type RezolveTargetMetadataWrapper Inheritance Object RezolveTargetMetadataConverter Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class RezolveTargetMetadataConverter : JsonConverter <!-- <hr class=\"typeSectionDivider\" /> --> Properties CanWrite Declaration public override bool CanWrite { get; } Property Value Type Description Boolean <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CanConvert(Type) Declaration public override bool CanConvert(Type objectType) Parameters Name Type Description objectType Type Returns Type Description Boolean <!-- .classchild --> ReadJson(JsonReader, Type, Object, JsonSerializer) Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Name Type Description reader JsonReader objectType Type existingValue Object serializer JsonSerializer Returns Type Description Object <!-- .classchild --> WriteJson(JsonWriter, Object, JsonSerializer) Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Name Type Description writer JsonWriter value Object serializer JsonSerializer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.RezolveTargetMetadataWrapper.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.RezolveTargetMetadataWrapper.html",
    "title": "Class RezolveTargetMetadataWrapper",
    "keywords": "Class RezolveTargetMetadataWrapper Metadata wrapper to accommodate the nature of how JSON configuration is deserialized. Of little practical use outside of the Json configuration library, unless you are creating your own metadata types which need the Unwrap semantics Inheritance Object RezolveTargetMetadataBase RezolveTargetMetadataWrapper Inherited Members RezolveTargetMetadataBase.Type RezolveTargetMetadataBase.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) RezolveTargetMetadataBase.Bind(ITypeReference[]) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax [Obsolete(\"no longer required\", true)] public class RezolveTargetMetadataWrapper : RezolveTargetMetadataBase, IRezolveTargetMetadataExtension, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RezolveTargetMetadataWrapper(IRezolveTargetMetadata) Declaration public RezolveTargetMetadataWrapper(IRezolveTargetMetadata wrapped) Parameters Name Type Description wrapped IRezolveTargetMetadata <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Fields ExtensionTypeName Declaration public const string ExtensionTypeName = \"#JSONWRAPPER#\" Field Value Type Description String <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides RezolveTargetMetadataBase.DeclaredType Implements IRezolveTargetMetadata.DeclaredType <!-- .classchild --> ExtensionType Declaration public string ExtensionType { get; } Property Value Type Description String Implements IRezolveTargetMetadataExtension.ExtensionType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides RezolveTargetMetadataBase.BindBase(ITypeReference[]) <!-- .classchild --> CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Implementation of CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) , except this implementation always throws a NotSupportedException , because it must be unwrapped (through a call to UnwrapMetadata(ITypeReference[]) ) before it can be used to create an ITarget . Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description ITarget Overrides RezolveTargetMetadataBase.CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild --> UnwrapConstructorMetadata(IRezolveTargetMetadata, ITypeReference[]) Unwraps an IConstructorTargetMetadata object by binding it to the forTargetTypes . Declaration protected virtual IRezolveTargetMetadata UnwrapConstructorMetadata(IRezolveTargetMetadata meta, ITypeReference[] forTargetTypes) Parameters Name Type Description meta IRezolveTargetMetadata forTargetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata <!-- .classchild --> UnwrapExtensionMetadata(IRezolveTargetMetadata, ITypeReference[]) Special case version of UnwrapMetadata(ITypeReference[]) for metadata with the type Extension . The base implementation supports instances of the RezolveTargetMetadataWrapper type only - and simply chain the call through to its UnwrapMetadata method. Declaration protected virtual IRezolveTargetMetadata UnwrapExtensionMetadata(IRezolveTargetMetadata meta, ITypeReference[] forTargetTypes) Parameters Name Type Description meta IRezolveTargetMetadata forTargetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata <!-- .classchild --> UnwrapListMetadata(IRezolveTargetMetadata, ITypeReference[]) Unwraps a list metadata (and any inner target metadata) for the target types. Declaration protected virtual IRezolveTargetMetadata UnwrapListMetadata(IRezolveTargetMetadata meta, ITypeReference[] forTargetTypes) Parameters Name Type Description meta IRezolveTargetMetadata forTargetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata <!-- .classchild --> UnwrapMetadata(ITypeReference[]) Unwraps the metadata contained within this wrapper for the passed target types in readiness to be pushed into an IConfigurationEntry. Note - if the metadata can't be unwrapped, then the method will simply return this instance. Declaration public virtual IRezolveTargetMetadata UnwrapMetadata(ITypeReference[] forTargetTypes) Parameters Name Type Description forTargetTypes ITypeReference [] Type references that the unwrapped metadata should support. Returns Type Description IRezolveTargetMetadata Remarks Unwrapping is the process whereby a type declared for registration is back-referenced using the '$auto' unbound type name in configuration for, say a constructor target or similar. <!-- .classchild --> UnwrapMetadataList(IRezolveTargetMetadata, ITypeReference[]) Unwraps a series of metadata objects stored in the list (passed in the meta parameter) for the target types, returning another metadata list containing the unwrapped metadata objects. Declaration protected IRezolveTargetMetadataList UnwrapMetadataList(IRezolveTargetMetadata meta, ITypeReference[] forTargetTypes) Parameters Name Type Description meta IRezolveTargetMetadata forTargetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadataList <!-- .classchild --> UnwrapMetadataList(IRezolveTargetMetadataList, ITypeReference[]) Strongly-typed virtual method for unwrapping metadata lists (invoked by UnwrapMetadataList(IRezolveTargetMetadata, ITypeReference[]) after confirming that the metadata passed to it is of the correct type. Declaration protected virtual IRezolveTargetMetadataList UnwrapMetadataList(IRezolveTargetMetadataList listMeta, ITypeReference[] forTargetTypes) Parameters Name Type Description listMeta IRezolveTargetMetadataList forTargetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadataList <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.TypeReferenceConverter.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.TypeReferenceConverter.html",
    "title": "Class TypeReferenceConverter",
    "keywords": "Class TypeReferenceConverter Responsible for converting Json to a Rezolver Configuration TypeReference Inheritance Object TypeReferenceConverter Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class TypeReferenceConverter : JsonConverter <!-- <hr class=\"typeSectionDivider\" /> --> Properties CanWrite Declaration public override bool CanWrite { get; } Property Value Type Description Boolean <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CanConvert(Type) Declaration public override bool CanConvert(Type objectType) Parameters Name Type Description objectType Type Returns Type Description Boolean <!-- .classchild --> ReadJson(JsonReader, Type, Object, JsonSerializer) Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Name Type Description reader JsonReader objectType Type existingValue Object serializer JsonSerializer Returns Type Description Object <!-- .classchild --> WriteJson(JsonWriter, Object, JsonSerializer) Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Name Type Description writer JsonWriter value Object serializer JsonSerializer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.html",
    "title": "Namespace Rezolver.Configuration.Json",
    "keywords": "Namespace Rezolver.Configuration.Json Classes AdvancedConfigurationAdapterContextFactory An advanced factory which automatically loads and references all assemblies that are deployed in the application's base directory and any subfolders determined by the AppDomain 's SetupInformation's PrivateBinBath. This is a singleton - accessed through the Instance property. ConfigurationEntryConverter JSON converter for IConfigurationEntry The converter defaults to looking for type registrations; to enable it to look for a different entry type, you must instruct Json.Net to create an instance of it using the constructor that accepts a ConfigurationEntryType JsonConfiguration Class JsonConfiguration. JsonConfiguration.JsonConfigurationConverter Class for loading JsonConfiguration from Json through Json.Net. JsonConfigurationException Thrown when a Json container configuration file is invalid. JsonConfigurationParser LazyJsonObjectTargetMetadata Special version of IObjectTargetMetadata which creates an instance of the requested type from a JToken. Some more work might be required here to RezolveTargetMetadataConverter This converter is registered against the type RezolveTargetMetadataWrapper RezolveTargetMetadataWrapper Metadata wrapper to accommodate the nature of how JSON configuration is deserialized. Of little practical use outside of the Json configuration library, unless you are creating your own metadata types which need the Unwrap semantics TypeReferenceConverter Responsible for converting Json to a Rezolver Configuration TypeReference"
  },
  "rezolver-api/Rezolver.Configuration.ListTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.ListTargetMetadata.html",
    "title": "Class ListTargetMetadata",
    "keywords": "Class ListTargetMetadata Standard implementation of the IListTargetMetadata interface. Inheritance Object RezolveTargetMetadataBase ListTargetMetadata Inherited Members RezolveTargetMetadataBase.Type RezolveTargetMetadataBase.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ListTargetMetadata : RezolveTargetMetadataBase, IListTargetMetadata, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ListTargetMetadata(ITypeReference, IRezolveTargetMetadataList, Boolean) Initializes a new instance of the ListTargetMetadata class. Declaration public ListTargetMetadata(ITypeReference elementType, IRezolveTargetMetadataList items, bool isArray) Parameters Name Type Description elementType ITypeReference Type of the elements of the eventual array/list. items IRezolveTargetMetadataList Metadata for the targets that will eventually create the items for the array or list. isArray Boolean if set to true then an array is to be built, otherwise a list is to be built. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides RezolveTargetMetadataBase.DeclaredType Implements IRezolveTargetMetadata.DeclaredType <!-- .classchild --> ElementType Gets the declared element type of the array or list that will be created from this metadata. Declaration public ITypeReference ElementType { get; } Property Value Type Description ITypeReference The type of the element. Implements IListTargetMetadata.ElementType Exceptions Type Condition NotImplementedException <!-- .classchild --> IsArray Maps to the AsArray property. If true, then an array of ElementType will be created, otherwise a List< ElementType > will be created by the ListTarget created from this metadata. Declaration public bool IsArray { get; } Property Value Type Description Boolean true if this instance represents a ListTarget that will create an array; otherwise, false . Implements IListTargetMetadata.IsArray <!-- .classchild --> Items Gets the metadata for the targets that will be used for the items that'll be returned in the Array or List that will be created by the ListTarget created from this metadata. Declaration public IRezolveTargetMetadataList Items { get; } Property Value Type Description IRezolveTargetMetadataList The elements. Implements IListTargetMetadata.Items <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Bind(ITypeReference[]) Declaration public override IRezolveTargetMetadata Bind(ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides RezolveTargetMetadataBase.Bind(ITypeReference[]) Implements IRezolveTargetMetadata.Bind(ITypeReference[]) <!-- .classchild --> BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides RezolveTargetMetadataBase.BindBase(ITypeReference[]) <!-- .classchild --> CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description ITarget Overrides RezolveTargetMetadataBase.CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ObjectTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.ObjectTargetMetadata.html",
    "title": "Class ObjectTargetMetadata",
    "keywords": "Class ObjectTargetMetadata Standard implementation of ObjectTargetMetadataBase , to encapsulate object references that are to be baked into a container as targets. Inheritance Object RezolveTargetMetadataBase ObjectTargetMetadataBase ObjectTargetMetadata Inherited Members ObjectTargetMetadataBase.CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) RezolveTargetMetadataBase.Type RezolveTargetMetadataBase.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) RezolveTargetMetadataBase.Bind(ITypeReference[]) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ObjectTargetMetadata : ObjectTargetMetadataBase, IObjectTargetMetadata, IRezolveTargetMetadata Remarks This class accepts either an object reference that is to be returned when the target is resolved; or a delegate that will be called with the desired type (passed in from GetObject(Type) ). <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ObjectTargetMetadata(Func<Type, Object>) Initializes a new instance of the ObjectTargetMetadata class. Declaration public ObjectTargetMetadata(Func<Type, object> valueProvider) Parameters Name Type Description valueProvider Func < Type , Object > The value provider that will be called. <!-- .classchild --> ObjectTargetMetadata(Object) Initializes a new instance of the ObjectTargetMetadata class. Declaration public ObjectTargetMetadata(object obj) Parameters Name Type Description obj Object The object that is to be returned from GetObject(Type) . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides RezolveTargetMetadataBase.DeclaredType Implements IRezolveTargetMetadata.DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides RezolveTargetMetadataBase.BindBase(ITypeReference[]) <!-- .classchild --> GetObject(Type) Called to get the object that will be registered in the IRezolveTargetContainer to be returned when a caller requests one of its registered types. The method can construct an object anew everytime it is called, or it can always return the same instance; this behaviour is implementation-dependant. Declaration public override object GetObject(Type type) Parameters Name Type Description type Type The type of object that is desired. The implementation determines whether this parameter is required. If it is, and you pass null, then an ArgumentNullException will be thrown. If you pass an argument, the implementation is not bound to check or honour the type. Its purpose is to provide a hint only, not a guarantee that the object returned is compatible with the type. Returns Type Description Object An object. Note - if the operation returns null this is not an error. Overrides ObjectTargetMetadataBase.GetObject(Type) Implements IObjectTargetMetadata.GetObject(Type) Exceptions Type Condition ArgumentNullException type <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ObjectTargetMetadataBase.html": {
    "href": "rezolver-api/Rezolver.Configuration.ObjectTargetMetadataBase.html",
    "title": "Class ObjectTargetMetadataBase",
    "keywords": "Class ObjectTargetMetadataBase Abstract base class for metadata that builds an object target. Inheritance Object RezolveTargetMetadataBase ObjectTargetMetadataBase Inherited Members RezolveTargetMetadataBase.Type RezolveTargetMetadataBase.DeclaredType RezolveTargetMetadataBase.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) RezolveTargetMetadataBase.Bind(ITypeReference[]) RezolveTargetMetadataBase.BindBase(ITypeReference[]) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public abstract class ObjectTargetMetadataBase : RezolveTargetMetadataBase, IObjectTargetMetadata, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ObjectTargetMetadataBase() Declaration public ObjectTargetMetadataBase() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description ITarget Overrides RezolveTargetMetadataBase.CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild --> GetObject(Type) Called to get the object that will be registered in the IRezolveTargetContainer to be returned when a caller requests one of its registered types. The method can construct an object anew everytime it is called, or it can always return the same instance; this behaviour is implementation-dependant. Declaration public abstract object GetObject(Type type) Parameters Name Type Description type Type The type of object that is desired. The implementation determines whether this parameter is required. If it is, and you pass null, then an ArgumentNullException will be thrown. If you pass an argument, the implementation is not bound to check or honour the type. Its purpose is to provide a hint only, not a guarantee that the object returned is compatible with the type. Returns Type Description Object An object. Note - if the operation returns null this is not an error. Implements IObjectTargetMetadata.GetObject(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RegisterInstruction.html": {
    "href": "rezolver-api/Rezolver.Configuration.RegisterInstruction.html",
    "title": "Class RegisterInstruction",
    "keywords": "Class RegisterInstruction The basic workhorse of a parsed configuration - an instruction to register a target in an IRezolveTargetContainer instance against one or more types with a given name. Inheritance Object RezolverBuilderInstruction RegisterInstruction Inherited Members RezolverBuilderInstruction.Entry Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class RegisterInstruction : RezolverBuilderInstruction <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RegisterInstruction(IEnumerable<Type>, ITarget, IConfigurationEntry) Constructs a new instance of the RegisterInstruction class. Declaration public RegisterInstruction(IEnumerable<Type> targetTypes, ITarget target, IConfigurationEntry entry) Parameters Name Type Description targetTypes IEnumerable < Type > The types that the target will be registered with target ITarget The target to be registered. entry IConfigurationEntry The original configuration entry from which this instruction was built. Exceptions Type Condition ArgumentNullException targetTypes or target ArgumentException List must contain one or more types;targetTypes or All types in list must be non-null;targetTypes <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Target The target that is to be registered. Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> TargetTypes The types that the target will be registered with Declaration public IEnumerable<Type> TargetTypes { get; } Property Value Type Description IEnumerable < Type > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Apply(ITargetContainer) The implementation will register the target for the given types. In the case of multiple types, the target is registered directly against that type, and aliases are registered for all the others. Declaration public override void Apply(ITargetContainer builder) Parameters Name Type Description builder ITargetContainer Overrides RezolverBuilderInstruction.Apply(ITargetContainer) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RegisterMultipleInstruction.html": {
    "href": "rezolver-api/Rezolver.Configuration.RegisterMultipleInstruction.html",
    "title": "Class RegisterMultipleInstruction",
    "keywords": "Class RegisterMultipleInstruction Similar to the RegisterInstruction except this specifically wraps the method. Construction is largely identical, except where in the aforementioned class you pass a single target, here you pass multiple targets in a list. Inheritance Object RezolverBuilderInstruction RegisterMultipleInstruction Inherited Members RezolverBuilderInstruction.Entry Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class RegisterMultipleInstruction : RezolverBuilderInstruction <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RegisterMultipleInstruction(IEnumerable<Type>, IEnumerable<ITarget>, IConfigurationEntry) Initializes a new instance of the RegisterMultipleInstruction class. Declaration public RegisterMultipleInstruction(IEnumerable<Type> targetTypes, IEnumerable<ITarget> targets, IConfigurationEntry entry) Parameters Name Type Description targetTypes IEnumerable < Type > The target types for the registration. targets IEnumerable < ITarget > The targets. Note that this is a list to support modification after the instruction is created; since this is a configuration API. entry IConfigurationEntry The source entry for this instruction - allows the system to track the instruction back to the configuration it was loaded from. Exceptions Type Condition ArgumentNullException targetTypes or targets ArgumentException List must contain one or more types;targetTypes or All types in list must be non-null;targetTypes or List must contain one or more targets;targets or All targets in list must be non-null;targets <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Targets Gets the targets that'll be used for the registration. Declaration public IEnumerable<ITarget> Targets { get; } Property Value Type Description IEnumerable < ITarget > The targets. <!-- .classchild --> TargetTypes The types that the target will be registered with Declaration public IEnumerable<Type> TargetTypes { get; } Property Value Type Description IEnumerable < Type > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Apply(ITargetContainer) Declaration public override void Apply(ITargetContainer builder) Parameters Name Type Description builder ITargetContainer Overrides RezolverBuilderInstruction.Apply(ITargetContainer) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RezolverBuilderInstruction.html": {
    "href": "rezolver-api/Rezolver.Configuration.RezolverBuilderInstruction.html",
    "title": "Class RezolverBuilderInstruction",
    "keywords": "Class RezolverBuilderInstruction An instruction to perform an operation on a container builder from an IConfigurationEntry that's been parsed from a configuration source (and which has been retrieved from an IConfiguration instance). Inheritance Object RezolverBuilderInstruction Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public abstract class RezolverBuilderInstruction <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RezolverBuilderInstruction(IConfigurationEntry) Inheritance constructor. Declaration protected RezolverBuilderInstruction(IConfigurationEntry entry) Parameters Name Type Description entry IConfigurationEntry The entry that built this instruction. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Entry The source configuration entry for this instruction. Declaration public IConfigurationEntry Entry { get; } Property Value Type Description IConfigurationEntry <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Apply(ITargetContainer) Abstract method which performs whatever instruction this instance represents on the passed builder. Declaration public abstract void Apply(ITargetContainer builder) Parameters Name Type Description builder ITargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataBase.html": {
    "href": "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataBase.html",
    "title": "Class RezolveTargetMetadataBase",
    "keywords": "Class RezolveTargetMetadataBase Suggested base class for implementations of IRezolveTargetMetadata . Inheritance Object RezolveTargetMetadataBase Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public abstract class RezolveTargetMetadataBase : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RezolveTargetMetadataBase(RezolveTargetMetadataType) Initializes a new instance of the RezolveTargetMetadataBase class. Declaration protected RezolveTargetMetadataBase(RezolveTargetMetadataType type) Parameters Name Type Description type RezolveTargetMetadataType The type of target. Exceptions Type Condition ArgumentException If type is RezolveTargetMetadataType.Extension this instance must implement IRezolveTargetMetadataExtension <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Gets the declared type of the object that will be created by an IRezolveTarget created by this metadata. Note - this isn't always known, or always fixed, since configuration systems will allow developers to avoid being specific about the types that are to be built. Declaration public abstract ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference The type of the declared. Implements IRezolveTargetMetadata.DeclaredType <!-- .classchild --> Type The type of rezolve target that is expected to be produced from this metadata Declaration public RezolveTargetMetadataType Type { get; } Property Value Type Description RezolveTargetMetadataType The type. Implements IRezolveTargetMetadata.Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Bind(ITypeReference[]) Declaration public virtual IRezolveTargetMetadata Bind(ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Implements IRezolveTargetMetadata.Bind(ITypeReference[]) <!-- .classchild --> BindBase(ITypeReference[]) Creates a new instance (clone) of this metadata that's bound to the target types (although, typically, you'll only ever pick the first target type that is in the array). Only ever called if DeclaredType is unbound Declaration protected abstract IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] The target types. Returns Type Description IRezolveTargetMetadata IRezolveTargetMetadata. <!-- .classchild --> CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Implementation of CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) - see that documentation for more detail about the intentions of this method. This implementation will check all the arguments (for nulls etc), including that all targetTypes have a common base; then it will invoke the abstract method CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) . Declaration public virtual ITarget CreateRezolveTarget(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry = null) Parameters Name Type Description targetTypes Type [] Required. One or more target types that the returned target is expected to be compatible with (i.e. able to build an instance of). Generally, this will be the target types for the configuration entry that is passed in entry . context ConfigurationAdapterContext The current context - provides access to the builder currently being constructed, as well as methods for resolving type names from ITypeReference instances or strings (and more). entry IConfigurationEntry If provided, this is a reference to the configuration entry (typically an ITypeRegistrationEntry ) against which this target will be registered. Please note - this doesn't mean that the target that is returned will become the target of the registration. It might be that the target is one that is used by a parent target that will become the target of the registration. Returns Type Description ITarget IRezolveTarget. Implements IRezolveTargetMetadata.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Exceptions Type Condition ArgumentNullException context or targetTypes ArgumentException Array must contain at least one target type;targetTypes or All items in the array must be non-null;targetTypes <!-- .classchild --> CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Called by CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) to create the rezolve target that will be registered into the ITargetContainer currently being built (available on the context ) If an error occurs, you indicate that by adding to the context 's errors collection, and return null. You can also throw an exception, which will be caught and added to the errors collection for you. Declaration protected abstract ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] The target types. context ConfigurationAdapterContext The context. entry IConfigurationEntry The entry. Returns Type Description ITarget IRezolveTarget. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataList.html": {
    "href": "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataList.html",
    "title": "Class RezolveTargetMetadataList",
    "keywords": "Class RezolveTargetMetadataList Inheritance Object RezolveTargetMetadataBase RezolveTargetMetadataList Inherited Members RezolveTargetMetadataBase.Type RezolveTargetMetadataBase.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class RezolveTargetMetadataList : RezolveTargetMetadataBase, IRezolveTargetMetadataList, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RezolveTargetMetadataList() Declaration public RezolveTargetMetadataList() <!-- .classchild --> RezolveTargetMetadataList(IEnumerable<IRezolveTargetMetadata>) Declaration public RezolveTargetMetadataList(IEnumerable<IRezolveTargetMetadata> range) Parameters Name Type Description range IEnumerable < IRezolveTargetMetadata > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides RezolveTargetMetadataBase.DeclaredType Implements IRezolveTargetMetadata.DeclaredType <!-- .classchild --> Targets Declaration public IList<IRezolveTargetMetadata> Targets { get; } Property Value Type Description IList < IRezolveTargetMetadata > Implements IRezolveTargetMetadataList.Targets <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Bind(ITypeReference[]) Declaration public override IRezolveTargetMetadata Bind(ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides RezolveTargetMetadataBase.Bind(ITypeReference[]) Implements IRezolveTargetMetadata.Bind(ITypeReference[]) <!-- .classchild --> BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides RezolveTargetMetadataBase.BindBase(ITypeReference[]) <!-- .classchild --> CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description ITarget Overrides RezolveTargetMetadataBase.CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild --> CreateRezolveTargets(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration public IEnumerable<ITarget> CreateRezolveTargets(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description IEnumerable < ITarget > Implements IRezolveTargetMetadataList.CreateRezolveTargets(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataType.html": {
    "href": "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataType.html",
    "title": "Enum RezolveTargetMetadataType",
    "keywords": "Enum RezolveTargetMetadataType Types of IRezolveTargetMetadata that can be expressed in configuration Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public enum RezolveTargetMetadataType <!-- <hr class=\"typeSectionDivider\" /> --> Fields Constructor Binding to a constructor of a type to create new instances of that type when the object is resolved Declaration Constructor = 2 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> Extension A custom metadata - the instance should also have the interface IRezolveTargetMetadataExtension Declaration Extension = 2147483647 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> List A list or array whose items are individually specified as resolve targets and eventually loaded into a ListTarget. This enables configuration files to hand-crank a list directly and when multiple registration is not applicable. Declaration List = 4 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> MetadataList Describes a list of IRezolveTargetMetadata instances - to be used for metadata objects that require multiple metadata objects. Can be created to feed a multiple instance registration for a single type (e.g. registering multiple instances of IFoo to a container, so that you can resolve all of them by resolving IEnumerable<IFoo>), or simply as a collection of targets that are to be used to build an array that is to be passed as a constructor argument or property. Declaration MetadataList = 5 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> Object A physical instance to be returned when a resolve operation is performed Declaration Object = 1 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> Singleton A singleton - only one object will ever be created from the target that this metadata builds. A singleton might also be scoped - i.e. that the lifetime is limited to the lifetime of an external scope. Declaration Singleton = 3 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> Unknown Declaration Unknown = 0 Field Value Type Description RezolveTargetMetadataType <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RuntimeTypeReference.html": {
    "href": "rezolver-api/Rezolver.Configuration.RuntimeTypeReference.html",
    "title": "Class RuntimeTypeReference",
    "keywords": "Class RuntimeTypeReference An ITypeReference that has been built directly from a runtime type. Inheritance Object RuntimeTypeReference Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public sealed class RuntimeTypeReference : ITypeReference, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RuntimeTypeReference(Type) Declaration public RuntimeTypeReference(Type runtimeType) Parameters Name Type Description runtimeType Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties EndLineNo Declaration public int ? EndLineNo { get; } Property Value Type Description Nullable < Int32 > Implements IConfigurationLineInfo.EndLineNo <!-- .classchild --> EndLinePos Declaration public int ? EndLinePos { get; } Property Value Type Description Nullable < Int32 > Implements IConfigurationLineInfo.EndLinePos <!-- .classchild --> GenericArguments Declaration public ITypeReference[] GenericArguments { get; } Property Value Type Description ITypeReference [] Implements ITypeReference.GenericArguments <!-- .classchild --> IsArray Declaration public bool IsArray { get; } Property Value Type Description Boolean Implements ITypeReference.IsArray <!-- .classchild --> IsOpenGenericTypeArgument Declaration public bool IsOpenGenericTypeArgument { get; } Property Value Type Description Boolean Implements ITypeReference.IsOpenGenericTypeArgument <!-- .classchild --> IsUnbound Declaration public bool IsUnbound { get; } Property Value Type Description Boolean Implements ITypeReference.IsUnbound <!-- .classchild --> RuntimeType Declaration public Type RuntimeType { get; } Property Value Type Description Type <!-- .classchild --> StartLineNo Declaration public int ? StartLineNo { get; } Property Value Type Description Nullable < Int32 > Implements IConfigurationLineInfo.StartLineNo <!-- .classchild --> StartLinePos Declaration public int ? StartLinePos { get; } Property Value Type Description Nullable < Int32 > Implements IConfigurationLineInfo.StartLinePos <!-- .classchild --> TypeName Declaration public string TypeName { get; } Property Value Type Description String Implements ITypeReference.TypeName <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.SingletonTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.SingletonTargetMetadata.html",
    "title": "Class SingletonTargetMetadata",
    "keywords": "Class SingletonTargetMetadata Inheritance Object RezolveTargetMetadataBase SingletonTargetMetadata Inherited Members RezolveTargetMetadataBase.Type RezolveTargetMetadataBase.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) RezolveTargetMetadataBase.Bind(ITypeReference[]) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class SingletonTargetMetadata : RezolveTargetMetadataBase, ISingletonTargetMetadata, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors SingletonTargetMetadata(IRezolveTargetMetadata, Boolean) Initializes a new instance of the SingletonTargetMetadata class. Declaration public SingletonTargetMetadata(IRezolveTargetMetadata inner, bool scoped = false) Parameters Name Type Description inner IRezolveTargetMetadata The inner target that will be turned into a singleton. scoped Boolean if set to true [scoped]. Exceptions Type Condition ArgumentNullException inner <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Gets the declared type of the object that will be created by an IRezolveTarget created by this metadata. Note - this isn't always known, or always fixed, since configuration systems will allow developers to avoid being specific about the types that are to be built. Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference The type of the declared. Overrides RezolveTargetMetadataBase.DeclaredType Implements IRezolveTargetMetadata.DeclaredType <!-- .classchild --> Inner Metadata for the inner target that is turned into a scoped singleton Declaration public IRezolveTargetMetadata Inner { get; } Property Value Type Description IRezolveTargetMetadata Implements ISingletonTargetMetadata.Inner <!-- .classchild --> Scoped If true, then the singleton object should be scope-compatible, i.e. with a lifetime limited to the lifetime of an external scope rather than to the AppDomain's lifetime. Declaration public bool Scoped { get; } Property Value Type Description Boolean Implements ISingletonTargetMetadata.Scoped <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods BindBase(ITypeReference[]) Creates a new instance (clone) of this metadata that's bound to the target types (although, typically, you'll only ever pick the first target type that is in the array). Only ever called if DeclaredType is unbound Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] The target types. Returns Type Description IRezolveTargetMetadata IRezolveTargetMetadata. Overrides RezolveTargetMetadataBase.BindBase(ITypeReference[]) <!-- .classchild --> CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Implementation of the abstract method from the base class of the same name. If Scoped is true, then this creates a new ScopedTarget ; if false, it creates a new SingletonTarget Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] The target types. context ConfigurationAdapterContext The context. entry IConfigurationEntry The entry. Returns Type Description ITarget Overrides RezolveTargetMetadataBase.CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.TypeReference.html": {
    "href": "rezolver-api/Rezolver.Configuration.TypeReference.html",
    "title": "Class TypeReference",
    "keywords": "Class TypeReference Concrete implementation of the TypeReferenceBase abstract class, and the default implementation of ITypeReference to use when parsing configuration. Inheritance Object TypeReferenceBase TypeReference Inherited Members TypeReferenceBase.StartLineNo TypeReferenceBase.StartLinePos TypeReferenceBase.EndLineNo TypeReferenceBase.EndLinePos TypeReferenceBase.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class TypeReference : TypeReferenceBase, ITypeReference, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TypeReference(String, IConfigurationLineInfo, ITypeReference[]) Initializes a new instance of the TypeReference class. Declaration public TypeReference(string typeName, IConfigurationLineInfo lineInfo, params ITypeReference[] genericArguments) Parameters Name Type Description typeName String Name of the type. lineInfo IConfigurationLineInfo Optional. genericArguments ITypeReference [] The generic arguments. <!-- .classchild --> TypeReference(String, IConfigurationLineInfo, Boolean, ITypeReference[]) Declaration public TypeReference(string typeName, IConfigurationLineInfo lineInfo, bool isArray, params ITypeReference[] genericArguments) Parameters Name Type Description typeName String lineInfo IConfigurationLineInfo isArray Boolean genericArguments ITypeReference [] <!-- .classchild --> TypeReference(String, IConfigurationLineInfo, Boolean, Boolean, ITypeReference[]) Initializes a new instance of the TypeReference class, allowing you to create an explicitly 'unbound' type, which is expected to be replaced by whichever type is required by another component, later. Declaration public TypeReference(string typeName, IConfigurationLineInfo lineInfo, bool isArray, bool isUnbound, params ITypeReference[] genericArguments) Parameters Name Type Description typeName String Name of the type. lineInfo IConfigurationLineInfo The line information. isArray Boolean if set to true [is array]. isUnbound Boolean if set to true [is unbound]. genericArguments ITypeReference [] The generic arguments. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Fields NoGenericArguments Declaration public static readonly ITypeReference[] NoGenericArguments Field Value Type Description ITypeReference [] <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties GenericArguments Declaration public override ITypeReference[] GenericArguments { get; } Property Value Type Description ITypeReference [] Overrides TypeReferenceBase.GenericArguments <!-- .classchild --> IsArray Declaration public override bool IsArray { get; } Property Value Type Description Boolean Overrides TypeReferenceBase.IsArray <!-- .classchild --> IsOpenGenericTypeArgument Gets a value indicating whether this instance represents an open generic type argument (e.g. the 'T' from List<T>). Declaration public override bool IsOpenGenericTypeArgument { get; } Property Value Type Description Boolean true if this instance is an open generic type argument; otherwise, false . Overrides TypeReferenceBase.IsOpenGenericTypeArgument <!-- .classchild --> IsUnbound Gets a value indicating whether this instance represents the Unbound special type reference. Declaration public override bool IsUnbound { get; } Property Value Type Description Boolean true if this instance is unbound; otherwise, false . Overrides TypeReferenceBase.IsUnbound <!-- .classchild --> OpenGenericTypeArgument The one-and-only open generic argument instance. The only way to fetch a non-derived TypeReference that returns true for IsOpenGenericTypeArgument is to use the reference from this field. Declaration public static ITypeReference OpenGenericTypeArgument { get; } Property Value Type Description ITypeReference The open generic type argument. <!-- .classchild --> TypeName Gets the name of the type. Declaration public override string TypeName { get; } Property Value Type Description String The name of the type. Overrides TypeReferenceBase.TypeName <!-- .classchild --> Unbound A static Unbound TypeReference that can be used in cases where a simple instance of an unbound type is required. You can also, of course, create explicitly unbound type references using the greediest constructor on this type. Declaration public static ITypeReference Unbound { get; } Property Value Type Description ITypeReference The unbound. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.TypeReferenceBase.html": {
    "href": "rezolver-api/Rezolver.Configuration.TypeReferenceBase.html",
    "title": "Class TypeReferenceBase",
    "keywords": "Class TypeReferenceBase abstract base class to serve as a starting point for implementing the ITypeReference interface. Inheritance Object TypeReferenceBase Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public abstract class TypeReferenceBase : ITypeReference, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TypeReferenceBase() Initializes a new instance of the TypeReferenceBase class. Declaration protected TypeReferenceBase() <!-- .classchild --> TypeReferenceBase(IConfigurationLineInfo) Initializes a new instance of the TypeReferenceBase class, copying the passed line information into this object, if provided. Declaration protected TypeReferenceBase(IConfigurationLineInfo lineInfo) Parameters Name Type Description lineInfo IConfigurationLineInfo Optional. The line information. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties EndLineNo Gets the line number within the configuration source that sees the end of the text from which this object was parsed. Used in conjunction with EndLinePos , it allows you to zero-in on the exact ending of this parsed object. Declaration public int ? EndLineNo { get; } Property Value Type Description Nullable < Int32 > The end line number. Implements IConfigurationLineInfo.EndLineNo <!-- .classchild --> EndLinePos Gets the position from the start of the line, indicated by EndLineNo , where the configuration text ends for this parsed object. Declaration public int ? EndLinePos { get; } Property Value Type Description Nullable < Int32 > The end line position. Implements IConfigurationLineInfo.EndLinePos <!-- .classchild --> GenericArguments Any explicitly provided generic arguments are stored here. Note that it might turn out that the TypeName refers to a whole closed generic type, in which case the referenced type could still be generic even if this array is empty. It's also the case that arguments could be passed here when the root type name resolves to a non-generic type definition, in which case type resolution will likely fail. Declaration public abstract ITypeReference[] GenericArguments { get; } Property Value Type Description ITypeReference [] The generic arguments. Implements ITypeReference.GenericArguments <!-- .classchild --> IsArray Gets a value indicating whether the type ultimately represented by this instance is an array of the type described by the rest of this instance's properties. Declaration public abstract bool IsArray { get; } Property Value Type Description Boolean true if this instance represents an array type; otherwise, false . Implements ITypeReference.IsArray <!-- .classchild --> IsOpenGenericTypeArgument True if this type represents an open generic argument - this is how to explicitly reference an open generic type in a type reference: you specify a base type, then have one or more open generic arguments specified in the GenericArguments array. If all are open generic arguments, then you have created a reference to the fully open generic type. You only need to provide all-open arguments if the base TypeName could be ambiguous between a non generic and generic type, or there are multiple generic types with the same base name. Equally, you can do this to create references to partially open generics, which may or may not be supported by the adapter or the target that is built. Declaration public abstract bool IsOpenGenericTypeArgument { get; } Property Value Type Description Boolean true if this instance is open generic type argument; otherwise, false . Implements ITypeReference.IsOpenGenericTypeArgument <!-- .classchild --> IsUnbound Gets a value indicating whether this instance represents a type that is to be late-bound for a specific target type. Declaration public abstract bool IsUnbound { get; } Property Value Type Description Boolean true if this instance is unbound; otherwise, false . Implements ITypeReference.IsUnbound <!-- .classchild --> StartLineNo Gets the line number within the configuration source that contains the start of the text from which this object was parsed. Used in conjunction with StartLinePos , it allows you to zero-in on the exact starting point of this parsed object. Declaration public int ? StartLineNo { get; } Property Value Type Description Nullable < Int32 > The start line number. Implements IConfigurationLineInfo.StartLineNo <!-- .classchild --> StartLinePos Gets the position from the start of the line, indicated by StartLineNo , where the configuration text begins for this parsed object. Declaration public int ? StartLinePos { get; } Property Value Type Description Nullable < Int32 > The start line position. Implements IConfigurationLineInfo.StartLinePos <!-- .classchild --> TypeName The root type name. Declaration public abstract string TypeName { get; } Property Value Type Description String The name of the type. Implements ITypeReference.TypeName <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods ToString() Produces a string representation of the type name, including generic arguments. Please note - this is not intended to produce a type name that can be fed to System.Type.GetType, even if occasionally it does. Declaration public override string ToString() Returns Type Description String Overrides Object.ToString() <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.TypeRegistrationEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.TypeRegistrationEntry.html",
    "title": "Class TypeRegistrationEntry",
    "keywords": "Class TypeRegistrationEntry Inheritance Object ConfigurationEntryBase TypeRegistrationEntry Inherited Members ConfigurationEntryBase.Type ConfigurationEntryBase.StartLineNo ConfigurationEntryBase.StartLinePos ConfigurationEntryBase.EndLineNo ConfigurationEntryBase.EndLinePos Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class TypeRegistrationEntry : ConfigurationEntryBase, ITypeRegistrationEntry, IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TypeRegistrationEntry(ITypeReference[], IRezolveTargetMetadata, Boolean, IConfigurationLineInfo) Declaration public TypeRegistrationEntry(ITypeReference[] types, IRezolveTargetMetadata targetMetadata, bool isMultipleRegistration, IConfigurationLineInfo lineInfo = null) Parameters Name Type Description types ITypeReference [] targetMetadata IRezolveTargetMetadata isMultipleRegistration Boolean lineInfo IConfigurationLineInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties IsMultipleRegistration Declaration public bool IsMultipleRegistration { get; } Property Value Type Description Boolean Implements ITypeRegistrationEntry.IsMultipleRegistration <!-- .classchild --> TargetMetadata Declaration public IRezolveTargetMetadata TargetMetadata { get; } Property Value Type Description IRezolveTargetMetadata Implements ITypeRegistrationEntry.TargetMetadata <!-- .classchild --> Types Declaration public ITypeReference[] Types { get; } Property Value Type Description ITypeReference [] Implements ITypeRegistrationEntry.Types <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.html": {
    "href": "rezolver-api/Rezolver.Configuration.html",
    "title": "Namespace Rezolver.Configuration",
    "keywords": "Namespace Rezolver.Configuration Classes AssemblyReferenceEntry ConfigurationAdapter Standard implementation of the IConfigurationAdapter interface. ConfigurationAdapter.ConfigurationEntryProcessOrderer Used by the ConfigurationAdapter class to sort configuration entries for processing. It ensures that Assembly Reference entries are given priority, followed by Namespace Imports, and then finally all the rest. ConfigurationAdapterContext This class is used to store the intermediate state for the default IConfigurationAdapter implementation's ( ConfigurationAdapter ) parsing operation on an IConfiguration instance. If you are extending the default adapter you might need also to extend this class to ensure any additional state you require is maintained. ConfigurationAdapterContext.UnresolvedType Used as a sentinel type by the ResolveType(String, Nullable<Int32>) method when the type search fails. ConfigurationAdapterContextFactory The standard Singleton implementation of the IConfigurationAdapterContextFactory interface, and one which you can use as the starting point of your own factory. By default, it creates a new instance of the ConfigurationAdapterContext class (using the virtual method CreateContext(ConfigurationAdapter, IConfiguration) , and then instructs it to add its default assembly references. ConfigurationEntryBase suggested starting point for implementing your own configuration entries. ConfigurationError ConfigurationException ConstructorTargetMetadata ListTargetMetadata Standard implementation of the IListTargetMetadata interface. ObjectTargetMetadata Standard implementation of ObjectTargetMetadataBase , to encapsulate object references that are to be baked into a container as targets. ObjectTargetMetadataBase Abstract base class for metadata that builds an object target. RegisterInstruction The basic workhorse of a parsed configuration - an instruction to register a target in an IRezolveTargetContainer instance against one or more types with a given name. RegisterMultipleInstruction Similar to the RegisterInstruction except this specifically wraps the method. Construction is largely identical, except where in the aforementioned class you pass a single target, here you pass multiple targets in a list. RezolverBuilderInstruction An instruction to perform an operation on a container builder from an IConfigurationEntry that's been parsed from a configuration source (and which has been retrieved from an IConfiguration instance). RezolveTargetMetadataBase Suggested base class for implementations of IRezolveTargetMetadata . RezolveTargetMetadataList RuntimeTypeReference An ITypeReference that has been built directly from a runtime type. SingletonTargetMetadata TypeReference Concrete implementation of the TypeReferenceBase abstract class, and the default implementation of ITypeReference to use when parsing configuration. TypeReferenceBase abstract base class to serve as a starting point for implementing the ITypeReference interface. TypeRegistrationEntry Interfaces IAssemblyReferenceEntry A configuration entry instructing the configuration adapter to load an assembly before resolving types. IConfiguration IConfigurationAdapter Represents an object that is responsible for transforming configuration data into target containers. IConfigurationAdapterContextFactory Used by this library's default implementation of IConfigurationAdapter, the ConfigurationAdapter class, to create an instance of the ConfigurationAdapterContext class for a given adapter that's processing a given configuration. IConfigurationEntry IConfigurationError Interface for an error that originates from a configuration file. IConfigurationExtensionEntry IConfigurationLineInfo Encapsulates information about where a particular object, parsed from a configuration file, can be found. IConstructorTargetMetadata IListTargetMetadata Configuration metadata for building a ListTarget in a RezolverBuilder. IObjectTargetMetadata Interface for metadata for constructing an ObjectTarget IRezolveTarget. IRezolveTargetMetadata Represents an instruction to create an IRezolveTarget from parsed configuration. IRezolveTargetMetadataExtension IRezolveTargetMetadataList Represents a list of IRezolveTargetMetadata instances - for when you want to register multiple targets against a single type. Note - although the interface IRezolveTargetMetadata is included by this interface, instances are not expected to be able to create a single target through the CreateRezolveTarget method - because by definition, multiple targets are produced by this. Use the CreateRezolveTargets method instead. The Bind method, however, will be expected to produce a new instance of the implementing type if any underlying targets are not bound to a specific type. ISingletonTargetMetadata Interface for Singleton metadata. ITypeReference Captures a reference to a type made in a configuration file. It does not guarantee that the type can be located, it simply provides a common interface for storing the type information written in a configuration file. An IConfigurationAdapter instance will need to resolve the actual runtime type from this when registering targets from a configuration file. ITypeRegistrationEntry Represents an instruction to register one or more targets in an ITargetContainer against one or more types. Think of it as wrapping a single call to one of the builder's Register methods. Enums ConfigurationEntryType Types of configuration entry that can be parsed from a configuration file RezolveTargetMetadataType Types of IRezolveTargetMetadata that can be expressed in configuration"
  },
  "rezolver-api/Rezolver.ConstructorBinding.html": {
    "href": "rezolver-api/Rezolver.ConstructorBinding.html",
    "title": "Class ConstructorBinding",
    "keywords": "Class ConstructorBinding Represents a binding specifically to a class constructor, optionally with an additional set of MemberBindings to be used to initialise a new instance's properties or fields directly. Inheritance Object MethodBinding ConstructorBinding Inherited Members MethodBinding.Method MethodBinding.BoundArguments Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ConstructorBinding : MethodBinding <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConstructorBinding(ConstructorInfo, ParameterBinding[], MemberBinding[]) Initializes a new instance of the ConstructorBinding class. Declaration public ConstructorBinding(ConstructorInfo constructor, ParameterBinding[] boundArgs = null, MemberBinding[] memberBindings = null) Parameters Name Type Description constructor ConstructorInfo The constructor to be used . boundArgs ParameterBinding [] Optional. The bound arguments. Can be null or empty. memberBindings MemberBinding [] Optional. The bindings for the members of the new instance created by the constructor. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Constructor Gets the constructor to be invoked. Note that this simply returns the base Method property cast to . Declaration public ConstructorInfo Constructor { get; } Property Value Type Description ConstructorInfo The constructor. <!-- .classchild --> MemberBindings Gets the member bindings to be applied to the new instance created by the Constructor Declaration public MemberBinding[] MemberBindings { get; } Property Value Type Description MemberBinding [] The member bindings. Remarks Member bindings represent the inline initialisation of writable properties or fields immediately after constructing a new instance of a type. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ConstructorTarget.html": {
    "href": "rezolver-api/Rezolver.ConstructorTarget.html",
    "title": "Class ConstructorTarget",
    "keywords": "Class ConstructorTarget A target that binds to a type's constructor with zero or more arguments supplied by other ITarget s and, optionally binding to the new instance's writeable properties. The target supports en explicitly supplied constructor, as well as just-in-time lookups for the best available constructor based on the available services and/or any named arguments which might been provided up front. Inheritance Object TargetBase ConstructorTarget Inherited Members TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ConstructorTarget : TargetBase, ITarget Remarks Although you can create this target directly through the Rezolver.ConstructorTarget.#ctor(System.Type,ConstructorInfo,Rezolver.IMemberBindingBehaviour,Rezolver.ParameterBinding[],System.Collections.Generic.IDictionary{System.String,Rezolver.ITarget}) constructor, you're more likely to create it through factory methods such as Auto<T>(IMemberBindingBehaviour) or, more likely still, extension methods such as RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) during your application's container setup phase. To compile this target, an ITargetCompiler must call the Bind(ICompileContext) method <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConstructorTarget(ConstructorInfo, IMemberBindingBehaviour, ParameterBinding[]) Initializes a new instance of the ConstructorTarget class bound in advance to a specific constructor. Declaration public ConstructorTarget(ConstructorInfo ctor, IMemberBindingBehaviour memberBindingBehaviour = null, ParameterBinding[] parameterBindings = null) Parameters Name Type Description ctor ConstructorInfo Required - the constructor that is to be bound. The DeclaredType of the new instance will be set to the of this object. memberBindingBehaviour IMemberBindingBehaviour Optional. If provided, can be used to select properties which are to be initialised before the new instance is returned. parameterBindings ParameterBinding [] Optional. Specific bindings for the parameters of the given ctor which should be used during code generation. Note that this array can contain fewer or more entries than there are parameters on the ctor . Any missing bindings will be automatically generated when Bind(ICompileContext) is called. <!-- .classchild --> ConstructorTarget(Type, IMemberBindingBehaviour, IDictionary<String, ITarget>) Initializes a just-in-time-bound instance of the ConstructorTarget class which must be bound to the best constructor at compile-time by calling the Bind(ICompileContext) method. Declaration public ConstructorTarget(Type type, IMemberBindingBehaviour memberBindingBehaviour = null, IDictionary<string, ITarget> namedArgs = null) Parameters Name Type Description type Type Required. The type whose constructor is to bound. memberBindingBehaviour IMemberBindingBehaviour Optional. If provided, can be used to select properties which are to be initialised before the new instance is returned. namedArgs IDictionary < String , ITarget > Optional. The named arguments which will be passed to, and used to find, the best-matched constructor. These are taken into account when the constructor is sought - with the constructor containing the most matched parameters matched being selected. Remarks To compile this target, a ITargetCompiler first calls the Bind(ICompileContext) method to discover the constructor to be executed, along with the final set of arguments to be provided to it (see ConstructorBinding ). The best available constructor is defined as the constructor with the most parameters for which arguments can be resolved from the ICompileContext at compile-time to the fewest number of ITarget objects whose UseFallback is false. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Ctor Can be null. Gets the constructor that this target is bound to, if it was known when the target was created. Declaration public ConstructorInfo Ctor { get; } Property Value Type Description ConstructorInfo Remarks ConstructorTargets can be bound to a particular constructor in advance, or they can search for a best-match constructor at the point where Bind(ICompileContext) is called. This property will only be set ultimately if it was passed to the ConstructorTarget(ConstructorInfo, IMemberBindingBehaviour, ParameterBinding[]) constructor, possibly by a factory method like WithArgs(ConstructorInfo, IDictionary<String, ITarget>) , or FromNewExpression(Type, NewExpression) , where the constructor is captured within the expression. <!-- .classchild --> DeclaredType Implementation of DeclaredType . Always equal to the type whose constructor will be bound by this target. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> MemberBindingBehaviour Gets the member binding behaviour to be used when Bind(ICompileContext) is called. Declaration public IMemberBindingBehaviour MemberBindingBehaviour { get; } Property Value Type Description IMemberBindingBehaviour <!-- .classchild --> NamedArgs Named arguments (as ITarget objects) to be supplied to the object on construction, also aiding the search for a constructor. This equivalent to the way that languages such as C# can bind to overloaded functions based solely on named arguments. Declaration public IReadOnlyDictionary<string, ITarget> NamedArgs { get; } Property Value Type Description IReadOnlyDictionary < String , ITarget > Remarks Note the difference between this and ParameterBindings - this property might be used when the constructor is not known in advance, whereas ParameterBindings is used when it is. <!-- .classchild --> ParameterBindings If this target was created with a specific constructor then this might contain argument bindings for that constructor's parameters. Declaration public IReadOnlyList<ParameterBinding> ParameterBindings { get; } Property Value Type Description IReadOnlyList < ParameterBinding > Remarks This is not the same as NamedArgs - as is noted by the documentation on that property. This property is for when the constructor is known in advance and when certain parameters are to be bound with specific arguments; whereas NamedArgs is for when the constructor is not known. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Auto(Type, IMemberBindingBehaviour) Creates a late bound ConstructorTarget or GenericConstructorTarget for the given type . Declaration public static ITarget Auto(Type type, IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Name Type Description type Type The type that is to be constructed when this target is compiled and executed. memberBindingBehaviour IMemberBindingBehaviour Optional. An object which selects properties on the new instance which are to be bound from the container. Returns Type Description ITarget Either a ConstructorTarget or GenericConstructorTarget , depending on whether the type is a generic type definition. Remarks This factory is merely a shortcut for calling the ConstructorTarget(Type, IMemberBindingBehaviour, IDictionary<String, ITarget>) with only the type and memberBindingBehaviour arguments supplied. When creating a GenericConstructorTarget , the function uses the GenericConstructorTarget(Type, IMemberBindingBehaviour) constructor. <!-- .classchild --> Auto<T>(IMemberBindingBehaviour) Generic version of the Auto(Type, IMemberBindingBehaviour) method. Declaration public static ITarget Auto<T>(IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Name Type Description memberBindingBehaviour IMemberBindingBehaviour See the documentation for the memberBindingBehaviour parameter on the non-generic version of this method. Returns Type Description ITarget Either a ConstructorTarget or GenericConstructorTarget , depending on whether T is a generic type definition. Type Parameters Name Description T The type that is to be constructed when the new target is compiled and executed. <!-- .classchild --> Bind(ICompileContext) Gets the ConstructorBinding for the DeclaredType using the targets available in the context for dependency lookup. The constructor is either resolved by checking available targets for the best match, or is pre-selected on construction ( Ctor will be non-null in this case). Declaration public ConstructorBinding Bind(ICompileContext context) Parameters Name Type Description context ICompileContext The current compilation context. Returns Type Description ConstructorBinding Exceptions Type Condition InvalidOperationException If no sutiable constructors can be found. <!-- .classchild --> FromNewExpression(Type, NewExpression) Non-generic version of FromNewExpression<T>(Expression<Func<T>>) . See the documentation on that method for more. Declaration public static ITarget FromNewExpression(Type declaredType, NewExpression newExpr) Parameters Name Type Description declaredType Type The of the object to be created by the new ConstructorTarget newExpr NewExpression An expression from which the target can be built - parameter bindings and the specific constructor called in the expression will be used to seed the new target. Returns Type Description ITarget <!-- .classchild --> FromNewExpression<T>(Expression<Func<T>>) Creates a new ConstructorTarget from the passed lambda expression (whose must be a ) Declaration public static ITarget FromNewExpression<T>(Expression<Func<T>> newExpr) Parameters Name Type Description newExpr Expression < Func <T>> Required. The expression from which to create the target. Returns Type Description ITarget An ITarget which, when compiled, will perform that same construction as provided in the given expression. Type Parameters Name Description T The type of the object to be created by the new ConstructorTarget Remarks This method does not support member binding expressions - e.g. c => new MyObject() { A = \"hello\" } - these can be converted into targets - for these you should construct an ExpressionTarget and let the compiler do the rest. When providing custom expressions to be used as targets in an ITargetContainer , it is possible to explicitly define properties/arguments as being resolved from the container itself, in exactly the same way as generated by the other factory methods such as Auto<T>(IMemberBindingBehaviour) and RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) . To do this, simply call the Resolve<T>() function on the object passed into your expression (see the signature of the lambda newExpr ), and Rezolver will convert that call into a RezolvedTarget . Exceptions Type Condition ArgumentNullException If newExpr is null. ArgumentException If the newExpr does not have a NewExpression as its root (Body) node, or if the type of that expression does not equal T <!-- .classchild --> WithArgs(ConstructorInfo, IDictionary<String, ITarget>) Similar to WithArgs(Type, IDictionary<String, ITarget>) except this one creates a ConstructorTarget that is specifically bound to a particular constructor on a given type, using any matched argument bindings from the provided namedArgs dictionary, and using RezolvedTarget targets for any that are not matched. Declaration public static ITarget WithArgs(ConstructorInfo ctor, IDictionary<string, ITarget> namedArgs) Parameters Name Type Description ctor ConstructorInfo Required. The constructor to be bound. namedArgs IDictionary < String , ITarget > Optional. Any arguments to be supplied to parameters on the ctor by name. Any parameters for which matches are not found in this dictionary will be automatically bound either from compile-time defaults or by resolving those types dynamically. Returns Type Description ITarget Remarks Although this overload accepts a dictionary of arguments, note that it will not result in the NamedArgs property being set on the target that is created - it's just an alternative for deriving the ParameterBindings with which the target will be created. Also, this function will not fail if the args dictionary contains named arguments that cannot be matched to parameters on the ctor . <!-- .classchild --> WithArgs(ConstructorInfo, Object) Performs the same operation as WithArgs(ConstructorInfo, IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration public static ITarget WithArgs(ConstructorInfo ctor, object namedArgs) Parameters Name Type Description ctor ConstructorInfo Required. The constructor to be bound. namedArgs Object An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Remarks Although this overload accepts a dictionary of arguments, note that it will not result in the NamedArgs property being set on the target that is created - it's just an alternative for deriving the ParameterBindings with which the target will be created. Also, this function will not fail if the args dictionary contains named arguments that cannot be matched to parameters on the ctor . <!-- .classchild --> WithArgs(Type, IDictionary<String, ITarget>) Non-generic version of WithArgs<T>(IDictionary<String, ITarget>) . Creates a ConstructorTarget with a set of named targets which will be used like named arguments to late-bind the constructor when code-generation occurs. Declaration public static ITarget WithArgs(Type declaredType, IDictionary<string, ITarget> namedArgs) Parameters Name Type Description declaredType Type The type whose constructor is to be bound. namedArgs IDictionary < String , ITarget > The named arguments to be used when building the expression. Returns Type Description ITarget Remarks Both versions of this method will create a target which will try to find the best-matching constructor where all of the named arguments match, and with the fewest number of auto-resolved arguments. So, a class with a constructor such as Foo(IService1 s1, IService2 s2) Can happily be bound if you only provide a named argument for 's1'; the target will simply attempt to auto-resolve the argument for the IService2 s2 parameter when constructing the object - and will fail only if it can't be resolved at that point. <!-- .classchild --> WithArgs(Type, Object) Performs the same operation as WithArgs(Type, IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration public static ITarget WithArgs(Type declaredType, object namedArgs) Parameters Name Type Description declaredType Type The type whose constructor is to be bound. namedArgs Object An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Remarks This overload exists to simplify the process of creating a ConstructorTarget with argument bindings by removing the need to create an argument dictionary in advance. An anonymous type can instead be used to supply the arguments. Examples This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a ConstructorTarget for the type 'MyType': ConstructorTarget.WithArgs(typeof(MyType), new { param1 = new ObjectTarget(\"Hello World\") }); <!-- .classchild --> WithArgs<T>(IDictionary<String, ITarget>) Creates a ConstructorTarget with a set of named targets which will be used like named arguments to late-bind the constructor when code-generation occurs. Declaration public static ITarget WithArgs<T>(IDictionary<string, ITarget> namedArgs) Parameters Name Type Description namedArgs IDictionary < String , ITarget > The named arguments to be used when building the expression. Returns Type Description ITarget Type Parameters Name Description T The type whose constructor is to be bound Remarks Both versions of this method will create a target which will try to find the best-matching constructor where all of the named arguments match, and with the fewest number of auto-resolved arguments. So, a class with a constructor such as Foo(IService1 s1, IService2 s2) Can happily be bound if you only provide a named argument for 's1'; the target will simply attempt to auto-resolve the argument for the IService2 s2 parameter when constructing the object - and will fail only if it can't be resolved at that point. <!-- .classchild --> WithArgs<T>(Object) Performs the same operation as WithArgs<T>(IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration public static ITarget WithArgs<T>(object namedArgs) Parameters Name Type Description namedArgs Object An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Type Parameters Name Description T Remarks This overload exists to simplify the process of creating a ConstructorTarget with argument bindings by removing the need to create an argument dictionary in advance. An anonymous type can instead be used to supply the arguments. Examples This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a ConstructorTarget for the type 'MyType': ConstructorTarget.WithArgs<MyType>(new { param1 = new ObjectTarget(\"Hello World\") }); <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Container.html": {
    "href": "rezolver-api/Rezolver.Container.html",
    "title": "Class Container",
    "keywords": "Class Container The standard IOC container class in Rezolver. Inheritance Object ContainerBase CachingContainerBase Container Inherited Members CachingContainerBase.GetCompiledRezolveTarget(ResolveContext) ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Compiler ContainerBase.Targets ContainerBase.Resolve(ResolveContext) ContainerBase.TryResolve(ResolveContext, Object) ContainerBase.CreateLifetimeScope() ContainerBase.FetchCompiled(ResolveContext) ContainerBase.CanResolve(ResolveContext) ContainerBase.GetFallbackCompiledRezolveTarget(ResolveContext) Rezolver.ContainerBase.System.IServiceProvider.GetService(System.Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.Fetch(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.FetchAll(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer, System.Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class Container : CachingContainerBase, IContainer, IServiceProvider, ITargetContainer Remarks All of this class' functionality is inherited through CachingContainerBase and its base classes. Note that it doesn't implement lifetime scoping (although you can create a lifetime scope from it by calling its CreateLifetimeScope() method). Also note that the class implements ITargetContainer through its ContainerBase base (which merely wraps around the Targets property. The reason for this is simplicity: in many applications, you'll want to simply create a new container, register services into it, and then start using it. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors Container(ITargetContainer, ITargetCompiler) Constructs a new instance of the Container class. Declaration public Container(ITargetContainer targets = null, ITargetCompiler compiler = null) Parameters Name Type Description targets ITargetContainer Optional. The targets that will be used to resolve objects. If left null, then a new, empty, target container will be constructed. compiler ITargetCompiler Optional. The compiler to be used to turn the ITarget s obtained from the Targets into ICompiledTarget targets that can actually be used at resolve-time. If not provided, then the Default will be used. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ContainerBase.DirectResolveCompiledTarget.html": {
    "href": "rezolver-api/Rezolver.ContainerBase.DirectResolveCompiledTarget.html",
    "title": "Class ContainerBase.DirectResolveCompiledTarget",
    "keywords": "Class ContainerBase.DirectResolveCompiledTarget Used when an ITarget is also of the same type as the one for which it is returned by the Fetch(Type) method of the Targets container. In this case, the target is not compiled, but instead is simply returned as the desired object. Inheritance Object ContainerBase.DirectResolveCompiledTarget Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax protected class DirectResolveCompiledTarget : ICompiledTarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DirectResolveCompiledTarget(ITarget) Constructs a new instance of the ContainerBase.DirectResolveCompiledTarget Declaration public DirectResolveCompiledTarget(ITarget target) Parameters Name Type Description target ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetObject(ResolveContext) Implementation of GetObject(ResolveContext) - simply returns the target with which this instance was constructed. Declaration public object GetObject(ResolveContext context) Parameters Name Type Description context ResolveContext ignored Returns Type Description Object Implements ICompiledTarget.GetObject(ResolveContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ContainerBase.MissingCompiledTarget.html": {
    "href": "rezolver-api/Rezolver.ContainerBase.MissingCompiledTarget.html",
    "title": "Class ContainerBase.MissingCompiledTarget",
    "keywords": "Class ContainerBase.MissingCompiledTarget Used as a sentinel type when a type cannot be resolved by a ContainerBase instance. Instead of returning a null ICompiledTarget instance, the container will construct an instance of this type (typically through GetMissingTarget(Type) , which caches singleton instances of this class on a per-type basis) which can then be used just as if the lookup succeeded. Inheritance Object ContainerBase.MissingCompiledTarget Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax protected class MissingCompiledTarget : ICompiledTarget Remarks The GetObject(ResolveContext) always throws an InvalidOperationException with the message 'Could resolve type [[type]]' <!-- <hr class=\"typeSectionDivider\" /> --> Constructors MissingCompiledTarget(Type) Constructs a new instance of the ContainerBase.MissingCompiledTarget class. Declaration public MissingCompiledTarget(Type type) Parameters Name Type Description type Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetObject(ResolveContext) Implementation of GetObject(ResolveContext) . Always throws an InvalidOperationException . Declaration public object GetObject(ResolveContext context) Parameters Name Type Description context ResolveContext The current rezolve context. Returns Type Description Object Implements ICompiledTarget.GetObject(ResolveContext) Exceptions Type Condition InvalidOperationException Always thrown. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ContainerBase.html": {
    "href": "rezolver-api/Rezolver.ContainerBase.html",
    "title": "Class ContainerBase",
    "keywords": "Class ContainerBase Starting point for implementations of IContainer - only creatable through inheritance. Inheritance Object ContainerBase Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ContainerBase : IContainer, IServiceProvider, ITargetContainer Remarks This class also implements ITargetContainer by proxying the Targets that are provided to it on construction (or created anew if not supplied). All of those interface methods are implemented explicitly except the Register(ITarget, Type) method, which is available through the class' public API. Note: IContainer s are generally not expected to implement ITargetContainer , and the framework will never assume they do. The reason this class does is to make it easier to create a new container and to register targets into it without having to worry about managing a separate ITargetContainer instance in your application root - because all the registration extension methods defined in classes like RegisterTypeTargetContainerExtensions , SingletonTargetDictionaryExtensions plus many more will be available to developers in code which has a reference to this class, or one derived from it. Note also that calling CombineWith(ITargetContainer, Type) on an instance of this type will always cause a NotSupportedException to be thrown. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ContainerBase(ITargetContainer, ITargetCompiler) Constructs a new instance of the ContainerBase , optionally initialising it with the given targets and compiler Declaration protected ContainerBase(ITargetContainer targets = null, ITargetCompiler compiler = null) Parameters Name Type Description targets ITargetContainer Optional. The target container whose registrations will be used for dependency lookup when Resolve(ResolveContext) (and other operations) is called. If not provided, a new TargetContainer instance is constructed. This will ultimately be available to inherited types, after construction, through the Targets property. compiler ITargetCompiler Optional. The compiler which will be used to create ICompiledTarget instances from the ITarget instances which are registered in the targets target container during resolve-time. If not provided, then the Default compiler is used. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Compiler The compiler that will be used to compile ITarget instances (obtained from the Targets container during Resolve(ResolveContext) and TryResolve(ResolveContext, out Object) operations) into ICompiledTarget instances that will actually provide the objects that are resolved. Declaration protected ITargetCompiler Compiler { get; } Property Value Type Description ITargetCompiler Remarks Notes to implementers: This property must NEVER be null. <!-- .classchild --> Targets Provides the ITarget instances that will be compiled by the Compiler into ICompiledTarget instances. Declaration protected ITargetContainer Targets { get; } Property Value Type Description ITargetContainer Remarks Notes to implementers: This property must NEVER be null. This class implements the ITargetContainer interface by wrapping around this instance so that an application can create an instance of ContainerBase and directly register targets into it; rather than having to create and setup the target container first. You can add registrations to this target container at any point in the lifetime of any ContainerBase instances which are attached to it. In reality, however, if any Resolve(ResolveContext) operations have been performed prior to adding more registrations, then there's no guarantee that new dependencies will be picked up - especially if the CachingContainerBase is being used as your application's container (which it nearly always will be). <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CanResolve(ResolveContext) Implementation of the CanResolve(ResolveContext) method. Returns true if, and only if, the Targets ITargetContainer returns a non-null ITarget when the RequestedType is passed to its Fetch(Type) method. Declaration public virtual bool CanResolve(ResolveContext context) Parameters Name Type Description context ResolveContext The resolve context containing the requested type. Returns Type Description Boolean Implements IContainer.CanResolve(ResolveContext) <!-- .classchild --> CreateLifetimeScope() Implementation of the CreateLifetimeScope() method. The base definition creates a new instance of the OverridingScopedContainer , passing this container as its parent and, if this container is an IScopedContainer , also as its parent scope. Declaration public virtual IScopedContainer CreateLifetimeScope() Returns Type Description IScopedContainer Implements IContainer.CreateLifetimeScope() <!-- .classchild --> FetchCompiled(ResolveContext) Base implementation of FetchCompiled(ResolveContext) . Note that any container already defined in the Container is ignored in favour of this container. Declaration public virtual ICompiledTarget FetchCompiled(ResolveContext context) Parameters Name Type Description context ResolveContext The context containing the requested type and any scope which is currently in force. Returns Type Description ICompiledTarget Always returns a reference to a compiled target - but note that if CanResolve(ResolveContext) returns false for the same context, then the target's GetObject(ResolveContext) method will likely throw an exception - in line with the behaviour of the ContainerBase.MissingCompiledTarget class' behaviour. Implements IContainer.FetchCompiled(ResolveContext) <!-- .classchild --> GetCompiledRezolveTarget(ResolveContext) The main workhorse of the resolve process - obtains an ICompiledTarget for the given context by looking up an ITarget from the Targets target container, then compiling it. Declaration protected virtual ICompiledTarget GetCompiledRezolveTarget(ResolveContext context) Parameters Name Type Description context ResolveContext The current resolve context Returns Type Description ICompiledTarget Remarks The specifics of how this process works are not important if you simply want to use the container, but if you are looking to extend it, then it's essential you understand the different steps that the process goes through. If the Fetch(Type) method of the Targets target container returns a null ITarget , or one which has its UseFallback set to true , then the method gets an alternative compiled target by calling the GetFallbackCompiledRezolveTarget(ResolveContext) method. This fallback compiled target will be used instead of compiling the target unless the target was not null and its UseFallback is true AND the compiled target returned by the fallback method is a ContainerBase.MissingCompiledTarget - in which case the fallback target will be compiled as normal. Before proceeding with compilation, the container checks whether the target can resolve the required object directly. This means that the target either implements the ICompiledTarget interface (in which case it is immediately returned) or the RequestedType is not Object and the target's type is compatible with it (in which case the target is simply embedded in a new ContainerBase.DirectResolveCompiledTarget , which will later just return the target when its GetObject(ResolveContext) is called). The ObjectTarget supports the ICompiledTarget interface, therefore any objects which are directly registered through this target will always use that class' implementation of ICompiledTarget if requested through the Resolve(ResolveContext) method. Once the decision has been taken to compile the target, the container first needs a compiler ( ITargetCompiler ) and a compile context provider ( ICompileContextProvider ). Note that classes which implement the ITargetCompiler interface also frequently implement the ICompileContextProvider interface so that any additional state they require is correctly attached to the ICompileContext which will be fed to their CompileTarget(ITarget, ICompileContext) implementation. These are both obtained by resolving them directly from the Container of the context (since a container can be delegated to from another container which originally received the Resolve(ResolveContext) call). Attentive readers will realise at this point that this could lead to an infinite recursion - i.e. since compiling a target means resolving a compiler, which in turn must mean compiling that target. The class sidesteps this potential pitfall by requiring that the targets registered for these types support direct resolving, as per the description a couple of paragraphs back. Therefore, compilers and context providers are typically registered as objects via the ObjectTarget target. Finally, a new ICompileContext is created via the CreateContext(ResolveContext, ITargetContainer, IContainer) method of the resolved context provider, and then passed to the CompileTarget(ITarget, ICompileContext) method of the resolved compiler. The result of that operation is then returned to the caller. <!-- .classchild --> GetFallbackCompiledRezolveTarget(ResolveContext) Called by GetCompiledRezolveTarget(ResolveContext) if no valid ITarget can be found for the context or if the one found has its UseFallback property set to true . Declaration protected virtual ICompiledTarget GetFallbackCompiledRezolveTarget(ResolveContext context) Parameters Name Type Description context ResolveContext Returns Type Description ICompiledTarget An ICompiledTarget to be used as the result of a Resolve(ResolveContext) operation where the search for a valid target either fails or is inconclusive (e.g. - empty enumerables). Remarks The base implementation always returns an instance of the ContainerBase.MissingCompiledTarget via the GetMissingTarget(Type) static method. <!-- .classchild --> GetMissingTarget(Type) Gets an ICompiledTarget for the given type which will always throw an InvalidOperationException whenever its GetObject(ResolveContext) method is called. Use this when you can't resolve a target for a type. Declaration protected static ICompiledTarget GetMissingTarget(Type type) Parameters Name Type Description type Type The type for which you wish to create a missing target. Returns Type Description ICompiledTarget <!-- .classchild --> GetService(Type) Protected virtual implementation of GetService(Type) . Uses the TryResolve(ResolveContext, out Object) method to resolve the service, returning null if the operation fails. Declaration protected virtual object GetService(Type serviceType) Parameters Name Type Description serviceType Type Type of service to be resolved. Returns Type Description Object <!-- .classchild --> IsMissingTarget(ICompiledTarget) Determines whether the given target is an instance of ContainerBase.MissingCompiledTarget . Declaration protected static bool IsMissingTarget(ICompiledTarget target) Parameters Name Type Description target ICompiledTarget The target. Returns Type Description Boolean <!-- .classchild --> Register(ITarget, Type) Implementation of Register(ITarget, Type) - simply proxies the call to the target container referenced by the Targets property. Declaration public void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget serviceType Type Implements ITargetContainer.Register(ITarget, Type) Remarks Remember: registering new targets into an ITargetContainer after an IContainer has started compiling targets within it can yield unpredictable results. If you create a new container and perform all your registrations before you use it, however, then everything will work as expected. Note also the other ITargetContainer interface methods are implemented explicitly so as to hide them from the list of class members. <!-- .classchild --> Resolve(ResolveContext) Implementation of the Resolve(ResolveContext) method. Obtains an ICompiledTarget by calling the GetCompiledRezolveTarget(ResolveContext) method, and then immediately calls its GetObject(ResolveContext) method, returning the result. Declaration public virtual object Resolve(ResolveContext context) Parameters Name Type Description context ResolveContext The context containing the type that's requested, any active scope and so on. Returns Type Description Object Implements IContainer.Resolve(ResolveContext) <!-- .classchild --> TryResolve(ResolveContext, out Object) Implementation of the TryResolve(ResolveContext, out Object) method. Attempts to resolve the requested type (given on the context , returning a boolean indicating whether the operation was successful. If successful, then result receives a reference to the resolved object. Declaration public virtual bool TryResolve(ResolveContext context, out object result) Parameters Name Type Description context ResolveContext The context containing the type that's requested, any active scope and so on. result Object Receives a reference to the object that was resolved, if successful, or null if not. Returns Type Description Boolean A boolean indicating whether the operation completed successfully. Implements IContainer.TryResolve(ResolveContext, Object) <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Explicit Interface Implementations ITargetContainer.CombineWith(ITargetContainer, Type) Declaration ITargetContainer ITargetContainer.CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer type Type Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) <!-- .classchild --> ITargetContainer.Fetch(Type) Declaration ITarget ITargetContainer.Fetch(Type type) Parameters Name Type Description type Type Returns Type Description ITarget Implements ITargetContainer.Fetch(Type) <!-- .classchild --> ITargetContainer.FetchAll(Type) Declaration IEnumerable<ITarget> ITargetContainer.FetchAll(Type type) Parameters Name Type Description type Type Returns Type Description IEnumerable < ITarget > Implements ITargetContainer.FetchAll(Type) <!-- .classchild --> IServiceProvider.GetService(Type) Declaration object IServiceProvider.GetService(Type serviceType) Parameters Name Type Description serviceType Type Returns Type Description Object Implements IServiceProvider.GetService(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DecoratingTargetContainer.html": {
    "href": "rezolver-api/Rezolver.DecoratingTargetContainer.html",
    "title": "Class DecoratingTargetContainer",
    "keywords": "Class DecoratingTargetContainer Implements service decoration in an ITargetContainer , producing instances of the DecoratorTarget when Fetch(Type) or FetchAll(Type) are called. The best way to add a decorator to your target container is to use the extension method RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) or its non-generic equivalent. Inheritance Object DecoratingTargetContainer Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DecoratingTargetContainer : ITargetContainerOwner, ITargetContainer Remarks This class does not implement ITarget , rather it's an ITargetContainerOwner into which other targets can be added, and when Fetch(Type) or FetchAll(Type) are called, a temporary DecoratorTarget is created which wraps around the targets that have been registered within and which will ultimately create instances of DecoratorType <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DecoratingTargetContainer(Type, Type) Initializes a new instance of the DecoratingTargetContainer class. Declaration public DecoratingTargetContainer(Type decoratorType, Type decoratedType) Parameters Name Type Description decoratorType Type Type of the decorator. decoratedType Type Type being decorated. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DecoratedType Gets the type that's being decorated - in essence, this is the type that this decorator target Declaration public Type DecoratedType { get; } Property Value Type Description Type <!-- .classchild --> DecoratorType Gets the type which will be used to decorate the instances produced by targets in this decorator target. Declaration public Type DecoratorType { get; } Property Value Type Description Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CombineWith(ITargetContainer, Type) Implements CombineWith(ITargetContainer, Type) by wrapping the existing container and returning itself. This allows decorators to be applied on top of decorators; and decorators to be added after types have begun to be registered in another target container. Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer The existing ITargetContainer instance that this instance is to be combined with type Type The type that the combined container owner will be registered under. Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) Exceptions Type Condition InvalidOperationException If this target container is already decorating another container <!-- .classchild --> Fetch(Type) Implementation of Fetch(Type) - wraps a special target around the target returned by the target container that's decorated by this one. Declaration public ITarget Fetch(Type type) Parameters Name Type Description type Type Required. The type for which an ITarget is to be retrieved. Returns Type Description ITarget Implements ITargetContainer.Fetch(Type) Remarks If the inner container returns null, then so does this one. <!-- .classchild --> FetchAll(Type) Implementation of FetchAll(Type) - passes the call on to the inner container that's decorated by this one, and then wraps each of those targets in a DecoratorTarget which represents the decoration logic for each instance. Declaration public IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type Type Required. The type for which the ITarget instances are to be retrieved. Returns Type Description IEnumerable < ITarget > Implements ITargetContainer.FetchAll(Type) <!-- .classchild --> FetchContainer(Type) Retrieves an existing container registered against the given type , or null if not found. Declaration public ITargetContainer FetchContainer(Type type) Parameters Name Type Description type Type The type. Returns Type Description ITargetContainer Implements ITargetContainerOwner.FetchContainer(Type) Remarks This is an implementation of FetchContainer(Type) which wraps around the inner target container and passes the call on to that. Exceptions Type Condition InvalidOperationException If this decorator's inner container isn't an instance of ITargetContainerOwner <!-- .classchild --> Register(ITarget, Type) Registers a target, either for the serviceType specified or, if null, the DeclaredType of the target . Implementation of Register(ITarget, Type) . Declaration public void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget Required. The target to be registered serviceType Type Optional. The type the target is to be registered against, if different from the DeclaredType of the target . If provided, then the target must be compatible with this type. Implements ITargetContainer.Register(ITarget, Type) Remarks The decorator target does not accept registrations directly; rather it passes the call on to its inner container which could be a TargetListContainer , or GenericTargetContainer in the most basic cases; or it could be another DecoratingTargetContainer in situations where a type has had multiple decorators registered against it. <!-- .classchild --> RegisterContainer(Type, ITargetContainer) Implementation of RegisterContainer(Type, ITargetContainer) - the call is automatically forwarded on to the inner target container that's being decorated, since decorator targets don't support direct registration of targets or containers. Declaration public void RegisterContainer(Type type, ITargetContainer container) Parameters Name Type Description type Type The type. container ITargetContainer The container. Implements ITargetContainerOwner.RegisterContainer(Type, ITargetContainer) Exceptions Type Condition InvalidOperationException This decorator must be decorating another ITargetContainerOwner , or be decorating a generic type <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DecoratorTarget.html": {
    "href": "rezolver-api/Rezolver.DecoratorTarget.html",
    "title": "Class DecoratorTarget",
    "keywords": "Class DecoratorTarget Represents the action of implementing a common DecoratedType by decorating one instance (produced by DecoratedTarget ) with another ( Target , which will create an instance of DecoratorType ). NOTE - You shouldn't register or otherwise create instances of this target unless you absolutely know what you're doing. Rather, decorators should be registered using the extension method RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) or its non-generic alternative because the target needs a DecoratingTargetContainer to work properly (the creation of which is automatically handled by these extension methods). Inheritance Object TargetBase DecoratorTarget Inherited Members TargetBase.SuppressScopeTracking TargetBase.UseFallback Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DecoratorTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DecoratorTarget(Type, ITarget, Type) Creates a new instance of the DecoratorTarget type, initialising the Target to a just-in-time-bound ConstructorTarget for the decoratorType . Declaration public DecoratorTarget(Type decoratorType, ITarget decoratedTarget, Type decoratedType) Parameters Name Type Description decoratorType Type The type which is decorating the decoratedType decoratedTarget ITarget The target which is being decorated decoratedType Type The common type which is being decorated - e.g. IService when the decoratedTarget is bound to the type MyService : IService and the decoratorType is set to MyServiceDecorator : IService . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Always returns DecoratorType Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> DecoratedTarget Gets the target whose instance will be wrapped (decorated) by the one produced by Target . Declaration public ITarget DecoratedTarget { get; } Property Value Type Description ITarget <!-- .classchild --> DecoratedType Gets the underlying type (e.g. a common service interface or base) that is being implemented through decoration. Declaration public Type DecoratedType { get; } Property Value Type Description Type <!-- .classchild --> DecoratorType Gets the type which is decorating the instance produced by the DecoratedTarget for the common service type DecoratedType Declaration public Type DecoratorType { get; } Property Value Type Description Type <!-- .classchild --> Target Gets the target which will create an instance of the DecoratorType Declaration public ITarget Target { get; } Property Value Type Description ITarget Remarks The constructor currently auto-initialises this to a just-in-time-bound ConstructorTarget targetting the DecoratorType by using the Auto(Type, IMemberBindingBehaviour) method. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods SupportsType(Type) Overrides SupportsType(Type) to forward the call to Target . Declaration public override bool SupportsType(Type type) Parameters Name Type Description type Type The type which is to be checked. Returns Type Description Boolean true if the type is compatible with the object created by Target , false if not. Overrides TargetBase.SupportsType(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DecoratorTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.DecoratorTargetContainerExtensions.html",
    "title": "Class DecoratorTargetContainerExtensions",
    "keywords": "Class DecoratorTargetContainerExtensions Extensions for ITargetContainerOwner which simplify the registration of decorators (via the DecoratingTargetContainer pseudo-target) Inheritance Object DecoratorTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class DecoratorTargetContainerExtensions Remarks Note: The decoration functionality provided by the framework is only possible on ITargetContainer implementations which also implement the ITargetContainerOwner interface. All the main target container types you'll use in your application ( TargetContainer and ChildTargetContainer ) do support this interface. <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterDecorator(ITargetContainerOwner, Type, Type) Registers a decorator container which will cause all instances of decoratedType to be decorated with the type decoratorType . Any existing registrations for decoratedType will be decorated correctly, and subsequent registrations of decoratedType will also be decorated as expected. Declaration public static void RegisterDecorator(this ITargetContainerOwner targetContainerOwner, Type decoratorType, Type decoratedType) Parameters Name Type Description targetContainerOwner ITargetContainerOwner The container into which the decorator will be registered. decoratorType Type The type to be used as the decorator implementation decoratedType Type The type which will be decorated by decoratorType . <!-- .classchild --> RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) Registers a decorator container which will cause all instances of TDecorated to be decorated with the type TDecorator . Any existing registrations for TDecorated will be decorated correctly, and subsequent registrations of TDecorated will also be decorated as expected. Declaration public static void RegisterDecorator<TDecorator, TDecorated>(this ITargetContainerOwner targetContainerOwner) Parameters Name Type Description targetContainerOwner ITargetContainerOwner The container into which the decorator will be registered. Type Parameters Name Description TDecorator The type to be used as the decorator implementation TDecorated The type which will be decorated by TDecorator . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DefaultMemberBindingBehaviour.html": {
    "href": "rezolver-api/Rezolver.DefaultMemberBindingBehaviour.html",
    "title": "Class DefaultMemberBindingBehaviour",
    "keywords": "Class DefaultMemberBindingBehaviour The default implementation of IMemberBindingBehaviour when you are creating a ConstructorTarget or GenericConstructorTarget and you want publicly writable properties and public fields to be assigned values obtained from the container. If you do not require properties or fields to be bound from the container, then use a null IMemberBindingBehaviour . Inheritance Object DefaultMemberBindingBehaviour Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DefaultMemberBindingBehaviour : IMemberBindingBehaviour Remarks This is a stateless singleton accessible through the Instance static property. The class also serves as a good starting point for any custom binding behaviours you might need - as there are numerous virtual methods which allow you to change which fields and/or properties are selected for binding, as well as how those bindings are created. The default behaviour is bind each member to a new RezolvedTarget whose DeclaredType is set to the member's type. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DefaultMemberBindingBehaviour() Constructs a new instance of the DefaultMemberBindingBehaviour class. Declaration protected DefaultMemberBindingBehaviour() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Instance Gets the one and only instance of DefaultMemberBindingBehaviour Declaration public static DefaultMemberBindingBehaviour Instance { get; } Property Value Type Description DefaultMemberBindingBehaviour <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) Called by GetMemberBindings(ICompileContext, Type) - iterates through the fields , calling CreateBinding(ICompileContext, Type, FieldInfo) for each, and those which are non-null. Declaration protected virtual IEnumerable<MemberBinding> BindFields(ICompileContext context, Type type, IEnumerable<FieldInfo> fields) Parameters Name Type Description context ICompileContext The current compilation context. type Type The type whose members are to be bound. fields IEnumerable < FieldInfo > The fields for which bindings are to be created. This is fed by the function GetBindableFields(ICompileContext, Type) Returns Type Description IEnumerable < MemberBinding > <!-- .classchild --> BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) Called by GetMemberBindings(ICompileContext, Type) - iterates through the properties , calling CreateBinding(ICompileContext, Type, PropertyInfo) for each, and those which are non-null. Declaration protected virtual IEnumerable<MemberBinding> BindProperties(ICompileContext context, Type type, IEnumerable<PropertyInfo> properties) Parameters Name Type Description context ICompileContext The current compilation context. type Type The type whose members are to be bound. properties IEnumerable < PropertyInfo > The properties for which bindings are to be created. This is fed by the function GetBindableProperties(ICompileContext, Type) Returns Type Description IEnumerable < MemberBinding > An enumerable of MemberBinding objects representing the bindings to be used for each bindable property in properties . <!-- .classchild --> CreateBinding(ICompileContext, Type, FieldInfo) Creates a binding for the given field. Called by GetMemberBindings(ICompileContext, Type) Declaration protected virtual MemberBinding CreateBinding(ICompileContext context, Type type, FieldInfo field) Parameters Name Type Description context ICompileContext The current compilation context. type Type The type whose members are to be bound. field FieldInfo The field for which a binding is to be created. Returns Type Description MemberBinding Remarks Override this method to customise the binding that is create for the given field, or to prevent the binding from being created at all(return null if you want to abort binding the field). The base implementation simply creates a new MemberBinding whose Target is set to a new RezolvedTarget for the type - thus causing the field to be assigned a value resolved from the container when the instance is created. <!-- .classchild --> CreateBinding(ICompileContext, Type, PropertyInfo) Creates a binding for the given property. Called by GetMemberBindings(ICompileContext, Type) Declaration protected virtual MemberBinding CreateBinding(ICompileContext context, Type type, PropertyInfo prop) Parameters Name Type Description context ICompileContext The current compilation context. type Type The type whose members are to be bound. prop PropertyInfo The property for which a binding is to be created. Returns Type Description MemberBinding Remarks Override this method to customise the binding that is create for the given property, or to prevent the binding from being created at all(return null if you want to abort binding the property). The base implementation simply creates a new MemberBinding whose Target is set to a new RezolvedTarget for the type - thus causing the property to be assigned a value resolved from the container when the instance is created. <!-- .classchild --> GetBindableFields(ICompileContext, Type) Gets the bindable fields on the type . Used by GetMemberBindings(ICompileContext, Type) and passed to the BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) method. Declaration protected virtual IEnumerable<FieldInfo> GetBindableFields(ICompileContext context, Type type) Parameters Name Type Description context ICompileContext The current compilation context. type Type The type whose members are to be bound. Returns Type Description IEnumerable < FieldInfo > Remarks Override this method to filter the fields which can be bound. The base implementation returns all public instance fields declared on the type . <!-- .classchild --> GetBindableProperties(ICompileContext, Type) Gets the bindable properties on the type . Used by GetMemberBindings(ICompileContext, Type) and passed to the BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) method. Declaration protected virtual IEnumerable<PropertyInfo> GetBindableProperties(ICompileContext context, Type type) Parameters Name Type Description context ICompileContext The current compilation context. type Type The type whose members are to be bound. Returns Type Description IEnumerable < PropertyInfo > Remarks Override this method to filter the properties which can be bound. The base implementation returns all instance properties which have publicly accessible 'set' accessors. <!-- .classchild --> GetMemberBindings(ICompileContext, Type) Implementation of GetMemberBindings(ICompileContext, Type) . Declaration public virtual MemberBinding[] GetMemberBindings(ICompileContext context, Type type) Parameters Name Type Description context ICompileContext The current compilation context. type Type The type whose members are to be bound. Returns Type Description MemberBinding [] Implements IMemberBindingBehaviour.GetMemberBindings(ICompileContext, Type) Remarks The base implementation calls GetBindableProperties(ICompileContext, Type) , passing the resultant enumerable to the BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) function; it also does the same thing with GetBindableFields(ICompileContext, Type) and BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) - concatenating the two enumerables together and returning the result as an array of MemberBinding objects. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DefaultPropertyBindingBehaviour.html": {
    "href": "rezolver-api/Rezolver.DefaultPropertyBindingBehaviour.html",
    "title": "Class DefaultPropertyBindingBehaviour",
    "keywords": "Class DefaultPropertyBindingBehaviour The default implementation of IPropertyBindingBehaviour when you are creating a ConstructorTarget or GenericConstructorTarget and you want publicly writable properties and public fields to be assigned values obtained from the container. If you do not require properties or fields to be bound from the container, then use a null IPropertyBindingBehaviour . Inheritance Object DefaultPropertyBindingBehaviour Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DefaultPropertyBindingBehaviour : IPropertyBindingBehaviour Remarks This is a singleton class accessible through the Instance static property. <!-- <hr class=\"typeSectionDivider\" /> --> Properties Instance Gets the one and only instance of DefaultPropertyBindingBehaviour Declaration public static DefaultPropertyBindingBehaviour Instance { get; } Property Value Type Description DefaultPropertyBindingBehaviour <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods BindProperties(Type, IEnumerable<PropertyInfo>) Declaration protected virtual IEnumerable<PropertyOrFieldBinding> BindProperties(Type type, IEnumerable<PropertyInfo> properties) Parameters Name Type Description type Type properties IEnumerable < PropertyInfo > Returns Type Description IEnumerable < PropertyOrFieldBinding > <!-- .classchild --> CreateBinding(Type, FieldInfo) Creates the binding for the given field. Called by GetPropertyBindings(CompileContext, Type) Declaration protected virtual PropertyOrFieldBinding CreateBinding(Type type, FieldInfo field) Parameters Name Type Description type Type The type. field FieldInfo The field. Returns Type Description PropertyOrFieldBinding <!-- .classchild --> CreateBinding(Type, PropertyInfo) Creates the binding for the given property. Called by GetPropertyBindings(CompileContext, Type) Declaration protected virtual PropertyOrFieldBinding CreateBinding(Type type, PropertyInfo prop) Parameters Name Type Description type Type The type. prop PropertyInfo The property. Returns Type Description PropertyOrFieldBinding <!-- .classchild --> GetBindableFields(Type) Gets the bindable fields on the type . Used by GetPropertyBindings(CompileContext, Type) . Declaration protected virtual IEnumerable<FieldInfo> GetBindableFields(Type type) Parameters Name Type Description type Type The type. Returns Type Description IEnumerable < FieldInfo > <!-- .classchild --> GetBindableProperties(Type) Gets the bindable properties on the type . Used by GetPropertyBindings(CompileContext, Type) . Declaration protected virtual IEnumerable<PropertyInfo> GetBindableProperties(Type type) Parameters Name Type Description type Type The type. Returns Type Description IEnumerable < PropertyInfo > <!-- .classchild --> GetPropertyBindings(CompileContext, Type) Implementation of GetPropertyBindings(CompileContext, Type) . Returns a binding for each publicly writable property (i.e. with a public set accessor) and each public field on the type . Declaration public virtual PropertyOrFieldBinding[] GetPropertyBindings(CompileContext context, Type type) Parameters Name Type Description context CompileContext The context. type Type The type. Returns Type Description PropertyOrFieldBinding [] Implements IPropertyBindingBehaviour.GetPropertyBindings(CompileContext, Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DefaultTarget.html": {
    "href": "rezolver-api/Rezolver.DefaultTarget.html",
    "title": "Class DefaultTarget",
    "keywords": "Class DefaultTarget A target that simply creates a default instance of a given type. I.e. the same as doing default(type) in C#. Inheritance Object TargetBase DefaultTarget Inherited Members TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DefaultTarget : TargetBase, ITarget, ICompiledTarget Remarks The type also implements the ICompiledTarget interface for direct resolving. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DefaultTarget(Type) Initializes a new instance of the DefaultTarget class. Declaration public DefaultTarget(Type type) Parameters Name Type Description type Type The type. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Always equal to the type for which the default value will be returned Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Explicit Interface Implementations ICompiledTarget.GetObject(ResolveContext) Declaration object ICompiledTarget.GetObject(ResolveContext context) Parameters Name Type Description context ResolveContext Returns Type Description Object Implements ICompiledTarget.GetObject(ResolveContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-1.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-1.html",
    "title": "Class DelegateTarget<TResult>",
    "keywords": "Class DelegateTarget<TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<TResult> : DelegateTarget, ITarget Type Parameters Name Description TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<TResult>, Type) Initializes a new instance of the DelegateTarget<TResult> class. Declaration public DelegateTarget(Func<TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-10.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-10.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-11.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-11.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-12.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-12.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-13.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-13.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-14.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-14.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-15.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-15.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-16.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-16.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) T15 The type of the 15th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-2.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-2.html",
    "title": "Class DelegateTarget<T, TResult>",
    "keywords": "Class DelegateTarget<T, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T, TResult> : DelegateTarget, ITarget Type Parameters Name Description T The type of the 1st delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T, TResult>, Type) Initializes a new instance of the DelegateTarget<T, TResult> class. Declaration public DelegateTarget(Func<T, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-3.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-3.html",
    "title": "Class DelegateTarget<T1, T2, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, TResult> class. Declaration public DelegateTarget(Func<T1, T2, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-4.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-4.html",
    "title": "Class DelegateTarget<T1, T2, T3, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-5.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-5.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-6.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-6.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-7.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-7.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-8.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-8.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-9.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-9.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, T8, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget.html",
    "title": "Class DelegateTarget",
    "keywords": "Class DelegateTarget An ITarget which resolve objects by executing a delegate with argument injection. Inheritance Object TargetBase DelegateTarget Inherited Members TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget : TargetBase, ITarget Remarks The delegate must be non-void and can have any number of parameters. A compiler must ensure that any parameters for the Factory are automatically resolved from the container, and that a parameter of the type ResolveContext will receive the context passed to the Resolve(ResolveContext) method call for which this target is being compiled and/or executed. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Delegate, Type) Initializes a new instance of the DelegateTarget class. Declaration public DelegateTarget(Delegate factory, Type declaredType = null) Parameters Name Type Description factory Delegate Required - the factory delegate. Must have a return type and can take 0 or more parameters. declaredType Type Optional - type that will be set into the DeclaredType for the target; if not provided, then it will be derived from the factory 's return type Exceptions Type Condition ArgumentNullException If factory is null ArgumentException If the factory represents a void delegate or if declaredType is passed but the type is not compatible with the return type of factory . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Gets the declared type of object that is constructed by this target, either set on construction or derived from the return type of the Factory Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> Factory Gets the factory method that will be invoked when this target is compiled and executed Declaration public Delegate Factory { get; } Property Value Type Description Delegate The factory. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.GenericConstructorTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.GenericConstructorTargetBuilder.html",
    "title": "Class GenericConstructorTargetBuilder",
    "keywords": "Class GenericConstructorTargetBuilder An IExpressionBuilder specialised for building expressions for GenericConstructorTarget targets. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < GenericConstructorTarget > GenericConstructorTargetBuilder Inherited Members ExpressionBuilderBase<GenericConstructorTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.GenericConstructorTarget>.Rezolver.Compilation.Expressions.IExpressionBuilder<Rezolver.GenericConstructorTarget>.Build(Rezolver.GenericConstructorTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) ExpressionBuilderBase<GenericConstructorTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase.Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class GenericConstructorTargetBuilder : ExpressionBuilderBase<GenericConstructorTarget>, IExpressionBuilder<GenericConstructorTarget>, IExpressionBuilder <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(GenericConstructorTarget, IExpressionCompileContext, IExpressionCompiler) Obtains the bound target for the target passed (by calling , and passes it to the compiler to have an expression built for it. Declaration protected override Expression Build(GenericConstructorTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target GenericConstructorTarget The target whose expression is to be built. context IExpressionCompileContext The compilation context. compiler IExpressionCompiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.GenericConstructorTarget>.Build(Rezolver.GenericConstructorTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.IExpressionBuilder-1.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.IExpressionBuilder-1.html",
    "title": "Interface IExpressionBuilder<TTarget>",
    "keywords": "Interface IExpressionBuilder<TTarget> Interface for an object that produces expressions from instances of TTarget . This is a generic extension to the IExpressionBuilder interface. Inherited Members IExpressionBuilder.CanBuild(ITarget, IExpressionCompileContext) IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public interface IExpressionBuilder<in TTarget> : IExpressionBuilder where TTarget : ITarget Type Parameters Name Description TTarget The type of the target. <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target. Declaration Expression Build(TTarget target, IExpressionCompileContext context, IExpressionCompiler compiler = null) Parameters Name Type Description target TTarget The target whose expression is to be built. context IExpressionCompileContext The compilation context. compiler IExpressionCompiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the builder should attempt to fetch the compiler from the context; or throw an exception if it is required but not provided and cannot be resolved fromm the context. Returns Type Description Expression Remarks When invoked by the ExpressionCompiler class, the compiler parameter will always be provided. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.IExpressionBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.IExpressionBuilder.html",
    "title": "Interface IExpressionBuilder",
    "keywords": "Interface IExpressionBuilder The interface for an object that produces expressions (which can be compiled to delegates) from ITarget instances. Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public interface IExpressionBuilder <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the specified target. Declaration Expression Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler = null) Parameters Name Type Description target ITarget The target for which an expression is to be built context IExpressionCompileContext The compilation context. compiler IExpressionCompiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the builder should attempt to fetch the compiler from the context; or throw an exception if it is required but not provided and cannot be resolved fromm the context. Returns Type Description Expression Remarks When invoked by the ExpressionCompiler class, the compiler parameter will always be provided. <!-- .classchild --> CanBuild(ITarget, IExpressionCompileContext) Determines whether this instance can build an expression for the specified target. Declaration bool CanBuild(ITarget target, IExpressionCompileContext context) Parameters Name Type Description target ITarget The target. context IExpressionCompileContext The compilation context. Returns Type Description Boolean <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.IExpressionCompileContext.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.IExpressionCompileContext.html",
    "title": "Interface IExpressionCompileContext",
    "keywords": "Interface IExpressionCompileContext Extension to the ICompileContext interface which provides additional state and functionality for the IExpressionCompiler and the IExpressionBuilder implementations which are used by the default expression compiler, the ExpressionCompiler class. Inherited Members ICompileContext.Container ICompileContext.SuppressScopeTracking ICompileContext.TargetType ICompileContext.CompileStack ICompileContext.NewContext(Type, Nullable<Boolean>) ICompileContext.PopCompileStack() ICompileContext.PushCompileStack(ITarget) ITargetContainer.Register(ITarget, Type) ITargetContainer.Fetch(Type) ITargetContainer.FetchAll(Type) ITargetContainer.CombineWith(ITargetContainer, Type) Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public interface IExpressionCompileContext : ICompileContext, ITargetContainer <!-- <hr class=\"typeSectionDivider\" /> --> Properties ContainerExpression Gets an expression which gives a reference to the IContainer for this context - i.e. the same reference as given by the Container property. Declaration Expression ContainerExpression { get; } Property Value Type Description Expression Remarks Note that this is not the same as ContextContainerPropertyExpression - but is provided to allow expressions to be compiled which compare the container supplied at compile time to the one from the Container at resolve-time. <!-- .classchild --> ContextContainerPropertyExpression Gets an expression for reading the Container property of the ResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration MemberExpression ContextContainerPropertyExpression { get; } Property Value Type Description MemberExpression <!-- .classchild --> ContextScopePropertyExpression Gets an expression for reading the Scope property of the ResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration MemberExpression ContextScopePropertyExpression { get; } Property Value Type Description MemberExpression <!-- .classchild --> ParentContext Gets the parent context. Declaration IExpressionCompileContext ParentContext { get; } Property Value Type Description IExpressionCompileContext Remarks Note that this property hides the inherited ParentContext property, since an IExpressionCompileContext can only be a child of another IExpressionCompileContext . <!-- .classchild --> ResolveContextExpression This is the parameter expression which represents the ResolveContext that is passed to the ICompiledTarget at resolve-time. The other expressions - ContextContainerPropertyExpression and ContextScopePropertyExpression are both built from this too. Declaration ParameterExpression ResolveContextExpression { get; } Property Value Type Description ParameterExpression Remarks If the code produced by the IExpressionBuilder for a given target needs to read or use the ResolveContext that was originally passed to the Resolve(ResolveContext) method, then it does it by using this expression, which will be set as the only parameter on the lambda expression which is eventually compiled (in the case of the default expression compiler, ExpressionCompiler . <!-- .classchild --> SharedExpressions Gets a read-only enumerable of all the shared expressions that have been inherited from any parent context or added via calls to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) or GetOrAddSharedLocal(Type, String, Type) . Declaration IEnumerable<Expression> SharedExpressions { get; } Property Value Type Description IEnumerable < Expression > The shared expressions. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetOrAddSharedExpression(Type, String, Func<Expression>, Type) Gets or adds an expression which is potentially shared between multiple targets' expression trees. Declaration Expression GetOrAddSharedExpression(Type type, string name, Func<Expression> expressionFactory, Type requestingType = null) Parameters Name Type Description type Type Required - the type of the expression. name String Required - the caller-defined name for this expression. expressionFactory Func < Expression > Required - Delegate to call to create the expression if it does not already exist. requestingType Type Optional - the type of the object requesting this shared expression. If this is provided, then the search for an existing shared expression will only work if the same requesting type was passed previously. Returns Type Description Expression Remarks Using shared expressions opens the door to potentially multiple optimisations, depending on the type of expression in question. For example, conditional expressions which share the same operand and comparand can all be merged into one with all the 'true' and 'false' branches being combined into one of each, thus saving multiple identical comparisons. <!-- .classchild --> GetOrAddSharedLocal(Type, String, Type) Similar to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) , except this is used when expression builders want to use local variables in block expressions to store the result of some operation in the expression tree built for a particular target. Reusing one local variable is more efficient than declaring the same local multiple times. Declaration ParameterExpression GetOrAddSharedLocal(Type type, string name, Type requestingType = null) Parameters Name Type Description type Type The type. name String The name. requestingType Type Optional - the type of the object requesting this shared expression. If this is provided, then the search for an existing shared expression will only work if the same requesting type was passed previously. Returns Type Description ParameterExpression Remarks When multiple expression trees from multiple targets are brought together into one lambda, there will often be many duplicate variables which could be shared. So, if an IExpressionBuilder needs a local variable for a block, instead of simply declaring it directly through the function, it can use this function instead, which will return a previously created one if available. <!-- .classchild --> NewContext(Type, Boolean, Nullable<Boolean>) Creates a new IExpressionCompileContext using this one as a seed. This function is identical to NewContext(Type, Nullable<Boolean>) but allows you to control whether the SharedExpressions are inherited (the default); and is more convenient because it returns another IExpressionCompileContext . Declaration IExpressionCompileContext NewContext(Type targetType = null, bool inheritSharedExpressions = true, bool ? suppressScopeTracking = null) Parameters Name Type Description targetType Type Optional. The type for which the target is to be compiled, if different from this context's . inheritSharedExpressions Boolean If true then the shared expressions in this context will be inherited by the new context by reference. That is, when the new context goes out of scope, any new shared expressions it created will still be available. If false, then the new context will get a brand new, empty, set of shared expressions. suppressScopeTracking Nullable < Boolean > The value passed here will be used for the new context's Returns Type Description IExpressionCompileContext Remarks When you have a reference to an IExpressionCompileContext the compiler will favour this method to the one defined on the ICompileContext interface because it is 'closer', even if you do not explicitly provide an argument for the inheritSharedExpressions parameter. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.IExpressionCompiler.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.IExpressionCompiler.html",
    "title": "Interface IExpressionCompiler",
    "keywords": "Interface IExpressionCompiler Interface for an object which is responsible for coordinating the production of expressions for targets during the compilation phase. Objects implementing this are expected to be implementations of ITargetCompiler ; this library provides the one implementation, too: ExpressionCompiler . Inherited Members ITargetCompiler.CompileTarget(ITarget, ICompileContext) Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public interface IExpressionCompiler : ITargetCompiler Remarks All expressions are built to be called from the GetObject(ResolveContext) function which, in turn, is typically called in response to a container's Resolve(ResolveContext) function being called. Note that the Build(ITarget, IExpressionCompileContext) method declared here is effectively an analogue to the Build(ITarget, IExpressionCompileContext, IExpressionCompiler) . Indeed, the default implementation resolves IExpressionBuilder instances to delegate the building of expressions. <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(ITarget, IExpressionCompileContext) Gets an unoptimised expression containing the logic required to create or fetch an instance of the target 's DeclaredType when invoked for a particular ResolveContext . Use this method if you want the raw expression for a target (possibly when integrating it into your own expressions during custom compilation). Declaration Expression Build(ITarget target, IExpressionCompileContext context) Parameters Name Type Description target ITarget The target. context IExpressionCompileContext The current compilation context. Returns Type Description Expression Remarks Whilst the returned expression can be directly used as the body for a new Expression<Func<ResolveContext, object>> , you should not use it for that, because the expression will not have had potential duplicate logic and variables optimised away. As mentioned in the summary, it's primarily useful when you want to incporate the code for one target inside that of another. If you want the optimised code for the passed target, you should use the BuildResolveLambda(ITarget, IExpressionCompileContext) function instead. <!-- .classchild --> BuildResolveLambda(ITarget, IExpressionCompileContext) Similar to the Build(ITarget, IExpressionCompileContext) function, except the returned lambda will be optimised and can be immediately compiled into a delegate and executed; or quoted inside another expression as a callback. The ResolveContextExpression of the context will be used to define the single parameter for the lambda that is created. Declaration Expression<Func<ResolveContext, object>> BuildResolveLambda(ITarget target, IExpressionCompileContext context) Parameters Name Type Description target ITarget The target. context IExpressionCompileContext The current compilation context. Returns Type Description Expression < Func < ResolveContext , Object >> <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ListTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ListTargetBuilder.html",
    "title": "Class ListTargetBuilder",
    "keywords": "Class ListTargetBuilder An IExpressionBuilder specialised for building expressions for the ListTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ListTarget > ListTargetBuilder Inherited Members ExpressionBuilderBase<ListTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.ListTarget>.Rezolver.Compilation.Expressions.IExpressionBuilder<Rezolver.ListTarget>.Build(Rezolver.ListTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) ExpressionBuilderBase<ListTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase.Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class ListTargetBuilder : ExpressionBuilderBase<ListTarget>, IExpressionBuilder<ListTarget>, IExpressionBuilder <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(ListTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression which either represents creating an array or a list of objects using an enumerable of targets from the target 's Items . The target's AsArray flag is used to determine which expression to build. Declaration protected override Expression Build(ListTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target ListTarget The target whose expression is to be built. context IExpressionCompileContext The compilation context. compiler IExpressionCompiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.ListTarget>.Build(Rezolver.ListTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ObjectTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ObjectTargetBuilder.html",
    "title": "Class ObjectTargetBuilder",
    "keywords": "Class ObjectTargetBuilder An IExpressionBuilder specialised to build expressions for the ObjectTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ObjectTarget > ObjectTargetBuilder Inherited Members ExpressionBuilderBase<ObjectTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.ObjectTarget>.Rezolver.Compilation.Expressions.IExpressionBuilder<Rezolver.ObjectTarget>.Build(Rezolver.ObjectTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) ExpressionBuilderBase<ObjectTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase.Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class ObjectTargetBuilder : ExpressionBuilderBase<ObjectTarget>, IExpressionBuilder<ObjectTarget>, IExpressionBuilder <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(ObjectTarget, IExpressionCompileContext, IExpressionCompiler) returns a ConstantExpression wrapped around the Value reference. Declaration protected override Expression Build(ObjectTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target ObjectTarget The target whose expression is to be built. context IExpressionCompileContext The compilation context. compiler IExpressionCompiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.ObjectTarget>.Build(Rezolver.ObjectTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Exceptions Type Condition NotImplementedException <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.OptionalParameterTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.OptionalParameterTargetBuilder.html",
    "title": "Class OptionalParameterTargetBuilder",
    "keywords": "Class OptionalParameterTargetBuilder An IExpressionBuilder specialised for building an expression for the OptionalParameterTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < OptionalParameterTarget > OptionalParameterTargetBuilder Inherited Members ExpressionBuilderBase<OptionalParameterTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.OptionalParameterTarget>.Rezolver.Compilation.Expressions.IExpressionBuilder<Rezolver.OptionalParameterTarget>.Build(Rezolver.OptionalParameterTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) ExpressionBuilderBase<OptionalParameterTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase.Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class OptionalParameterTargetBuilder : ExpressionBuilderBase<OptionalParameterTarget>, IExpressionBuilder<OptionalParameterTarget>, IExpressionBuilder <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(OptionalParameterTarget, IExpressionCompileContext, IExpressionCompiler) Declaration protected override Expression Build(OptionalParameterTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target OptionalParameterTarget context IExpressionCompileContext compiler IExpressionCompiler Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.OptionalParameterTarget>.Build(Rezolver.OptionalParameterTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.RedundantConvertRewriter.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.RedundantConvertRewriter.html",
    "title": "Class RedundantConvertRewriter",
    "keywords": "Class RedundantConvertRewriter Removes unnecessary convert expressions from an expression. An unnecessary conversion is one where the target type is equal to, or a base of, the source type. Only boxing/unboxing conversions or upcasts are left intact. Inheritance Object RedundantConvertRewriter Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class RedundantConvertRewriter : ExpressionVisitor <!-- <hr class=\"typeSectionDivider\" /> --> Methods VisitUnary(UnaryExpression) Visits the children of the UnaryExpression . Declaration protected override Expression VisitUnary(UnaryExpression node) Parameters Name Type Description node UnaryExpression The expression to visit. Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.RezolvedTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.RezolvedTargetBuilder.html",
    "title": "Class RezolvedTargetBuilder",
    "keywords": "Class RezolvedTargetBuilder An IExpressionBuilder specialised for building the expression for the RezolvedTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < RezolvedTarget > RezolvedTargetBuilder Inherited Members ExpressionBuilderBase<RezolvedTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.RezolvedTarget>.Rezolver.Compilation.Expressions.IExpressionBuilder<Rezolver.RezolvedTarget>.Build(Rezolver.RezolvedTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) ExpressionBuilderBase<RezolvedTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase.Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class RezolvedTargetBuilder : ExpressionBuilderBase<RezolvedTarget>, IExpressionBuilder<RezolvedTarget>, IExpressionBuilder <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(RezolvedTarget, IExpressionCompileContext, IExpressionCompiler) Declaration protected override Expression Build(RezolvedTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target RezolvedTarget context IExpressionCompileContext compiler IExpressionCompiler Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.RezolvedTarget>.Build(Rezolver.RezolvedTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ScopedTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ScopedTargetBuilder.html",
    "title": "Class ScopedTargetBuilder",
    "keywords": "Class ScopedTargetBuilder An IExpressionBuilder specialised for building expressions for ScopedTarget targets. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ScopedTarget > ScopedTargetBuilder Inherited Members ExpressionBuilderBase<ScopedTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.ScopedTarget>.Rezolver.Compilation.Expressions.IExpressionBuilder<Rezolver.ScopedTarget>.Build(Rezolver.ScopedTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) ExpressionBuilderBase<ScopedTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase.Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class ScopedTargetBuilder : ExpressionBuilderBase<ScopedTarget>, IExpressionBuilder<ScopedTarget>, IExpressionBuilder <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(ScopedTarget, IExpressionCompileContext, IExpressionCompiler) Declaration protected override Expression Build(ScopedTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target ScopedTarget context IExpressionCompileContext compiler IExpressionCompiler Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.ScopedTarget>.Build(Rezolver.ScopedTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.SingletonTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.SingletonTargetBuilder.html",
    "title": "Class SingletonTargetBuilder",
    "keywords": "Class SingletonTargetBuilder An IExpressionBuilder specialised for the building the expression for a SingletonTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < SingletonTarget > SingletonTargetBuilder Inherited Members ExpressionBuilderBase<SingletonTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.SingletonTarget>.Rezolver.Compilation.Expressions.IExpressionBuilder<Rezolver.SingletonTarget>.Build(Rezolver.SingletonTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) ExpressionBuilderBase<SingletonTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase.Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class SingletonTargetBuilder : ExpressionBuilderBase<SingletonTarget>, IExpressionBuilder<SingletonTarget>, IExpressionBuilder <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(SingletonTarget, IExpressionCompileContext, IExpressionCompiler) Declaration protected override Expression Build(SingletonTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target SingletonTarget context IExpressionCompileContext compiler IExpressionCompiler Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.SingletonTarget>.Build(Rezolver.SingletonTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.TargetExpression.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.TargetExpression.html",
    "title": "Class TargetExpression",
    "keywords": "Class TargetExpression An expression which represents an ITarget that can be baked into any type of expression during code generation. Used by the extensively. Inheritance Object TargetExpression Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class TargetExpression : Expression <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TargetExpression(ITarget) Initializes a new instance of the TargetExpression class. Declaration public TargetExpression(ITarget target) Parameters Name Type Description target ITarget The target. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties CanReduce Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form. Declaration public override bool CanReduce { get; } Property Value Type Description Boolean true if this instance can reduce; otherwise, false . Remarks The implementation always returns true ; although the Reduce() methodd is not implemented. <!-- .classchild --> NodeType Gets the node type of this . Declaration public override ExpressionType NodeType { get; } Property Value Type Description ExpressionType Always returns . <!-- .classchild --> Target Gets the target whose expression (obtained from ) will be subsituted for this TargetExpression in the final expression tree. Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> Type Gets the static type of the expression that this represents. Declaration public override Type Type { get; } Property Value Type Description Type Remarks Always returns the type referenced by the DeclaredType property of Target . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Reduce() Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced. Declaration public override Expression Reduce() Returns Type Description Expression Exceptions Type Condition NotSupportedException RezolveTargetExpression must be rewritten as a bona-fide expression before walking the expression tree for any other purpose <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.html",
    "title": "Namespace Rezolver.Compilation.Expressions",
    "keywords": "Namespace Rezolver.Compilation.Expressions Classes ChangeTypeTargetBuilder Implementation of IExpressionBuilder specialised to build expressions for the ChangeTypeTarget This always produces a conversion expression (i.e. cast or box/unbox) ConstructorTargetBuilder An IExpressionBuilder specialised for building the target ConstructorTarget DecoratorTargetBuilder Specialised builder for DecoratorTarget targets. DefaultTargetBuilder An IExpressionBuilder specialised for building the expression for the DefaultTarget target. Essentially, it just calls for the DeclaredType . DelegateTargetBuilder Specialised builder for the DelegateTarget class and all its derivatives. ExpressionBuilderBase Abstract starting point for implementing IExpressionBuilder . Note that the interface is implemented explicitly; but exposes protected abstract or virtual methods for inheritors to extend. ExpressionBuilderBase <TTarget> Abstract base class for implementations of IExpressionBuilder<TTarget> . Provide an implementation of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) and then register an instance in an ObjectTarget in the active container. ExpressionCompileContext An implementation of ICompileContext which is specialised for use by an IExpressionCompiler . ExpressionCompiler Implementation of the ITargetCompiler interface which produces ICompiledTarget objects by building and compiling expression trees from the ITarget objects which are registered. To enable the use of this compiler, use the extension method on your root target container. ExpressionTargetBuilder An IExpressionBuilder specialised for building the expression trees for the ExpressionTarget target type. This builder takes care of all expressions, including lambdas (where additional parameters beyond the standard ResolveContext are turned into local variables with injected values), producing an expression which can be compiled by an IExpressionCompiler after a Rezolver.Compilation.Expressions.TargetExpressionRewriter has been used to expand any targets embedded in the expression. GenericConstructorTargetBuilder An IExpressionBuilder specialised for building expressions for GenericConstructorTarget targets. ListTargetBuilder An IExpressionBuilder specialised for building expressions for the ListTarget target. ObjectTargetBuilder An IExpressionBuilder specialised to build expressions for the ObjectTarget target. OptionalParameterTargetBuilder An IExpressionBuilder specialised for building an expression for the OptionalParameterTarget target. RedundantConvertRewriter Removes unnecessary convert expressions from an expression. An unnecessary conversion is one where the target type is equal to, or a base of, the source type. Only boxing/unboxing conversions or upcasts are left intact. RezolvedTargetBuilder An IExpressionBuilder specialised for building the expression for the RezolvedTarget target. ScopedTargetBuilder An IExpressionBuilder specialised for building expressions for ScopedTarget targets. SingletonTargetBuilder An IExpressionBuilder specialised for the building the expression for a SingletonTarget target. TargetExpression An expression which represents an ITarget that can be baked into any type of expression during code generation. Used by the extensively. Interfaces IExpressionBuilder The interface for an object that produces expressions (which can be compiled to delegates) from ITarget instances. IExpressionBuilder <TTarget> Interface for an object that produces expressions from instances of TTarget . This is a generic extension to the IExpressionBuilder interface. IExpressionCompileContext Extension to the ICompileContext interface which provides additional state and functionality for the IExpressionCompiler and the IExpressionBuilder implementations which are used by the default expression compiler, the ExpressionCompiler class. IExpressionCompiler Interface for an object which is responsible for coordinating the production of expressions for targets during the compilation phase. Objects implementing this are expected to be implementations of ITargetCompiler ; this library provides the one implementation, too: ExpressionCompiler ."
  },
  "rezolver-api/Rezolver.Compilation.ICompileContext.html": {
    "href": "rezolver-api/Rezolver.Compilation.ICompileContext.html",
    "title": "Interface ICompileContext",
    "keywords": "Interface ICompileContext Tracks state and provides services during the compilation phase in which ITarget targets are compiled into ICompiledTarget targets, which produce actual instances of objects. Inherited Members ITargetContainer.Register(ITarget, Type) ITargetContainer.Fetch(Type) ITargetContainer.FetchAll(Type) ITargetContainer.CombineWith(ITargetContainer, Type) Namespace :Rezolver.Compilation Assembly :cs.temp.dll.dll Syntax public interface ICompileContext : ITargetContainer Remarks Implementations must also implement the ITargetContainer so the compile context can be used for dependency lookups during compilation time. Indeed, if you are developing your own compilation component (possibly for a custom ITarget implementation) and need to resolve any dependencies from an ITargetContainer during compilation, it should be done through the context's implementation of ITargetContainer. <!-- <hr class=\"typeSectionDivider\" /> --> Properties CompileStack Gets the stack entries for all the targets that are being compiled. Declaration IEnumerable<CompileStackEntry> CompileStack { get; } Property Value Type Description IEnumerable < CompileStackEntry > The compile stack. <!-- .classchild --> Container The container that is considered the current compilation 'scope' - i.e. the container for which the compilation is being performed and, usually, the one on which the Resolve(ResolveContext) method was originally called which triggered the compilation call. Declaration IContainer Container { get; } Property Value Type Description IContainer <!-- .classchild --> ParentContext Gets the parent context from which this context was created, if applicable. Declaration ICompileContext ParentContext { get; } Property Value Type Description ICompileContext The parent context. <!-- .classchild --> SuppressScopeTracking If true, then any target that is compiling within this context should not generate any runtime code to fetch the object from, or track the object in, the current IScopedContainer . Declaration bool SuppressScopeTracking { get; } Property Value Type Description Boolean Remarks This is currently used, for example, by wrapper targets that generate their own scope tracking code (specifically, the SingletonTarget and ScopedTarget . It's therefore very important that any custom ITarget implementations which intend to do their own scoping honour this flag in their implementation. The TargetBase class does honour this flag. <!-- .classchild --> TargetType Any ICompiledTarget built for a ITarget with this context should target this type. If null, then the DeclaredType of the target being compiled should be used. Declaration Type TargetType { get; } Property Value Type Description Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods NewContext(Type, Nullable<Boolean>) Creates a new child context from this one, except the TargetType and SuppressScopeTracking properties can be overriden if required, the rest of the state is inherited from this context. Declaration ICompileContext NewContext(Type targetType = null, bool ? suppressScopeTracking = null) Parameters Name Type Description targetType Type Optional. The type for which the target is to be compiled, if different from this context's TargetType . suppressScopeTracking Nullable < Boolean > The value passed here will be used for the new context's SuppressScopeTracking Returns Type Description ICompileContext A new ICompileContext . <!-- .classchild --> PopCompileStack() Pops the compile stack, returning the entry that was popped. Declaration CompileStackEntry PopCompileStack() Returns Type Description CompileStackEntry <!-- .classchild --> PushCompileStack(ITarget) Pushes the passed target on to the compile stack if it's not already on it for the same TargetType Compilers should consult the return value and abort compilation if it's true - since that implies a cyclic dependency graph. Declaration bool PushCompileStack(ITarget toCompile) Parameters Name Type Description toCompile ITarget Returns Type Description Boolean Remarks Targets can appear on the compilation stack more than once for different types, since the ICompiledTarget produced for a target for one type can be different than it is for another. Ultimately, if a target does in fact have a cyclic dependency graph, then the PushCompileStack(ITarget) method will detect it. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.ICompileContextProvider.html": {
    "href": "rezolver-api/Rezolver.Compilation.ICompileContextProvider.html",
    "title": "Interface ICompileContextProvider",
    "keywords": "Interface ICompileContextProvider Interface for an object which creates ICompileContext instances for when the system needs to compile an ITarget into an ICompiledTarget . Namespace :Rezolver.Compilation Assembly :cs.temp.dll.dll Syntax public interface ICompileContextProvider Remarks In normal operation, this interface is closely related to the ITargetCompiler interface because the core ContainerBase class (which provides most of the default implementation for IContainer ) obtains a new ICompileContext by resolving an instance of this interface, and calling the CreateContext(ResolveContext, ITargetContainer, IContainer) method, passing the result to the CompileTarget(ITarget, ICompileContext) method, along with the target to be compiled. Frequently, implementations of ITargetCompiler will also implement this interface to ensure that the compilation context contains everything the compiler needs to do its work. <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateContext(ResolveContext, ITargetContainer, IContainer) Creates a compilation context for the given resolveContext - which is used to determine the RequestedType that the eventual ICompiledTarget should return. Declaration ICompileContext CreateContext(ResolveContext resolveContext, ITargetContainer targets, IContainer containerOverride = null) Parameters Name Type Description resolveContext ResolveContext The resolve context - used to get the RequestedType and the Container (if containerOverride is not provided). targets ITargetContainer The target container that should be used to lookup other non-compiled targets. containerOverride IContainer The container requesting the new compilation context, if different from the Container on the resolveContext Returns Type Description ICompileContext <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.ITargetCompiler.html": {
    "href": "rezolver-api/Rezolver.Compilation.ITargetCompiler.html",
    "title": "Interface ITargetCompiler",
    "keywords": "Interface ITargetCompiler An object that produces ICompiledTarget s from ITarget s given a particular ICompileContext . Namespace :Rezolver.Compilation Assembly :cs.temp.dll.dll Syntax public interface ITargetCompiler <!-- <hr class=\"typeSectionDivider\" /> --> Methods CompileTarget(ITarget, ICompileContext) Create the ICompiledTarget for the given target using the context to inform the type of object that is to be built, and for compile-time dependency resolution. Declaration ICompiledTarget CompileTarget(ITarget target, ICompileContext context) Parameters Name Type Description target ITarget Required. The target to be compiled. context ICompileContext Required. The current compilation context. Returns Type Description ICompiledTarget A compiled target which can then be used to get produce objects represented by the target . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.SharedExpressionKey.html": {
    "href": "rezolver-api/Rezolver.Compilation.SharedExpressionKey.html",
    "title": "Class SharedExpressionKey",
    "keywords": "Class SharedExpressionKey Key for a shared expression used during expression tree generation. As a consumer of this library, you are unlikely ever to need to use it. Inheritance Object SharedExpressionKey Inherited Members Object.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation Assembly :cs.temp.dll.dll Syntax public class SharedExpressionKey : IEquatable<SharedExpressionKey> <!-- <hr class=\"typeSectionDivider\" /> --> Constructors SharedExpressionKey(Type, String, Type) Initializes a new instance of the SharedExpressionKey class. Declaration public SharedExpressionKey(Type targetType, string name, Type requestingType = null) Parameters Name Type Description targetType Type Required. Eventual runtime type of the object produced by the expression that will be cached using this key. name String Required. The name used for storing and retrieving expressions cached with this key. requestingType Type The type (e.g. the runtime type of an ITarget implementation) whose compilation requires the cached expression. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Name Gets the name used for expressions that are cached using this key. Declaration public string Name { get; } Property Value Type Description String The name. <!-- .classchild --> RequestingType Gets the type that registered the shared expression Declaration public Type RequestingType { get; } Property Value Type Description Type <!-- .classchild --> TargetType The intended type of the expression that is cached by this key. Declaration public Type TargetType { get; } Property Value Type Description Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Equals(SharedExpressionKey) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(SharedExpressionKey other) Parameters Name Type Description other SharedExpressionKey An object to compare with this object. Returns Type Description Boolean true if the current object is equal to the other parameter; otherwise, false. Implements IEquatable<SharedExpressionKey>.Equals(SharedExpressionKey) <!-- .classchild --> Equals(Object) Determines whether the specified Object is equal to this instance. Declaration public override bool Equals(object obj) Parameters Name Type Description obj Object The object to compare with the current object. Returns Type Description Boolean true if the specified Object is equal to this instance; otherwise, false . Overrides Object.Equals(Object) <!-- .classchild --> GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description Int32 A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. Overrides Object.GetHashCode() <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.TargetCompiler.html": {
    "href": "rezolver-api/Rezolver.Compilation.TargetCompiler.html",
    "title": "Class TargetCompiler",
    "keywords": "Class TargetCompiler Holds a reference to the default compiler for this application. Inheritance Object TargetCompiler Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation Assembly :cs.temp.dll.dll Syntax public static class TargetCompiler <!-- <hr class=\"typeSectionDivider\" /> --> Properties Default The default compiler to be used by rezolvers when they are not explicitly provided one. Declaration public static ITargetCompiler Default { get; set; } Property Value Type Description ITargetCompiler <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.html": {
    "href": "rezolver-api/Rezolver.Compilation.html",
    "title": "Namespace Rezolver.Compilation",
    "keywords": "Namespace Rezolver.Compilation Classes CompileContext Core implementation of ICompileContext . A root context (i.e. where ParentContext is null ; created via the CompileContext(IContainer, ITargetContainer, Type) constructor) is the starting point for all shared state, such as the Container and the compilation stack. The ITargetContainer implementation is done by decorating a new ChildTargetContainer , so that new registrations can be added without interfering with upstream containers. Note that many of the interface members are implemented explicitly - therefore most of your interaction with this type is through its implementation of ICompileContext and ITargetContainer . CompileStackEntry Represents an entry in the compilation stack of a ICompileContext , recording both a target that is being compiled, and the type for which it is being compiled. SharedExpressionKey Key for a shared expression used during expression tree generation. As a consumer of this library, you are unlikely ever to need to use it. TargetCompiler Holds a reference to the default compiler for this application. Interfaces ICompileContext Tracks state and provides services during the compilation phase in which ITarget targets are compiled into ICompiledTarget targets, which produce actual instances of objects. ICompileContextProvider Interface for an object which creates ICompileContext instances for when the system needs to compile an ITarget into an ICompiledTarget . ITargetCompiler An object that produces ICompiledTarget s from ITarget s given a particular ICompileContext ."
  },
  "rezolver-api/Rezolver.CompileContext.CompileStackEntry.html": {
    "href": "rezolver-api/Rezolver.CompileContext.CompileStackEntry.html",
    "title": "Class CompileContext.CompileStackEntry",
    "keywords": "Class CompileContext.CompileStackEntry Represents an Inheritance Object CompileContext.CompileStackEntry Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class CompileStackEntry : IEquatable<CompileContext.CompileStackEntry> <!-- <hr class=\"typeSectionDivider\" /> --> Constructors CompileStackEntry(ITarget, Type) Declaration public CompileStackEntry(ITarget target, Type compilingType) Parameters Name Type Description target ITarget compilingType Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties CompilingType Declaration public Type CompilingType { get; } Property Value Type Description Type <!-- .classchild --> Target Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Equals(CompileContext.CompileStackEntry) Declaration public bool Equals(CompileContext.CompileStackEntry other) Parameters Name Type Description other CompileContext.CompileStackEntry Returns Type Description Boolean Implements IEquatable<CompileContext.CompileStackEntry>.Equals(CompileContext.CompileStackEntry) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.CompileContext.SharedExpressionKey.html": {
    "href": "rezolver-api/Rezolver.CompileContext.SharedExpressionKey.html",
    "title": "Class CompileContext.SharedExpressionKey",
    "keywords": "Class CompileContext.SharedExpressionKey Key for a shared expression used during expression tree generation. As a consumer of this library, you are unlikely ever to need to use it. Inheritance Object CompileContext.SharedExpressionKey Inherited Members Object.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class SharedExpressionKey : IEquatable<CompileContext.SharedExpressionKey> <!-- <hr class=\"typeSectionDivider\" /> --> Constructors SharedExpressionKey(Type, String, Type) Initializes a new instance of the CompileContext.SharedExpressionKey class. Declaration public SharedExpressionKey(Type targetType, string name, Type requestingType = null) Parameters Name Type Description targetType Type Required. Eventual runtime type of the object produced by the expression that will be cached using this key. name String Required. The name used for storing and retrieving expressions cached with this key. requestingType Type The type (e.g. the runtime type of an ITarget implementation) whose compilation requires the cached expression. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Name Gets the name used for expressions that are cached using this key. Declaration public string Name { get; } Property Value Type Description String The name. <!-- .classchild --> RequestingType Gets the type that registered the shared expression Declaration public Type RequestingType { get; } Property Value Type Description Type <!-- .classchild --> TargetType The intended type of the expression that is cached by this key. Declaration public Type TargetType { get; } Property Value Type Description Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Equals(CompileContext.SharedExpressionKey) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(CompileContext.SharedExpressionKey other) Parameters Name Type Description other CompileContext.SharedExpressionKey An object to compare with this object. Returns Type Description Boolean true if the current object is equal to the other parameter; otherwise, false. Implements IEquatable<CompileContext.SharedExpressionKey>.Equals(CompileContext.SharedExpressionKey) <!-- .classchild --> Equals(Object) Determines whether the specified Object is equal to this instance. Declaration public override bool Equals(object obj) Parameters Name Type Description obj Object The object to compare with the current object. Returns Type Description Boolean true if the specified Object is equal to this instance; otherwise, false . Overrides Object.Equals(Object) <!-- .classchild --> GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description Int32 A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. Overrides Object.GetHashCode() <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.CompileContext.html": {
    "href": "rezolver-api/Rezolver.CompileContext.html",
    "title": "Class CompileContext",
    "keywords": "Class CompileContext Provides support and compile-time state for the compilation of an ITarget by an ITargetCompiler . THIS CLASS IS NOT THREAD-SAFE Inheritance Object CompileContext Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class CompileContext : ITargetContainer Remarks The purpose of this class is to help an ITarget generate an expression tree that will ultimately be compiled using CompileTarget(ITarget, CompileContext) method. The goal being to produce an ICompiledTarget whose Rezolver.ICompiledTarget.GetObject(Rezolver.RezolveContext) method will be called to get instances when a container's Rezolver.IContainer.Resolve(Rezolver.RezolveContext) method is invoked. Therefore, the context of the expression tree being generated is a method which takes a single RezolveContext parameter - hence the expressions exposed by this type (e.g. RezolveContextExpression ) are there to help generate code that will work in that context. Working directly with this, or any other code connected with the expression tree/compilation process, is an advanced topic! The class implements the ITargetContainer interface also to extend dependency lookups during compilation time. Indeed, if you are developing your own ITarget implementation and need to resolve any dependencies from an ITargetContainer during compilation, it should be done through the context's implementation of ITargetContainer. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors CompileContext(CompileContext, Type, Boolean, Boolean) Creates a new CompileContext using an existing one as a template. Declaration public CompileContext(CompileContext parentContext, Type targetType = null, bool inheritSharedExpressions = true, bool suppressScopeTracking = false) Parameters Name Type Description parentContext CompileContext Used to seed the compilation stack, container, rezolve context parameter and optionally the target type (if you pass null for targetType . targetType Type The target type that is expected to be compiled, or null to inherit the parentContext 's TargetType property. inheritSharedExpressions Boolean If true (the default), then the SharedExpressions for this context will be shared from the parent context - meaning that any new additions will be added back to the parent context again. This is the most common behaviour when chaining multiple targets' expressions together. Passing false for this parameter is only required in rare situations. suppressScopeTracking Boolean If true, then any expressions constructed from ITarget objects should not contain automatically generated code to track objects in an enclosing scope. The default is false. This is typically only enabled when one target is explicitly using expressions created from other targets, and has its own scope tracking code, or expects to be surrounded by automatically generated scope tracking code itself. <!-- .classchild --> CompileContext(IContainer, ITargetContainer, Type, ParameterExpression, IEnumerable<CompileContext.CompileStackEntry>) Creates a new CompileContext Declaration public CompileContext(IContainer container, ITargetContainer dependencyTargetContainer, Type targetType = null, ParameterExpression rezolveContextExpression = null, IEnumerable<CompileContext.CompileStackEntry> compilingTargets = null) Parameters Name Type Description container IContainer Required. The container for which compilation is being performed. Will be set into the Container property. dependencyTargetContainer ITargetContainer Required - An ITargetContainer that contains the ITarget s that will be required to complete compilation. Note - this argument is passed to a new ChildTargetContainer that is created and proxied by this class' implementation of ITargetContainer . As a result, it's possible to register new targets directly into the context via the Register(ITarget, Type) method, without modifying the underlying targets in the container you pass. Some of the core ITarget s exposed by this library take advantage of that functionality (notably, the DecoratorTarget ). targetType Type Optional. Will be set into the TargetType property. If not provided, then any code generated within this context should compile for the DeclaredType . rezolveContextExpression ParameterExpression Optional. Will be set into the RezolveContextExpression property. If not provided, then the RezolveContextParameterExpression global reference will be used. compilingTargets IEnumerable < CompileContext.CompileStackEntry > Optional. Allows you to seed the stack of compiling targets from creation. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties CompilingTargets An enumerable representing the current stack of targets that are being compiled on this context. The underlying stack is not exposed through this enumerable. Declaration public IEnumerable<CompileContext.CompileStackEntry> CompilingTargets { get; } Property Value Type Description IEnumerable < CompileContext.CompileStackEntry > <!-- .classchild --> Container The container that is considered the current compilation 'scope' - i.e. the container for which the compilation is being performed and, usually, the one on which the Rezolver.IContainer.Resolve(Rezolver.RezolveContext) method was originally called which triggered the compilation call. Declaration public IContainer Container { get; } Property Value Type Description IContainer Remarks NOTE - For compile-time dependency resolution (i.e. other ITarget s) you should use this class' implementation of ITargetContainer . <!-- .classchild --> ContainerExpression A ConstantExpression that equals the Container that is active for this context - you can use this during code generation to alter your expression's behaviour if the Container during a future call to Rezolver.IContainer.Resolve(Rezolver.RezolveContext) is different from the one for which the expression was first compiled. For this kind of behaviour you will also need to use the RezolveContextExpression Declaration public Expression ContainerExpression { get; } Property Value Type Description Expression <!-- .classchild --> ContextContainerPropertyExpression Returns an expression that represents reading the Container property of the RezolveContextExpression during the execution of an ICompiledTarget 's Rezolver.ICompiledTarget.GetObject(Rezolver.RezolveContext) method. Declaration public MemberExpression ContextContainerPropertyExpression { get; } Property Value Type Description MemberExpression Remarks This IS NOT the same as the ContainerExpression property, which always returns a constant reference to the original IContainer for which this compilation context was created. Always non-null. <!-- .classchild --> ContextScopePropertyExpression Returns an expression that represents reading the Scope property of the RezolveContext referenced by the RezolveContextExpression at resolve-time. Declaration public MemberExpression ContextScopePropertyExpression { get; } Property Value Type Description MemberExpression <!-- .classchild --> RezolveContextExpression An expression to be used to bind to the RezolveContext parameter be passed to the generated code at runtime (the context parameter for Rezolver.IContainer.Resolve(Rezolver.RezolveContext) and, eventually, Rezolver.ICompiledTarget.GetObject(Rezolver.RezolveContext) ). Declaration public ParameterExpression RezolveContextExpression { get; } Property Value Type Description ParameterExpression Remarks If this is never explicitly set, the framework uses RezolveContextParameterExpression by default. In theory, you should never need to set this to anything else, unless you're doing something very interesting with the generated expressions. <!-- .classchild --> SharedExpressions The expressions that have been registered by targets whilst creating expressions for compiled targets. Declaration public IEnumerable<Expression> SharedExpressions { get; } Property Value Type Description IEnumerable < Expression > Remarks Shared expressions are expressions which targets add to the compile context as they are compiled, enabling them to generate code which is both more efficient at runtime (e.g. avoiding the creation of redundant locals for blocks which can reuse a pre-existing local) and which can be more efficiently rewritten due to the reuse of identical expression references for things like conditional checks and so on. A compiler MUST handle the case where this enumerable contains ParameterExpressions, as they will need to be added as local variables to an all-encompassing BlockExpression around the root of an expression tree that is to be compiled. <!-- .classchild --> SuppressScopeTracking If true, then any target that is compiling within this context should not generate any runtime code to fetch the object from, or track the object in, the current IScopedContainer (identified by the ContextScopePropertyExpression ). Declaration public bool SuppressScopeTracking { get; } Property Value Type Description Boolean Remarks This is currently used, for example, by wrapper targets that generate their own scope tracking code (specifically, the SingletonTarget and ScopedTarget . It's therefore very important that any custom ITarget implementations which intend to do their own scoping honour this flag in their implementation of Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) . The TargetBase class does honour this flag. <!-- .classchild --> TargetType The type that is to be returned by the generated code. Declaration public Type TargetType { get; } Property Value Type Description Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CombineWith(ITargetContainer, Type) Always throws a NotSupportedException Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer Ignored type Type Ignored Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) Exceptions Type Condition NotSupportedException Always thrown <!-- .classchild --> Fetch(Type) Implements Fetch(Type) by wrapping around the child target container created by this context on construction. Declaration public ITarget Fetch(Type type) Parameters Name Type Description type Type See Fetch(Type) for more. Returns Type Description ITarget Implements ITargetContainer.Fetch(Type) <!-- .classchild --> FetchAll(Type) Implements FetchAll(Type) by wrapping around the child target container created by this context on construction. Declaration public IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type Type See FetchAll(Type) for more Returns Type Description IEnumerable < ITarget > Implements ITargetContainer.FetchAll(Type) <!-- .classchild --> GetOrAddSharedExpression(Type, String, Func<Expression>, Type) Gets or adds a shared expression (created by the expressionFactory if it's not already cached) with the given name, type, optionally for the given requestingType . Declaration public Expression GetOrAddSharedExpression(Type type, string name, Func<Expression> expressionFactory, Type requestingType = null) Parameters Name Type Description type Type The runtime type of the Expression. name String The runtime name of the Expression - and also the name used to retrieve it later. expressionFactory Func < Expression > The factory method to use to construct the shared expression from scratch, if it's not already cached. requestingType Type Optional - to avoid naming clashes with shared expressions created by other targets, you can pass a type here (usually the runtime type of your ITarget implementation). Returns Type Description Expression Expression. <!-- .classchild --> GetOrAddSharedLocal(Type, String, Type) Creates or retrieves a shared with the given name and type, optionally registered for the given requestingType . Declaration public ParameterExpression GetOrAddSharedLocal(Type type, string name, Type requestingType = null) Parameters Name Type Description type Type The runtime type of the ParameterExpression. name String The runtime name of the ParameterExpression - and also the name used to retrieve it later. requestingType Type Optional - to avoid naming clashes with shared parameter expressions created by other targets, you can pass a type here (usually the runtime type of your ITarget implementation). Returns Type Description ParameterExpression Remarks If you use a shared for a local in your expression trees, you are signifying that all of your targets which use that local, regardless of whether they represent different results at runtime, can safely store and retrieve whatever state they are tracking within without interfering with each other. <!-- .classchild --> New(Type, Boolean, Boolean) Spawns a new context for the passed targetType , with everything else being inherited from this context by default. Declaration public CompileContext New(Type targetType, bool inheritSharedExpressions = true, bool suppressScopeTracking = false) Parameters Name Type Description targetType Type Required. The type to be compiled. inheritSharedExpressions Boolean if set to true [inherit shared expressions]. suppressScopeTracking Boolean if set to true [suppress scope tracking]. Returns Type Description CompileContext A new CompileContext Remarks This is a convenience method which simply wraps the CompileContext(CompileContext, Type, Boolean, Boolean) constructor, except in this method the targetType is required. <!-- .classchild --> PopCompileStack() Pops a target from the stack and returns it. Note that if there are no targets on the stack, an InvalidOperationException will occur. Declaration public CompileContext.CompileStackEntry PopCompileStack() Returns Type Description CompileContext.CompileStackEntry <!-- .classchild --> PushCompileStack(ITarget) Adds the target to the compilation stack if it doesn't already exist. Declaration public bool PushCompileStack(ITarget toCompile) Parameters Name Type Description toCompile ITarget The target to be pushed Returns Type Description Boolean A boolean indicating whether the target was added. Will be false if the target is already on the stack. <!-- .classchild --> Register(ITarget, Type) Implements Register(ITarget, Type) by wrapping around the child target container created by this context on construction. Declaration public void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget See Register(ITarget, Type) for more serviceType Type See Register(ITarget, Type) for more Implements ITargetContainer.Register(ITarget, Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.CompiledTargetBase.html": {
    "href": "rezolver-api/Rezolver.CompiledTargetBase.html",
    "title": "Class CompiledTargetBase",
    "keywords": "Class CompiledTargetBase Standard starting point for an implementation of ICompiledTarget where the target is built directly from an ITarget . Inheritance Object CompiledTargetBase Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public abstract class CompiledTargetBase : ICompiledTarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors CompiledTargetBase(ITarget) Initialises the CompiledTargetBase abstract class. Declaration protected CompiledTargetBase(ITarget originalTarget) Parameters Name Type Description originalTarget ITarget Required - the target that was compiled into this instance. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties OriginalTarget The target whose expression (obtained from Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) ) was compiled into this instance. Will not be null. Declaration protected ITarget OriginalTarget { get; } Property Value Type Description ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetObject(RezolveContext) Abstract implementation of Rezolver.ICompiledTarget.GetObject(Rezolver.RezolveContext) Declaration public abstract object GetObject(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description Object Implements Rezolver.ICompiledTarget.GetObject(Rezolver.RezolveContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ConditionalRewriter.html": {
    "href": "rezolver-api/Rezolver.ConditionalRewriter.html",
    "title": "Class ConditionalRewriter",
    "keywords": "Class ConditionalRewriter Reorders an expression tree where duplicate conditional expressions are found in multiple places throughout that expression tree. Those duplicated conditionals are moved further up the expression tree into one conditional. Inheritance Object ConditionalRewriter Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ConditionalRewriter : ExpressionVisitor <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConditionalRewriter(Expression, IEnumerable<Expression>) Declaration public ConditionalRewriter(Expression expression, IEnumerable<Expression> candidateTests) Parameters Name Type Description expression Expression candidateTests IEnumerable < Expression > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Rewrite() Declaration public Expression Rewrite() Returns Type Description Expression <!-- .classchild --> Visit(Expression) Declaration public override Expression Visit(Expression node) Parameters Name Type Description node Expression Returns Type Description Expression <!-- .classchild --> VisitConditional(ConditionalExpression) Declaration protected override Expression VisitConditional(ConditionalExpression node) Parameters Name Type Description node ConditionalExpression Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.AssemblyReferenceEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.AssemblyReferenceEntry.html",
    "title": "Class AssemblyReferenceEntry",
    "keywords": "Class AssemblyReferenceEntry Inheritance Object ConfigurationEntryBase AssemblyReferenceEntry Inherited Members ConfigurationEntryBase.Type ConfigurationEntryBase.StartLineNo ConfigurationEntryBase.StartLinePos ConfigurationEntryBase.EndLineNo ConfigurationEntryBase.EndLinePos Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class AssemblyReferenceEntry : ConfigurationEntryBase, IAssemblyReferenceEntry, IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors AssemblyReferenceEntry(String, IConfigurationLineInfo) Declaration public AssemblyReferenceEntry(string assemblyName, IConfigurationLineInfo lineInfo = null) Parameters Name Type Description assemblyName String lineInfo IConfigurationLineInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties AssemblyName Declaration public string AssemblyName { get; } Property Value Type Description String Implements IAssemblyReferenceEntry.AssemblyName <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapter.ConfigurationEntryProcessOrderer.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapter.ConfigurationEntryProcessOrderer.html",
    "title": "Class ConfigurationAdapter.ConfigurationEntryProcessOrderer",
    "keywords": "Class ConfigurationAdapter.ConfigurationEntryProcessOrderer Used by the ConfigurationAdapter class to sort configuration entries for processing. It ensures that Assembly Reference entries are given priority, followed by Namespace Imports, and then finally all the rest. Inheritance Object ConfigurationAdapter.ConfigurationEntryProcessOrderer Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax protected class ConfigurationEntryProcessOrderer : IComparer<IConfigurationEntry> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Compare(IConfigurationEntry, IConfigurationEntry) Declaration public int Compare(IConfigurationEntry x, IConfigurationEntry y) Parameters Name Type Description x IConfigurationEntry y IConfigurationEntry Returns Type Description Int32 Implements IComparer<IConfigurationEntry>.Compare(IConfigurationEntry, IConfigurationEntry) <!-- .classchild -->"
  },
  "index.html": {
    "href": "index.html",
    "title": "Rezolver",
    "keywords": "Improve this Doc Rezolver Welcome to the home of Rezolver - here you'll find guides, walkthroughs, deep-dives and reference for all of the APIs and functionality in the Rezolver library. What is Rezolver? Rezolver is (yet another :)) open source IOC container. It supports many of the features supported by most other popular IOC containers out there, integrates into the new .Net Core 1.0 framework (supporting the NetStandard1.1 profile), and supports some unique functionality too. It's very fast, extensible and reliable, and should slot nicely into any project in which you already have another IOC container. Quick Links Getting Started <!--- [Nuget Packages](rezolver-usage/nuget-packages/) --> API Reference Please note - this documentation is a work in progress! Rezolver is currently undergoing an API change which has invalidated some of the documentation we had before. Once everything is built and re-tested, all the documentation will be added ASAP to provide in-depth guides and tutorials which are then guaranteed to stand the test of time! So, keep coming back! We'll get there :) If you're the kind of person who likes to learn from seeing the code - then check out the Rezolver repo on Github , there are some example applications on there, and you can look at the unit tests to get an idea of how to create and configure containers."
  },
  "rezolver-api/index.html": {
    "href": "rezolver-api/index.html",
    "title": "Rezolver API reference",
    "keywords": "Improve this Doc Rezolver API reference Looking for documentation on individual classes or methods in the Rezolver project? You've come to the right place! Crucial types to look at are: TargetContainer (implements ITargetContainer ): Stores ITarget instances, and is the main class you'll use for your 'registration' phase Container (implements IContainer ): The standard, non-scoped, container you'll use in your composition root - you can create child scopes from this by calling its implementation of CreateLifetimeScope() . This class requires an ITargetContainer for its registrations"
  },
  "rezolver-usage/index.html": {
    "href": "rezolver-usage/index.html",
    "title": "1. Getting started",
    "keywords": "Improve this Doc 1. Getting started As with many open source .Net projects, there are two primary ways to get Rezolver integrated into your project. The easiest is via the Nuget packages By using the Nuget packages, you ensure that you're using the latest (hopefully stable!) releases. Alpha packages will also be made available for in-development features. Fork or download the source from Github Use this if you can't integrate nuget into your build pipeline, or if you'd like to customise or contribute to the project. If you're looking to customise, though, then there should be enough extensibility points in the framework to allow you to do so without having to change core types. If that's not the case, post an issue on the Github project so we can get it added in and make it better for everyone! Once you've got the main assembly referenced (Rezolver.dll) - then you can create a Container , register targets against its internal ITargetContainer target container, and then grab objects from it! Notice: This documentation is not complete!!!"
  },
  "rezolver-api/toc.html": {
    "href": "rezolver-api/toc.html",
    "title": "Table of Content",
    "keywords": ""
  },
  "toc.html": {
    "href": "toc.html",
    "title": "Table of Content",
    "keywords": ""
  },
  "rezolver-api/Microsoft.Extensions.DependencyInjection.IServiceCollectionExtensions.html": {
    "href": "rezolver-api/Microsoft.Extensions.DependencyInjection.IServiceCollectionExtensions.html",
    "title": "Class IServiceCollectionExtensions",
    "keywords": "Class IServiceCollectionExtensions Rezolver interop extension methods for the IServiceCollection class in Microsoft.Extensions.DependencyInjection Inheritance Object IServiceCollectionExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Microsoft.Extensions.DependencyInjection Assembly :cs.temp.dll.dll Syntax public static class IServiceCollectionExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateRezolverContainer(IServiceCollection) Creates a new default and registers the services in services as targets. Declaration public static IContainer CreateRezolverContainer(this IServiceCollection services) Parameters Name Type Description services IServiceCollection The services to be registered. Returns Type Description IContainer An instance Exceptions Type Condition ArgumentNullException If services is null. <!-- .classchild --> RegisterTargets(IServiceCollection, ITargetContainer) Registers services in services as targets in the passed targetContainer Declaration public static void RegisterTargets(this IServiceCollection services, ITargetContainer targetContainer) Parameters Name Type Description services IServiceCollection The services to b registered. targetContainer ITargetContainer The target container that is to receive the new registrations. Remarks This extension method just uses the method also found in this library. Exceptions Type Condition ArgumentNullException If either services or targetContainer are null. <!-- .classchild -->"
  },
  "rezolver-api/Microsoft.Extensions.DependencyInjection.RezolverServiceCollectionExtensions.html": {
    "href": "rezolver-api/Microsoft.Extensions.DependencyInjection.RezolverServiceCollectionExtensions.html",
    "title": "Class RezolverServiceCollectionExtensions",
    "keywords": "Class RezolverServiceCollectionExtensions Rezolver interop extension methods for the IServiceCollection class in Microsoft.Extensions.DependencyInjection Inheritance Object RezolverServiceCollectionExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Microsoft.Extensions.DependencyInjection Assembly :cs.temp.dll.dll Syntax public static class RezolverServiceCollectionExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateRezolverContainer(IServiceCollection) Creates a new default and registers the services in services as targets. Declaration public static IContainer CreateRezolverContainer(this IServiceCollection services) Parameters Name Type Description services IServiceCollection The services to be registered. Returns Type Description IContainer An instance Exceptions Type Condition ArgumentNullException If services is null. <!-- .classchild --> RegisterTargets(IServiceCollection, ITargetContainer) Registers services in services as targets in the passed targetContainer Declaration public static void RegisterTargets(this IServiceCollection services, ITargetContainer targetContainer) Parameters Name Type Description services IServiceCollection The services to be registered. targetContainer ITargetContainer The target container that is to receive the new registrations. Remarks This extension method just uses the method also found in this library. Exceptions Type Condition ArgumentNullException If either services or targetContainer are null. <!-- .classchild -->"
  },
  "rezolver-api/Microsoft.Extensions.DependencyInjection.html": {
    "href": "rezolver-api/Microsoft.Extensions.DependencyInjection.html",
    "title": "Namespace Microsoft.Extensions.DependencyInjection",
    "keywords": "Namespace Microsoft.Extensions.DependencyInjection Classes RezolverServiceCollectionExtensions Rezolver interop extension methods for the IServiceCollection class in Microsoft.Extensions.DependencyInjection"
  },
  "rezolver-api/Rezolver.AliasTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.AliasTargetContainerExtensions.html",
    "title": "Class AliasTargetContainerExtensions",
    "keywords": "Class AliasTargetContainerExtensions Contains extension methods for ITargetContainer to create targets which alias others by different types. Inheritance Object AliasTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class AliasTargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterAlias(ITargetContainer, Type, Type) Registers an alias for one type to another type. The created entry will effectively represent a second Resolve call into the container for the aliased type. Declaration public static void RegisterAlias(this ITargetContainer targetContainer, Type aliasType, Type originalType) Parameters Name Type Description targetContainer ITargetContainer The builder in which the alias is to be registered aliasType Type The type to be registered as an alias originalType Type The type being aliased. Remarks Use this when it's important that a given target type is always served through the same compiled target, even when the consumer expects it to be of a different type. A very common scenario is when you have a singleton instance of the originalType , and need to serve that same instance for aliasType . If you register the same singleton for both types, you get two separate singletons for each type, whereas if you create an alias, both will be served by the same alias. <!-- .classchild --> RegisterAlias<TAlias, TOriginal>(ITargetContainer) Generic version of RegisterAlias(ITargetContainer, Type, Type) , see that method for more. Declaration public static void RegisterAlias<TAlias, TOriginal>(this ITargetContainer targetContainer) Parameters Name Type Description targetContainer ITargetContainer The target container in which the alias is to be registered Type Parameters Name Description TAlias Type being registered as an alias to another type TOriginal The target type of the alias. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Builder.html": {
    "href": "rezolver-api/Rezolver.Builder.html",
    "title": "Class Builder",
    "keywords": "Class Builder Stores and retrieves registrations of ITarget s, is also Generic type aware, unlike its base class - TargetDictionaryContainer . Should be used as the root target container for implementations of IContainer . Inheritance Object TargetDictionaryContainer Builder Inherited Members Fetch(Type) FetchAll(Type) CombineWith(ITargetContainer, Type) ToString() Equals(Object) Equals(Object, Object) ReferenceEquals(Object, Object) GetHashCode() GetType() MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class Builder : TargetDictionaryContainer, ITargetContainerOwner, ITargetContainer Remarks This is the type used by default for the Rezolver.IContainer.Builder of the Container and ScopedContainer when you don't supply an instance of an ITargetContainer explicitly on construction. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors Builder(Boolean) Constructs a new instance of the Builder class Declaration public Builder(bool autoRezolveIEnumerable = true) Parameters Name Type Description autoRezolveIEnumerable Boolean If true, then IEnumerable<T> will be automatically resolved as a concatenation of all the ITarget s that are registered against a particular type. Note - this parameter might be removed in a future version - you can achieve the same thing by using the extension method Rezolver.EnumerableTargetBuilderExtensions.EnableEnumerableResolving(Rezolver.Builder) <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateContainer(Type, ITarget) Called to create and register a container for the given serviceType and target . This class overrides the base version ( CreateContainer(Type, ITarget) ) to create a specialised container for generic types ( GenericTargetContainer ) if serviceType if a generic type or generic type definition. Declaration protected override ITargetContainer CreateContainer(Type serviceType, ITarget target) Parameters Name Type Description serviceType Type The type for which a container is to be created and registered. target ITarget Optional. The target that will be added to the container that is returned. Returns Type Description ITargetContainer An ITargetContainer in which the passed target will be registered. Overrides CreateContainer(Type, ITarget) Remarks The main caller for this method will be the base Register method, which will create a new container for a target that's being registered against a new type. It is, however, also called by this class' implementation of RegisterContainer(Type, ITargetContainer) when the type is a generic type - as all generics must have a container registered against their generic type definitions as a starting point. <!-- .classchild --> CreateGenericTypeDefContainer(Type, ITarget) Called by CreateContainer(Type, ITarget) to create a container suitable for handling targets that are registered against generic types. Declaration protected virtual ITargetContainer CreateGenericTypeDefContainer(Type genericTypeDefinition, ITarget target) Parameters Name Type Description genericTypeDefinition Type Will be an open generic type (generic type definition) target ITarget Optional. The initial target for which the container is being constructed Returns Type Description ITargetContainer The base implementation always creates an instance of CreateGenericTypeDefContainer(Type, ITarget) <!-- .classchild --> FetchContainer(Type) Retrieves Declaration public override ITargetContainer FetchContainer(Type type) Parameters Name Type Description type Type Returns Type Description ITargetContainer Overrides FetchContainer(Type) <!-- .classchild --> Register(ITarget, Type) Declaration public override void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget serviceType Type Overrides Register(ITarget, Type) <!-- .classchild --> RegisterContainer(Type, ITargetContainer) Overrides the base method so that if type is a generic type, then the container will be registered inside another which will be registered for the generic type definition first. Declaration public override void RegisterContainer(Type type, ITargetContainer container) Parameters Name Type Description type Type container ITargetContainer Overrides RegisterContainer(Type, ITargetContainer) <!-- .classchild --> RegisterContainerDirect(Type, ITargetContainer) Version of RegisterContainer(Type, ITargetContainer) which does not interrogate the type to see if it's generic - simply registers the passed container directly against the passed type (it just chains through directly to the RegisterContainer(Type, ITargetContainer) method non-virtually. Declaration protected virtual void RegisterContainerDirect(Type type, ITargetContainer container) Parameters Name Type Description type Type container ITargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.CachingContainerBase.html": {
    "href": "rezolver-api/Rezolver.CachingContainerBase.html",
    "title": "Class CachingContainerBase",
    "keywords": "Class CachingContainerBase Builds on the ContainerBase base class to introduce thread-safe caching of compiled targets so they are only compiled once per requested type. Only creatable through inheritance. Inheritance Object ContainerBase CachingContainerBase Inherited Members ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Compiler ContainerBase.Targets ContainerBase.Resolve(ResolveContext) ContainerBase.TryResolve(ResolveContext, Object) ContainerBase.CreateLifetimeScope() ContainerBase.FetchCompiled(ResolveContext) ContainerBase.CanResolve(ResolveContext) ContainerBase.GetFallbackCompiledRezolveTarget(ResolveContext) Rezolver.ContainerBase.System.IServiceProvider.GetService(System.Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.Fetch(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.FetchAll(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer, System.Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class CachingContainerBase : ContainerBase, IContainer, IServiceProvider, ITargetContainer Remarks Internally, the class uses a ConcurrentDictionary<TKey, TValue> to store ICompiledTarget s keyed by the requested type. All the main IContainer implementations used directly in an application should ideally inherit from this class, because otherwise every Resolve(ResolveContext) operation would require a compilation phase before the object could be returned, which would be incredibly slow. It's because of this caching that registering new targets in any ITargetContainer used by this class is not recommended: because after the first request for a particular type is made, the resultant ICompiledTarget is fixed until the container is thrown away. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors CachingContainerBase(ITargetContainer, ITargetCompiler) Initializes a new instance of the CachingContainerBase class. Declaration protected CachingContainerBase(ITargetContainer targets = null, ITargetCompiler compiler = null) Parameters Name Type Description targets ITargetContainer Optional. Contains the targets that will be used to create the ICompiledTarget s that this container will use to produce objects when requested. If not provided, then the base class' default (see ContainerBase(ITargetContainer, ITargetCompiler) ) will be used. compiler ITargetCompiler Optional. The compiler that will be used to compile the ITarget s in the targets container into ICompiledTarget s. If not provided, then the base class' default (see ContainerBase(ITargetContainer, ITargetCompiler) ) will be used. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetCompiledRezolveTarget(ResolveContext) Obtains an ICompiledTarget for the given context . Declaration protected override ICompiledTarget GetCompiledRezolveTarget(ResolveContext context) Parameters Name Type Description context ResolveContext Returns Type Description ICompiledTarget Overrides ContainerBase.GetCompiledRezolveTarget(ResolveContext) Remarks The method is called by Resolve(ResolveContext) to get the compiled target whose GetObject(ResolveContext) method is to be used to get the instance that is to be resolved for a given request. The internal cache is examined first to see if an entry exists for the RequestedType type and, if not, then the result of the base class' GetCompiledRezolveTarget(ResolveContext) is cached and returned. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ChangeTypeTarget.html": {
    "href": "rezolver-api/Rezolver.ChangeTypeTarget.html",
    "title": "Class ChangeTypeTarget",
    "keywords": "Class ChangeTypeTarget This target is specifically used for explicitly casting the result of one target to another type. Its use is rare, since the framework already caters for downcasting the result of targets to base types. Inheritance Object TargetBase ChangeTypeTarget Inherited Members TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ChangeTypeTarget : TargetBase, ITarget Remarks A valid use of this target is when you have a SingletonTarget registered against one type, and you want the same singleton (backed by the same instance) to server another type. In this case, instead of registering the same singleton target multiple times, you can register it once for its primary type, then register one of these for the other type, with a RezolvedTarget as its inner target. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ChangeTypeTarget(ITarget, Type) Creates a new instance of the ChangeTypeTarget class. Declaration public ChangeTypeTarget(ITarget innerTarget, Type targetType) Parameters Name Type Description innerTarget ITarget Required. See InnerTarget targetType Type Required. See DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Always returns the target type that was passed in the ChangeTypeTarget(ITarget, Type) constructor. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> InnerTarget The target whose type will be changed to DeclaredType . Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget <!-- .classchild --> SuppressScopeTracking Always returns true. Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides TargetBase.SuppressScopeTracking <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ChildBuilder.html": {
    "href": "rezolver-api/Rezolver.ChildBuilder.html",
    "title": "Class ChildBuilder",
    "keywords": "Class ChildBuilder A Builder which acts as a child of another builder. When it's looking to find an entry for a type, if it cannot find one within its own registrations, it will forward the call on to its Parent . This means that a child builder can override any registrations that are present in its parent. Inheritance Object TargetDictionaryContainer Builder ChildBuilder Inherited Members CreateContainer(Type, ITarget) CreateGenericTypeDefContainer(Type, ITarget) FetchContainer(Type) Register(ITarget, Type) RegisterContainer(Type, ITargetContainer) RegisterContainerDirect(Type, ITargetContainer) CombineWith(ITargetContainer, Type) ToString() Equals(Object) Equals(Object, Object) ReferenceEquals(Object, Object) GetHashCode() GetType() MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ChildBuilder : Builder, ITargetContainerOwner, IChildTargetContainer, ITargetContainer <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ChildBuilder(ITargetContainer) Declaration public ChildBuilder(ITargetContainer parent) Parameters Name Type Description parent ITargetContainer <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Parent Declaration public ITargetContainer Parent { get; } Property Value Type Description ITargetContainer Implements Parent <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Fetch(Type) Declaration public override ITarget Fetch(Type type) Parameters Name Type Description type Type Returns Type Description ITarget Overrides Fetch(Type) Implements Fetch(Type) <!-- .classchild --> FetchAll(Type) Declaration public override IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type Type Returns Type Description IEnumerable < ITarget > Overrides FetchAll(Type) Implements FetchAll(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ChildTargetContainer.html": {
    "href": "rezolver-api/Rezolver.ChildTargetContainer.html",
    "title": "Class ChildTargetContainer",
    "keywords": "Class ChildTargetContainer A version of TargetContainer which overrides the registrations of another (the Parent ). Inheritance Object TargetDictionaryContainer TargetContainer ChildTargetContainer Inherited Members TargetContainer.CreateContainer(Type, ITarget) TargetContainer.CreateGenericTypeDefContainer(Type, ITarget) TargetContainer.FetchContainer(Type) TargetContainer.Register(ITarget, Type) TargetContainer.RegisterContainer(Type, ITargetContainer) TargetContainer.RegisterContainerDirect(Type, ITargetContainer) TargetDictionaryContainer.CombineWith(ITargetContainer, Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ChildTargetContainer : TargetContainer, ITargetContainerOwner, IChildTargetContainer, ITargetContainer Remarks When it's looking to find an entry for a type, if it cannot find one within its own registrations, it will forward the call on to its ancestors (starting with its Parent ). As a result, any dependencies required by registrations in this container can be provided by any ancestor. Fallback logic in the Fetch(Type) is triggered by the UseFallback property. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ChildTargetContainer(ITargetContainer) Initializes a new instance of the ChildTargetContainer class. Declaration public ChildTargetContainer(ITargetContainer parent) Parameters Name Type Description parent ITargetContainer Required. The parent target container <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Parent Gets the parent. Declaration public ITargetContainer Parent { get; } Property Value Type Description ITargetContainer The parent. Implements IChildTargetContainer.Parent <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Fetch(Type) Fetches the registered target for the given type , if found, or forwards the call to the Parent container. Declaration public override ITarget Fetch(Type type) Parameters Name Type Description type Type The type whose registration is sought. Returns Type Description ITarget The target which is registered for the given type, or null if no registration can be found. Overrides TargetDictionaryContainer.Fetch(Type) Implements ITargetContainer.Fetch(Type) <!-- .classchild --> FetchAll(Type) Implementation of FetchAll(Type) Declaration public override IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type Type The type whose targets are to be retrieved. Returns Type Description IEnumerable < ITarget > A non-null enumerable containing the targets that match the type, or an empty enumerable if the type is not registered. Overrides TargetDictionaryContainer.FetchAll(Type) Implements ITargetContainer.FetchAll(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.CompileContext.html": {
    "href": "rezolver-api/Rezolver.Compilation.CompileContext.html",
    "title": "Class CompileContext",
    "keywords": "Class CompileContext Core implementation of ICompileContext . A root context (i.e. where ParentContext is null ; created via the CompileContext(IContainer, ITargetContainer, Type) constructor) is the starting point for all shared state, such as the Container and the compilation stack. The ITargetContainer implementation is done by decorating a new ChildTargetContainer , so that new registrations can be added without interfering with upstream containers. Note that many of the interface members are implemented explicitly - therefore most of your interaction with this type is through its implementation of ICompileContext and ITargetContainer . Inheritance Object CompileContext Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation Assembly :cs.temp.dll.dll Syntax public class CompileContext : ICompileContext, ITargetContainer Remarks Note that you can only create an instance of this either through inheritance, via the explicit implementation of NewContext(Type, Nullable<Boolean>) , or (preferably) via an ICompileContextProvider resolved from an IContainer or ITargetContainer directly from a registered target. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors CompileContext(ICompileContext, Type, Nullable<Boolean>) Creates a new CompileContext as a child of another. Declaration protected CompileContext(ICompileContext parentContext, Type targetType = null, bool ? suppressScopeTracking = null) Parameters Name Type Description parentContext ICompileContext Used to seed the compilation stack, container, dependency container (which will still be wrapped in a new ChildTargetContainer for isolation) and, optionally, the target type (unless you pass a non-null type for targetType , which would override that). targetType Type The target type that is expected to be compiled, or null if the TargetType is to be inherited from the parentContext . suppressScopeTracking Nullable < Boolean > If null (the default), then the value will be inherited from the parentContext 's SuppressScopeTracking property, whereas a non-null value will override it. If true, then any compilation performed in this context should not consider scopes. This is typically set to true when a target definitely does not need scoping, or if a target actively controls scoping in such a way that any child targets can ignore it. <!-- .classchild --> CompileContext(IContainer, ITargetContainer, Type) Creates a new CompileContext Declaration protected CompileContext(IContainer container, ITargetContainer dependencyTargetContainer, Type targetType = null) Parameters Name Type Description container IContainer Required. The container for which compilation is being performed. Will be set into the Container property. dependencyTargetContainer ITargetContainer Required - An ITargetContainer that contains the ITarget s that will be required to complete compilation. Note - this argument is passed to a new ChildTargetContainer that is created and proxied by this class' implementation of ITargetContainer . As a result, it's possible to register new targets directly into the context via its implementation of ITargetContainer , without modifying the underlying targets in the container you pass. targetType Type Optional. Will be set into the TargetType property. If null, then any ITarget that is compiled should be compiled for its own DeclaredType . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties CompileStack Gets the stack entries for all the targets that are being compiled. Declaration public IEnumerable<CompileStackEntry> CompileStack { get; } Property Value Type Description IEnumerable < CompileStackEntry > The compile stack. Implements ICompileContext.CompileStack <!-- .classchild --> Container The container that is considered the current compilation 'scope' - i.e. the container for which the compilation is being performed and, usually, the one on which the Resolve(ResolveContext) method was originally called which triggered the compilation call. Declaration public IContainer Container { get; } Property Value Type Description IContainer The container. Implements ICompileContext.Container <!-- .classchild --> DependencyTargetContainer This is the ITargetContainer through which dependencies are resolved by this context in its implementation of ITargetContainer . In essence, this class acts as a decorator for this inner target container. Declaration protected ITargetContainer DependencyTargetContainer { get; } Property Value Type Description ITargetContainer <!-- .classchild --> ParentContext Gets the parent context from which this context was created, if applicable. Declaration public ICompileContext ParentContext { get; } Property Value Type Description ICompileContext The parent context. Implements ICompileContext.ParentContext <!-- .classchild --> SuppressScopeTracking If true, then any target that is compiling within this context should not generate any runtime code to fetch the object from, or track the object in, the current IScopedContainer . Declaration public bool SuppressScopeTracking { get; } Property Value Type Description Boolean true if [suppress scope tracking]; otherwise, false . Implements ICompileContext.SuppressScopeTracking Remarks This is currently used, for example, by wrapper targets that generate their own scope tracking code (specifically, the SingletonTarget and ScopedTarget . It's therefore very important that any custom compilers honour this flag in their implementation. <!-- .classchild --> TargetType Any ICompiledTarget built for a ITarget with this context should target this type. If null, then the DeclaredType of the target being compiled should be used. Declaration public Type TargetType { get; } Property Value Type Description Type Implements ICompileContext.TargetType Remarks Note that when creating a child context with a null targetType argument, this property will be inherited from the ParentContext . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods NewContext(Type, Nullable<Boolean>) Used by the explicit implementation of NewContext(Type, Nullable<Boolean>) . Override this in your derived class to create the correct implementation of ICompileContext . Declaration protected virtual ICompileContext NewContext(Type targetType = null, bool ? suppressScopeTracking = null) Parameters Name Type Description targetType Type Optional. The type for which the target is to be compiled, if different from this context's TargetType . suppressScopeTracking Nullable < Boolean > The value passed here will be used for the new context's SuppressScopeTracking Returns Type Description ICompileContext <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Explicit Interface Implementations ICompileContext.NewContext(Type, Nullable<Boolean>) Creates a new child context from this one, except the TargetType and SuppressScopeTracking properties can be overriden if required, the rest of the state is inherited from this context. Declaration ICompileContext ICompileContext.NewContext(Type targetType, bool ? suppressScopeTracking) Parameters Name Type Description targetType Type Optional. The type for which the target is to be compiled, if different from this context's TargetType . suppressScopeTracking Nullable < Boolean > The value passed here will be used for the new context's SuppressScopeTracking Returns Type Description ICompileContext Implements ICompileContext.NewContext(Type, Nullable<Boolean>) <!-- .classchild --> ICompileContext.PopCompileStack() Pops a target from the stack and returns it. Note that if there are no targets on the stack, an InvalidOperationException will occur. Declaration CompileStackEntry ICompileContext.PopCompileStack() Returns Type Description CompileStackEntry The CompileStackEntry that was popped off the compilation stack. Implements ICompileContext.PopCompileStack() Remarks If ParentContext is not null, then the call is redirected to that context, so that the compilation stack is always shared between all contexts spawned from the same root. <!-- .classchild --> ICompileContext.PushCompileStack(ITarget) Adds the target to the compilation stack if it doesn't already exist. Declaration bool ICompileContext.PushCompileStack(ITarget toCompile) Parameters Name Type Description toCompile ITarget The target to be pushed Returns Type Description Boolean A boolean indicating whether the target was added. Will be false if the target is already on the stack. Implements ICompileContext.PushCompileStack(ITarget) Remarks If ParentContext is not null, then the call is redirected to that context, so that the compilation stack is always shared between all contexts spawned from the same root. <!-- .classchild --> ITargetContainer.CombineWith(ITargetContainer, Type) Always throws a NotSupportedException Declaration ITargetContainer ITargetContainer.CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer Ignored type Type Ignored Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) Exceptions Type Condition NotSupportedException Always thrown <!-- .classchild --> ITargetContainer.Fetch(Type) Implements Fetch(Type) by wrapping around the child target container created by this context on construction. Declaration ITarget ITargetContainer.Fetch(Type type) Parameters Name Type Description type Type See Fetch(Type) for more. Returns Type Description ITarget Implements ITargetContainer.Fetch(Type) <!-- .classchild --> ITargetContainer.FetchAll(Type) Implements FetchAll(Type) by wrapping around the child target container created by this context on construction. Declaration IEnumerable<ITarget> ITargetContainer.FetchAll(Type type) Parameters Name Type Description type Type See FetchAll(Type) for more Returns Type Description IEnumerable < ITarget > Implements ITargetContainer.FetchAll(Type) <!-- .classchild --> ITargetContainer.Register(ITarget, Type) Implements Register(ITarget, Type) by wrapping around the child target container created by this context on construction. Declaration void ITargetContainer.Register(ITarget target, Type serviceType) Parameters Name Type Description target ITarget See Register(ITarget, Type) for more serviceType Type See Register(ITarget, Type) for more Implements ITargetContainer.Register(ITarget, Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.CompileStackEntry.html": {
    "href": "rezolver-api/Rezolver.Compilation.CompileStackEntry.html",
    "title": "Class CompileStackEntry",
    "keywords": "Class CompileStackEntry Represents an entry in the compilation stack of a ICompileContext , recording both a target that is being compiled, and the type for which it is being compiled. Inheritance Object CompileStackEntry Inherited Members Object.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation Assembly :cs.temp.dll.dll Syntax public class CompileStackEntry : IEquatable<CompileStackEntry> <!-- <hr class=\"typeSectionDivider\" /> --> Constructors CompileStackEntry(ITarget, Type) Initializes a new instance of the CompileStackEntry class. Declaration public CompileStackEntry(ITarget target, Type targetType) Parameters Name Type Description target ITarget The target being compiled. targetType Type Type for which the target is being compiled. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Target Gets the target being compiled. Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> TargetType Gets the type for which the target is being compiled. Declaration public Type TargetType { get; } Property Value Type Description Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Equals(CompileStackEntry) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(CompileStackEntry other) Parameters Name Type Description other CompileStackEntry An object to compare with this object. Returns Type Description Boolean Implements IEquatable<CompileStackEntry>.Equals(CompileStackEntry) Remarks Equality is defined as both the Target and the TargetType being equal between this instance and the other instance. <!-- .classchild --> Equals(Object) Determines whether the specified Object is equal to this instance. Declaration public override bool Equals(object obj) Parameters Name Type Description obj Object The object to compare with the current object. Returns Type Description Boolean Overrides Object.Equals(Object) <!-- .classchild --> GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description Int32 Overrides Object.GetHashCode() <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ChangeTypeTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ChangeTypeTargetBuilder.html",
    "title": "Class ChangeTypeTargetBuilder",
    "keywords": "Class ChangeTypeTargetBuilder Implementation of IExpressionBuilder specialised to build expressions for the ChangeTypeTarget This always produces a conversion expression (i.e. cast or box/unbox) Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ChangeTypeTarget > ChangeTypeTargetBuilder Inherited Members ExpressionBuilderBase<ChangeTypeTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.ChangeTypeTarget>.Rezolver.Compilation.Expressions.IExpressionBuilder<Rezolver.ChangeTypeTarget>.Build(Rezolver.ChangeTypeTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) ExpressionBuilderBase<ChangeTypeTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase.Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class ChangeTypeTargetBuilder : ExpressionBuilderBase<ChangeTypeTarget>, IExpressionBuilder<ChangeTypeTarget>, IExpressionBuilder <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(ChangeTypeTarget, IExpressionCompileContext, IExpressionCompiler) Builds the conversion expression represented by the target Declaration protected override Expression Build(ChangeTypeTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target ChangeTypeTarget The target whose expression is to be built. context IExpressionCompileContext The compilation context. compiler IExpressionCompiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.ChangeTypeTarget>.Build(Rezolver.ChangeTypeTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ConstructorTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ConstructorTargetBuilder.html",
    "title": "Class ConstructorTargetBuilder",
    "keywords": "Class ConstructorTargetBuilder An IExpressionBuilder specialised for building the target ConstructorTarget Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ConstructorTarget > ConstructorTargetBuilder Inherited Members ExpressionBuilderBase<ConstructorTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.ConstructorTarget>.Rezolver.Compilation.Expressions.IExpressionBuilder<Rezolver.ConstructorTarget>.Build(Rezolver.ConstructorTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) ExpressionBuilderBase<ConstructorTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase.Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class ConstructorTargetBuilder : ExpressionBuilderBase<ConstructorTarget>, IExpressionBuilder<ConstructorTarget>, IExpressionBuilder <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(ConstructorBinding, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the specified ConstructorBinding . Called by Build(ConstructorTarget, IExpressionCompileContext, IExpressionCompiler) Declaration protected virtual Expression Build(ConstructorBinding binding, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description binding ConstructorBinding The binding. context IExpressionCompileContext The context. compiler IExpressionCompiler Returns Type Description Expression Remarks The returned expression will either be a NewExpression or a MemberInitExpression <!-- .classchild --> Build(ConstructorTarget, IExpressionCompileContext, IExpressionCompiler) Override of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Declaration protected override Expression Build(ConstructorTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target ConstructorTarget The target whose expression is to be built. context IExpressionCompileContext The compilation context. compiler IExpressionCompiler Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.ConstructorTarget>.Build(Rezolver.ConstructorTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.DecoratorTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.DecoratorTargetBuilder.html",
    "title": "Class DecoratorTargetBuilder",
    "keywords": "Class DecoratorTargetBuilder Specialised builder for DecoratorTarget targets. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < DecoratorTarget > DecoratorTargetBuilder Inherited Members ExpressionBuilderBase<DecoratorTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.DecoratorTarget>.Rezolver.Compilation.Expressions.IExpressionBuilder<Rezolver.DecoratorTarget>.Build(Rezolver.DecoratorTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) ExpressionBuilderBase<DecoratorTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase.Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class DecoratorTargetBuilder : ExpressionBuilderBase<DecoratorTarget>, IExpressionBuilder<DecoratorTarget>, IExpressionBuilder <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(DecoratorTarget, IExpressionCompileContext, IExpressionCompiler) Creates a new compilation context, registers the target's DecoratedTarget into it as the correct target for the DecoratedType , and then builds the expression for the Target (which is typically a constructor target). Declaration protected override Expression Build(DecoratorTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target DecoratorTarget The target whose expression is to be built. context IExpressionCompileContext The compilation context. compiler IExpressionCompiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.DecoratorTarget>.Build(Rezolver.DecoratorTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.DefaultTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.DefaultTargetBuilder.html",
    "title": "Class DefaultTargetBuilder",
    "keywords": "Class DefaultTargetBuilder An IExpressionBuilder specialised for building the expression for the DefaultTarget target. Essentially, it just calls for the DeclaredType . Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < DefaultTarget > DefaultTargetBuilder Inherited Members ExpressionBuilderBase<DefaultTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.DefaultTarget>.Rezolver.Compilation.Expressions.IExpressionBuilder<Rezolver.DefaultTarget>.Build(Rezolver.DefaultTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) ExpressionBuilderBase<DefaultTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase.Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class DefaultTargetBuilder : ExpressionBuilderBase<DefaultTarget>, IExpressionBuilder<DefaultTarget>, IExpressionBuilder <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(DefaultTarget, IExpressionCompileContext, IExpressionCompiler) Declaration protected override Expression Build(DefaultTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target DefaultTarget context IExpressionCompileContext compiler IExpressionCompiler Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.DefaultTarget>.Build(Rezolver.DefaultTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.DelegateTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.DelegateTargetBuilder.html",
    "title": "Class DelegateTargetBuilder",
    "keywords": "Class DelegateTargetBuilder Specialised builder for the DelegateTarget class and all its derivatives. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < DelegateTarget > DelegateTargetBuilder Inherited Members ExpressionBuilderBase<DelegateTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.DelegateTarget>.Rezolver.Compilation.Expressions.IExpressionBuilder<Rezolver.DelegateTarget>.Build(Rezolver.DelegateTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) ExpressionBuilderBase<DelegateTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase.Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class DelegateTargetBuilder : ExpressionBuilderBase<DelegateTarget>, IExpressionBuilder<DelegateTarget>, IExpressionBuilder <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(DelegateTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target for the given OVerride this to implement the compilation for your target type. Declaration protected override Expression Build(DelegateTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target DelegateTarget The target whose expression is to be built. context IExpressionCompileContext The compilation context. compiler IExpressionCompiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.DelegateTarget>.Build(Rezolver.DelegateTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Exceptions Type Condition NotImplementedException <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ExpressionBuilderBase-1.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ExpressionBuilderBase-1.html",
    "title": "Class ExpressionBuilderBase<TTarget>",
    "keywords": "Class ExpressionBuilderBase<TTarget> Abstract base class for implementations of IExpressionBuilder<TTarget> . Provide an implementation of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) and then register an instance in an ObjectTarget in the active container. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase<TTarget> Inherited Members ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase.Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public abstract class ExpressionBuilderBase<TTarget> : ExpressionBuilderBase, IExpressionBuilder<TTarget>, IExpressionBuilder where TTarget : ITarget Type Parameters Name Description TTarget The type of target for which this builder can build an expression. Remarks This is a generic extension of the ExpressionBuilderBase class, designed to simplify the process of implementating the IExpressionBuilder<TTarget> (and, by extension, IExpressionBuilder ) interface. This is the class from which most of the built-in expression builders derive, because the ExpressionCompiler , when asked to compile an expression, attempts to resolve an IExpressionBuilder<TTarget> whose TTarget is the same type as the target that needs compiling. Inheriting from ExpressionBuilderBase is more appropriate if your builder is capable of handling multiple types of ITarget - a scenario that's much less common. Note that this class' implementation of IExpressionBuilder<TTarget> is entirely explicit and non-virtual, the same as with its base class, hence the only way to build an expression via an instance of this class without exposing the behaviour to external callers yourself is via the interface. <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target for the given ICompileContext OVerride this to implement the compilation for your target type. Declaration protected abstract Expression Build(TTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target TTarget The target whose expression is to be built. context IExpressionCompileContext The compilation context. compiler IExpressionCompiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression <!-- .classchild --> Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Overrides the abstract Build(ITarget, IExpressionCompileContext, IExpressionCompiler) (and seals it from further overrides); checks that target is an instance of TTarget (throwing an ArgumentException if not) and then calls this class' Build(TTarget, IExpressionCompileContext, IExpressionCompiler) abstract function. Declaration protected override sealed Expression Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target ITarget The target for which an expression is to be built. Must be an instance of TTarget . context IExpressionCompileContext The compilation context. compiler IExpressionCompiler Returns Type Description Expression Overrides ExpressionBuilderBase.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Exceptions Type Condition ArgumentException If the passed target is not an instance of TTarget <!-- .classchild --> CanBuild(ITarget, IExpressionCompileContext) Determines whether this instance can build an expression from the specified target. This base implementation simply checks that the type of target is compatible with the type TTarget . Declaration public override bool CanBuild(ITarget target, IExpressionCompileContext context) Parameters Name Type Description target ITarget The target. context IExpressionCompileContext The compilation context. Returns Type Description Boolean Overrides ExpressionBuilderBase.CanBuild(ITarget, IExpressionCompileContext) Implements IExpressionBuilder.CanBuild(ITarget, IExpressionCompileContext) <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Explicit Interface Implementations IExpressionBuilder<TTarget>.Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Builds the specified target. Declaration Expression IExpressionBuilder<TTarget>.Build(TTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target TTarget The target. context IExpressionCompileContext The context. compiler IExpressionCompiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the implementation attempts to locate the context compiler using the method, and will throw an InvalidOperationException if it cannot do so. Returns Type Description Expression Implements IExpressionBuilder<TTarget>.Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Exceptions Type Condition ArgumentNullException target is null or context is null InvalidOperationException compiler is null and an IExpressionCompiler couldn't be resolved for the current context (via <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ExpressionBuilderBase.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ExpressionBuilderBase.html",
    "title": "Class ExpressionBuilderBase",
    "keywords": "Class ExpressionBuilderBase Abstract starting point for implementing IExpressionBuilder . Note that the interface is implemented explicitly; but exposes protected abstract or virtual methods for inheritors to extend. Inheritance Object ExpressionBuilderBase Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public abstract class ExpressionBuilderBase : IExpressionBuilder Remarks This class takes care of checking the type requested in the IExpressionCompileContext is compatible with the target that's passed to the Build(ITarget, IExpressionCompileContext, IExpressionCompiler) method <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Abstract method used as part implementation of the Build(ITarget, IExpressionCompileContext, IExpressionCompiler) It's called by BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) . Declaration protected abstract Expression Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target ITarget The target. context IExpressionCompileContext The context. compiler IExpressionCompiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression <!-- .classchild --> BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) The core expression build function - takes care of handling mismatched types between the target and the requested type in the context - both checking compatibility and producing conversion expressions where necessary. Also performs cyclic dependency checking. Declaration protected Expression BuildCore(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target ITarget The target to be compiled. context IExpressionCompileContext The context. compiler IExpressionCompiler The compiler. Returns Type Description Expression Remarks This class' implementation of Build(ITarget, IExpressionCompileContext, IExpressionCompiler) calls this, as does the derived abstract class ExpressionBuilderBase<TTarget> for its implementation of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) . It is this function that is responsible for calling the abstract Build(ITarget, IExpressionCompileContext, IExpressionCompiler) function, which deriving classes implement to actually produce their expression for the target . Exceptions Type Condition ArgumentException targetType InvalidOperationException <!-- .classchild --> CanBuild(ITarget, IExpressionCompileContext) Abstract method (implementation of CanBuild(ITarget, IExpressionCompileContext) ) which determines whether this instance can build an expression for the specified target. Declaration public abstract bool CanBuild(ITarget target, IExpressionCompileContext context) Parameters Name Type Description target ITarget The target. context IExpressionCompileContext The compilation context. Returns Type Description Boolean Implements IExpressionBuilder.CanBuild(ITarget, IExpressionCompileContext) <!-- .classchild --> GetContextCompiler(IExpressionCompileContext) Gets the IExpressionCompiler to be used to build the expression for the given target for the given context, if different from one passed to this class' implementation of Build(ITarget, IExpressionCompileContext, IExpressionCompiler) . This function is called by BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) which will throw an exception if it returns null and no compiler was provided to BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) (typically via the explicit implementation of IExpressionBuilder ). Declaration protected virtual IExpressionCompiler GetContextCompiler(IExpressionCompileContext context) Parameters Name Type Description context IExpressionCompileContext The current compile context. Returns Type Description IExpressionCompiler Remarks The base implementation simply attempts to resolve a concrete instance of IExpressionCompiler from the ITargetContainer which should, with the default configuration, resolve to the root ExpressionCompiler <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Explicit Interface Implementations IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Explicit implementation of Build(ITarget, IExpressionCompileContext, IExpressionCompiler) - ultimately forwards the call to the BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) function. Declaration Expression IExpressionBuilder.Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target ITarget The target for which an expression is to be built context IExpressionCompileContext The compilation context. compiler IExpressionCompiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the implementation attempts to locate the context compiler using the GetContextCompiler(IExpressionCompileContext) method, and will throw an InvalidOperationException if it cannot do so. Returns Type Description Expression Implements IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Exceptions Type Condition ArgumentNullException target is null or context is null InvalidOperationException compiler is null and an IExpressionCompiler couldn't be resolved for the current context (via GetContextCompiler(IExpressionCompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ExpressionCompileContext.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ExpressionCompileContext.html",
    "title": "Class ExpressionCompileContext",
    "keywords": "Class ExpressionCompileContext An implementation of ICompileContext which is specialised for use by an IExpressionCompiler . Inheritance Object CompileContext ExpressionCompileContext Inherited Members CompileContext.Container CompileContext.TargetType CompileContext.SuppressScopeTracking CompileContext.DependencyTargetContainer CompileContext.CompileStack Rezolver.Compilation.CompileContext.Rezolver.Compilation.ICompileContext.NewContext(System.Type, System.Nullable<System.Boolean>) Rezolver.Compilation.CompileContext.Rezolver.Compilation.ICompileContext.PushCompileStack(Rezolver.ITarget) Rezolver.Compilation.CompileContext.Rezolver.Compilation.ICompileContext.PopCompileStack() Rezolver.Compilation.CompileContext.Rezolver.ITargetContainer.Register(Rezolver.ITarget, System.Type) Rezolver.Compilation.CompileContext.Rezolver.ITargetContainer.Fetch(System.Type) Rezolver.Compilation.CompileContext.Rezolver.ITargetContainer.FetchAll(System.Type) Rezolver.Compilation.CompileContext.Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer, System.Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class ExpressionCompileContext : CompileContext, IExpressionCompileContext, ICompileContext, ITargetContainer <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ExpressionCompileContext(IExpressionCompileContext, Type, Boolean, Nullable<Boolean>) Initializes a new instance of the ExpressionCompileContext class as a child of another. Note that all the expression properties ( ResolveContextExpression , ContextContainerPropertyExpression and ContextScopePropertyExpression ) are always inherited from the source context to ensure consistency across all expressions being built during a particular compilation chain. Declaration protected ExpressionCompileContext(IExpressionCompileContext sourceContext, Type targetType = null, bool useParentSharedExpressions = true, bool ? suppressScopeTracking = null) Parameters Name Type Description sourceContext IExpressionCompileContext The source context. targetType Type If not null, the type for which expressions are to be compiled. If null, then the sourceContext 's TargetType will be inherited. useParentSharedExpressions Boolean If true then the SharedExpressions of the sourceContext will be reused by this new context. If false , then this context will start with a new empty set of shared expressions. suppressScopeTracking Nullable < Boolean > null to inherit the sourceContext 's SuppressScopeTracking value, any non-null value overrides that value. <!-- .classchild --> ExpressionCompileContext(IContainer, ITargetContainer, Type, ParameterExpression) Initializes a new instance of the ExpressionCompileContext class. Declaration protected ExpressionCompileContext(IContainer container, ITargetContainer dependencyTargetContainer, Type targetType = null, ParameterExpression resolveContextExpression = null) Parameters Name Type Description container IContainer Required. The container for which the compilation is being performed. When compiling in response to a call to Resolve(ResolveContext) , the container which first receives the call should be the one passed here. dependencyTargetContainer ITargetContainer Required - target container used for dependency lookups. As with the base class this is actually wrapped in a new ChildTargetContainer and used as this class' implementation of ITargetContainer . targetType Type Optional. Will be set into the property. If null, then any ITarget that is compiled should be compiled for its own DeclaredType . resolveContextExpression ParameterExpression Optional, mapped to ResolveContextExpression - the default for this (i.e. when you leave it as null) is to use the static DefaultResolveContextParameterExpression and generally it should always be left as that. The ExpressionCompiler , when building expressions to turn into compiled lambdas, uses this as the main parameter on the lambda itself. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties ContainerExpression Gets an expression which gives a reference to the IContainer for this context - i.e. the same reference as given by the Container property. Declaration public Expression ContainerExpression { get; } Property Value Type Description Expression The container expression. Implements IExpressionCompileContext.ContainerExpression Remarks Note that this is not the same as ContextContainerPropertyExpression - but is provided to allow expressions to be compiled which compare the container supplied at compile time to the one from the Container at resolve-time. <!-- .classchild --> ContextContainerPropertyExpression Gets an expression for reading the Container property of the ResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration public MemberExpression ContextContainerPropertyExpression { get; } Property Value Type Description MemberExpression The context container property expression. Implements IExpressionCompileContext.ContextContainerPropertyExpression <!-- .classchild --> ContextScopePropertyExpression Gets an expression for reading the Scope property of the ResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration public MemberExpression ContextScopePropertyExpression { get; } Property Value Type Description MemberExpression The context scope property expression. Implements IExpressionCompileContext.ContextScopePropertyExpression <!-- .classchild --> DefaultResolveContextParameterExpression The default ResolveContext parameter expression used by the expression-based code generators defined in this library, although it's not used directly for that purpose - instead, the ResolveContextExpression of new contexts is initialised to this if not explicitly provided on construction and when not being inherited from another context. Declaration public static ParameterExpression DefaultResolveContextParameterExpression { get; } Property Value Type Description ParameterExpression <!-- .classchild --> ParentContext Gets the parent context. Declaration public IExpressionCompileContext ParentContext { get; } Property Value Type Description IExpressionCompileContext Implements IExpressionCompileContext.ParentContext Remarks Note that this property hides the inherited ParentContext property, since an IExpressionCompileContext can only be a child of another IExpressionCompileContext . <!-- .classchild --> ResolveContextExpression This is the parameter expression which represents the ResolveContext that is passed to the ICompiledTarget at resolve-time. The other expressions - ContextContainerPropertyExpression and ContextScopePropertyExpression are both built from this too. Declaration public ParameterExpression ResolveContextExpression { get; } Property Value Type Description ParameterExpression The resolve context expression. Implements IExpressionCompileContext.ResolveContextExpression Remarks If the code produced by the IExpressionBuilder for a given target needs to read or use the ResolveContext that was originally passed to the Resolve(ResolveContext) method, then it does it by using this expression, which will be set as the only parameter on the lambda expression which is eventually compiled (in the case of the default expression compiler, ExpressionCompiler . <!-- .classchild --> SharedExpressions Gets a read-only enumerable of all the shared expressions that have been inherited from any parent context and/or added via calls to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) or GetOrAddSharedLocal(Type, String, Type) . Declaration public IEnumerable<Expression> SharedExpressions { get; } Property Value Type Description IEnumerable < Expression > Implements IExpressionCompileContext.SharedExpressions <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetOrAddSharedExpression(Type, String, Func<Expression>, Type) Gets or adds a shared expression (created by the expressionFactory if it's not already cached) with the given name, type, optionally for the given requestingType . Declaration public Expression GetOrAddSharedExpression(Type type, string name, Func<Expression> expressionFactory, Type requestingType = null) Parameters Name Type Description type Type The runtime type of the Expression. name String The runtime name of the Expression - and also the name used to retrieve it later. expressionFactory Func < Expression > The factory method to use to construct the shared expression from scratch, if it's not already cached. requestingType Type Optional - to avoid naming clashes with shared expressions created by other targets, you can pass a type here (usually the runtime type of your ITarget implementation). Returns Type Description Expression Expression. Implements IExpressionCompileContext.GetOrAddSharedExpression(Type, String, Func<Expression>, Type) <!-- .classchild --> GetOrAddSharedLocal(Type, String, Type) Similar to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) , except this is used when expression builders want to use local variables in block expressions to store the result of some operation in the expression tree built for a particular target. Reusing one local variable is more efficient than declaring the same local multiple times. Declaration public ParameterExpression GetOrAddSharedLocal(Type type, string name, Type requestingType = null) Parameters Name Type Description type Type The type. name String The name. requestingType Type Optional - the type of the object requesting this shared expression. If this is provided, then the search for an existing shared expression will only work if the same requesting type was passed previously. Returns Type Description ParameterExpression Implements IExpressionCompileContext.GetOrAddSharedLocal(Type, String, Type) Remarks When multiple expression trees from multiple targets are brought together into one lambda, there will often be many duplicate variables which could be shared. So, if an IExpressionBuilder needs a local variable for a block, instead of simply declaring it directly through the function, it can use this function instead, which will return a previously created one if available. Exceptions Type Condition InvalidOperationException Cannot add ParameterExpression: A shared expression of a different type has already been added with the same type and name. <!-- .classchild --> NewContext(Type, Nullable<Boolean>) Used by the explicit implementation of NewContext(Type, Nullable<Boolean>) . This is overriden to ensure that the correct type of context is created when created directly through the ICompileContext interface. Declaration protected override ICompileContext NewContext(Type targetType = null, bool ? suppressScopeTracking = null) Parameters Name Type Description targetType Type Optional. The type for which the target is to be compiled, if different from this context's TargetType . suppressScopeTracking Nullable < Boolean > The value passed here will be used for the new context's SuppressScopeTracking Returns Type Description ICompileContext Overrides CompileContext.NewContext(Type, Nullable<Boolean>) Remarks Note all child contexts created through this virtual method will always inherit the parent context's shared expressions. <!-- .classchild --> RegisterExpressionTargets() Declaration protected void RegisterExpressionTargets() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Explicit Interface Implementations IExpressionCompileContext.NewContext(Type, Boolean, Nullable<Boolean>) Creates a new IExpressionCompileContext using this one as a seed. This function is identical to NewContext(Type, Nullable<Boolean>) but allows you to control whether the SharedExpressions are inherited (the default); and is more convenient because it returns another IExpressionCompileContext . Declaration IExpressionCompileContext IExpressionCompileContext.NewContext(Type targetType, bool useParentSharedExpressions, bool ? suppressScopeTracking) Parameters Name Type Description targetType Type Optional. The type for which the target is to be compiled, if different from this context's . useParentSharedExpressions Boolean If true then the shared expressions in this context will be inherited by the new context by reference. That is, when the new context goes out of scope, any new shared expressions it created will still be available. If false, then the new context will get a brand new, empty, set of shared expressions. suppressScopeTracking Nullable < Boolean > The value passed here will be used for the new context's Returns Type Description IExpressionCompileContext Implements IExpressionCompileContext.NewContext(Type, Boolean, Nullable<Boolean>) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ExpressionCompiler.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ExpressionCompiler.html",
    "title": "Class ExpressionCompiler",
    "keywords": "Class ExpressionCompiler Implementation of the ITargetCompiler interface which produces ICompiledTarget objects by building and compiling expression trees from the ITarget objects which are registered. To enable the use of this compiler, use the extension method on your root target container. Inheritance Object ExpressionCompiler Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class ExpressionCompiler : IExpressionCompiler, ITargetCompiler, ICompileContextProvider Remarks This class works by directly resolving IExpressionBuilder instances which can build an expression for a given ITarget from the IExpressionCompileContext . Typically, this is done by searching for an IExpressionBuilder<TTarget> where 'TTarget' is equal to the runtime type of the target - e.g. ConstructorTarget . If one cannot be found, it will then search for an IExpressionBuilder whose function returns true for the given target. With a correctly configured target dictionary (using the extension method, for example), this should resolve to an instance of the ConstructorTargetBuilder class, which implements IExpressionBuilder<ConstructorTarget> . As such, the compiler can be extended to support extra target types and its existing expression builders can be replaced for customised behaviour because they are all resolved from the ITargetContainer underpinning a particular CompileContext . There is a caveat for this, however: you can't use the traditional targets ( ConstructorTarget etc) to extend the compiler because they currently need to be compiled in order to work - and therefore cannot be used because it would cause an infinite recursion. At present, therefore, the targets which are registered as expression builders must directly implement either the IExpressionBuilder<TTarget> or IExpressionBuilder interfaces; or implement the ICompiledTarget interface and produce an instance of those interfaces when GetObject(ResolveContext) is called on them. Because of this requirement, the most common way to register an expression builder is to register an instance inside an ObjectTarget against the correct type, because it also implements ICompiledTarget in addition to ITarget . Using this pattern, it's important that an expression builder is completely threadsafe and recursion safe (since one target's compilation might depend on the compilation of another of the same type). Under the default configuration, if you want to get hold of this compiler then you should request the type IExpressionCompiler from the current compilation context, or from your target container. <!-- <hr class=\"typeSectionDivider\" /> --> Properties Default Gets the default expression compiler which is, by default, registered into an ITargetContainer when the method is called. Declaration public static ExpressionCompiler Default { get; } Property Value Type Description ExpressionCompiler <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(ITarget, IExpressionCompileContext) Called to build an expression for the specified target for the given IExpressionCompileContext - implementation of the Build(ITarget, IExpressionCompileContext) method. Declaration public Expression Build(ITarget target, IExpressionCompileContext context) Parameters Name Type Description target ITarget The target for which an expression is to be built context IExpressionCompileContext The compilation context. Returns Type Description Expression Implements IExpressionCompiler.Build(ITarget, IExpressionCompileContext) Remarks This implementation attempts to resolve an IExpressionBuilder<TTarget> (with TTarget equal to the runtime type of the target ) or IExpressionBuilder whose CanBuild(ITarget, IExpressionCompileContext) function returns true for the given target and context. If that lookup fails, then an ArgumentException is raised. If the lookup succeeds, then the builder's function is called, and the expression it produces is returned. Exceptions Type Condition ArgumentException If the compiler is unable to resolve an IExpressionBuilder from the context for the target <!-- .classchild --> BuildCompiledTargetForLambda(Expression<Func<ResolveContext, Object>>) Declaration protected virtual ICompiledTarget BuildCompiledTargetForLambda(Expression<Func<ResolveContext, object>> lambda) Parameters Name Type Description lambda Expression < Func < ResolveContext , Object >> Returns Type Description ICompiledTarget <!-- .classchild --> BuildResolveLambda(Expression, IExpressionCompileContext) Declaration protected Expression<Func<ResolveContext, object>> BuildResolveLambda(Expression expression, IExpressionCompileContext context) Parameters Name Type Description expression Expression context IExpressionCompileContext Returns Type Description Expression < Func < ResolveContext , Object >> <!-- .classchild --> BuildResolveLambda(ITarget, IExpressionCompileContext) Similar to the function, except the returned lambda will be optimised and can be immediately compiled into a delegate and executed; or quoted inside another expression as a callback. The will be passed to define the single parameter for the lambda that is created. Declaration public virtual Expression<Func<ResolveContext, object>> BuildResolveLambda(ITarget target, IExpressionCompileContext context) Parameters Name Type Description target ITarget The target. context IExpressionCompileContext The current compilation context. Returns Type Description Expression < Func < ResolveContext , Object >> Implements IExpressionCompiler.BuildResolveLambda(ITarget, IExpressionCompileContext) <!-- .classchild --> CompileTarget(ITarget, ICompileContext) Declaration public ICompiledTarget CompileTarget(ITarget target, ICompileContext context) Parameters Name Type Description target ITarget context ICompileContext Returns Type Description ICompiledTarget Implements ITargetCompiler.CompileTarget(ITarget, ICompileContext) <!-- .classchild --> CreateContext(ResolveContext, ITargetContainer, IContainer) Declaration public ICompileContext CreateContext(ResolveContext resolveContext, ITargetContainer targets, IContainer containerOverride = null) Parameters Name Type Description resolveContext ResolveContext targets ITargetContainer containerOverride IContainer Returns Type Description ICompileContext Implements ICompileContextProvider.CreateContext(ResolveContext, ITargetContainer, IContainer) <!-- .classchild --> ResolveBuilder(ITarget, IExpressionCompileContext) Resolves an expression builder that can build the given target for the given compile context. Or Returns null if no builder can be found. Declaration public virtual IExpressionBuilder ResolveBuilder(ITarget target, IExpressionCompileContext context) Parameters Name Type Description target ITarget The target. context IExpressionCompileContext The context. Returns Type Description IExpressionBuilder Remarks The function builds a list of all the types in the hierarchy represented by the type of the target and, for each of those types which are compatible with ITarget , it looks for an IExpressionBuilder<TTarget> which is specialised for that type. If no compatible builder is found, then it attempts to find a general purpose IExpressionBuilder which can build the type. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ExpressionTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ExpressionTargetBuilder.html",
    "title": "Class ExpressionTargetBuilder",
    "keywords": "Class ExpressionTargetBuilder An IExpressionBuilder specialised for building the expression trees for the ExpressionTarget target type. This builder takes care of all expressions, including lambdas (where additional parameters beyond the standard ResolveContext are turned into local variables with injected values), producing an expression which can be compiled by an IExpressionCompiler after a Rezolver.Compilation.Expressions.TargetExpressionRewriter has been used to expand any targets embedded in the expression. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ExpressionTarget > ExpressionTargetBuilder Inherited Members ExpressionBuilderBase<ExpressionTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.ExpressionTarget>.Rezolver.Compilation.Expressions.IExpressionBuilder<Rezolver.ExpressionTarget>.Build(Rezolver.ExpressionTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) ExpressionBuilderBase<ExpressionTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) Rezolver.Compilation.Expressions.ExpressionBuilderBase.Rezolver.Compilation.Expressions.IExpressionBuilder.Build(Rezolver.ITarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class ExpressionTargetBuilder : ExpressionBuilderBase<ExpressionTarget>, IExpressionBuilder<ExpressionTarget>, IExpressionBuilder <!-- <hr class=\"typeSectionDivider\" /> --> Methods Build(ExpressionTarget, IExpressionCompileContext, IExpressionCompiler) Declaration protected override Expression Build(ExpressionTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Name Type Description target ExpressionTarget context IExpressionCompileContext compiler IExpressionCompiler Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.ExpressionTarget>.Build(Rezolver.ExpressionTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) <!-- .classchild -->"
  }
}