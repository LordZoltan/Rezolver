{
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapter.ConfigurationEntryProcessOrderer.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapter.ConfigurationEntryProcessOrderer.html",
    "title": "Class ConfigurationAdapter.ConfigurationEntryProcessOrderer",
    "keywords": "Class ConfigurationAdapter.ConfigurationEntryProcessOrderer Used by the ConfigurationAdapter class to sort configuration entries for processing. It ensures that Assembly Reference entries are given priority, followed by Namespace Imports, and then finally all the rest. Inheritance Object ConfigurationAdapter.ConfigurationEntryProcessOrderer Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax protected class ConfigurationEntryProcessOrderer : IComparer<IConfigurationEntry> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Compare(IConfigurationEntry, IConfigurationEntry) Declaration public int Compare(IConfigurationEntry x, IConfigurationEntry y) Parameters Name Type Description x IConfigurationEntry y IConfigurationEntry Returns Type Description Int32 Implements IComparer<IConfigurationEntry>.Compare(IConfigurationEntry, IConfigurationEntry) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapter.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapter.html",
    "title": "Class ConfigurationAdapter",
    "keywords": "Class ConfigurationAdapter Standard implementation of the IConfigurationAdapter interface. Inheritance Object ConfigurationAdapter Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationAdapter : IConfigurationAdapter <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConfigurationAdapter(IConfigurationAdapterContextFactory) Creates a new instance of the ConfigurationAdapter class. Declaration public ConfigurationAdapter(IConfigurationAdapterContextFactory contextFactory = null) Parameters Name Type Description contextFactory IConfigurationAdapterContextFactory The factory that is, by default, used to create a new context to be used while transforming an IConfiguration instance. If you pass null, then the DefaultContextFactory will be used. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties ContextFactory Declaration protected IConfigurationAdapterContextFactory ContextFactory { get; } Property Value Type Description IConfigurationAdapterContextFactory <!-- .classchild --> DefaultContextFactory Gets or sets the default context factory. The uninitialised default is Instance . Note - this can never be a null reference. Declaration public static IConfigurationAdapterContextFactory DefaultContextFactory { get; set; } Property Value Type Description IConfigurationAdapterContextFactory The default context factory. Exceptions Type Condition System.ArgumentNullException If you try to set the property to null. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods AppendInstructions(ConfigurationAdapterContext) Called to add instructions into the context from the configuration entries in the configuration within the passed context. Declaration protected virtual void AppendInstructions(ConfigurationAdapterContext context) Parameters Name Type Description context ConfigurationAdapterContext The context for this operation - provides access to the configuration whose entries are to be processed, and acts as the target for the processing instructions. <!-- .classchild --> CreateBuilderInstance(IConfiguration) Called to construct the instance of the ITargetContainer into which registrations are to be loaded. Declaration protected virtual ITargetContainer CreateBuilderInstance(IConfiguration configuration) Parameters Name Type Description configuration IConfiguration The configuration instance for which a builder is to be created. Returns Type Description ITargetContainer Remarks No parsing of the configuration is to be done here (except, perhaps, if the actual implementation of ITargetContainer that is used is dependant upon, say, the type of configuration object. The base behaviour is simply to create an instance of TargetContainer . <!-- .classchild --> CreateContext(IConfiguration) Creates the context that will be used while the passed configuration is processed. The default implementation forwards this call onto the context factory that was supplied on construction. Declaration protected virtual ConfigurationAdapterContext CreateContext(IConfiguration configuration) Parameters Name Type Description configuration IConfiguration Returns Type Description ConfigurationAdapterContext <!-- .classchild --> CreateTargetContainer(IConfiguration) Attempts to create an IRezolveTargetContainer instance from the passed configuration object. If the operation succeeds, then a builder will be returned, which you can then use to construct a new Rezolver. If the operation fails, then a ConfigurationException will be thrown. Declaration public virtual ITargetContainer CreateTargetContainer(IConfiguration configuration) Parameters Name Type Description configuration IConfiguration The parsed configuration to be loaded. Returns Type Description ITargetContainer An IRezolveTargetContainer instance ready to be used to construct a new IRezolver. Implements IConfigurationAdapter.CreateTargetContainer(IConfiguration) Exceptions Type Condition ConfigurationException If any part of the passed configuration is invalid (e.g. bad type references) or cannot be handled by this adapter (e.g. custom IConfigurationEntry instances or custom IRezolveTargetMetadata instances). <!-- .classchild --> TransformAssemblyReferenceEntry(IConfigurationEntry, ConfigurationAdapterContext) Transforms an IConfigurationEntry with a Type of AssemblyReference by attempting to convert the entry to an IAssemblyReferenceEntry , and then passing that to the current context as an assembly reference to be added. Declaration protected virtual RezolverBuilderInstruction TransformAssemblyReferenceEntry(IConfigurationEntry entry, ConfigurationAdapterContext context) Parameters Name Type Description entry IConfigurationEntry The entry to be processed. context ConfigurationAdapterContext The context for the operation Returns Type Description RezolverBuilderInstruction The default implementation returns null Remarks The default behaviour of this method is not to return anything - instead the entry is passed to the context to be treated as an Assembly Reference. The function signature still allows the returning of an instruction, however, in case derived classes want to tie this operation to an action being performed on the ITargetContainer later on. <!-- .classchild --> TransformEntry(IConfigurationEntry, ConfigurationAdapterContext) Called to transform a configuration entry into an instruction that will later be performed on the builder that is constructed by the configuration adapter. Declaration protected virtual RezolverBuilderInstruction TransformEntry(IConfigurationEntry entry, ConfigurationAdapterContext context) Parameters Name Type Description entry IConfigurationEntry The entry to be transformed into an instruction. context ConfigurationAdapterContext The context for the operation. Returns Type Description RezolverBuilderInstruction An instance of RezolverBuilderInstruction if successful, otherwise null. If errors occur, they are added to the context. <!-- .classchild --> TransformTypeRegistrationEntry(IConfigurationEntry, ConfigurationAdapterContext) Transforms an IConfigurationEntry with a Type of TypeRegistration into a RezolverBuilderInstruction . Declaration protected virtual RezolverBuilderInstruction TransformTypeRegistrationEntry(IConfigurationEntry entry, ConfigurationAdapterContext context) Parameters Name Type Description entry IConfigurationEntry The entry to be transformed. context ConfigurationAdapterContext The context for the operation. Returns Type Description RezolverBuilderInstruction If the entry can be converted into a RezolverBuilderInstruction , then an instance of that type, otherwise null. Remarks The default behaviour is to: Attempt to convert the entry to an ITypeRegistrationEntry Parsing its type references in Types Constructing an ITarget from the entry's TargetMetadata through a call to its CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) method. If that returns a non-null target, then a RegisterInstruction is created and returned. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContext.UnresolvedType.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContext.UnresolvedType.html",
    "title": "Class ConfigurationAdapterContext.UnresolvedType",
    "keywords": "Class ConfigurationAdapterContext.UnresolvedType Used as a sentinel type by the ResolveType(String, Nullable<Int32>) method when the type search fails. Inheritance Object ConfigurationAdapterContext.UnresolvedType Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax protected class UnresolvedType"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContext.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContext.html",
    "title": "Class ConfigurationAdapterContext",
    "keywords": "Class ConfigurationAdapterContext This class is used to store the intermediate state for the default IConfigurationAdapter implementation's ( ConfigurationAdapter ) parsing operation on an IConfiguration instance. If you are extending the default adapter you might need also to extend this class to ensure any additional state you require is maintained. Inheritance Object ConfigurationAdapterContext Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationAdapterContext <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConfigurationAdapterContext(IConfigurationAdapter, IConfiguration, IEnumerable<Assembly>) Constructs a new instance of the ConfigurationAdapterContext class. Declaration public ConfigurationAdapterContext(IConfigurationAdapter adapter, IConfiguration configuration, IEnumerable<Assembly> defaultAssemblyReferences = null) Parameters Name Type Description adapter IConfigurationAdapter The adapter that will create the ITargetContainer from the configuration. configuration IConfiguration Required. The configuration that is being processed by the adapter for which this context is being constructed defaultAssemblyReferences IEnumerable < Assembly > Optional. Default set of assemblies that are to be searched for types when type references are processed. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Adapter Declaration public IConfigurationAdapter Adapter { get; } Property Value Type Description IConfigurationAdapter <!-- .classchild --> Configuration Gets the configuration that is being processed by the adapter that is working within this context. Declaration public IConfiguration Configuration { get; } Property Value Type Description IConfiguration The configuration. <!-- .classchild --> ErrorCount Retrieves the number of errors currently in the Errors enumerable. Declaration public int ErrorCount { get; } Property Value Type Description Int32 <!-- .classchild --> Errors Retrieves a snapshot of the current errors list. If further errors are added while you are enumerating the enumerable returned by this property, no exception will occur, and the newly added items will not be included. Declaration public IEnumerable<IConfigurationError> Errors { get; } Property Value Type Description IEnumerable < IConfigurationError > <!-- .classchild --> Instructions Retrieves a snapshot of the instructions currently present in the context. Declaration public IEnumerable<RezolverBuilderInstruction> Instructions { get; } Property Value Type Description IEnumerable < RezolverBuilderInstruction > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods AddAssemblyReference(Assembly) Called to add an assembly reference to this context - the assembly will then be included in the search for types that are not fully qualified. Declaration public void AddAssemblyReference(Assembly assembly) Parameters Name Type Description assembly Assembly Required - the assembly to be added as a reference. <!-- .classchild --> AddAssemblyReference(IAssemblyReferenceEntry) Adds an assembly reference from an IAssemblyReferenceEntry obtained directly from an IConfiguration instance. The default behaviour is to attempt to load an assembly with the given name and, if found, add that using the overload that accepts an Assembly reference. Declaration public virtual void AddAssemblyReference(IAssemblyReferenceEntry entry) Parameters Name Type Description entry IAssemblyReferenceEntry <!-- .classchild --> AddAssemblyReferenceBase(Assembly) The core method for adding an assembly reference. The method will never be called (by the base at least) with a null argument. Declaration protected virtual void AddAssemblyReferenceBase(Assembly assembly) Parameters Name Type Description assembly Assembly <!-- .classchild --> AddAssemblyReferences(IEnumerable<Assembly>) Declaration public virtual void AddAssemblyReferences(IEnumerable<Assembly> assemblies) Parameters Name Type Description assemblies IEnumerable < Assembly > <!-- .classchild --> AddError(IConfigurationError) Declaration public void AddError(IConfigurationError error) Parameters Name Type Description error IConfigurationError <!-- .classchild --> AddErrors(IEnumerable<IConfigurationError>) Declaration public void AddErrors(IEnumerable<IConfigurationError> errors) Parameters Name Type Description errors IEnumerable < IConfigurationError > <!-- .classchild --> AppendInstruction(RezolverBuilderInstruction) Declaration public void AppendInstruction(RezolverBuilderInstruction instruction) Parameters Name Type Description instruction RezolverBuilderInstruction <!-- .classchild --> GetNamespacePrefixedTypeNames(String) Declaration protected IEnumerable<string> GetNamespacePrefixedTypeNames(string typeName) Parameters Name Type Description typeName String Returns Type Description IEnumerable < String > <!-- .classchild --> GetReferencedAssemblies() Gets an enumerable of all the assemblies that are referenced by this configuration file. This is used when resolving types. Declaration protected virtual IEnumerable<Assembly> GetReferencedAssemblies() Returns Type Description IEnumerable < Assembly > <!-- .classchild --> GetUsingNamespaces() Gets an enumerable of strings of all the namespaces (using dotted separators) that are imported for the configuration. This is used, by default, to project a list of type names to search for during type resolution. Declaration protected virtual IEnumerable<string> GetUsingNamespaces() Returns Type Description IEnumerable < String > <!-- .classchild --> InsertAfter(RezolverBuilderInstruction, RezolverBuilderInstruction) Allows for explicit ordering of instructions Declaration public void InsertAfter(RezolverBuilderInstruction instruction, RezolverBuilderInstruction after) Parameters Name Type Description instruction RezolverBuilderInstruction after RezolverBuilderInstruction <!-- .classchild --> InsertBefore(RezolverBuilderInstruction, RezolverBuilderInstruction) Allows for explicit ordering of instructions Declaration public void InsertBefore(RezolverBuilderInstruction instruction, RezolverBuilderInstruction before) Parameters Name Type Description instruction RezolverBuilderInstruction before RezolverBuilderInstruction <!-- .classchild --> InsertRangeAfter(IEnumerable<RezolverBuilderInstruction>, RezolverBuilderInstruction) Declaration public void InsertRangeAfter(IEnumerable<RezolverBuilderInstruction> instructions, RezolverBuilderInstruction after) Parameters Name Type Description instructions IEnumerable < RezolverBuilderInstruction > after RezolverBuilderInstruction <!-- .classchild --> InsertRangeBefore(IEnumerable<RezolverBuilderInstruction>, RezolverBuilderInstruction) Declaration public void InsertRangeBefore(IEnumerable<RezolverBuilderInstruction> instructions, RezolverBuilderInstruction before) Parameters Name Type Description instructions IEnumerable < RezolverBuilderInstruction > before RezolverBuilderInstruction <!-- .classchild --> ResolveType(String, Nullable<Int32>) Resolves a particular type name given this context's assembly references and, potentially, any namespace imports. This is designed to be used by a configuration adapter during the process of creating a container builder from a set of configuration entries. Declaration public virtual Type ResolveType(string typeName, int ? genericParameterCount = null) Parameters Name Type Description typeName String The typename genericParameterCount Nullable < Int32 > Used as a hint when multiple versions of the same type exist with open generic parameters and potentially with no generic parameters. Null means that either a generic or non-generic type can match. Zero means that only a non-generic type (or a closed generic type) can match. Any other positive value means that only an open generic type with that exact number of parameters can match. Returns Type Description Type A Type reference if the type is located, otherwise null. Exceptions Type Condition System.Reflection.AmbiguousMatchException If more than one type could be matched with the given name, typically due to namespace imports being used and more than type being available which has the same <!-- .classchild --> TryParseTypeReference(ITypeReference, out Type) Attempts to convert the passed typeReference into a Type . Errors are added to this context's Errors if the method returns false. Declaration public virtual bool TryParseTypeReference(ITypeReference typeReference, out Type type) Parameters Name Type Description typeReference ITypeReference The type reference. type Type The type that is identified, if successful. Returns Type Description Boolean true if the type reference is successfully parsed, false otherwise (with errors being added to the Errors collection). <!-- .classchild --> TryParseTypeReferences(IEnumerable<ITypeReference>, out Type[]) Tries to parse all type references, returning an overall success flag, with successfully parsed types being added to a list that is returned in the types output parameter. Declaration public bool TryParseTypeReferences(IEnumerable<ITypeReference> typeReferences, out Type[] types) Parameters Name Type Description typeReferences IEnumerable < ITypeReference > The type references. types Type [] Receives the types that are parsed. Note that if the method returns true, then this list will contain the same number of types as there are references in typeReferences , in the same order. If the method returns false, however, then the number of results in this list is undefined and you will not be able to marry up the input type reference to its output type. Returns Type Description Boolean true if all type references could be parsed, otherwise false . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContextFactory.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContextFactory.html",
    "title": "Class ConfigurationAdapterContextFactory",
    "keywords": "Class ConfigurationAdapterContextFactory The standard Singleton implementation of the IConfigurationAdapterContextFactory interface, and one which you can use as the starting point of your own factory. By default, it creates a new instance of the ConfigurationAdapterContext class (using the virtual method CreateContext(ConfigurationAdapter, IConfiguration) , and then instructs it to add its default assembly references. Inheritance Object ConfigurationAdapterContextFactory Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationAdapterContextFactory : IConfigurationAdapterContextFactory <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConfigurationAdapterContextFactory() Creation of new instances of this class, outside of the Instance instance, is only through inheritance. Declaration protected ConfigurationAdapterContextFactory() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Instance The one and only instance of this context factory. Note that this is also the default application-wide context factory that is used by the standard ConfigurationAdapter class when converting configuration data into rezolvers (by virtue of the DefaultContextFactory property, which you can change). Declaration public static ConfigurationAdapterContextFactory Instance { get; } Property Value Type Description ConfigurationAdapterContextFactory <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateContext(ConfigurationAdapter, IConfiguration) Implements the IConfigurationAdapterContextFactory method of the same name. The base behaviour is to create an instance of the ConfigurationAdapterContext class, passing the configuration and the default set of assembly references returned by GetDefaultAssemblyReferences() . Declaration public virtual ConfigurationAdapterContext CreateContext(ConfigurationAdapter adapter, IConfiguration configuration) Parameters Name Type Description adapter ConfigurationAdapter The adapter. configuration IConfiguration The configuration. Returns Type Description ConfigurationAdapterContext Implements IConfigurationAdapterContextFactory.CreateContext(ConfigurationAdapter, IConfiguration) <!-- .classchild --> GetDefaultAssemblyReferences() Gets the assemblies that are to be used for new contexts as the default set of references. The base behaviour is to add mscorlib, System and System.Core although, depending on the target platform, the list might be less. Declaration protected virtual IEnumerable<Assembly> GetDefaultAssemblyReferences() Returns Type Description IEnumerable < Assembly > <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationEntryBase.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationEntryBase.html",
    "title": "Class ConfigurationEntryBase",
    "keywords": "Class ConfigurationEntryBase suggested starting point for implementing your own configuration entries. Inheritance Object ConfigurationEntryBase Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationEntryBase : IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConfigurationEntryBase(ConfigurationEntryType, IConfigurationLineInfo) Declaration protected ConfigurationEntryBase(ConfigurationEntryType type, IConfigurationLineInfo lineInfo) Parameters Name Type Description type ConfigurationEntryType lineInfo IConfigurationLineInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties EndLineNo Declaration public int ? EndLineNo { get; } Property Value Type Description Nullable < Int32 > Implements IConfigurationLineInfo.EndLineNo <!-- .classchild --> EndLinePos Declaration public int ? EndLinePos { get; } Property Value Type Description Nullable < Int32 > Implements IConfigurationLineInfo.EndLinePos <!-- .classchild --> StartLineNo Declaration public int ? StartLineNo { get; } Property Value Type Description Nullable < Int32 > Implements IConfigurationLineInfo.StartLineNo <!-- .classchild --> StartLinePos Declaration public int ? StartLinePos { get; } Property Value Type Description Nullable < Int32 > Implements IConfigurationLineInfo.StartLinePos <!-- .classchild --> Type Declaration public ConfigurationEntryType Type { get; } Property Value Type Description ConfigurationEntryType Implements IConfigurationEntry.Type <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationEntryType.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationEntryType.html",
    "title": "Enum ConfigurationEntryType",
    "keywords": "Enum ConfigurationEntryType Types of configuration entry that can be parsed from a configuration file Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public enum ConfigurationEntryType <!-- <hr class=\"typeSectionDivider\" /> --> Fields AssemblyReference An instruction to load one or more assemblies before any type registrations are processed Depending on the runtime environment, to be sure of the type binder finding namespace-qualified types mentioned in a configuration file, then any assemblies you might be referencing should be included in your configuration file. Equally, you can use this to load assemblies that wouldn't normally be found (e.g. a la unity) Note that types which would usually be found with a simple call to Type.GetType do not need their parent assemblies explicitly referenced. Declaration AssemblyReference = 1 Field Value Type Description ConfigurationEntryType <!-- .classchild --> Extension A custom entry - the instance should also have the interface IConfigurationExtensionEntry Declaration Extension = 2147483647 Field Value Type Description ConfigurationEntryType <!-- .classchild --> NamedBuilder An instruction to create a named builder in the target builder, within which further named builders or type registrations might be performed. Declaration NamedBuilder = 11 Field Value Type Description ConfigurationEntryType <!-- .classchild --> NamespaceImport Just like 'using' or 'import' in C# or VB, this allows you to specify namespaces that you will be using in your type names elsewhere in a configuration file. Declaration NamespaceImport = 2 Field Value Type Description ConfigurationEntryType <!-- .classchild --> TypeRegistration The most common type - an instruction to generate one or more type registrations in the target builder Declaration TypeRegistration = 10 Field Value Type Description ConfigurationEntryType <!-- .classchild --> Unknown Declaration Unknown = 0 Field Value Type Description ConfigurationEntryType <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationError.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationError.html",
    "title": "Class ConfigurationError",
    "keywords": "Class ConfigurationError Inheritance Object ConfigurationError Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationError : IConfigurationError <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConfigurationError(Exception, IConfigurationLineInfo) Declaration public ConfigurationError(Exception exception, IConfigurationLineInfo lineInfo) Parameters Name Type Description exception Exception lineInfo IConfigurationLineInfo <!-- .classchild --> ConfigurationError(String, IConfigurationLineInfo) Declaration public ConfigurationError(string errorMessage, IConfigurationLineInfo lineInfo) Parameters Name Type Description errorMessage String lineInfo IConfigurationLineInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties ErrorMessage Declaration public string ErrorMessage { get; } Property Value Type Description String Implements IConfigurationError.ErrorMessage <!-- .classchild --> ErrorMessageWithLineInfo Declaration public string ErrorMessageWithLineInfo { get; } Property Value Type Description String Implements IConfigurationError.ErrorMessageWithLineInfo <!-- .classchild --> Exception Declaration public Exception Exception { get; } Property Value Type Description Exception <!-- .classchild --> IsException Declaration public bool IsException { get; } Property Value Type Description Boolean <!-- .classchild --> LineInfo Declaration public IConfigurationLineInfo LineInfo { get; } Property Value Type Description IConfigurationLineInfo Implements IConfigurationError.LineInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods UnexpectedMetadataType(RezolveTargetMetadataType, Type, Type, IConfigurationLineInfo) Declaration public static ConfigurationError UnexpectedMetadataType(RezolveTargetMetadataType type, Type expected, Type actual, IConfigurationLineInfo lineInfo) Parameters Name Type Description type RezolveTargetMetadataType expected Type actual Type lineInfo IConfigurationLineInfo Returns Type Description ConfigurationError <!-- .classchild --> UnresolvedType(ITypeReference) Declaration public static ConfigurationError UnresolvedType(ITypeReference typeReference) Parameters Name Type Description typeReference ITypeReference Returns Type Description ConfigurationError <!-- .classchild --> UnresolvedType(String, IConfigurationLineInfo) Declaration public static ConfigurationError UnresolvedType(string typeName, IConfigurationLineInfo lineInfo) Parameters Name Type Description typeName String lineInfo IConfigurationLineInfo Returns Type Description ConfigurationError <!-- .classchild -->"
  },
  "rezolver-api/System.Linq.Expressions.html": {
    "href": "rezolver-api/System.Linq.Expressions.html",
    "title": "Namespace System.Linq.Expressions",
    "keywords": "Namespace System.Linq.Expressions Classes ExpressionExtensions"
  },
  "rezolver-api/System.html": {
    "href": "rezolver-api/System.html",
    "title": "Namespace System",
    "keywords": "Namespace System Classes DelegateExtensions"
  },
  "rezolver-api/Rezolver.ChildTargetContainer.html": {
    "href": "rezolver-api/Rezolver.ChildTargetContainer.html",
    "title": "Class ChildTargetContainer",
    "keywords": "Class ChildTargetContainer A version of TargetContainer which overrides the registrations of another (the Parent ). Inheritance Object TargetDictionaryContainer TargetContainer ChildTargetContainer Inherited Members TargetContainer.CreateContainer(Type, ITarget) TargetContainer.CreateGenericTypeDefContainer(Type, ITarget) TargetContainer.FetchContainer(Type) TargetContainer.Register(ITarget, Type) TargetContainer.RegisterContainer(Type, ITargetContainer) TargetContainer.RegisterContainerDirect(Type, ITargetContainer) TargetDictionaryContainer.CombineWith(ITargetContainer, Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ChildTargetContainer : TargetContainer, ITargetContainerOwner, IChildTargetContainer, ITargetContainer Remarks When it's looking to find an entry for a type, if it cannot find one within its own registrations, it will forward the call on to its ancestors (starting with its Parent ). As a result, any dependencies required by registrations in this container can be provided by any ancestor. Fallback logic in the Fetch(Type) is triggered by the UseFallback property. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ChildTargetContainer(ITargetContainer) Initializes a new instance of the ChildTargetContainer class. Declaration public ChildTargetContainer(ITargetContainer parent) Parameters Name Type Description parent ITargetContainer Required. The parent target container <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Parent Gets the parent. Declaration public ITargetContainer Parent { get; } Property Value Type Description ITargetContainer The parent. Implements IChildTargetContainer.Parent <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Fetch(Type) Fetches the registered target for the given type , if found, or forwards the call to the Parent container. Declaration public override ITarget Fetch(Type type) Parameters Name Type Description type Type The type whose registration is sought. Returns Type Description ITarget The target which is registered for the given type, or null if no registration can be found. Overrides TargetDictionaryContainer.Fetch(Type) Implements ITargetContainer.Fetch(Type) <!-- .classchild --> FetchAll(Type) Implementation of FetchAll(Type) Declaration public override IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type Type The type whose targets are to be retrieved. Returns Type Description IEnumerable < ITarget > A non-null enumerable containing the targets that match the type, or an empty enumerable if the type is not registered. Overrides TargetDictionaryContainer.FetchAll(Type) Implements ITargetContainer.FetchAll(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.CompileContext.CompileStackEntry.html": {
    "href": "rezolver-api/Rezolver.CompileContext.CompileStackEntry.html",
    "title": "Class CompileContext.CompileStackEntry",
    "keywords": "Class CompileContext.CompileStackEntry Represents an Inheritance Object CompileContext.CompileStackEntry Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class CompileStackEntry : IEquatable<CompileContext.CompileStackEntry> <!-- <hr class=\"typeSectionDivider\" /> --> Constructors CompileStackEntry(ITarget, Type) Declaration public CompileStackEntry(ITarget target, Type compilingType) Parameters Name Type Description target ITarget compilingType Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties CompilingType Declaration public Type CompilingType { get; } Property Value Type Description Type <!-- .classchild --> Target Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Equals(CompileContext.CompileStackEntry) Declaration public bool Equals(CompileContext.CompileStackEntry other) Parameters Name Type Description other CompileContext.CompileStackEntry Returns Type Description Boolean Implements IEquatable<CompileContext.CompileStackEntry>.Equals(CompileContext.CompileStackEntry) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.CompileContext.SharedExpressionKey.html": {
    "href": "rezolver-api/Rezolver.CompileContext.SharedExpressionKey.html",
    "title": "Class CompileContext.SharedExpressionKey",
    "keywords": "Class CompileContext.SharedExpressionKey Key for a shared expression used during expression tree generation. As a consumer of this library, you are unlikely ever to need to use it. Inheritance Object CompileContext.SharedExpressionKey Inherited Members Object.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class SharedExpressionKey : IEquatable<CompileContext.SharedExpressionKey> <!-- <hr class=\"typeSectionDivider\" /> --> Constructors SharedExpressionKey(Type, String, Type) Initializes a new instance of the CompileContext.SharedExpressionKey class. Declaration public SharedExpressionKey(Type targetType, string name, Type requestingType = null) Parameters Name Type Description targetType Type Required. Eventual runtime type of the object produced by the expression that will be cached using this key. name String Required. The name used for storing and retrieving expressions cached with this key. requestingType Type The type (e.g. the runtime type of an ITarget implementation) whose compilation requires the cached expression. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Name Gets the name used for expressions that are cached using this key. Declaration public string Name { get; } Property Value Type Description String The name. <!-- .classchild --> RequestingType Gets the type that registered the shared expression Declaration public Type RequestingType { get; } Property Value Type Description Type <!-- .classchild --> TargetType The intended type of the expression that is cached by this key. Declaration public Type TargetType { get; } Property Value Type Description Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Equals(CompileContext.SharedExpressionKey) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(CompileContext.SharedExpressionKey other) Parameters Name Type Description other CompileContext.SharedExpressionKey An object to compare with this object. Returns Type Description Boolean true if the current object is equal to the other parameter; otherwise, false. Implements IEquatable<CompileContext.SharedExpressionKey>.Equals(CompileContext.SharedExpressionKey) <!-- .classchild --> Equals(Object) Determines whether the specified Object is equal to this instance. Declaration public override bool Equals(object obj) Parameters Name Type Description obj Object The object to compare with the current object. Returns Type Description Boolean true if the specified Object is equal to this instance; otherwise, false . Overrides Object.Equals(Object) <!-- .classchild --> GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description Int32 A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. Overrides Object.GetHashCode() <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.CompileContext.html": {
    "href": "rezolver-api/Rezolver.CompileContext.html",
    "title": "Class CompileContext",
    "keywords": "Class CompileContext Provides support and compile-time state for the compilation of an ITarget by an ITargetCompiler . THIS CLASS IS NOT THREAD-SAFE Inheritance Object CompileContext Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class CompileContext : ITargetContainer Remarks The purpose of this class is to help an ITarget generate an expression tree that will ultimately be compiled using CompileTarget(ITarget, CompileContext) method. The goal being to produce an ICompiledTarget whose GetObject(RezolveContext) method will be called to get instances when a container's Resolve(RezolveContext) method is invoked. Therefore, the context of the expression tree being generated is a method which takes a single RezolveContext parameter - hence the expressions exposed by this type (e.g. RezolveContextExpression ) are there to help generate code that will work in that context. Working directly with this, or any other code connected with the expression tree/compilation process, is an advanced topic! The class implements the ITargetContainer interface also to extend dependency lookups during compilation time. Indeed, if you are developing your own ITarget implementation and need to resolve any dependencies from an ITargetContainer during compilation, it should be done through the context's implementation of ITargetContainer. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors CompileContext(CompileContext, Type, Boolean, Boolean) Creates a new CompileContext using an existing one as a template. Declaration public CompileContext(CompileContext parentContext, Type targetType = null, bool inheritSharedExpressions = true, bool suppressScopeTracking = false) Parameters Name Type Description parentContext CompileContext Used to seed the compilation stack, container, rezolve context parameter and optionally the target type (if you pass null for targetType . targetType Type The target type that is expected to be compiled, or null to inherit the parentContext 's TargetType property. inheritSharedExpressions Boolean If true (the default), then the SharedExpressions for this context will be shared from the parent context - meaning that any new additions will be added back to the parent context again. This is the most common behaviour when chaining multiple targets' expressions together. Passing false for this parameter is only required in rare situations. suppressScopeTracking Boolean If true, then any expressions constructed from ITarget objects should not contain automatically generated code to track objects in an enclosing scope. The default is false. This is typically only enabled when one target is explicitly using expressions created from other targets, and has its own scope tracking code, or expects to be surrounded by automatically generated scope tracking code itself. <!-- .classchild --> CompileContext(IContainer, ITargetContainer, Type, ParameterExpression, IEnumerable<CompileContext.CompileStackEntry>) Creates a new CompileContext Declaration public CompileContext(IContainer container, ITargetContainer dependencyTargetContainer, Type targetType = null, ParameterExpression rezolveContextExpression = null, IEnumerable<CompileContext.CompileStackEntry> compilingTargets = null) Parameters Name Type Description container IContainer Required. The container for which compilation is being performed. Will be set into the Container property. dependencyTargetContainer ITargetContainer Required - An ITargetContainer that contains the ITarget s that will be required to complete compilation. Note - this argument is passed to a new ChildTargetContainer that is created and proxied by this class' implementation of ITargetContainer . As a result, it's possible to register new targets directly into the context via the Register(ITarget, Type) method, without modifying the underlying targets in the container you pass. Some of the core ITarget s exposed by this library take advantage of that functionality (notably, the DecoratorTarget ). targetType Type Optional. Will be set into the TargetType property. If not provided, then any code generated within this context should compile for the DeclaredType . rezolveContextExpression ParameterExpression Optional. Will be set into the RezolveContextExpression property. If not provided, then the RezolveContextParameterExpression global reference will be used. compilingTargets IEnumerable < CompileContext.CompileStackEntry > Optional. Allows you to seed the stack of compiling targets from creation. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties CompilingTargets An enumerable representing the current stack of targets that are being compiled on this context. The underlying stack is not exposed through this enumerable. Declaration public IEnumerable<CompileContext.CompileStackEntry> CompilingTargets { get; } Property Value Type Description IEnumerable < CompileContext.CompileStackEntry > <!-- .classchild --> Container The container that is considered the current compilation 'scope' - i.e. the container for which the compilation is being performed and, usually, the one on which the Resolve(RezolveContext) method was originally called which triggered the compilation call. Declaration public IContainer Container { get; } Property Value Type Description IContainer Remarks NOTE - For compile-time dependency resolution (i.e. other ITarget s) you should use this class' implementation of ITargetContainer . <!-- .classchild --> ContainerExpression A ConstantExpression that equals the Container that is active for this context - you can use this during code generation to alter your expression's behaviour if the Container during a future call to Resolve(RezolveContext) is different from the one for which the expression was first compiled. For this kind of behaviour you will also need to use the RezolveContextExpression Declaration public Expression ContainerExpression { get; } Property Value Type Description Expression <!-- .classchild --> ContextContainerPropertyExpression Returns an expression that represents reading the Container property of the RezolveContextExpression during the execution of an ICompiledTarget 's GetObject(RezolveContext) method. Declaration public MemberExpression ContextContainerPropertyExpression { get; } Property Value Type Description MemberExpression Remarks This IS NOT the same as the ContainerExpression property, which always returns a constant reference to the original IContainer for which this compilation context was created. Always non-null. <!-- .classchild --> ContextScopePropertyExpression Returns an expression that represents reading the Scope property of the RezolveContext referenced by the RezolveContextExpression at resolve-time. Declaration public MemberExpression ContextScopePropertyExpression { get; } Property Value Type Description MemberExpression <!-- .classchild --> RezolveContextExpression An expression to be used to bind to the RezolveContext parameter be passed to the generated code at runtime (the context parameter for Resolve(RezolveContext) and, eventually, GetObject(RezolveContext) ). Declaration public ParameterExpression RezolveContextExpression { get; } Property Value Type Description ParameterExpression Remarks If this is never explicitly set, the framework uses RezolveContextParameterExpression by default. In theory, you should never need to set this to anything else, unless you're doing something very interesting with the generated expressions. <!-- .classchild --> SharedExpressions The expressions that have been registered by targets whilst creating expressions for compiled targets. Declaration public IEnumerable<Expression> SharedExpressions { get; } Property Value Type Description IEnumerable < Expression > Remarks Shared expressions are expressions which targets add to the compile context as they are compiled, enabling them to generate code which is both more efficient at runtime (e.g. avoiding the creation of redundant locals for blocks which can reuse a pre-existing local) and which can be more efficiently rewritten due to the reuse of identical expression references for things like conditional checks and so on. A compiler MUST handle the case where this enumerable contains ParameterExpressions, as they will need to be added as local variables to an all-encompassing BlockExpression around the root of an expression tree that is to be compiled. <!-- .classchild --> SuppressScopeTracking If true, then any target that is compiling within this context should not generate any runtime code to fetch the object from, or track the object in, the current IScopedContainer (identified by the ContextScopePropertyExpression ). Declaration public bool SuppressScopeTracking { get; } Property Value Type Description Boolean Remarks This is currently used, for example, by wrapper targets that generate their own scope tracking code (specifically, the SingletonTarget and ScopedTarget . It's therefore very important that any custom ITarget implementations which intend to do their own scoping honour this flag in their implementation of CreateExpression(CompileContext) . The TargetBase class does honour this flag. <!-- .classchild --> TargetType The type that is to be returned by the generated code. Declaration public Type TargetType { get; } Property Value Type Description Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CombineWith(ITargetContainer, Type) Always throws a System.NotSupportedException Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer Ignored type Type Ignored Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) Exceptions Type Condition System.NotSupportedException Always thrown <!-- .classchild --> Fetch(Type) Implements Fetch(Type) by wrapping around the child target container created by this context on construction. Declaration public ITarget Fetch(Type type) Parameters Name Type Description type Type See Fetch(Type) for more. Returns Type Description ITarget Implements ITargetContainer.Fetch(Type) <!-- .classchild --> FetchAll(Type) Implements FetchAll(Type) by wrapping around the child target container created by this context on construction. Declaration public IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type Type See FetchAll(Type) for more Returns Type Description IEnumerable < ITarget > Implements ITargetContainer.FetchAll(Type) <!-- .classchild --> GetOrAddSharedExpression(Type, String, Func<Expression>, Type) Gets or adds a shared expression (created by the expressionFactory if it's not already cached) with the given name, type, optionally for the given requestingType . Declaration public Expression GetOrAddSharedExpression(Type type, string name, Func<Expression> expressionFactory, Type requestingType = null) Parameters Name Type Description type Type The runtime type of the Expression. name String The runtime name of the Expression - and also the name used to retrieve it later. expressionFactory Func < Expression > The factory method to use to construct the shared expression from scratch, if it's not already cached. requestingType Type Optional - to avoid naming clashes with shared expressions created by other targets, you can pass a type here (usually the runtime type of your ITarget implementation). Returns Type Description Expression Expression. <!-- .classchild --> GetOrAddSharedLocal(Type, String, Type) Creates or retrieves a shared with the given name and type, optionally registered for the given requestingType . Declaration public ParameterExpression GetOrAddSharedLocal(Type type, string name, Type requestingType = null) Parameters Name Type Description type Type The runtime type of the ParameterExpression. name String The runtime name of the ParameterExpression - and also the name used to retrieve it later. requestingType Type Optional - to avoid naming clashes with shared parameter expressions created by other targets, you can pass a type here (usually the runtime type of your ITarget implementation). Returns Type Description ParameterExpression Remarks If you use a shared for a local in your expression trees, you are signifying that all of your targets which use that local, regardless of whether they represent different results at runtime, can safely store and retrieve whatever state they are tracking within without interfering with each other. <!-- .classchild --> New(Type, Boolean, Boolean) Spawns a new context for the passed targetType , with everything else being inherited from this context by default. Declaration public CompileContext New(Type targetType, bool inheritSharedExpressions = true, bool suppressScopeTracking = false) Parameters Name Type Description targetType Type Required. The type to be compiled. inheritSharedExpressions Boolean if set to true [inherit shared expressions]. suppressScopeTracking Boolean if set to true [suppress scope tracking]. Returns Type Description CompileContext A new CompileContext Remarks This is a convenience method which simply wraps the CompileContext(CompileContext, Type, Boolean, Boolean) constructor, except in this method the targetType is required. <!-- .classchild --> PopCompileStack() Pops a target from the stack and returns it. Note that if there are no targets on the stack, an System.InvalidOperationException will occur. Declaration public CompileContext.CompileStackEntry PopCompileStack() Returns Type Description CompileContext.CompileStackEntry <!-- .classchild --> PushCompileStack(ITarget) Adds the target to the compilation stack if it doesn't already exist. Declaration public bool PushCompileStack(ITarget toCompile) Parameters Name Type Description toCompile ITarget The target to be pushed Returns Type Description Boolean A boolean indicating whether the target was added. Will be false if the target is already on the stack. <!-- .classchild --> Register(ITarget, Type) Implements Register(ITarget, Type) by wrapping around the child target container created by this context on construction. Declaration public void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget See Register(ITarget, Type) for more serviceType Type See Register(ITarget, Type) for more Implements ITargetContainer.Register(ITarget, Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.CompiledTargetBase.html": {
    "href": "rezolver-api/Rezolver.CompiledTargetBase.html",
    "title": "Class CompiledTargetBase",
    "keywords": "Class CompiledTargetBase Standard starting point for an implementation of ICompiledTarget where the target is built directly from an ITarget . Inheritance Object CompiledTargetBase Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public abstract class CompiledTargetBase : ICompiledTarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors CompiledTargetBase(ITarget) Initialises the CompiledTargetBase abstract class. Declaration protected CompiledTargetBase(ITarget originalTarget) Parameters Name Type Description originalTarget ITarget Required - the target that was compiled into this instance. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties OriginalTarget The target whose expression (obtained from CreateExpression(CompileContext) ) was compiled into this instance. Will not be null. Declaration protected ITarget OriginalTarget { get; } Property Value Type Description ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetObject(RezolveContext) Abstract implementation of GetObject(RezolveContext) Declaration public abstract object GetObject(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description Object Implements ICompiledTarget.GetObject(RezolveContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ConditionalRewriter.html": {
    "href": "rezolver-api/Rezolver.ConditionalRewriter.html",
    "title": "Class ConditionalRewriter",
    "keywords": "Class ConditionalRewriter Reorders an expression tree where duplicate conditional expressions are found in multiple places throughout that expression tree. Those duplicated conditionals are moved further up the expression tree into one conditional. Inheritance Object ConditionalRewriter Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ConditionalRewriter : ExpressionVisitor <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConditionalRewriter(Expression, IEnumerable<Expression>) Declaration public ConditionalRewriter(Expression expression, IEnumerable<Expression> candidateTests) Parameters Name Type Description expression Expression candidateTests IEnumerable < Expression > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Rewrite() Declaration public Expression Rewrite() Returns Type Description Expression <!-- .classchild --> Visit(Expression) Declaration public override Expression Visit(Expression node) Parameters Name Type Description node Expression Returns Type Description Expression <!-- .classchild --> VisitConditional(ConditionalExpression) Declaration protected override Expression VisitConditional(ConditionalExpression node) Parameters Name Type Description node ConditionalExpression Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.AssemblyReferenceEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.AssemblyReferenceEntry.html",
    "title": "Class AssemblyReferenceEntry",
    "keywords": "Class AssemblyReferenceEntry Inheritance Object ConfigurationEntryBase AssemblyReferenceEntry Inherited Members ConfigurationEntryBase.Type ConfigurationEntryBase.StartLineNo ConfigurationEntryBase.StartLinePos ConfigurationEntryBase.EndLineNo ConfigurationEntryBase.EndLinePos Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class AssemblyReferenceEntry : ConfigurationEntryBase, IAssemblyReferenceEntry, IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors AssemblyReferenceEntry(String, IConfigurationLineInfo) Declaration public AssemblyReferenceEntry(string assemblyName, IConfigurationLineInfo lineInfo = null) Parameters Name Type Description assemblyName String lineInfo IConfigurationLineInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties AssemblyName Declaration public string AssemblyName { get; } Property Value Type Description String Implements IAssemblyReferenceEntry.AssemblyName <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationException.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationException.html",
    "title": "Class ConfigurationException",
    "keywords": "Class ConfigurationException Inheritance Object Exception ConfigurationException Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.Data Exception.InnerException Exception.TargetSite Exception.StackTrace Exception.HelpLink Exception.Source Exception.HResult Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationException : Exception, ISerializable, _Exception <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConfigurationException(ConfigurationAdapterContext) Declaration public ConfigurationException(ConfigurationAdapterContext context) Parameters Name Type Description context ConfigurationAdapterContext <!-- .classchild --> ConfigurationException(IConfiguration, IEnumerable<IConfigurationError>) Declaration public ConfigurationException(IConfiguration configuration, IEnumerable<IConfigurationError> errors) Parameters Name Type Description configuration IConfiguration errors IEnumerable < IConfigurationError > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Message Declaration public override string Message { get; } Property Value Type Description String Overrides Exception.Message <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConstructorTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConstructorTargetMetadata.html",
    "title": "Class ConstructorTargetMetadata",
    "keywords": "Class ConstructorTargetMetadata Inheritance Object RezolveTargetMetadataBase ConstructorTargetMetadata Inherited Members RezolveTargetMetadataBase.Type RezolveTargetMetadataBase.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) RezolveTargetMetadataBase.Bind(ITypeReference[]) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConstructorTargetMetadata : RezolveTargetMetadataBase, IConstructorTargetMetadata, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConstructorTargetMetadata(ITypeReference[], ITypeReference[], IDictionary<String, IRezolveTargetMetadata>) Constructs a new instance of the ConstructorTargetMetadata class. Declaration public ConstructorTargetMetadata(ITypeReference[] typesToBuild, ITypeReference[] signatureTypes = null, IDictionary<string, IRezolveTargetMetadata> args = null) Parameters Name Type Description typesToBuild ITypeReference [] The types to build. signatureTypes ITypeReference [] The types of the parameters for the constructor that is to be bound. If null, then the constructor is to be sought by finding the best match based on the arguments (if provided). This is typically required if you have an ambiguity when matching purely by name. args IDictionary < String , IRezolveTargetMetadata > The arguments. Remarks Please note that although the typesToBuild parameter is an array, in practise only one type can ever be built. Multiple types are accepted to cover scenarios where a class, its bases and zero or more interfaces are all referenced as target registration types, and these types are passed directly to the constructor target. In building such a target from the metadata an adapter will typically find the most derived type of the group and bind to that only. Note that if one or more types are not related to the rest of the group, then an adapter is free to throw a runtime error. Exceptions Type Condition System.ArgumentNullException typesToBuild System.ArgumentException The array cannot be empty;typesToBuild or All entries in the array must be non-null;typesToBuild <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Arguments Declaration public IDictionary<string, IRezolveTargetMetadata> Arguments { get; } Property Value Type Description IDictionary < String , IRezolveTargetMetadata > Implements IConstructorTargetMetadata.Arguments <!-- .classchild --> DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides RezolveTargetMetadataBase.DeclaredType Implements IRezolveTargetMetadata.DeclaredType <!-- .classchild --> SignatureTypes Declaration public ITypeReference[] SignatureTypes { get; } Property Value Type Description ITypeReference [] Implements IConstructorTargetMetadata.SignatureTypes <!-- .classchild --> TypesToBuild Remember - the intention is that only one of these types will actually be bound on constructing the constructor target. Declaration public ITypeReference[] TypesToBuild { get; } Property Value Type Description ITypeReference [] Implements IConstructorTargetMetadata.TypesToBuild <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides RezolveTargetMetadataBase.BindBase(ITypeReference[]) <!-- .classchild --> CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description ITarget Overrides RezolveTargetMetadataBase.CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IAssemblyReferenceEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.IAssemblyReferenceEntry.html",
    "title": "Interface IAssemblyReferenceEntry",
    "keywords": "Interface IAssemblyReferenceEntry A configuration entry instructing the configuration adapter to load an assembly before resolving types. Inherited Members IConfigurationEntry.Type IConfigurationLineInfo.StartLineNo IConfigurationLineInfo.StartLinePos IConfigurationLineInfo.EndLineNo IConfigurationLineInfo.EndLinePos Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IAssemblyReferenceEntry : IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties AssemblyName Declaration string AssemblyName { get; } Property Value Type Description String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfiguration.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfiguration.html",
    "title": "Interface IConfiguration",
    "keywords": "Interface IConfiguration Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfiguration <!-- <hr class=\"typeSectionDivider\" /> --> Properties Entries Declaration IEnumerable<IConfigurationEntry> Entries { get; } Property Value Type Description IEnumerable < IConfigurationEntry > <!-- .classchild --> FileName Declaration string FileName { get; } Property Value Type Description String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationAdapter.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationAdapter.html",
    "title": "Interface IConfigurationAdapter",
    "keywords": "Interface IConfigurationAdapter Represents an object that is responsible for transforming configuration data into target containers. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationAdapter <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateTargetContainer(IConfiguration) Creates an ITargetContainer instance from an IConfiguration instance. Declaration ITargetContainer CreateTargetContainer(IConfiguration configuration) Parameters Name Type Description configuration IConfiguration Required - the configuration object that is to be used to build a container. Returns Type Description ITargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationAdapterContextFactory.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationAdapterContextFactory.html",
    "title": "Interface IConfigurationAdapterContextFactory",
    "keywords": "Interface IConfigurationAdapterContextFactory Used by this library's default implementation of IConfigurationAdapter, the ConfigurationAdapter class, to create an instance of the ConfigurationAdapterContext class for a given adapter that's processing a given configuration. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationAdapterContextFactory <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateContext(ConfigurationAdapter, IConfiguration) Declaration ConfigurationAdapterContext CreateContext(ConfigurationAdapter adapter, IConfiguration configuration) Parameters Name Type Description adapter ConfigurationAdapter configuration IConfiguration Returns Type Description ConfigurationAdapterContext <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationEntry.html",
    "title": "Interface IConfigurationEntry",
    "keywords": "Interface IConfigurationEntry Inherited Members IConfigurationLineInfo.StartLineNo IConfigurationLineInfo.StartLinePos IConfigurationLineInfo.EndLineNo IConfigurationLineInfo.EndLinePos Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationEntry : IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties Type Declaration ConfigurationEntryType Type { get; } Property Value Type Description ConfigurationEntryType <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationError.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationError.html",
    "title": "Interface IConfigurationError",
    "keywords": "Interface IConfigurationError Interface for an error that originates from a configuration file. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationError <!-- <hr class=\"typeSectionDivider\" /> --> Properties ErrorMessage The message Declaration string ErrorMessage { get; } Property Value Type Description String <!-- .classchild --> ErrorMessageWithLineInfo The message formatted with the start/end line and position for more accurate error reporting. Declaration string ErrorMessageWithLineInfo { get; } Property Value Type Description String <!-- .classchild --> LineInfo Start and (potentially) end position within the configuration file where this error originates. Declaration IConfigurationLineInfo LineInfo { get; } Property Value Type Description IConfigurationLineInfo <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Container.html": {
    "href": "rezolver-api/Rezolver.Container.html",
    "title": "Class Container",
    "keywords": "Class Container The standard IOC container class in Rezolver. Inheritance Object ContainerBase CachingContainerBase Container Inherited Members CachingContainerBase.GetCompiledRezolveTarget(RezolveContext) ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Compiler ContainerBase.Targets ContainerBase.Resolve(RezolveContext) ContainerBase.TryResolve(RezolveContext, Object) ContainerBase.CreateLifetimeScope() ContainerBase.FetchCompiled(RezolveContext) ContainerBase.CanResolve(RezolveContext) ContainerBase.GetFallbackCompiledRezolveTarget(RezolveContext) Rezolver.ContainerBase.System.IServiceProvider.GetService(System.Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.Fetch(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.FetchAll(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer, System.Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class Container : CachingContainerBase, IContainer, IServiceProvider, ITargetContainer Remarks All of this class' functionality is inherited through CachingContainerBase and its base classes. Note that it doesn't implement lifetime scoping (although you can create a lifetime scope from it by calling its CreateLifetimeScope() method). Also note that the class implements ITargetContainer through its ContainerBase base (which merely wraps around the Targets property. The reason for this is simplicity: in many applications, you'll want to simply create a new container, register services into it, and then start using it. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors Container(ITargetContainer, ITargetCompiler) Constructs a new instance of the Container class. Declaration public Container(ITargetContainer targets = null, ITargetCompiler compiler = null) Parameters Name Type Description targets ITargetContainer Optional. The targets that will be used to resolve objects. If left null, then a new, empty, target container will be constructed. compiler ITargetCompiler Optional. The compiler to be used to turn the ITarget s obtained from the Targets into ICompiledTarget targets that can actually be used at resolve-time. If not provided, then the Default will be used. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ContainerBase.MissingCompiledTarget.html": {
    "href": "rezolver-api/Rezolver.ContainerBase.MissingCompiledTarget.html",
    "title": "Class ContainerBase.MissingCompiledTarget",
    "keywords": "Class ContainerBase.MissingCompiledTarget Used as a sentinel type when a type cannot be resolved by a ContainerBase instance. Instead of returning a null ICompiledTarget instance, the container will construct an instance of this type (typically through GetMissingTarget(Type) , which caches singleton instances of this class on a per-type basis) which can then be used just as if the lookup succeeded. Inheritance Object ContainerBase.MissingCompiledTarget Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax protected class MissingCompiledTarget : ICompiledTarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors MissingCompiledTarget(Type) Declaration public MissingCompiledTarget(Type type) Parameters Name Type Description type Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetObject(RezolveContext) Implementation of GetObject(RezolveContext) . Always throws an System.InvalidOperationException . Declaration public object GetObject(RezolveContext context) Parameters Name Type Description context RezolveContext The current rezolve context. Returns Type Description Object Implements ICompiledTarget.GetObject(RezolveContext) Exceptions Type Condition System.InvalidOperationException Always thrown. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ContainerBase.html": {
    "href": "rezolver-api/Rezolver.ContainerBase.html",
    "title": "Class ContainerBase",
    "keywords": "Class ContainerBase Starting point for implementations of IContainer - only creatable through inheritance. Inheritance Object ContainerBase Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ContainerBase : IContainer, IServiceProvider, ITargetContainer Remarks This class also implements ITargetContainer by proxying the Targets that are provided to it on construction (or created anew if not supplied). All of those interface methods are implemented explicitly except the Register(ITarget, Type) method, which is available through the class' public API. Note: IContainer s are generally not expected to implement ITargetContainer , and the framework will never assume they do. The reason this class does is to make it easier to create a new container and to register targets into it without having to worry about managing a separate ITargetContainer instance in your application root - because all the registration extension methods defined in SingletonTargetDictionaryExtensions will be available to developers in code which has a reference to this class, or one derived from it. Note also that calling CombineWith(ITargetContainer, Type) on an instance of this type will always cause a System.NotSupportedException to be thrown. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ContainerBase(ITargetContainer, ITargetCompiler) Constructs a new instance of the ContainerBase , optionally initialising it with the given targets and compiler Declaration protected ContainerBase(ITargetContainer targets = null, ITargetCompiler compiler = null) Parameters Name Type Description targets ITargetContainer Optional. The target container whose registrations will be used for dependency lookup when Resolve(RezolveContext) (and other operations) is called. If not provided, a new TargetContainer instance is constructed. This will ultimately be available to inherited types, after construction, through the Targets property. compiler ITargetCompiler Optional. The compiler which will be used to create ICompiledTarget instances from the ITarget instances which are registered in the targets target container during resolve-time. If not provided, then the Default compiler is used. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Compiler The compiler that will be used to compile ITarget instances (obtained from the Targets container during Resolve(RezolveContext) and TryResolve(RezolveContext, out Object) operations) into ICompiledTarget instances that will actually provide the objects that are resolved. Declaration protected ITargetCompiler Compiler { get; } Property Value Type Description ITargetCompiler Remarks Notes to implementers: This property must NEVER be null. <!-- .classchild --> Targets Provides the ITarget instances that will be compiled by the Compiler into ICompiledTarget instances. Declaration protected ITargetContainer Targets { get; } Property Value Type Description ITargetContainer Remarks Notes to implementers: This property must NEVER be null. This class implements the ITargetContainer interface by wrapping around this instance so that an application can create an instance of ContainerBase and directly register targets into it; rather than having to create and setup the target container first. You can add registrations to this target container at any point in the lifetime of any ContainerBase instances which are attached to it. In reality, however, if any Resolve(RezolveContext) operations have been performed prior to adding more registrations, then there's no guarantee that new dependencies will be picked up - especially if the CachingContainerBase is being used as your application's container (which it nearly always will be). <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CanResolve(RezolveContext) Declaration public virtual bool CanResolve(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description Boolean Implements IContainer.CanResolve(RezolveContext) <!-- .classchild --> CreateLifetimeScope() Declaration public virtual IScopedContainer CreateLifetimeScope() Returns Type Description IScopedContainer Implements IContainer.CreateLifetimeScope() <!-- .classchild --> FetchCompiled(RezolveContext) Declaration public virtual ICompiledTarget FetchCompiled(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description ICompiledTarget Implements IContainer.FetchCompiled(RezolveContext) <!-- .classchild --> GetCompiledRezolveTarget(RezolveContext) Declaration protected virtual ICompiledTarget GetCompiledRezolveTarget(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description ICompiledTarget <!-- .classchild --> GetFallbackCompiledRezolveTarget(RezolveContext) Called by GetCompiledRezolveTarget(RezolveContext) if no valid ITarget can be found for the context or if the one found has its UseFallback property set to true . Declaration protected virtual ICompiledTarget GetFallbackCompiledRezolveTarget(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description ICompiledTarget An ICompiledTarget to be used as the result of a Resolve(RezolveContext) operation where the search for a valid target either fails or is inconclusive (e.g. - empty enumerables). Remarks The base implementation always returns an instance of the ContainerBase.MissingCompiledTarget via the GetMissingTarget(Type) static method. <!-- .classchild --> GetMissingTarget(Type) Gets an ICompiledTarget for the given type which will always throw an System.InvalidOperationException whenever its GetObject(RezolveContext) method is called. Use this when you can't resolve a target for a type. Declaration protected static ICompiledTarget GetMissingTarget(Type type) Parameters Name Type Description type Type The type for which you wish to create a missing target. Returns Type Description ICompiledTarget <!-- .classchild --> GetService(Type) Protected virtual implementation of GetService(Type) . Declaration protected virtual object GetService(Type serviceType) Parameters Name Type Description serviceType Type Returns Type Description Object <!-- .classchild --> IsMissingTarget(ICompiledTarget) Determines whether the given target is an instance of ContainerBase.MissingCompiledTarget . Declaration protected static bool IsMissingTarget(ICompiledTarget target) Parameters Name Type Description target ICompiledTarget The target. Returns Type Description Boolean <!-- .classchild --> Register(ITarget, Type) Implementation of Register(ITarget, Type) - simply proxies the call to the target container referenced by the Targets property. Declaration public void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget serviceType Type Implements ITargetContainer.Register(ITarget, Type) Remarks Remember: registering new targets into an ITargetContainer after an IContainer has started compiling targets within it can yield unpredictable results. If you create a new container and perform all your registrations before you use it, however, then everything will work as expected. Note also the other ITargetContainer interface methods are implemented explicitly so as to hide them from the list of class members. <!-- .classchild --> Resolve(RezolveContext) Declaration public virtual object Resolve(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description Object Implements IContainer.Resolve(RezolveContext) <!-- .classchild --> TryResolve(RezolveContext, out Object) Declaration public virtual bool TryResolve(RezolveContext context, out object result) Parameters Name Type Description context RezolveContext result Object Returns Type Description Boolean Implements IContainer.TryResolve(RezolveContext, Object) <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Explicit Interface Implementations ITargetContainer.CombineWith(ITargetContainer, Type) Declaration ITargetContainer ITargetContainer.CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer type Type Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) <!-- .classchild --> ITargetContainer.Fetch(Type) Declaration ITarget ITargetContainer.Fetch(Type type) Parameters Name Type Description type Type Returns Type Description ITarget Implements ITargetContainer.Fetch(Type) <!-- .classchild --> ITargetContainer.FetchAll(Type) Declaration IEnumerable<ITarget> ITargetContainer.FetchAll(Type type) Parameters Name Type Description type Type Returns Type Description IEnumerable < ITarget > Implements ITargetContainer.FetchAll(Type) <!-- .classchild --> IServiceProvider.GetService(Type) Declaration object IServiceProvider.GetService(Type serviceType) Parameters Name Type Description serviceType Type Returns Type Description Object Implements IServiceProvider.GetService(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DecoratorTarget.html": {
    "href": "rezolver-api/Rezolver.DecoratorTarget.html",
    "title": "Class DecoratorTarget",
    "keywords": "Class DecoratorTarget Implements service decoration in an ITargetContainer . The best way to add a decorator to your target container is to use the extension method or its non-generic equivalent. Inheritance Object DecoratorTarget Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DecoratorTarget : ITargetContainerOwner, ITargetContainer Remarks This class does not implement ITarget , rather it's an ITargetContainerOwner into which other targets can be added, and when Fetch(Type) or FetchAll(Type) are called, a temporary target object is created which wraps around the targets that have been registered within and which will ultimately create instances of DecoratorType <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DecoratorTarget(Type, Type) Initializes a new instance of the DecoratorTarget class. Declaration public DecoratorTarget(Type decoratorType, Type decoratedType) Parameters Name Type Description decoratorType Type Type of the decorator. decoratedType Type Type being decorated. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DecoratedType Gets the type that's being decorated - in essence, this is the type that this decorator target Declaration public Type DecoratedType { get; } Property Value Type Description Type <!-- .classchild --> DecoratorType Gets the type which will be used to decorate the instances produced by targets in this decorator target. Declaration public Type DecoratorType { get; } Property Value Type Description Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CombineWith(ITargetContainer, Type) Implements CombineWith(ITargetContainer, Type) by wrapping the existing container and returning itself. This allows decorators to be applied on top of decorators; and decorators to be added after types have begun to be registered in another target container. Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer The existing ITargetContainer instance that this instance is to be combined with type Type The type that the combined container owner will be registered under. Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) Exceptions Type Condition System.InvalidOperationException If this target container is already decorating another container <!-- .classchild --> Fetch(Type) Implementation of Fetch(Type) - wraps a special target around the target returned by the target container that's decorated by this one. Declaration public ITarget Fetch(Type type) Parameters Name Type Description type Type Required. The type for which an ITarget is to be retrieved. Returns Type Description ITarget Implements ITargetContainer.Fetch(Type) Remarks If the inner container returns null, then so does this one. <!-- .classchild --> FetchAll(Type) Implementation of FetchAll(Type) - passes the call on to the inner container that's decorated by this one, and then wraps each of those targets in a special target which represents the decoration logic for each instance. Declaration public IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type Type Required. The type for which the ITarget instances are to be retrieved. Returns Type Description IEnumerable < ITarget > Implements ITargetContainer.FetchAll(Type) <!-- .classchild --> FetchContainer(Type) Retrieves an existing container registered against the given type , or null if not found. Declaration public ITargetContainer FetchContainer(Type type) Parameters Name Type Description type Type The type. Returns Type Description ITargetContainer Implements ITargetContainerOwner.FetchContainer(Type) Remarks This is an implementation of FetchContainer(Type) which wraps around the inner target container and passes the call on to that. Exceptions Type Condition System.InvalidOperationException If this decorator's inner container isn't an instance of ITargetContainerOwner <!-- .classchild --> Register(ITarget, Type) Registers a target, either for the serviceType specified or, if null, the DeclaredType of the target . Declaration public void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget Required. The target to be registered serviceType Type Optional. The type the target is to be registered against, if different from the DeclaredType of the target . If provided, then the target must be compatible with this type. Implements ITargetContainer.Register(ITarget, Type) Remarks The decorator target does not accept registrations directly; rather it passes the call on to its inner container which could be a TargetListContainer , or GenericTargetContainer in the most basic cases; or it could be another DecoratorTarget in situations where a type has had multiple decorators registered against it. <!-- .classchild --> RegisterContainer(Type, ITargetContainer) Implementation of RegisterContainer(Type, ITargetContainer) - the call is automatically forwarded on to the inner target container that's being decorated, since decorator targets don't support direct registration of targets or containers. Declaration public void RegisterContainer(Type type, ITargetContainer container) Parameters Name Type Description type Type The type. container ITargetContainer The container. Implements ITargetContainerOwner.RegisterContainer(Type, ITargetContainer) Exceptions Type Condition System.InvalidOperationException This decorator must be decorating another owner, or be decorating a generic type <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DecoratorTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.DecoratorTargetContainerExtensions.html",
    "title": "Class DecoratorTargetContainerExtensions",
    "keywords": "Class DecoratorTargetContainerExtensions Extensions for ITargetContainerOwner which simplify the registration of decorators (via the DecoratorTarget pseudo-target) Inheritance Object DecoratorTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class DecoratorTargetContainerExtensions Remarks Note: The decoration functionality provided by the framework is only possible on ITargetContainer implementations which also implement the ITargetContainerOwner interface. All the main target container types you'll use in your application ( TargetContainer and ChildTargetContainer ) do support this interface. <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterDecorator(ITargetContainerOwner, Type, Type) Registers a decorator container which will cause all instances of decoratedType to be decorated with the type decoratorType . Any existing registrations for decoratedType will be decorated correctly, and subsequent registrations of decoratedType will also be decorated as expected. Declaration public static void RegisterDecorator(this ITargetContainerOwner targetContainerOwner, Type decoratorType, Type decoratedType) Parameters Name Type Description targetContainerOwner ITargetContainerOwner The container into which the decorator will be registered. decoratorType Type The type to be used as the decorator implementation decoratedType Type The type which will be decorated by decoratorType . <!-- .classchild --> RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) Registers a decorator container which will cause all instances of TDecorated to be decorated with the type TDecorator . Any existing registrations for TDecorated will be decorated correctly, and subsequent registrations of TDecorated will also be decorated as expected. Declaration public static void RegisterDecorator<TDecorator, TDecorated>(this ITargetContainerOwner targetContainerOwner) Parameters Name Type Description targetContainerOwner ITargetContainerOwner The container into which the decorator will be registered. Type Parameters Name Description TDecorator The type to be used as the decorator implementation TDecorated The type which will be decorated by TDecorator . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DefaultPropertyBindingBehaviour.html": {
    "href": "rezolver-api/Rezolver.DefaultPropertyBindingBehaviour.html",
    "title": "Class DefaultPropertyBindingBehaviour",
    "keywords": "Class DefaultPropertyBindingBehaviour The default implementation of IPropertyBindingBehaviour when you are creating a ConstructorTarget or GenericConstructorTarget and you want publicly writable properties and public fields to be assigned values obtained from the container. If you do not require properties or fields to be bound from the container, then use a null IPropertyBindingBehaviour . Inheritance Object DefaultPropertyBindingBehaviour Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DefaultPropertyBindingBehaviour : IPropertyBindingBehaviour Remarks This is a singleton class accessible through the Instance static property. <!-- <hr class=\"typeSectionDivider\" /> --> Properties Instance Gets the one and only instance of DefaultPropertyBindingBehaviour Declaration public static DefaultPropertyBindingBehaviour Instance { get; } Property Value Type Description DefaultPropertyBindingBehaviour <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods BindProperties(Type, IEnumerable<PropertyInfo>) Declaration protected virtual IEnumerable<PropertyOrFieldBinding> BindProperties(Type type, IEnumerable<PropertyInfo> properties) Parameters Name Type Description type Type properties IEnumerable < PropertyInfo > Returns Type Description IEnumerable < PropertyOrFieldBinding > <!-- .classchild --> CreateBinding(Type, FieldInfo) Creates the binding for the given field. Called by GetPropertyBindings(CompileContext, Type) Declaration protected virtual PropertyOrFieldBinding CreateBinding(Type type, FieldInfo field) Parameters Name Type Description type Type The type. field FieldInfo The field. Returns Type Description PropertyOrFieldBinding <!-- .classchild --> CreateBinding(Type, PropertyInfo) Creates the binding for the given property. Called by GetPropertyBindings(CompileContext, Type) Declaration protected virtual PropertyOrFieldBinding CreateBinding(Type type, PropertyInfo prop) Parameters Name Type Description type Type The type. prop PropertyInfo The property. Returns Type Description PropertyOrFieldBinding <!-- .classchild --> GetBindableFields(Type) Gets the bindable fields on the type . Used by GetPropertyBindings(CompileContext, Type) . Declaration protected virtual IEnumerable<FieldInfo> GetBindableFields(Type type) Parameters Name Type Description type Type The type. Returns Type Description IEnumerable < FieldInfo > <!-- .classchild --> GetBindableProperties(Type) Gets the bindable properties on the type . Used by GetPropertyBindings(CompileContext, Type) . Declaration protected virtual IEnumerable<PropertyInfo> GetBindableProperties(Type type) Parameters Name Type Description type Type The type. Returns Type Description IEnumerable < PropertyInfo > <!-- .classchild --> GetPropertyBindings(CompileContext, Type) Implementation of GetPropertyBindings(CompileContext, Type) . Returns a binding for each publicly writable property (i.e. with a public set accessor) and each public field on the type . Declaration public virtual PropertyOrFieldBinding[] GetPropertyBindings(CompileContext context, Type type) Parameters Name Type Description context CompileContext The context. type Type The type. Returns Type Description PropertyOrFieldBinding [] Implements IPropertyBindingBehaviour.GetPropertyBindings(CompileContext, Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DefaultTarget.html": {
    "href": "rezolver-api/Rezolver.DefaultTarget.html",
    "title": "Class DefaultTarget",
    "keywords": "Class DefaultTarget A target that simply creates a default instance of a given type. I.e. the same as doing default(type) in C#. Inheritance Object TargetBase DefaultTarget Inherited Members TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DefaultTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DefaultTarget(Type) Initializes a new instance of the DefaultTarget class. Declaration public DefaultTarget(Type type) Parameters Name Type Description type Type The type. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Always equal to the type for which the default value will be returned by the expression create by CreateExpressionBase(CompileContext) Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateExpressionBase(CompileContext) Always returns a of the type DeclaredType Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext The current compile context Returns Type Description Expression Overrides TargetBase.CreateExpressionBase(CompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-1.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-1.html",
    "title": "Class DelegateTarget<TResult>",
    "keywords": "Class DelegateTarget<TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType DelegateTarget.CreateExpressionBase(CompileContext) TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<TResult> : DelegateTarget, ITarget Type Parameters Name Description TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<TResult>, Type) Initializes a new instance of the DelegateTarget<TResult> class. Declaration public DelegateTarget(Func<TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.SingletonTargetDictionaryExtensions.html": {
    "href": "rezolver-api/Rezolver.SingletonTargetDictionaryExtensions.html",
    "title": "Class SingletonTargetDictionaryExtensions",
    "keywords": "Class SingletonTargetDictionaryExtensions Inheritance Object SingletonTargetDictionaryExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class SingletonTargetDictionaryExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterSingleton(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Registers the type objectType as a singleton ( SingletonTarget ) in the target container using either objectType as the service type, or serviceType instead - if it's provided. The instance will be built automatically with constructor injection (and, optionally, property injection if a propertyBindingBehaviour is passed) by leveraging the ConstructorTarget or GenericConstructorTarget targets. Declaration public static void RegisterSingleton(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The container on which the registrations will be made. objectType Type Required. The type of object to be created. serviceType Type Optional. The type against which the target will be registered in the targetContainer propertyBindingBehaviour IPropertyBindingBehaviour Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. <!-- .classchild --> RegisterSingleton<TObject>(ITargetContainer, IPropertyBindingBehaviour) Registers the type TObject as a singleton ( SingletonTarget ) in the target container. The instance will be built automatically with constructor injection (and, optionally, property injection if a propertyBindingBehaviour is passed) by leveraging the ConstructorTarget or GenericConstructorTarget targets. Declaration public static void RegisterSingleton<TObject>(this ITargetContainer targetContainer, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The container on which the registrations will be made. propertyBindingBehaviour IPropertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type to be created, and the type against which the registration will be made <!-- .classchild --> RegisterSingleton<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Registers the type TObject as a singleton ( SingletonTarget ) in the target container for the service type TService . The instance will be built automatically with constructor injection (and, optionally, property injection if a propertyBindingBehaviour is passed) by leveraging the ConstructorTarget or GenericConstructorTarget targets. Declaration public static void RegisterSingleton<TObject, TService>(this ITargetContainer targetContainer, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The container on which the registrations will be made. propertyBindingBehaviour IPropertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of object to be created. TService The type against which the target will be registered in the targetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetAdapter.html": {
    "href": "rezolver-api/Rezolver.TargetAdapter.html",
    "title": "Class TargetAdapter",
    "keywords": "Class TargetAdapter Default implementation of the ITargetAdapter interface. Also an ExpressionVisitor. Also, its Default property serves as the reference to the default adapter used by the system to convert expressions into IRezolveTarget instances. This class cannot be created directly - it is a singleton accessed through the Instance property. You can inherit from this class, however, to serve as the basis for your own implementation of ITargetAdapter . Inheritance Object TargetAdapter Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetAdapter : ExpressionVisitor, ITargetAdapter <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TargetAdapter() Protected constructor ensuring that new instances can only be created through inheritance. Declaration protected TargetAdapter() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Default The default IRezolveTargetAdapter to be used in converting expressions to IRezolveTarget instances. By default, this is initialised to a single instance of the TargetAdapter class. Declaration public static ITargetAdapter Default { get; set; } Property Value Type Description ITargetAdapter <!-- .classchild --> Instance The one and only instance of the RezolveTargetAdapter class Declaration public static ITargetAdapter Instance { get; } Property Value Type Description ITargetAdapter <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateTarget(Expression) Creates the target. Declaration public ITarget CreateTarget(Expression expression) Parameters Name Type Description expression Expression The expression. Returns Type Description ITarget Implements ITargetAdapter.CreateTarget(Expression) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetAdapterCreateExtensions.html": {
    "href": "rezolver-api/Rezolver.TargetAdapterCreateExtensions.html",
    "title": "Class TargetAdapterCreateExtensions",
    "keywords": "Class TargetAdapterCreateExtensions Inheritance Object TargetAdapterCreateExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class TargetAdapterCreateExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateTarget<TResult>(ITargetAdapter, Expression<Func<TResult>>) Declaration public static ITarget CreateTarget<TResult>(this ITargetAdapter adapter, Expression<Func<TResult>> expression) Parameters Name Type Description adapter ITargetAdapter expression Expression < Func <TResult>> Returns Type Description ITarget Type Parameters Name Description TResult <!-- .classchild --> CreateTarget<TResult>(ITargetAdapter, Expression<Func<RezolveContext, TResult>>) Declaration public static ITarget CreateTarget<TResult>(this ITargetAdapter adapter, Expression<Func<RezolveContext, TResult>> expression) Parameters Name Type Description adapter ITargetAdapter expression Expression < Func < RezolveContext , TResult>> Returns Type Description ITarget Type Parameters Name Description TResult <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetAdapterGenericRegisterExpressionExtensions.html": {
    "href": "rezolver-api/Rezolver.TargetAdapterGenericRegisterExpressionExtensions.html",
    "title": "Class TargetAdapterGenericRegisterExpressionExtensions",
    "keywords": "Class TargetAdapterGenericRegisterExpressionExtensions Contains numerous generic overloads of the RegisterExpression extension method for ITargetContainer All of these extensions act as proxies for the RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) extension method. Inheritance Object TargetAdapterGenericRegisterExpressionExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class TargetAdapterGenericRegisterExpressionExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<TResult>(this ITargetContainer targetContainer, Expression<Func<TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<TResult>(ITargetContainer, Expression<Func<RezolveContext, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) T15 The type of the 15th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) T15 The type of the 15th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T, TResult>(this ITargetContainer targetContainer, Expression<Func<T, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T The type of the 1st lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<RezolveContext, T, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T The type of the 2nd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild --> RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The container which will receive the registration expression Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, TResult>> The lambda expression that is to be converted into a target and registered type Type adapter ITargetAdapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetAdapterRegisterExpressionExtensions.html": {
    "href": "rezolver-api/Rezolver.TargetAdapterRegisterExpressionExtensions.html",
    "title": "Class TargetAdapterRegisterExpressionExtensions",
    "keywords": "Class TargetAdapterRegisterExpressionExtensions Extensions for to simplify registering expressions in an ITargetContainer . Inheritance Object TargetAdapterRegisterExpressionExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class TargetAdapterRegisterExpressionExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) Registers the expression. Declaration public static void RegisterExpression(this ITargetContainer targetContainer, Expression expression, Type type, ITargetAdapter adapter = null) Parameters Name Type Description targetContainer ITargetContainer The target container. expression Expression The expression. type Type The type. adapter ITargetAdapter The adapter. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetAssemblyCompiler.html": {
    "href": "rezolver-api/Rezolver.TargetAssemblyCompiler.html",
    "title": "Class TargetAssemblyCompiler",
    "keywords": "Class TargetAssemblyCompiler Implementation of the ITargetCompiler which compiles dynamic code to an assembly (which can, potentially, be saved to disk). Suitable for environments that support the full .Net profile. Generally, the performance of a container built using this compiler will be better than one that uses the TargetDelegateCompiler . Inheritance Object TargetAssemblyCompiler Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetAssemblyCompiler : ITargetCompiler <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TargetAssemblyCompiler() Initializes a new instance of the TargetAssemblyCompiler class. Declaration public TargetAssemblyCompiler() <!-- .classchild --> TargetAssemblyCompiler(AssemblyBuilder) Initializes a new instance of the TargetAssemblyCompiler class. Declaration public TargetAssemblyCompiler(AssemblyBuilder assemblyBuilder) Parameters Name Type Description assemblyBuilder AssemblyBuilder The assembly builder into which the dynamically generated code will be compiled. Exceptions Type Condition System.ArgumentNullException assemblyBuilder is null <!-- .classchild --> TargetAssemblyCompiler(ModuleBuilder) Initializes a new instance of the TargetAssemblyCompiler class. Declaration public TargetAssemblyCompiler(ModuleBuilder moduleBuilder) Parameters Name Type Description moduleBuilder ModuleBuilder The module builder - if the assembly builder is already being used for something else and you want the dynamic code for the container to be compiled into a specific module within that assembly. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties AssemblyBuilder Gets the assembly builder whose dynamic assembly is receiving the dynamically generated code. Declaration public AssemblyBuilder AssemblyBuilder { get; } Property Value Type Description AssemblyBuilder The assembly builder. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CompileTarget(ITarget, CompileContext) Creates and builds a compiled target for the passed rezolve target which can then be used to create/obtain the object(s) it produces. Declaration public ICompiledTarget CompileTarget(ITarget target, CompileContext context) Parameters Name Type Description target ITarget The target to be compiled. context CompileContext The current compilation context. Returns Type Description ICompiledTarget A compiled target that produces the object represented by target . Implements ITargetCompiler.CompileTarget(ITarget, CompileContext) <!-- .classchild --> CreateAssemblyBuilder(AssemblyBuilderAccess, String) Shortcut method for creating an assembly builder that is suitable for use with an TargetAssemblyCompiler , but with the supplied access settings (e.g. if you want to be able to save the assembly). Declaration public static AssemblyBuilder CreateAssemblyBuilder(AssemblyBuilderAccess assemblyBuilderAccess = null, string dir = null) Parameters Name Type Description assemblyBuilderAccess AssemblyBuilderAccess The assembly builder access. dir String If supplied, then it's the base directory that will be used when saving the dynamic dll. Returns Type Description AssemblyBuilder An AssemblyBuilder instance that can be passed to the TargetAssemblyCompiler constructor. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetBase.html": {
    "href": "rezolver-api/Rezolver.TargetBase.html",
    "title": "Class TargetBase",
    "keywords": "Class TargetBase Abstract base class, suggested as a starting point for implementations of ITarget . Inheritance Object TargetBase Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public abstract class TargetBase : ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Gets the declared type of object that is constructed by this target. This will be the return type of any expression built by CreateExpression(CompileContext) unless otherwise instructed to build a different type. Declaration public abstract Type DeclaredType { get; } Property Value Type Description Type Implements ITarget.DeclaredType <!-- .classchild --> SuppressScopeTracking If false (the default) then any expression produced by CreateExpressionBase(CompileContext) will be automatically wrapped in a block of boilerplate code that will push the return value into the IScopedContainer that is in scope. Override this in your target and return true to strip this automatic behaviour - either if the objects produced by the code generated by your target is not suitable for scoping in this way, or if you handle the scoping manually. Note - you can still call the CreateScopeTrackingExpression(CompileContext, Expression) method if the expression it generates is suitable for your use, just not where it would usually place it. Declaration protected virtual bool SuppressScopeTracking { get; } Property Value Type Description Boolean <!-- .classchild --> UseFallback Declaration public virtual bool UseFallback { get; } Property Value Type Description Boolean Implements ITarget.UseFallback <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateExpression(CompileContext) Virtual method implementing IRezolveTarget.CreateExpression. Rather than overriding this method, your starting point is to implement the abstract method CreateExpressionBase(CompileContext) . Declaration public virtual Expression CreateExpression(CompileContext context) Parameters Name Type Description context CompileContext The current compile context Returns Type Description Expression Implements ITarget.CreateExpression(CompileContext) <!-- .classchild --> CreateExpressionBase(CompileContext) Abstract method called to create the expression - this is called by CreateExpression(CompileContext) after the target type has been validated, if provided. Note - if your implementation needs to support dynamic Resolve operations from the container that is passed to an IRezolver's Resolve method, you can use the DynamicRezolverParam property, all the default implementations of this class (and others) use that by default. Declaration protected abstract Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext The current compile context Returns Type Description Expression <!-- .classchild --> CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) Called to generate the expression that represents the argument that'll be passed to the AddToScope(Object, RezolveContext) method when an object is being tracked in a lifetime scope. By default, the base implementation generates an expression that represents null - because usually there really is little point in adding a specific context along with the object being tracked, unless you're also grabbing instances back out of the scope which isn't done by the base class behaviour by default. Declaration protected virtual Expression CreateRezolveContextExpressionForScopeAddCall(CompileContext context, Expression expression) Parameters Name Type Description context CompileContext expression Expression Returns Type Description Expression <!-- .classchild --> CreateScopeSelectionExpression(CompileContext, Expression) Called by CreateScopeTrackingExpression(CompileContext, Expression) to generate the code that selects the correct scope instance that is to be used for scope tracking for the object produced by the code generated by CreateExpressionBase(CompileContext) . Declaration protected virtual Expression CreateScopeSelectionExpression(CompileContext context, Expression expression) Parameters Name Type Description context CompileContext expression Expression Returns Type Description Expression <!-- .classchild --> CreateScopeTrackingExpression(CompileContext, Expression) This is called by CreateExpression(CompileContext) after the derived class generates its expression via a call to CreateExpressionBase(CompileContext) - unless SuppressScopeTracking is true either on this object, or on the passed context . The purpose is to generate the code that will ensure that any instance produced will be tracked in a lifetime scope, if required. Declaration protected virtual Expression CreateScopeTrackingExpression(CompileContext context, Expression expression) Parameters Name Type Description context CompileContext The current compile context. expression Expression The code generated from the CreateExpressionBase(CompileContext) method, albeit possibly rewritten and optimised. Returns Type Description Expression Remarks By default, if there is a lifetime scope, then its AddToScope(Object, RezolveContext) method is called with the object that's produced by the target, before the object is returned. If there is no scope, then no tracking is performed. Note that, also, by default, an object will only be tracked in the scope if it's IDisposable . As mentioned in the summary, if you need to disable the automatic generation of this scope tracking code, then you can override the SuppressScopeTracking property, and return false. It can also be suppressed on a per-compilation basis by setting the SuppressScopeTracking property of the context to true. This is something that the ScopedTarget does on its nested target, since by definition it generates its own explicit scope tracking code. If the target simply needs to select a different scope from the current (at the time Resolve(RezolveContext) is called), then it can override the CreateScopeSelectionExpression(CompileContext, Expression) method. <!-- .classchild --> SupportsType(Type) Called to check whether a target can create an expression that builds an instance of the given type . Declaration public virtual bool SupportsType(Type type) Parameters Name Type Description type Type Required Returns Type Description Boolean true if this target supports the given type, false otherwise. Implements ITarget.SupportsType(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetCompiler.html": {
    "href": "rezolver-api/Rezolver.TargetCompiler.html",
    "title": "Class TargetCompiler",
    "keywords": "Class TargetCompiler Holds a reference to the default compiler for this application. By default this is set to the TargetDelegateCompiler - which is a general purpose compiler that should work on any platform which supports linq expression trees. Inheritance Object TargetCompiler Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class TargetCompiler <!-- <hr class=\"typeSectionDivider\" /> --> Properties Default The default compiler to be used by rezolvers when they are not explicitly provided one. Declaration public static ITargetCompiler Default { get; set; } Property Value Type Description ITargetCompiler <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetCompilerBase.html": {
    "href": "rezolver-api/Rezolver.TargetCompilerBase.html",
    "title": "Class TargetCompilerBase",
    "keywords": "Class TargetCompilerBase Inheritance Object TargetCompilerBase Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public abstract class TargetCompilerBase : ITargetCompiler <!-- <hr class=\"typeSectionDivider\" /> --> Methods CompileTarget(ITarget, CompileContext) Declaration public virtual ICompiledTarget CompileTarget(ITarget target, CompileContext context) Parameters Name Type Description target ITarget context CompileContext Returns Type Description ICompiledTarget Implements ITargetCompiler.CompileTarget(ITarget, CompileContext) <!-- .classchild --> CompileTargetBase(ITarget, Expression, CompileContext) Called to create an ICompiledTarget instance from the passed expression produced by the passed target for the passed context. The expression passed into this method is constructed by a call to GetLambdaBody(ITarget, CompileContext) Declaration protected abstract ICompiledTarget CompileTargetBase(ITarget target, Expression toCompile, CompileContext context) Parameters Name Type Description target ITarget The target from which the expression toCompile was built. Note - this expression will have been optimised and potentially rewritten ready for compilation, and will likely not be equal to the expression originally produced by its own CreateExpression(CompileContext) method. toCompile Expression The expression built from target by this instance's own GetLambdaBody(ITarget, CompileContext) methodd. context CompileContext The context for which the compilation is being performed. Returns Type Description ICompiledTarget <!-- .classchild --> GetLambdaBody(ITarget, CompileContext) Produces the lambda body for the target. The base class uses the method GetLambdaBodyForTarget(ITarget, CompileContext) to get the expression tree that will be compiled. Declaration protected virtual Expression GetLambdaBody(ITarget target, CompileContext context) Parameters Name Type Description target ITarget context CompileContext Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetCompilerHelper.RedundantConvertRemover.html": {
    "href": "rezolver-api/Rezolver.TargetCompilerHelper.RedundantConvertRemover.html",
    "title": "Class TargetCompilerHelper.RedundantConvertRemover",
    "keywords": "Class TargetCompilerHelper.RedundantConvertRemover Inheritance Object TargetCompilerHelper.RedundantConvertRemover Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RedundantConvertRemover : ExpressionVisitor <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RedundantConvertRemover() Declaration public RedundantConvertRemover() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods VisitUnary(UnaryExpression) Declaration protected override Expression VisitUnary(UnaryExpression node) Parameters Name Type Description node UnaryExpression Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetCompilerHelper.html": {
    "href": "rezolver-api/Rezolver.TargetCompilerHelper.html",
    "title": "Class TargetCompilerHelper",
    "keywords": "Class TargetCompilerHelper Inheritance Object TargetCompilerHelper Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class TargetCompilerHelper <!-- <hr class=\"typeSectionDivider\" /> --> Methods Optimise(Expression, IEnumerable<Func<Expression, Expression>>) Declaration public static Expression Optimise(this Expression expression, IEnumerable<Func<Expression, Expression>> additionalOptimisations = null) Parameters Name Type Description expression Expression additionalOptimisations IEnumerable < Func < Expression , Expression >> Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetContainer.html": {
    "href": "rezolver-api/Rezolver.TargetContainer.html",
    "title": "Class TargetContainer",
    "keywords": "Class TargetContainer Root container for ITarget s that can be used as the backing for the standard IContainer classes - Container , ScopedContainer , and the Stores and retrieves registrations of ITarget s, is also Generic type aware, unlike its base class - TargetDictionaryContainer . Should be used as the root target container for implementations of IContainer . Inheritance Object TargetDictionaryContainer TargetContainer Inherited Members TargetDictionaryContainer.Fetch(Type) TargetDictionaryContainer.FetchAll(Type) TargetDictionaryContainer.CombineWith(ITargetContainer, Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetContainer : TargetDictionaryContainer, ITargetContainerOwner, ITargetContainer Remarks This is the type used by default for the of the Container and ScopedContainer when you don't supply an instance of an ITargetContainer explicitly on construction. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TargetContainer(Boolean) Constructs a new instance of the TargetContainer class Declaration public TargetContainer(bool autoRezolveIEnumerable = true) Parameters Name Type Description autoRezolveIEnumerable Boolean If true, then IEnumerable<T> will be automatically resolved as a concatenation of all the ITarget s that are registered against a particular type. Note - this parameter might be removed in a future version - you can achieve the same thing by using the extension method EnableEnumerableResolving(TargetContainer) <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateContainer(Type, ITarget) Called to create and register a container for the given serviceType and target . This class overrides the base version ( CreateContainer(Type, ITarget) ) to create a specialised container for generic types ( GenericTargetContainer ) if serviceType if a generic type or generic type definition. Declaration protected override ITargetContainer CreateContainer(Type serviceType, ITarget target) Parameters Name Type Description serviceType Type The type for which a container is to be created and registered. target ITarget Optional. The target that will be added to the container that is returned. Returns Type Description ITargetContainer An ITargetContainer in which the passed target will be registered. Overrides TargetDictionaryContainer.CreateContainer(Type, ITarget) Remarks The main caller for this method will be the base Register method, which will create a new container for a target that's being registered against a new type. It is, however, also called by this class' implementation of RegisterContainer(Type, ITargetContainer) when the type is a generic type - as all generics must have a container registered against their generic type definitions as a starting point. <!-- .classchild --> CreateGenericTypeDefContainer(Type, ITarget) Called by CreateContainer(Type, ITarget) to create a container suitable for handling targets that are registered against generic types. Declaration protected virtual ITargetContainer CreateGenericTypeDefContainer(Type genericTypeDefinition, ITarget target) Parameters Name Type Description genericTypeDefinition Type Will be an open generic type (generic type definition) target ITarget Optional. The initial target for which the container is being constructed Returns Type Description ITargetContainer The base implementation always creates an instance of CreateGenericTypeDefContainer(Type, ITarget) <!-- .classchild --> FetchContainer(Type) Retrieves Declaration public override ITargetContainer FetchContainer(Type type) Parameters Name Type Description type Type Returns Type Description ITargetContainer Overrides TargetDictionaryContainer.FetchContainer(Type) <!-- .classchild --> Register(ITarget, Type) Declaration public override void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget serviceType Type Overrides TargetDictionaryContainer.Register(ITarget, Type) <!-- .classchild --> RegisterContainer(Type, ITargetContainer) Overrides the base method so that if type is a generic type, then the container will be registered inside another which will be registered for the generic type definition first. Declaration public override void RegisterContainer(Type type, ITargetContainer container) Parameters Name Type Description type Type container ITargetContainer Overrides TargetDictionaryContainer.RegisterContainer(Type, ITargetContainer) <!-- .classchild --> RegisterContainerDirect(Type, ITargetContainer) Version of RegisterContainer(Type, ITargetContainer) which does not interrogate the type to see if it's generic - simply registers the passed container directly against the passed type (it just chains through directly to the RegisterContainer(Type, ITargetContainer) method non-virtually. Declaration protected virtual void RegisterContainerDirect(Type type, ITargetContainer container) Parameters Name Type Description type Type container ITargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetDelegateCompiler.DelegatingCompiledRezolveTarget.html": {
    "href": "rezolver-api/Rezolver.TargetDelegateCompiler.DelegatingCompiledRezolveTarget.html",
    "title": "Class TargetDelegateCompiler.DelegatingCompiledRezolveTarget",
    "keywords": "Class TargetDelegateCompiler.DelegatingCompiledRezolveTarget Inheritance Object TargetDelegateCompiler.DelegatingCompiledRezolveTarget Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegatingCompiledRezolveTarget : ICompiledTarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegatingCompiledRezolveTarget(Func<RezolveContext, Object>) Declaration public DelegatingCompiledRezolveTarget(Func<RezolveContext, object> getObjectDelegate) Parameters Name Type Description getObjectDelegate Func < RezolveContext , Object > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetObject(RezolveContext) Declaration public object GetObject(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description Object Implements ICompiledTarget.GetObject(RezolveContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetDelegateCompiler.html": {
    "href": "rezolver-api/Rezolver.TargetDelegateCompiler.html",
    "title": "Class TargetDelegateCompiler",
    "keywords": "Class TargetDelegateCompiler The default compiler for ITarget instances - takes the expression tree(s) produced by an ITarget and simply compiles it to an anonymous delegate. Inheritance Object TargetCompilerBase TargetDelegateCompiler Inherited Members TargetCompilerBase.CompileTarget(ITarget, CompileContext) TargetCompilerBase.GetLambdaBody(ITarget, CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetDelegateCompiler : TargetCompilerBase, ITargetCompiler <!-- <hr class=\"typeSectionDivider\" /> --> Fields Default Declaration public static readonly ITargetCompiler Default Field Value Type Description ITargetCompiler <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CompileTargetBase(ITarget, Expression, CompileContext) Declaration protected override ICompiledTarget CompileTargetBase(ITarget target, Expression toCompile, CompileContext context) Parameters Name Type Description target ITarget toCompile Expression context CompileContext Returns Type Description ICompiledTarget Overrides TargetCompilerBase.CompileTargetBase(ITarget, Expression, CompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetDictionaryContainer.html": {
    "href": "rezolver-api/Rezolver.TargetDictionaryContainer.html",
    "title": "Class TargetDictionaryContainer",
    "keywords": "Class TargetDictionaryContainer An ITargetContainerOwner implementation that stores and retrieves ITarget and ITargetContainer by type. Inheritance Object TargetDictionaryContainer Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetDictionaryContainer : ITargetContainerOwner, ITargetContainer Remarks This type is not thread-safe Note that for generic type, a special container is registered first against the open generic version of the type, with concrete (closed) generics being registered within that. <!-- <hr class=\"typeSectionDivider\" /> --> Methods CombineWith(ITargetContainer, Type) Always adds this container into the existing container as a child. Declaration public virtual ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer type Type Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) <!-- .classchild --> CreateContainer(Type, ITarget) Called by Register(ITarget, Type) to create and register the container instance most suited for the passed target. The base implementation always creates a TargetListContainer , capable of storing multiple targets against a single type. Declaration protected virtual ITargetContainer CreateContainer(Type serviceType, ITarget target) Parameters Name Type Description serviceType Type target ITarget The initial target for which the container is being created. Can be null. Note - the function is not expected to add this target to the new container. Returns Type Description ITargetContainer <!-- .classchild --> Fetch(Type) Implementation of Fetch(Type) . Declaration public virtual ITarget Fetch(Type type) Parameters Name Type Description type Type The type whose default target is to be retrieved. Returns Type Description ITarget A single target representing the last target registered against the type , or, null if no target is found. Implements ITargetContainer.Fetch(Type) Remarks Note - in scenarios where you are chaining multiple containers, then you should consult the return value's UseFallback property if the method returns non-null because, if true, then it's an instruction to use a parent container's result for the same type. <!-- .classchild --> FetchAll(Type) Implementation of FetchAll(Type) Declaration public virtual IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type Type The type whose targets are to be retrieved. Returns Type Description IEnumerable < ITarget > A non-null enumerable containing the targets that match the type, or an empty enumerable if the type is not registered. Implements ITargetContainer.FetchAll(Type) <!-- .classchild --> FetchContainer(Type) Obtains a child container that was previously registered by the passed type . Returns null if no entry is found. Declaration public virtual ITargetContainer FetchContainer(Type type) Parameters Name Type Description type Type Returns Type Description ITargetContainer Implements ITargetContainerOwner.FetchContainer(Type) <!-- .classchild --> Register(ITarget, Type) Implementation of Register(ITarget, Type) . Declaration public virtual void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget The target to be registered serviceType Type Implements ITargetContainer.Register(ITarget, Type) Remarks This implementation creates an ITargetContainer for the serviceType with a call to the protected method CreateContainer(Type, ITarget) if one doesn't exist (it calls FetchContainer(Type) to check for existence), and then chains to its Register(ITarget, Type) method. <!-- .classchild --> RegisterContainer(Type, ITargetContainer) Implementation of RegisterContainer(Type, ITargetContainer) Declaration public virtual void RegisterContainer(Type type, ITargetContainer container) Parameters Name Type Description type Type container ITargetContainer Implements ITargetContainerOwner.RegisterContainer(Type, ITargetContainer) Remarks This container implementation actually stores containers against the types that targets are registered against, rather than simply storing a dictionary of targets. This method allows you to add your own containers against type (instead of the default, which is TargetListContainer ) so you can plug in some advanced behaviour into this container. For example, decorators are not actually ITarget implementations but specialised ITargetContainer instances into which the 'standard' targets are registered. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetExpression.html": {
    "href": "rezolver-api/Rezolver.TargetExpression.html",
    "title": "Class TargetExpression",
    "keywords": "Class TargetExpression An expression which represents an ITarget that can be baked into any type of expression during code generation. Used by the TargetAdapter extensively. Inheritance Object TargetExpression Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetExpression : Expression <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TargetExpression(ITarget) Initializes a new instance of the TargetExpression class. Declaration public TargetExpression(ITarget target) Parameters Name Type Description target ITarget The target. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties CanReduce Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form. Declaration public override bool CanReduce { get; } Property Value Type Description Boolean true if this instance can reduce; otherwise, false . Remarks The implementation always returns true ; although the Reduce() methodd is not implemented. <!-- .classchild --> NodeType Gets the node type of this . Declaration public override ExpressionType NodeType { get; } Property Value Type Description ExpressionType Always returns . <!-- .classchild --> Target Gets the target whose expression (obtained from CreateExpression(CompileContext) ) will be subsituted for this TargetExpression in the final expression tree. Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> Type Gets the static type of the expression that this represents. Declaration public override Type Type { get; } Property Value Type Description Type Remarks Always returns the type referenced by the DeclaredType property of Target . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Reduce() Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced. Declaration public override Expression Reduce() Returns Type Description Expression Exceptions Type Condition System.NotSupportedException RezolveTargetExpression must be rewritten as a bona-fide expression before walking the expression tree for any other purpose <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetExpressionRewriter.html": {
    "href": "rezolver-api/Rezolver.TargetExpressionRewriter.html",
    "title": "Class TargetExpressionRewriter",
    "keywords": "Class TargetExpressionRewriter Used by TargetBase (and potentially your own targets) to convert TargetExpression instances which have been baked into expression trees (most likely by a TargetAdapter ) into expressions for a given CompileContext . Inheritance Object TargetExpressionRewriter Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetExpressionRewriter : ExpressionVisitor Remarks The TargetBase class always pushes expressions it receives from its CreateExpressionBase(CompileContext) abstract method through a rewrite - because if there are any non-standard expressions left, then compilation will not be possible. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TargetExpressionRewriter(CompileContext) Initializes a new instance of the TargetExpressionRewriter class for the given context Declaration public TargetExpressionRewriter(CompileContext context) Parameters Name Type Description context CompileContext The compilation context. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Visit(Expression) Dispatches the expression to one of the more specialized visit methods in this class. Declaration public override Expression Visit(Expression node) Parameters Name Type Description node Expression The expression to visit. Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetListContainer.html": {
    "href": "rezolver-api/Rezolver.TargetListContainer.html",
    "title": "Class TargetListContainer",
    "keywords": "Class TargetListContainer An ITargetContainer that stores multiple targets in a list. This is not a type that you would typically use directly in your code, unless you are writing custom logic/behaviour for ITarget registration. Inheritance Object TargetListContainer Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetListContainer : ITargetContainer Remarks This type is not thread-safe, nor does it perform any type checking on the targets that are added to it. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TargetListContainer(Type, ITarget[]) Declaration public TargetListContainer(Type registeredType, params ITarget[] targets) Parameters Name Type Description registeredType Type targets ITarget [] <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Count Declaration public int Count { get; } Property Value Type Description Int32 <!-- .classchild --> DefaultTarget Declaration public ITarget DefaultTarget { get; } Property Value Type Description ITarget <!-- .classchild --> Item[Int32] Declaration public ITarget this[int index] { get; } Parameters Name Type Description index Int32 Property Value Type Description ITarget <!-- .classchild --> RegisteredType Declaration public Type RegisteredType { get; } Property Value Type Description Type <!-- .classchild --> Targets Declaration public IEnumerable<ITarget> Targets { get; } Property Value Type Description IEnumerable < ITarget > <!-- .classchild --> TargetsList Provides deriving classes a means to manipulate the underlying list. Declaration protected List<ITarget> TargetsList { get; } Property Value Type Description List < ITarget > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CombineWith(ITargetContainer, Type) Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer type Type Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) <!-- .classchild --> Fetch(Type) Declaration public virtual ITarget Fetch(Type type) Parameters Name Type Description type Type Returns Type Description ITarget Implements ITargetContainer.Fetch(Type) <!-- .classchild --> FetchAll(Type) Declaration public virtual IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type Type Returns Type Description IEnumerable < ITarget > Implements ITargetContainer.FetchAll(Type) <!-- .classchild --> Register(ITarget, Type) Declaration public virtual void Register(ITarget target, Type registeredType = null) Parameters Name Type Description target ITarget registeredType Type Implements ITargetContainer.Register(ITarget, Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.html": {
    "href": "rezolver-api/Rezolver.html",
    "title": "Namespace Rezolver",
    "keywords": "Namespace Rezolver Classes AliasTargetContainerExtensions Contains extension methods for ITargetContainer to create targets which alias others by different types. CachingContainerBase Builds on the ContainerBase base class to introduce thread-safe caching of compiled targets so they are only compiled once per requested type. Only creatable through inheritance. ChangeTypeTarget This target is specifically used for explicitly casting the result of one target to another type. It's effectively the same as inserting a ConvertExpression around an expression. Its use is rare. ChildTargetContainer A version of TargetContainer which overrides the registrations of another (the Parent ). CompileContext Provides support and compile-time state for the compilation of an ITarget by an ITargetCompiler . THIS CLASS IS NOT THREAD-SAFE CompileContext.CompileStackEntry Represents an CompileContext.SharedExpressionKey Key for a shared expression used during expression tree generation. As a consumer of this library, you are unlikely ever to need to use it. CompiledTargetBase Standard starting point for an implementation of ICompiledTarget where the target is built directly from an ITarget . ConstructorTarget A target that binds to a type's constructor with zero or more arguments supplied by other ITarget s and, optionally binding to the new instance's writeable properties. Container The standard IOC container class in Rezolver. ContainerBase Starting point for implementations of IContainer - only creatable through inheritance. ContainerBase.MissingCompiledTarget Used as a sentinel type when a type cannot be resolved by a ContainerBase instance. Instead of returning a null ICompiledTarget instance, the container will construct an instance of this type (typically through GetMissingTarget(Type) , which caches singleton instances of this class on a per-type basis) which can then be used just as if the lookup succeeded. DecoratorTarget Implements service decoration in an ITargetContainer . The best way to add a decorator to your target container is to use the extension method or its non-generic equivalent. DecoratorTargetContainerExtensions Extensions for ITargetContainerOwner which simplify the registration of decorators (via the DecoratorTarget pseudo-target) DefaultPropertyBindingBehaviour The default implementation of IPropertyBindingBehaviour when you are creating a ConstructorTarget or GenericConstructorTarget and you want publicly writable properties and public fields to be assigned values obtained from the container. If you do not require properties or fields to be bound from the container, then use a null IPropertyBindingBehaviour . DefaultTarget A target that simply creates a default instance of a given type. I.e. the same as doing default(type) in C#. DelegateTarget An ITarget which resolve objects by executing a delegate with argument injection. DelegateTarget <TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget <T1, T2, T3, T4, T5, T6, T7, T8, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTargetContainerExtensions Extension methods for ITargetContainer designed to simplify the registration of DelegateTarget and its numerous generic variants. DelegateTargetDelegateExtensions Extension methods for the Delegate type to aid in the construction of DelegateTarget . EnumerableTargetBuilderExtensions ExceptionResources A strongly-typed resource class, for looking up localized strings, etc. ExpressionHelper This static class contains methods and properties to aid in building expressions in an implementation of the CreateExpression(CompileContext) method. ExpressionTarget A generic target for all expressions not explicitly supported by a particular target. Enables more complex behaviours to be registered and used with the more formal ITarget implementations. Functions This type is only used when building targets from expressions, and provides a natural way to have specific ITarget objects created from natural code, when using the default TargetAdapter to translate expressions into targets. GenericConstructorTarget Equivalent of ConstructorTarget but for open generic types. So, this will handle the open generic MyType<,>, for example, whereas ConstructorTarget would handle the closed type MyType<int, string>. GenericTargetContainer A special type of ITargetContainerOwner which stores targets (and potentially other containers) which are specifically keyed either to a particular open generic type or a closed generic built from it. IContainerRezolveExtensions IRezolveTargetScopingExtensions Extension method(s) to convert targets into scoped targets. IRezolveTargetSingletonExtensions Extension method(s) to convert targets into singleton targets. LifetimeScopeRezolverExtensions ListTarget This exists primarily for the configuration system. This target produces arrays or lists whose individual items are built by IRezolveTarget instances. If you are setting up your container environment from code - e.g. using expressions, then you shouldn't need to use this unless you have some pretty extreme requirements for the different targets that will contribute each element of your list/array. MethodCallExtractor MSDIITargetContainerExtensions MultipleTargetContainerExtensions Extensions for registering multiple targets individually and against the same type ObjectTarget Implements IRezolveTarget by wrapping a single instance that's already been constructed. By default, scope tracking is disabled (since the caller owns the object, not the Rezolver framework)). If it's enabled, then scope tracking behaves exactly the same as SingletonTarget . ObjectTargetContainerExtensions Extensions for ITargetContainer relating to registering concrete instances via the ObjectTarget target. ObjectTargetExtensions Extension method(s) OptionalParameterTarget Used specifically when binding arguments to method parameters when a parameter is optional and its default value is to be used when binding to it. OverridingContainer An IContainer which can override the resolve operations of another. This is useful when you have a core application-wide container, with some objects being customised based on some ambient information, e.g. configuration, MVC Area/Controller, Brand (in a multi-tenant application for example) or more. The scoping version of this is called OverridingScopedContainer . OverridingScopedContainer ParameterBinding PropertyOrFieldBinding RegisterTypeDictionaryExtensions Extensions for ITargetContainer to provide shortcuts for the simplest cases of registering ConstructorTarget and GenericConstructorTarget targets. RezolveContext Context of a call to an IRezolver's Resolve method. The container is included in the context to allow code generated from CreateExpression(CompileContext) to refer back to the container. This also allows us to retarget compiled targets at other containers (e.g. OverridingContainer s that override existing registrations or define new ones). RezolveContextPlaceholderExpression wraps an expression that represents reading or otherwise manipulating the RezolveContext that's passed into a Resolve call. RezolvedTarget Represents a target that is rezolved statically at compile time via the CompileContext , or dynamically (at 'resolve time') from the IContainer that is attached to the current RezolveContext when Resolve(RezolveContext) is called. This is the most common way that we bind constructor parameters, for example - i.e. 'I want an IService instance - go get it'. ScopedContainer Extends the Container to implement lifetime scoping. If you want your root container to act as a lifetime scope, then you should use this class instead of using Container ScopedTarget A target that produces a single instance of an object within a lifetime scope. ScopedTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for registering constructor-injected types whose lifetimes are slaved to that of a parent IScopedContainer . All of the extension methods ultimately create a ScopedTarget SingletonTarget A target which applies the singleton pattern to any ITarget . The inner target is available from the InnerTarget property. SingletonTargetDictionaryExtensions TargetAdapter Default implementation of the ITargetAdapter interface. Also an ExpressionVisitor. Also, its Default property serves as the reference to the default adapter used by the system to convert expressions into IRezolveTarget instances. This class cannot be created directly - it is a singleton accessed through the Instance property. You can inherit from this class, however, to serve as the basis for your own implementation of ITargetAdapter . TargetAdapterCreateExtensions TargetAdapterGenericRegisterExpressionExtensions Contains numerous generic overloads of the RegisterExpression extension method for ITargetContainer All of these extensions act as proxies for the RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) extension method. TargetAdapterRegisterExpressionExtensions Extensions for to simplify registering expressions in an ITargetContainer . TargetAssemblyCompiler Implementation of the ITargetCompiler which compiles dynamic code to an assembly (which can, potentially, be saved to disk). Suitable for environments that support the full .Net profile. Generally, the performance of a container built using this compiler will be better than one that uses the TargetDelegateCompiler . TargetBase Abstract base class, suggested as a starting point for implementations of ITarget . TargetCompiler Holds a reference to the default compiler for this application. By default this is set to the TargetDelegateCompiler - which is a general purpose compiler that should work on any platform which supports linq expression trees. TargetCompilerBase TargetCompilerHelper TargetCompilerHelper.RedundantConvertRemover TargetContainer Root container for ITarget s that can be used as the backing for the standard IContainer classes - Container , ScopedContainer , and the Stores and retrieves registrations of ITarget s, is also Generic type aware, unlike its base class - TargetDictionaryContainer . Should be used as the root target container for implementations of IContainer . TargetDelegateCompiler The default compiler for ITarget instances - takes the expression tree(s) produced by an ITarget and simply compiles it to an anonymous delegate. TargetDelegateCompiler.DelegatingCompiledRezolveTarget TargetDictionaryContainer An ITargetContainerOwner implementation that stores and retrieves ITarget and ITargetContainer by type. TargetExpression An expression which represents an ITarget that can be baked into any type of expression during code generation. Used by the TargetAdapter extensively. TargetExpressionRewriter Used by TargetBase (and potentially your own targets) to convert TargetExpression instances which have been baked into expression trees (most likely by a TargetAdapter ) into expressions for a given CompileContext . TargetListContainer An ITargetContainer that stores multiple targets in a list. This is not a type that you would typically use directly in your code, unless you are writing custom logic/behaviour for ITarget registration. Interfaces IChildTargetContainer An ITargetContainer that inherits all registrations from an ancestor ( Parent ). If it cannot resolve a target for a particular type, will defer to its parent for fallback. ICompiledTarget Provides an abstraction for creating objects based on a given RezolveContext - this is the ultimate target of all Resolve(RezolveContext) calls in the standard container implementations within the Rezolver framework. IContainer The primary IOC container interface in the Rezolver framework. IPropertyBindingBehaviour Describes a type which discovers property/field bindings IScopedContainer A container that's also a lifetime scope - that is, it's disposable, and will dispose of any disposable instances that it creates when it's disposed. Also, any subsequent lifetime scopes that it, or any child, creates will be disposed of when this scope is disposed. Note that while a lifetime scope can track objects of any types, it only automatically tracks disposable objects. To force a scope to track an instance, regardless of whether it's dispoable or not, you can call AddToScope(Object, RezolveContext) . This is how the default ScopedSingletonTarget works - if an object with this lifetime isn't a disposable, it is explicitly added to the scope passed to it at runtime, and then when an instance is subsequently requested, the code compiled by the scoped singleton will search the current scope, for an existing instance, before creating one. ITarget As the name suggests, the underlying target of a Rezolver call. The output of a target is an expression. This allows a target that depends on another target to chain expressions together, creating specialised expression trees (and therefore specialised delegates). The expression produced from this interface is later compiled, by an IRezolveTargetCompiler, into an ICompiledRezolveTarget - whose job it is specifically to produce object instances. ITargetAdapter Interface for an object that can convert Expressions into ITarget s suitable for registration in an ITargetContainer ITargetCompiler An object that produces ICompiledTarget s from ITarget s given a particular CompileContext . ITargetContainer Stores and retrieves ITarget instances, keyed by the type of service that the targets are registered against. ITargetContainerOwner Interface for an ITargetContainer which also contains other target containers."
  },
  "rezolver-api/System.Collections.Generic.ReadOnlyEnumerableExtensions.html": {
    "href": "rezolver-api/System.Collections.Generic.ReadOnlyEnumerableExtensions.html",
    "title": "Class ReadOnlyEnumerableExtensions",
    "keywords": "Class ReadOnlyEnumerableExtensions Inheritance Object ReadOnlyEnumerableExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :System.Collections.Generic Assembly :cs.temp.dll.dll Syntax public static class ReadOnlyEnumerableExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods AsReadOnly<T>(IEnumerable<T>) Declaration public static IList<T> AsReadOnly<T>(this IEnumerable<T> range) Parameters Name Type Description range IEnumerable <T> Returns Type Description IList <T> Type Parameters Name Description T <!-- .classchild -->"
  },
  "rezolver-api/System.Collections.Generic.html": {
    "href": "rezolver-api/System.Collections.Generic.html",
    "title": "Namespace System.Collections.Generic",
    "keywords": "Namespace System.Collections.Generic Classes ReadOnlyEnumerableExtensions"
  },
  "rezolver-api/System.DelegateExtensions.html": {
    "href": "rezolver-api/System.DelegateExtensions.html",
    "title": "Class DelegateExtensions",
    "keywords": "Class DelegateExtensions Inheritance Object DelegateExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :System Assembly :cs.temp.dll.dll Syntax public static class DelegateExtensions"
  },
  "rezolver-api/System.Linq.Expressions.ExpressionExtensions.html": {
    "href": "rezolver-api/System.Linq.Expressions.ExpressionExtensions.html",
    "title": "Class ExpressionExtensions",
    "keywords": "Class ExpressionExtensions Inheritance Object ExpressionExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :System.Linq.Expressions Assembly :cs.temp.dll.dll Syntax public static class ExpressionExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods AsRezolveTarget(Expression, ITargetAdapter) Declaration public static ITarget AsRezolveTarget(this Expression expression, ITargetAdapter adapter = null) Parameters Name Type Description expression Expression adapter ITargetAdapter Returns Type Description ITarget <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationExtensionEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationExtensionEntry.html",
    "title": "Interface IConfigurationExtensionEntry",
    "keywords": "Interface IConfigurationExtensionEntry Inherited Members IConfigurationEntry.Type IConfigurationLineInfo.StartLineNo IConfigurationLineInfo.StartLinePos IConfigurationLineInfo.EndLineNo IConfigurationLineInfo.EndLinePos Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationExtensionEntry : IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties ExtensionType Declaration string ExtensionType { get; } Property Value Type Description String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationLineInfo.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationLineInfo.html",
    "title": "Interface IConfigurationLineInfo",
    "keywords": "Interface IConfigurationLineInfo Encapsulates information about where a particular object, parsed from a configuration file, can be found. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties EndLineNo Gets the line number within the configuration source that sees the end of the text from which this object was parsed. Used in conjunction with EndLinePos , it allows you to zero-in on the exact ending of this parsed object. Declaration int ? EndLineNo { get; } Property Value Type Description Nullable < Int32 > The end line number. <!-- .classchild --> EndLinePos Gets the position from the start of the line, indicated by EndLineNo , where the configuration text ends for this parsed object. Declaration int ? EndLinePos { get; } Property Value Type Description Nullable < Int32 > <!-- .classchild --> StartLineNo Gets the line number within the configuration source that contains the start of the text from which this object was parsed. Used in conjunction with StartLinePos , it allows you to zero-in on the exact starting point of this parsed object. Declaration int ? StartLineNo { get; } Property Value Type Description Nullable < Int32 > The start line number. <!-- .classchild --> StartLinePos Gets the position from the start of the line, indicated by StartLineNo , where the configuration text begins for this parsed object. Declaration int ? StartLinePos { get; } Property Value Type Description Nullable < Int32 > The start line position. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConstructorTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConstructorTargetMetadata.html",
    "title": "Interface IConstructorTargetMetadata",
    "keywords": "Interface IConstructorTargetMetadata Inherited Members IRezolveTargetMetadata.Type IRezolveTargetMetadata.DeclaredType IRezolveTargetMetadata.Bind(ITypeReference[]) IRezolveTargetMetadata.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConstructorTargetMetadata : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties Arguments Gets a dictionary of arguments that are to be supplied to the object's constructor Declaration IDictionary<string, IRezolveTargetMetadata> Arguments { get; } Property Value Type Description IDictionary < String , IRezolveTargetMetadata > The arguments. <!-- .classchild --> SignatureTypes Gets the types of the parameters for the specific constructor that is to be bound. Not required, and is mostly used when a suitable constructor cannot be found purely by matching parameter names and types to the Arguments . A common issue here being that some metadata types can build any type, therefore two constructors with identically named parameters that have different types could be matched by the same target metadata. If null, then no signature is specified. Declaration ITypeReference[] SignatureTypes { get; } Property Value Type Description ITypeReference [] The signature types. <!-- .classchild --> TypesToBuild One of these types will be selected to have its constructor bound. The rule is that multiple types passed here must represent types that all appear in an inheritance chain or interface list, and there must be one unambiguous most-derived type which will be the one whose constructor will be executed when an object is later dished out from the IRezolveTarget instance that is built from this metadata. Declaration ITypeReference[] TypesToBuild { get; } Property Value Type Description ITypeReference [] <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IListTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.IListTargetMetadata.html",
    "title": "Interface IListTargetMetadata",
    "keywords": "Interface IListTargetMetadata Configuration metadata for building a ListTarget in a RezolverBuilder. Inherited Members IRezolveTargetMetadata.Type IRezolveTargetMetadata.DeclaredType IRezolveTargetMetadata.Bind(ITypeReference[]) IRezolveTargetMetadata.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IListTargetMetadata : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties ElementType Gets the declared element type of the array or list that will be created from this metadata. Declaration ITypeReference ElementType { get; } Property Value Type Description ITypeReference The type of the element. <!-- .classchild --> IsArray Maps to the AsArray property. If true, then an array of ElementType will be created, otherwise a List< ElementType > will be created by the ListTarget created from this metadata. Declaration bool IsArray { get; } Property Value Type Description Boolean true if this instance represents a ListTarget that will create an array; otherwise, false . <!-- .classchild --> Items Gets the metadata for the targets that will be used for the items that'll be returned in the Array or List that will be created by the ListTarget created from this metadata. Declaration IRezolveTargetMetadataList Items { get; } Property Value Type Description IRezolveTargetMetadataList The elements. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IObjectTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.IObjectTargetMetadata.html",
    "title": "Interface IObjectTargetMetadata",
    "keywords": "Interface IObjectTargetMetadata Interface for metadata for constructing an ObjectTarget IRezolveTarget. Inherited Members IRezolveTargetMetadata.Type IRezolveTargetMetadata.DeclaredType IRezolveTargetMetadata.Bind(ITypeReference[]) IRezolveTargetMetadata.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IObjectTargetMetadata : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetObject(Type) Called to get the object that will be registered in the IRezolveTargetContainer to be returned when a caller requests one of its registered types. The method can construct an object anew everytime it is called, or it can always return the same instance; this behaviour is implementation-dependant. Declaration object GetObject(Type type) Parameters Name Type Description type Type The type of object that is desired. The implementation determines whether this parameter is required. If it is, and you pass null, then an ArgumentNullException will be thrown. If you pass an argument, the implementation is not bound to check or honour the type. Its purpose is to provide a hint only, not a guarantee that the object returned is compatible with the type. Returns Type Description Object An object. Note - if the operation returns null this is not an error. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadata.html",
    "title": "Interface IRezolveTargetMetadata",
    "keywords": "Interface IRezolveTargetMetadata Represents an instruction to create an IRezolveTarget from parsed configuration. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Gets the declared type of the object that will be created by an IRezolveTarget created by this metadata. Note - this isn't always known, or always fixed, since configuration systems will allow developers to avoid being specific about the types that are to be built. Declaration ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference The type of the declared. <!-- .classchild --> Type The type of rezolve target that is expected to be produced from this metadata Declaration RezolveTargetMetadataType Type { get; } Property Value Type Description RezolveTargetMetadataType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Bind(ITypeReference[]) Creates a new instance of this metadata (i.e. a clone) that is bound to the specified target types. This is invoked if DeclaredType represents the Unbound type reference. Declaration IRezolveTargetMetadata Bind(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] The target types. Ideally there'd only be one of these, but since type registrations can target multiple types - we need to be able to pass all of them. An implementation should seek the best possible type from the array, although in practise - given that there's no ConfigurationAdapterContext to aid in the parsing of the type names, the first type in the array is typically fine to use. Returns Type Description IRezolveTargetMetadata IRezolveTargetMetadata. <!-- .classchild --> CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Creates the rezolve target, optionally customised for the given target type(s), based on the given context. If the entry is passed, then it indicates the configuration entry for which the targets are being built. Declaration ITarget CreateRezolveTarget(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry = null) Parameters Name Type Description targetTypes Type [] Required. One or more target types that the returned target is expected to be compatible with (i.e. able to build an instance of). Generally, this will be the target types for the configuration entry that is passed in entry . context ConfigurationAdapterContext The current context - provides access to the builder currently being constructed, as well as methods for resolving type names from ITypeReference instances or strings (and more). entry IConfigurationEntry If provided, this is a reference to the configuration entry (typically an ITypeRegistrationEntry ) against which this target will be registered. Please note - this doesn't mean that the target that is returned will become the target of the registration. It might be that the target is one that is used by a parent target that will become the target of the registration. Returns Type Description ITarget <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadataExtension.html": {
    "href": "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadataExtension.html",
    "title": "Interface IRezolveTargetMetadataExtension",
    "keywords": "Interface IRezolveTargetMetadataExtension Inherited Members IRezolveTargetMetadata.Type IRezolveTargetMetadata.DeclaredType IRezolveTargetMetadata.Bind(ITypeReference[]) IRezolveTargetMetadata.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IRezolveTargetMetadataExtension : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties ExtensionType Declaration string ExtensionType { get; } Property Value Type Description String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadataList.html": {
    "href": "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadataList.html",
    "title": "Interface IRezolveTargetMetadataList",
    "keywords": "Interface IRezolveTargetMetadataList Represents a list of IRezolveTargetMetadata instances - for when you want to register multiple targets against a single type. Note - although the interface IRezolveTargetMetadata is included by this interface, instances are not expected to be able to create a single target through the CreateRezolveTarget method - because by definition, multiple targets are produced by this. Use the CreateRezolveTargets method instead. The Bind method, however, will be expected to produce a new instance of the implementing type if any underlying targets are not bound to a specific type. Inherited Members IRezolveTargetMetadata.Type IRezolveTargetMetadata.DeclaredType IRezolveTargetMetadata.Bind(ITypeReference[]) IRezolveTargetMetadata.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IRezolveTargetMetadataList : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties Targets Gets the list of targets that will be used to construct the array. Note - a list is used to allow for modification of the targets after initial creation. Declaration IList<IRezolveTargetMetadata> Targets { get; } Property Value Type Description IList < IRezolveTargetMetadata > The targets. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateRezolveTargets(Type[], ConfigurationAdapterContext, IConfigurationEntry) Replacement for IRezolveTargetMetadata for this interface. Creates the rezolve target, potentially customised for the given target type(s), based on the given context. If the entry is passed, then it indicates the configuration entry for which the targets are being built. Declaration IEnumerable<ITarget> CreateRezolveTargets(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] The target types for each of the returned target, generally, this will be the ultimate target types for the configuration entry that is passed in entry . An implementation is not bound to use these types at all, but it helps provide additional context that might be of use when generating the rezolve target. context ConfigurationAdapterContext The context. entry IConfigurationEntry If provided, this is a reference to the configuration entry for which this target is being built. Returns Type Description IEnumerable < ITarget > <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ISingletonTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.ISingletonTargetMetadata.html",
    "title": "Interface ISingletonTargetMetadata",
    "keywords": "Interface ISingletonTargetMetadata Interface for Singleton metadata. Inherited Members IRezolveTargetMetadata.Type IRezolveTargetMetadata.DeclaredType IRezolveTargetMetadata.Bind(ITypeReference[]) IRezolveTargetMetadata.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface ISingletonTargetMetadata : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties Inner Metadata representing the inner target for the singleton Declaration IRezolveTargetMetadata Inner { get; } Property Value Type Description IRezolveTargetMetadata <!-- .classchild --> Scoped If true, then the created singleton target should be a scoped singleton; i.e. with a lifetime tied to the lifetime of a parent ILifetimeScopeRezolver, not the whole application. Declaration bool Scoped { get; } Property Value Type Description Boolean <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ITypeReference.html": {
    "href": "rezolver-api/Rezolver.Configuration.ITypeReference.html",
    "title": "Interface ITypeReference",
    "keywords": "Interface ITypeReference Captures a reference to a type made in a configuration file. It does not guarantee that the type can be located, it simply provides a common interface for storing the type information written in a configuration file. An IConfigurationAdapter instance will need to resolve the actual runtime type from this when registering targets from a configuration file. Inherited Members IConfigurationLineInfo.StartLineNo IConfigurationLineInfo.StartLinePos IConfigurationLineInfo.EndLineNo IConfigurationLineInfo.EndLinePos Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface ITypeReference : IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties GenericArguments Any explicitly provided generic arguments are stored here. Note that it might turn out that the TypeName refers to a whole closed generic type, in which case the referenced type could still be generic even if this array is empty. It's also the case that arguments could be passed here when the root type name resolves to a non-generic type definition, in which case type resolution will likely fail. Declaration ITypeReference[] GenericArguments { get; } Property Value Type Description ITypeReference [] <!-- .classchild --> IsArray Gets a value indicating whether the type ultimately represented by this instance is an array of the type described by the rest of this instance's properties. Declaration bool IsArray { get; } Property Value Type Description Boolean true if this instance represents an array type; otherwise, false . <!-- .classchild --> IsOpenGenericTypeArgument True if this type represents an open generic argument - this is how to explicitly reference an open generic type in a type reference: you specify a base type, then have one or more open generic arguments specified in the GenericArguments array. If all are open generic arguments, then you have created a reference to the fully open generic type. You only need to provide all-open arguments if the base TypeName could be ambiguous between a non generic and generic type, or there are multiple generic types with the same base name. Equally, you can do this to create references to partially open generics, which may or may not be supported by the adapter or the target that is built. Declaration bool IsOpenGenericTypeArgument { get; } Property Value Type Description Boolean <!-- .classchild --> IsUnbound Gets a value indicating whether this instance represents a type that is to be late-bound for a specific target type. Declaration bool IsUnbound { get; } Property Value Type Description Boolean true if this instance is unbound; otherwise, false . <!-- .classchild --> TypeName The root type name. Declaration string TypeName { get; } Property Value Type Description String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ITypeRegistrationEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.ITypeRegistrationEntry.html",
    "title": "Interface ITypeRegistrationEntry",
    "keywords": "Interface ITypeRegistrationEntry Represents an instruction to register one or more targets in an ITargetContainer against one or more types. Think of it as wrapping a single call to one of the builder's Register methods. Inherited Members IConfigurationEntry.Type IConfigurationLineInfo.StartLineNo IConfigurationLineInfo.StartLinePos IConfigurationLineInfo.EndLineNo IConfigurationLineInfo.EndLinePos Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface ITypeRegistrationEntry : IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties IsMultipleRegistration Gets a value indicating whether this instance represents a multiple registration - i.e. that when one of the Types are resolved, it's expected that an enumerable of that type will be requested, returning one or more items rather than just one. Maps to the method call. Declaration bool IsMultipleRegistration { get; } Property Value Type Description Boolean true if this instance is multiple registration; otherwise, false . <!-- .classchild --> TargetMetadata Metadata for the target(s) that is/are to be registered. Declaration IRezolveTargetMetadata TargetMetadata { get; } Property Value Type Description IRezolveTargetMetadata <!-- .classchild --> Types The types for which the registration is to be made in the ITargetContainer that the entry is applied to. Declaration ITypeReference[] Types { get; } Property Value Type Description ITypeReference [] <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.AdvancedConfigurationAdapterContextFactory.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.AdvancedConfigurationAdapterContextFactory.html",
    "title": "Class AdvancedConfigurationAdapterContextFactory",
    "keywords": "Class AdvancedConfigurationAdapterContextFactory An advanced factory which automatically loads and references all assemblies that are deployed in the application's base directory and any subfolders determined by the System.AppDomain 's SetupInformation's PrivateBinBath. This is a singleton - accessed through the Instance property. Inheritance Object ConfigurationAdapterContextFactory AdvancedConfigurationAdapterContextFactory Inherited Members ConfigurationAdapterContextFactory.CreateContext(ConfigurationAdapter, IConfiguration) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class AdvancedConfigurationAdapterContextFactory : ConfigurationAdapterContextFactory, IConfigurationAdapterContextFactory Remarks The ConfigurationAdapterContextFactory has a very limited set of default assembly references, because it's a portable class, the AppDomain introspection APIs are not available. As a result, to simplify type references in a configuration file loaded in a portable environment, you need to add assembly references manually. This class, on the other hand, is targeted at environments where these APIs are available, and should effectively remove the need to add any references at all, meaning a configuration file can use shorter type names. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors AdvancedConfigurationAdapterContextFactory() Initializes a new instance of the AdvancedConfigurationAdapterContextFactory class. Class is creatable only through inheritance. Declaration protected AdvancedConfigurationAdapterContextFactory() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Instance Gets the one and only instance of the AdvancedConfigurationAdapterContextFactory . Declaration public static IConfigurationAdapterContextFactory Instance { get; } Property Value Type Description IConfigurationAdapterContextFactory The instance. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetDefaultAssemblyReferences() Gets the assemblies that are to be used for new contexts as the default set of references. This override gets all the assemblies that are deployed with the application. Note that this has the effect of pre-loading all those assemblies. Declaration protected override IEnumerable<Assembly> GetDefaultAssemblyReferences() Returns Type Description IEnumerable < System.Reflection.Assembly > IEnumerable<System.Reflection.Assembly>. Overrides ConfigurationAdapterContextFactory.GetDefaultAssemblyReferences() <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.ConfigurationEntryConverter.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.ConfigurationEntryConverter.html",
    "title": "Class ConfigurationEntryConverter",
    "keywords": "Class ConfigurationEntryConverter JSON converter for IConfigurationEntry The converter defaults to looking for type registrations; to enable it to look for a different entry type, you must instruct Json.Net to create an instance of it using the constructor that accepts a ConfigurationEntryType Inheritance Object ConfigurationEntryConverter Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class ConfigurationEntryConverter : JsonConverter <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConfigurationEntryConverter() Declaration public ConfigurationEntryConverter() <!-- .classchild --> ConfigurationEntryConverter(ConfigurationEntryType) Declaration public ConfigurationEntryConverter(ConfigurationEntryType expectedType) Parameters Name Type Description expectedType ConfigurationEntryType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties CanWrite Declaration public override bool CanWrite { get; } Property Value Type Description Boolean <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CanConvert(Type) Declaration public override bool CanConvert(Type objectType) Parameters Name Type Description objectType Type Returns Type Description Boolean <!-- .classchild --> ReadJson(JsonReader, Type, Object, JsonSerializer) Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Name Type Description reader JsonReader objectType Type existingValue Object serializer JsonSerializer Returns Type Description Object <!-- .classchild --> WriteJson(JsonWriter, Object, JsonSerializer) Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Name Type Description writer JsonWriter value Object serializer JsonSerializer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.JsonConfiguration.JsonConfigurationConverter.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.JsonConfiguration.JsonConfigurationConverter.html",
    "title": "Class JsonConfiguration.JsonConfigurationConverter",
    "keywords": "Class JsonConfiguration.JsonConfigurationConverter Class for loading JsonConfiguration from Json through Json.Net. Inheritance Object JsonConfiguration.JsonConfigurationConverter Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class JsonConfigurationConverter : JsonConverter <!-- <hr class=\"typeSectionDivider\" /> --> Properties CanWrite Gets a value indicating whether this Newtonsoft.Json.JsonConverter can write JSON. Declaration public override bool CanWrite { get; } Property Value Type Description Boolean true if this Newtonsoft.Json.JsonConverter can write JSON; otherwise, false . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CanConvert(Type) Determines whether this instance can convert the specified object type. Declaration public override bool CanConvert(Type objectType) Parameters Name Type Description objectType Type Type of the object. Returns Type Description Boolean true if this instance can convert the specified object type; otherwise, false . <!-- .classchild --> ReadJson(JsonReader, Type, Object, JsonSerializer) Reads the JSON representation of the object. Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Name Type Description reader JsonReader The Newtonsoft.Json.JsonReader to read from. objectType Type Type of the object. existingValue Object The existing value of object being read. serializer JsonSerializer The calling serializer. Returns Type Description Object The object value. <!-- .classchild --> WriteJson(JsonWriter, Object, JsonSerializer) Writes the JSON representation of the object. Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Name Type Description writer JsonWriter The Newtonsoft.Json.JsonWriter to write to. value Object The value. serializer JsonSerializer The calling serializer. Exceptions Type Condition System.NotImplementedException <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.JsonConfiguration.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.JsonConfiguration.html",
    "title": "Class JsonConfiguration",
    "keywords": "Class JsonConfiguration Class JsonConfiguration. Inheritance Object JsonConfiguration Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class JsonConfiguration : IConfiguration <!-- <hr class=\"typeSectionDivider\" /> --> Fields UnboundType The typename to use on a type entry when you want to register a constructor target directly for the type that is registered. E.g. { 'MyNamespace.Foo' : { 'type' : \"$auto' } } Which registers MyNamespace.Foo with a constructor target that binds to the same type. Is also used - where supported - to refer to a type from a parent object which you want to reference, but without having to specify the whole typename. Declaration public const string UnboundType = \"$auto\" Field Value Type Description String <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Entries Gets the entries. Declaration public IEnumerable<IConfigurationEntry> Entries { get; } Property Value Type Description IEnumerable < IConfigurationEntry > The entries. Implements IConfiguration.Entries <!-- .classchild --> FileName Gets the name of the file. Declaration public string FileName { get; } Property Value Type Description String The name of the file. Implements IConfiguration.FileName <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.JsonConfigurationException.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.JsonConfigurationException.html",
    "title": "Class JsonConfigurationException",
    "keywords": "Class JsonConfigurationException Thrown when a Json container configuration file is invalid. Inheritance Object Exception JsonConfigurationException Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.Data Exception.InnerException Exception.TargetSite Exception.StackTrace Exception.HelpLink Exception.Source Exception.HResult Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class JsonConfigurationException : Exception, ISerializable, _Exception <!-- <hr class=\"typeSectionDivider\" /> --> Constructors JsonConfigurationException(JsonToken, JsonReader) Constructs a new instance of the JsonConfigurationException class which reports that the token at the current location of the file was not expected. Declaration public JsonConfigurationException(JsonToken expectedTokenType, JsonReader reader) Parameters Name Type Description expectedTokenType JsonToken reader JsonReader <!-- .classchild --> JsonConfigurationException(String, JsonReader) Constructs a new instance of the JsonConfigurationException class. Note, if you supply a JsonReader, then the current line and column will be reported automatically at the end of the exception message. Declaration public JsonConfigurationException(string message, JsonReader reader) Parameters Name Type Description message String reader JsonReader <!-- .classchild --> JsonConfigurationException(String, JToken) Constructs a new instance of the JsonConfigurationException class. Note, if you supply a JObject, then the starting line and column of that object from the original source text will be reported automatically at the end of the exception message. Declaration public JsonConfigurationException(string message, JToken jToken) Parameters Name Type Description message String jToken JToken <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Message Declaration public override string Message { get; } Property Value Type Description String Overrides Exception.Message <!-- .classchild --> Reader If not null, then this is a reader whose position should be at the place where the error occurs. Declaration public JsonReader Reader { get; } Property Value Type Description JsonReader <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.JsonConfigurationParser.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.JsonConfigurationParser.html",
    "title": "Class JsonConfigurationParser",
    "keywords": "Class JsonConfigurationParser Inheritance Object JsonConfigurationParser Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class JsonConfigurationParser <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateJsonSerializerSettings() Declaration public virtual JsonSerializerSettings CreateJsonSerializerSettings() Returns Type Description JsonSerializerSettings <!-- .classchild --> CreateSerializer(JsonSerializerSettings) Declaration public virtual JsonSerializer CreateSerializer(JsonSerializerSettings settings) Parameters Name Type Description settings JsonSerializerSettings Returns Type Description JsonSerializer <!-- .classchild --> Parse(String) Declaration public IConfiguration Parse(string json) Parameters Name Type Description json String Returns Type Description IConfiguration <!-- .classchild --> Parse(String, JsonSerializer) Declaration public virtual IConfiguration Parse(string json, JsonSerializer jsonSerializer) Parameters Name Type Description json String jsonSerializer JsonSerializer Returns Type Description IConfiguration <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.LazyJsonObjectTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.LazyJsonObjectTargetMetadata.html",
    "title": "Class LazyJsonObjectTargetMetadata",
    "keywords": "Class LazyJsonObjectTargetMetadata Special version of IObjectTargetMetadata which creates an instance of the requested type from a JToken. Some more work might be required here to Inheritance Object RezolveTargetMetadataBase ObjectTargetMetadataBase LazyJsonObjectTargetMetadata Inherited Members ObjectTargetMetadataBase.CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) RezolveTargetMetadataBase.Type RezolveTargetMetadataBase.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) RezolveTargetMetadataBase.Bind(ITypeReference[]) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class LazyJsonObjectTargetMetadata : ObjectTargetMetadataBase, IObjectTargetMetadata, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides RezolveTargetMetadataBase.DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides RezolveTargetMetadataBase.BindBase(ITypeReference[]) <!-- .classchild --> GetObject(Type) Declaration public override object GetObject(Type type) Parameters Name Type Description type Type Returns Type Description Object Overrides ObjectTargetMetadataBase.GetObject(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.RezolveTargetMetadataConverter.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.RezolveTargetMetadataConverter.html",
    "title": "Class RezolveTargetMetadataConverter",
    "keywords": "Class RezolveTargetMetadataConverter This converter is registered against the type RezolveTargetMetadataWrapper Inheritance Object RezolveTargetMetadataConverter Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class RezolveTargetMetadataConverter : JsonConverter <!-- <hr class=\"typeSectionDivider\" /> --> Properties CanWrite Declaration public override bool CanWrite { get; } Property Value Type Description Boolean <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CanConvert(Type) Declaration public override bool CanConvert(Type objectType) Parameters Name Type Description objectType Type Returns Type Description Boolean <!-- .classchild --> ReadJson(JsonReader, Type, Object, JsonSerializer) Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Name Type Description reader JsonReader objectType Type existingValue Object serializer JsonSerializer Returns Type Description Object <!-- .classchild --> WriteJson(JsonWriter, Object, JsonSerializer) Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Name Type Description writer JsonWriter value Object serializer JsonSerializer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.RezolveTargetMetadataWrapper.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.RezolveTargetMetadataWrapper.html",
    "title": "Class RezolveTargetMetadataWrapper",
    "keywords": "Class RezolveTargetMetadataWrapper Metadata wrapper to accommodate the nature of how JSON configuration is deserialized. Of little practical use outside of the Json configuration library, unless you are creating your own metadata types which need the Unwrap semantics Inheritance Object RezolveTargetMetadataBase RezolveTargetMetadataWrapper Inherited Members RezolveTargetMetadataBase.Type RezolveTargetMetadataBase.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) RezolveTargetMetadataBase.Bind(ITypeReference[]) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax [Obsolete(\"no longer required\", true)] public class RezolveTargetMetadataWrapper : RezolveTargetMetadataBase, IRezolveTargetMetadataExtension, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RezolveTargetMetadataWrapper(IRezolveTargetMetadata) Declaration public RezolveTargetMetadataWrapper(IRezolveTargetMetadata wrapped) Parameters Name Type Description wrapped IRezolveTargetMetadata <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Fields ExtensionTypeName Declaration public const string ExtensionTypeName = \"#JSONWRAPPER#\" Field Value Type Description String <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides RezolveTargetMetadataBase.DeclaredType Implements IRezolveTargetMetadata.DeclaredType <!-- .classchild --> ExtensionType Declaration public string ExtensionType { get; } Property Value Type Description String Implements IRezolveTargetMetadataExtension.ExtensionType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides RezolveTargetMetadataBase.BindBase(ITypeReference[]) <!-- .classchild --> CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Implementation of CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) , except this implementation always throws a System.NotSupportedException , because it must be unwrapped (through a call to UnwrapMetadata(ITypeReference[]) ) before it can be used to create an ITarget . Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description ITarget Overrides RezolveTargetMetadataBase.CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild --> UnwrapConstructorMetadata(IRezolveTargetMetadata, ITypeReference[]) Unwraps an IConstructorTargetMetadata object by binding it to the forTargetTypes . Declaration protected virtual IRezolveTargetMetadata UnwrapConstructorMetadata(IRezolveTargetMetadata meta, ITypeReference[] forTargetTypes) Parameters Name Type Description meta IRezolveTargetMetadata forTargetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata <!-- .classchild --> UnwrapExtensionMetadata(IRezolveTargetMetadata, ITypeReference[]) Special case version of UnwrapMetadata(ITypeReference[]) for metadata with the type Extension . The base implementation supports instances of the RezolveTargetMetadataWrapper type only - and simply chain the call through to its UnwrapMetadata method. Declaration protected virtual IRezolveTargetMetadata UnwrapExtensionMetadata(IRezolveTargetMetadata meta, ITypeReference[] forTargetTypes) Parameters Name Type Description meta IRezolveTargetMetadata forTargetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata <!-- .classchild --> UnwrapListMetadata(IRezolveTargetMetadata, ITypeReference[]) Unwraps a list metadata (and any inner target metadata) for the target types. Declaration protected virtual IRezolveTargetMetadata UnwrapListMetadata(IRezolveTargetMetadata meta, ITypeReference[] forTargetTypes) Parameters Name Type Description meta IRezolveTargetMetadata forTargetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata <!-- .classchild --> UnwrapMetadata(ITypeReference[]) Unwraps the metadata contained within this wrapper for the passed target types in readiness to be pushed into an IConfigurationEntry. Note - if the metadata can't be unwrapped, then the method will simply return this instance. Declaration public virtual IRezolveTargetMetadata UnwrapMetadata(ITypeReference[] forTargetTypes) Parameters Name Type Description forTargetTypes ITypeReference [] Type references that the unwrapped metadata should support. Returns Type Description IRezolveTargetMetadata Remarks Unwrapping is the process whereby a type declared for registration is back-referenced using the '$auto' unbound type name in configuration for, say a constructor target or similar. <!-- .classchild --> UnwrapMetadataList(IRezolveTargetMetadata, ITypeReference[]) Unwraps a series of metadata objects stored in the list (passed in the meta parameter) for the target types, returning another metadata list containing the unwrapped metadata objects. Declaration protected IRezolveTargetMetadataList UnwrapMetadataList(IRezolveTargetMetadata meta, ITypeReference[] forTargetTypes) Parameters Name Type Description meta IRezolveTargetMetadata forTargetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadataList <!-- .classchild --> UnwrapMetadataList(IRezolveTargetMetadataList, ITypeReference[]) Strongly-typed virtual method for unwrapping metadata lists (invoked by UnwrapMetadataList(IRezolveTargetMetadata, ITypeReference[]) after confirming that the metadata passed to it is of the correct type. Declaration protected virtual IRezolveTargetMetadataList UnwrapMetadataList(IRezolveTargetMetadataList listMeta, ITypeReference[] forTargetTypes) Parameters Name Type Description listMeta IRezolveTargetMetadataList forTargetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadataList <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.TypeReferenceConverter.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.TypeReferenceConverter.html",
    "title": "Class TypeReferenceConverter",
    "keywords": "Class TypeReferenceConverter Responsible for converting Json to a Rezolver Configuration TypeReference Inheritance Object TypeReferenceConverter Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class TypeReferenceConverter : JsonConverter <!-- <hr class=\"typeSectionDivider\" /> --> Properties CanWrite Declaration public override bool CanWrite { get; } Property Value Type Description Boolean <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CanConvert(Type) Declaration public override bool CanConvert(Type objectType) Parameters Name Type Description objectType Type Returns Type Description Boolean <!-- .classchild --> ReadJson(JsonReader, Type, Object, JsonSerializer) Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Name Type Description reader JsonReader objectType Type existingValue Object serializer JsonSerializer Returns Type Description Object <!-- .classchild --> WriteJson(JsonWriter, Object, JsonSerializer) Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Name Type Description writer JsonWriter value Object serializer JsonSerializer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.html",
    "title": "Namespace Rezolver.Configuration.Json",
    "keywords": "Namespace Rezolver.Configuration.Json Classes AdvancedConfigurationAdapterContextFactory An advanced factory which automatically loads and references all assemblies that are deployed in the application's base directory and any subfolders determined by the System.AppDomain 's SetupInformation's PrivateBinBath. This is a singleton - accessed through the Instance property. ConfigurationEntryConverter JSON converter for IConfigurationEntry The converter defaults to looking for type registrations; to enable it to look for a different entry type, you must instruct Json.Net to create an instance of it using the constructor that accepts a ConfigurationEntryType JsonConfiguration Class JsonConfiguration. JsonConfiguration.JsonConfigurationConverter Class for loading JsonConfiguration from Json through Json.Net. JsonConfigurationException Thrown when a Json container configuration file is invalid. JsonConfigurationParser LazyJsonObjectTargetMetadata Special version of IObjectTargetMetadata which creates an instance of the requested type from a JToken. Some more work might be required here to RezolveTargetMetadataConverter This converter is registered against the type RezolveTargetMetadataWrapper RezolveTargetMetadataWrapper Metadata wrapper to accommodate the nature of how JSON configuration is deserialized. Of little practical use outside of the Json configuration library, unless you are creating your own metadata types which need the Unwrap semantics TypeReferenceConverter Responsible for converting Json to a Rezolver Configuration TypeReference"
  },
  "rezolver-api/Rezolver.Configuration.ListTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.ListTargetMetadata.html",
    "title": "Class ListTargetMetadata",
    "keywords": "Class ListTargetMetadata Standard implementation of the IListTargetMetadata interface. Inheritance Object RezolveTargetMetadataBase ListTargetMetadata Inherited Members RezolveTargetMetadataBase.Type RezolveTargetMetadataBase.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ListTargetMetadata : RezolveTargetMetadataBase, IListTargetMetadata, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ListTargetMetadata(ITypeReference, IRezolveTargetMetadataList, Boolean) Initializes a new instance of the ListTargetMetadata class. Declaration public ListTargetMetadata(ITypeReference elementType, IRezolveTargetMetadataList items, bool isArray) Parameters Name Type Description elementType ITypeReference Type of the elements of the eventual array/list. items IRezolveTargetMetadataList Metadata for the targets that will eventually create the items for the array or list. isArray Boolean if set to true then an array is to be built, otherwise a list is to be built. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides RezolveTargetMetadataBase.DeclaredType Implements IRezolveTargetMetadata.DeclaredType <!-- .classchild --> ElementType Gets the declared element type of the array or list that will be created from this metadata. Declaration public ITypeReference ElementType { get; } Property Value Type Description ITypeReference The type of the element. Implements IListTargetMetadata.ElementType Exceptions Type Condition System.NotImplementedException <!-- .classchild --> IsArray Maps to the AsArray property. If true, then an array of ElementType will be created, otherwise a List< ElementType > will be created by the ListTarget created from this metadata. Declaration public bool IsArray { get; } Property Value Type Description Boolean true if this instance represents a ListTarget that will create an array; otherwise, false . Implements IListTargetMetadata.IsArray <!-- .classchild --> Items Gets the metadata for the targets that will be used for the items that'll be returned in the Array or List that will be created by the ListTarget created from this metadata. Declaration public IRezolveTargetMetadataList Items { get; } Property Value Type Description IRezolveTargetMetadataList The elements. Implements IListTargetMetadata.Items <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Bind(ITypeReference[]) Declaration public override IRezolveTargetMetadata Bind(ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides RezolveTargetMetadataBase.Bind(ITypeReference[]) Implements IRezolveTargetMetadata.Bind(ITypeReference[]) <!-- .classchild --> BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides RezolveTargetMetadataBase.BindBase(ITypeReference[]) <!-- .classchild --> CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description ITarget Overrides RezolveTargetMetadataBase.CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ExpressionTarget.html": {
    "href": "rezolver-api/Rezolver.ExpressionTarget.html",
    "title": "Class ExpressionTarget",
    "keywords": "Class ExpressionTarget A generic target for all expressions not explicitly supported by a particular target. Enables more complex behaviours to be registered and used with the more formal ITarget implementations. Inheritance Object TargetBase ExpressionTarget Inherited Members TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ExpressionTarget : TargetBase, ITarget Remarks Note that this target does not support Lambda expressions. If you wish to create an ITarget from a lambda expression, then you should use the <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ExpressionTarget(Expression, Type) Initializes a new instance of the ExpressionTarget class. Declaration public ExpressionTarget(Expression expression, Type declaredType = null) Parameters Name Type Description expression Expression Required. The static expression which will be returned by CreateExpressionBase(CompileContext) . declaredType Type Declared type of the target to be created (used when registering without an explicit type or when this target is used as a value inside another target). Remarks declaredType will automatically be determined if not provided by examining the type of the expression . For lambdas, the type will be derived from the Type of the lambda's body. For all other expressions, the type is taken directly from the Type property of the expression itself. <!-- .classchild --> ExpressionTarget(Func<CompileContext, Expression>, Type) Initializes a new instance of the ExpressionTarget class. Declaration public ExpressionTarget(Func<CompileContext, Expression> expressionFactory, Type declaredType) Parameters Name Type Description expressionFactory Func < CompileContext , Expression > Required. The factory delegate that will be called to create the expression when CreateExpressionBase(CompileContext) is called. declaredType Type Required. Static type of all expressions that will be returned by expressionFactory . Remarks Note that when you use a factory to produce a new expression on demand each time CreateExpressionBase(CompileContext) is called, the declaredType is required to be the same for all. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Gets the type of Expression or the type that all expressions returned by the ExpressionFactory are expected to be equal to. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> Expression Gets the static expression represented by this target - if null , then a factory is being used to produce the expression, which is available from the ExpressionFactory property. Declaration public Expression Expression { get; } Property Value Type Description Expression <!-- .classchild --> ExpressionFactory Gets a factory which will be executed to obtain an expression when CreateExpressionBase(CompileContext) is called. If null , then a static expression will be used instead and is available from the Expression property. Declaration public Func<CompileContext, Expression> ExpressionFactory { get; } Property Value Type Description Func < CompileContext , Expression > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateExpressionBase(CompileContext) Returns either the static Expression or the result of calling the ExpressionFactory with the context . Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext The current compile context Returns Type Description Expression Overrides TargetBase.CreateExpressionBase(CompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Functions.html": {
    "href": "rezolver-api/Rezolver.Functions.html",
    "title": "Class Functions",
    "keywords": "Class Functions This type is only used when building targets from expressions, and provides a natural way to have specific ITarget objects created from natural code, when using the default TargetAdapter to translate expressions into targets. Inheritance Object Functions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class Functions <!-- <hr class=\"typeSectionDivider\" /> --> Methods Resolve<T>() Translated to a RezolvedTarget with T being the type taht will be resolved. Declaration public static T Resolve<T>() Returns Type Description T Type Parameters Name Description T The type to be resolved. Exceptions Type Condition System.NotImplementedException Always. The method is not intended to be used outside of an expression. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.GenericConstructorTarget.html": {
    "href": "rezolver-api/Rezolver.GenericConstructorTarget.html",
    "title": "Class GenericConstructorTarget",
    "keywords": "Class GenericConstructorTarget Equivalent of ConstructorTarget but for open generic types. So, this will handle the open generic MyType<,>, for example, whereas ConstructorTarget would handle the closed type MyType<int, string>. Inheritance Object TargetBase GenericConstructorTarget Inherited Members TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class GenericConstructorTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors GenericConstructorTarget(Type, IPropertyBindingBehaviour) Declaration public GenericConstructorTarget(Type genericType, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description genericType Type The type of the object that is to be built (open generic of course) propertyBindingBehaviour IPropertyBindingBehaviour Optional. The IPropertyBindingBehaviour to be used for binding properties and/or fields on the 'new' expression that is generated. If null, then no property or fields will be bound on construction. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Implementation of the abstract base property. Will retrn the unbound generic type passed to this object on construction. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Auto(Type, IPropertyBindingBehaviour) Equivalent of Auto(Type, IPropertyBindingBehaviour) but for open generic types. Declaration public static ITarget Auto(Type type, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description type Type The type. propertyBindingBehaviour IPropertyBindingBehaviour The property binding behaviour. Returns Type Description ITarget Exceptions Type Condition System.ArgumentException The passed type must be an open generic type or The passed type must a non-abstract class <!-- .classchild --> Auto<TGeneric>(IPropertyBindingBehaviour) Equivalent of Auto<T>(IPropertyBindingBehaviour) but for open generic types. Declaration public static ITarget Auto<TGeneric>(IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description propertyBindingBehaviour IPropertyBindingBehaviour Optional behaviour controlling which properties, if any, receive injected values. Returns Type Description ITarget Type Parameters Name Description TGeneric The open generic type which will be created when this target is called upon to create an instance. <!-- .classchild --> CreateExpressionBase(CompileContext) Determines the generic type to be bound, and then generates a for that type. Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides TargetBase.CreateExpressionBase(CompileContext) <!-- .classchild --> SupportsType(Type) Override - introduces additional logic to cope with generic types not generally supported by the majority of other targets. Declaration public override bool SupportsType(Type type) Parameters Name Type Description type Type Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.GenericTargetContainer.html": {
    "href": "rezolver-api/Rezolver.GenericTargetContainer.html",
    "title": "Class GenericTargetContainer",
    "keywords": "Class GenericTargetContainer A special type of ITargetContainerOwner which stores targets (and potentially other containers) which are specifically keyed either to a particular open generic type or a closed generic built from it. Inheritance Object TargetDictionaryContainer GenericTargetContainer Inherited Members TargetDictionaryContainer.FetchContainer(Type) TargetDictionaryContainer.RegisterContainer(Type, ITargetContainer) TargetDictionaryContainer.CreateContainer(Type, ITarget) TargetDictionaryContainer.CombineWith(ITargetContainer, Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class GenericTargetContainer : TargetDictionaryContainer, ITargetContainerOwner, ITargetContainer <!-- <hr class=\"typeSectionDivider\" /> --> Constructors GenericTargetContainer(Type) Initializes a new instance of the GenericTargetContainer class. Declaration public GenericTargetContainer(Type genericType) Parameters Name Type Description genericType Type Required. The generic type definition that all targets and subcontainers will be grouped under. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties GenericType Gets open generic type to which all targets and containers within this container relate. Declaration public Type GenericType { get; } Property Value Type Description Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Fetch(Type) Gets the target which can be used to build an instance of type . Declaration public override ITarget Fetch(Type type) Parameters Name Type Description type Type Required. The type for which a target is to be obtained. Because of the restrictions placed on the DeclaredType of the targets that can actually be registered into this container, the function will only ever return anything if type is a closed generic type whose definition equals GenericType . Returns Type Description ITarget Overrides TargetDictionaryContainer.Fetch(Type) Remarks Targets which have been registered specifically against the exact closed generic type represented by type take precedence over any targets which have been registered against the open generic type GenericType . <!-- .classchild --> FetchAll(Type) Implementation of FetchAll(Type) Declaration public override IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type Type The type whose targets are to be retrieved. Returns Type Description IEnumerable < ITarget > Overrides TargetDictionaryContainer.FetchAll(Type) <!-- .classchild --> Register(ITarget, Type) Overrides the Register(ITarget, Type) method to support registering both targets against the open generic type GenericType and against specific closed versions of that open generic type. Declaration public override void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget The target to be registered serviceType Type Service type against which the registration will be made. If null, then it will be assumed to be equal to GenericType . Only types equal to GenericType or generic types whose generic type definition is equal to GenericType are supported. Overrides TargetDictionaryContainer.Register(ITarget, Type) Remarks Notes to overriders: When serviceType is a closed generic type, this function creates an ITargetContainer for that serviceType by calling the protected method CreateContainer(Type, ITarget) if one doesn't exist (it calls FetchContainer(Type) to check for existence), and then chains to its Register(ITarget, Type) method. Exceptions Type Condition System.ArgumentException If serviceType is not equal to GenericType or is not a closed generic type whose generic type definition is GenericType . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IChildTargetContainer.html": {
    "href": "rezolver-api/Rezolver.IChildTargetContainer.html",
    "title": "Interface IChildTargetContainer",
    "keywords": "Interface IChildTargetContainer An ITargetContainer that inherits all registrations from an ancestor ( Parent ). If it cannot resolve a target for a particular type, will defer to its parent for fallback. Inherited Members ITargetContainer.Register(ITarget, Type) ITargetContainer.Fetch(Type) ITargetContainer.FetchAll(Type) ITargetContainer.CombineWith(ITargetContainer, Type) Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IChildTargetContainer : ITargetContainer <!-- <hr class=\"typeSectionDivider\" /> --> Properties Parent Gets the parent target container. Declaration ITargetContainer Parent { get; } Property Value Type Description ITargetContainer The parent. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ICompiledTarget.html": {
    "href": "rezolver-api/Rezolver.ICompiledTarget.html",
    "title": "Interface ICompiledTarget",
    "keywords": "Interface ICompiledTarget Provides an abstraction for creating objects based on a given RezolveContext - this is the ultimate target of all Resolve(RezolveContext) calls in the standard container implementations within the Rezolver framework. Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ICompiledTarget Remarks In the standard implementations of IContainer (e.g. Container ), an ITargetCompiler creates instances of this from ITarget s which are registered in an ITargetContainer . When the container is then called upon to resolve an instance of a particular type, the ICompiledTarget is first obtained, and then the responsibility for creating the object is delegated to its GetObject(RezolveContext) method. <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetObject(RezolveContext) Called to get/create an object, potentially using the passed context to resolve additional dependencies (via its Container ), or interact with any lifetime scope which is 'active' for that request (through Scope ). Declaration object GetObject(RezolveContext context) Parameters Name Type Description context RezolveContext The current rezolve context. Returns Type Description Object The object that is constructed. The return value can legitimately be null. Exceptions Type Condition System.InvalidOperationException If the target fails to create the object Exception Any other exception could be raised by this operation <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IContainer.html": {
    "href": "rezolver-api/Rezolver.IContainer.html",
    "title": "Interface IContainer",
    "keywords": "Interface IContainer The primary IOC container interface in the Rezolver framework. Inherited Members IServiceProvider.GetService(Type) Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IContainer : IServiceProvider Remarks Instances of objects (typically known as 'services' in IOC-speak) are resolved via the Resolve(RezolveContext) or TryResolve(RezolveContext, out Object) methods. You can introspect the container to check in advance whether a given type can be resolved through the CanResolve(RezolveContext) method. Lifetime scoping (where IDisposable objects are created within a scope and destroyed when that scope is destroyed) can be achieved by obtaining a new scope through the CreateLifetimeScope() method. Many of the functions which accept a RezolveContext also have alternatives (in the form of extension methods) in the IContainerRezolveExtensions class. If you're looking for the 'traditional' IOC container methods (e.g. Resolve<TObject>(IContainer) , that's where you'll find them. Note that while the standard implementation of this interface supplied by the framework ( ContainerBase and its derivatives) all utilitise the ITargetContainer to actually locate registrations for types which are ultimately requested from the container; the interface doesn't actually mandate that pattern. <!-- <hr class=\"typeSectionDivider\" /> --> Methods CanResolve(RezolveContext) Returns true if a resolve operation for the given context will succeed. If you're going to be calling Resolve(RezolveContext) immediately afterwards, consider using the TryResolve(RezolveContext, out Object) method instead, which allows you to check and obtain the result at the same time. Declaration bool CanResolve(RezolveContext context) Parameters Name Type Description context RezolveContext The resolve context. Returns Type Description Boolean true if this instance can resolve a type for the specified context; otherwise, false . <!-- .classchild --> CreateLifetimeScope() Called to create an IScopedContainer which can resolve the same objects as this container, but which will track, and dispose of, any disposable objects that it creates. Declaration IScopedContainer CreateLifetimeScope() Returns Type Description IScopedContainer Remarks If the container on which this is called also implements the IScopedContainer interface, then the newly created scope's lifetime will be tied to that parent container. <!-- .classchild --> FetchCompiled(RezolveContext) Fetches the ICompiledTarget for the given context, whose GetObject(RezolveContext) method would ultimately be called if the same context was passed to Resolve(RezolveContext) or TryResolve(RezolveContext, out Object) . Declaration ICompiledTarget FetchCompiled(RezolveContext context) Parameters Name Type Description context RezolveContext The context. Returns Type Description ICompiledTarget Remarks This is not typically a method that you're likely to use as the consumer of an IContainer . It's more typically used by implementations of ITargetCompiler or implementations of IContainer when communicating with other containers. As such, its use at an application level is limited. <!-- .classchild --> Resolve(RezolveContext) Called to resolve a reference to an object for the given context (which provides the RequestedType of the object that is required, among other things). Declaration object Resolve(RezolveContext context) Parameters Name Type Description context RezolveContext The context. Returns Type Description Object The resolved object, if successful. Exceptions Type Condition System.InvalidOperationException If the requested type cannot be resolved. <!-- .classchild --> TryResolve(RezolveContext, out Object) Merges the CanResolve(RezolveContext) and Resolve(RezolveContext) operations into one operation. Declaration bool TryResolve(RezolveContext context, out object result) Parameters Name Type Description context RezolveContext The context. result Object Receives the resultant resolved object if the operation succeeds. Returns Type Description Boolean true if the operation succeeded (the resolved object will be set into the result parameter); false otherwise. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IContainerRezolveExtensions.html": {
    "href": "rezolver-api/Rezolver.IContainerRezolveExtensions.html",
    "title": "Class IContainerRezolveExtensions",
    "keywords": "Class IContainerRezolveExtensions Inheritance Object IContainerRezolveExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class IContainerRezolveExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods Resolve(IContainer, Type) Resolves an object of the given type Declaration public static object Resolve(this IContainer container, Type type) Parameters Name Type Description container IContainer The container. type Type The type to be resolved. Returns Type Description Object An instance of the type . <!-- .classchild --> Resolve(IContainer, Type, IScopedContainer) Resolves an object of the given type , using the given lifetime scope for lifetime management. Declaration public static object Resolve(this IContainer container, Type type, IScopedContainer scope) Parameters Name Type Description container IContainer The container. type Type Type to be resolved. scope IScopedContainer The lifetime scope - can be a different instance to container (or the object on which the method is invoked if invoked as an extension method), e.g. when a master container instance is used to create a child 'scope' which has a different lifetime to that of the master. Returns Type Description Object An instance of the requested type . <!-- .classchild --> Resolve<TObject>(IContainer) Resolves an object of type TObject Declaration public static TObject Resolve<TObject>(this IContainer container) Parameters Name Type Description container IContainer The container. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject The type to be resolved. <!-- .classchild --> Resolve<TObject>(IContainer, IScopedContainer) Resolves an object of the type TObject , using the given lifetime scope for lifetime management. Declaration public static TObject Resolve<TObject>(this IContainer container, IScopedContainer scope) Parameters Name Type Description container IContainer The container. scope IScopedContainer The lifetime scope - can be a different instance to container (or the object on which the method is invoked if invoked as an extension method), e.g. when a master container instance is used to create a child 'scope' which has a different lifetime to that of the master. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject Type to be resolved. <!-- .classchild --> TryResolve(IContainer, Type, IScopedContainer, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer container, Type type, IScopedContainer scope, out object result) Parameters Name Type Description container IContainer The container. type Type The type to be resolved. scope IScopedContainer The lifetime scope - can be a different instance to container (or the object on which the method is invoked if invoked as an extension method), e.g. when a master container instance is used to create a child 'scope' which has a different lifetime to that of the master. result Object Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type, IScopedContainer) overloads <!-- .classchild --> TryResolve(IContainer, Type, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer container, Type type, out object result) Parameters Name Type Description container IContainer The container. type Type The type to be resolved. result Object Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type) overloads <!-- .classchild --> TryResolve<TObject>(IContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer container, out TObject result) Parameters Name Type Description container IContainer The container. result TObject Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved. <!-- .classchild --> TryResolve<TObject>(IContainer, IScopedContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer container, IScopedContainer scope, out TObject result) Parameters Name Type Description container IContainer The container. scope IScopedContainer The lifetime scope - can be a different instance to container (or the object on which the method is invoked if invoked as an extension method), e.g. when a master container instance is used to create a child 'scope' which has a different lifetime to that of the master. result TObject Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IPropertyBindingBehaviour.html": {
    "href": "rezolver-api/Rezolver.IPropertyBindingBehaviour.html",
    "title": "Interface IPropertyBindingBehaviour",
    "keywords": "Interface IPropertyBindingBehaviour Describes a type which discovers property/field bindings Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IPropertyBindingBehaviour <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetPropertyBindings(CompileContext, Type) Retrieves the property and/or field bindings for the given type based on the given CompileContext Declaration PropertyOrFieldBinding[] GetPropertyBindings(CompileContext context, Type type) Parameters Name Type Description context CompileContext type Type Returns Type Description PropertyOrFieldBinding [] <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IRezolverExtensions.html": {
    "href": "rezolver-api/Rezolver.IRezolverExtensions.html",
    "title": "Class IRezolverExtensions",
    "keywords": "Class IRezolverExtensions Inheritance Object IRezolverExtensions Inherited Members ToString() Equals(Object) Equals(Object, Object) ReferenceEquals(Object, Object) GetHashCode() GetType() MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class IRezolverExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods Register(IContainer, ITarget, Type) Wrapper for the Register(ITarget, Type) method of the rezolver argument's Rezolver.IContainer.Builder Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void Register(this IContainer rezolver, ITarget target, Type type = null) Parameters Name Type Description rezolver IContainer target ITarget type Type <!-- .classchild --> RegisterAll(IContainer, ITarget[]) Parameter array version of the RegisterAll method. Declaration public static void RegisterAll(this IContainer rezolver, params ITarget[] targets) Parameters Name Type Description rezolver IContainer The rezolver. targets ITarget [] The targets. <!-- .classchild --> RegisterAll(IContainer, IEnumerable<ITarget>) Batch-registers multiple targets with different contracts. Basically, this is like calling Register(IRezolveTarget) multiple times, but with an enumerable. Declaration public static void RegisterAll(this IContainer rezolver, IEnumerable<ITarget> targets) Parameters Name Type Description rezolver IContainer targets IEnumerable < ITarget > <!-- .classchild --> RegisterExpression<T>(IContainer, Expression<Func<RezolveContextExpressionHelper, T>>, Type, ITargetAdapter) Wrapper for the , please see that method for the reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterExpression<T>(this IContainer rezolver, Expression<Func<RezolveContextExpressionHelper, T>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description rezolver IContainer The rezolver. expression Expression < Func < RezolveContextExpressionHelper , T>> type Type adapter ITargetAdapter Type Parameters Name Description T <!-- .classchild --> RegisterMultiple(IContainer, IEnumerable<ITarget>, Type) Wrapper for the RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterMultiple(this IContainer rezolver, IEnumerable<ITarget> targets, Type commonServiceType = null) Parameters Name Type Description rezolver IContainer The rezolver. targets IEnumerable < ITarget > commonServiceType Type <!-- .classchild --> RegisterObject<T>(IContainer, T, Type, Boolean) Wrapper for the RegisterObject<T>(ITargetContainer, T, Type, Boolean) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterObject<T>(this IContainer rezolver, T obj, Type type = null, bool suppressScopeTracking = true) Parameters Name Type Description rezolver IContainer The rezolver. obj T type Type suppressScopeTracking Boolean Type Parameters Name Description T <!-- .classchild --> RegisterScoped(IContainer, Type, Type, IPropertyBindingBehaviour) Wrapper for the , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterScoped(this IContainer rezolver, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description rezolver IContainer objectType Type serviceType Type propertyBindingBehaviour IPropertyBindingBehaviour <!-- .classchild --> RegisterScoped<TObject>(IContainer, IPropertyBindingBehaviour) Wrapper for the RegisterScoped<TObject>(ITargetContainer, IPropertyBindingBehaviour) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterScoped<TObject>(this IContainer rezolver, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description rezolver IContainer propertyBindingBehaviour IPropertyBindingBehaviour Type Parameters Name Description TObject <!-- .classchild --> RegisterScoped<TObject, TService>(IContainer, IPropertyBindingBehaviour) Wrapper for the RegisterScoped<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterScoped<TObject, TService>(this IContainer rezolver, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description rezolver IContainer propertyBindingBehaviour IPropertyBindingBehaviour Type Parameters Name Description TObject TService <!-- .classchild --> RegisterType(IContainer, Type, Type, IPropertyBindingBehaviour) Wrapper for the RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterType(this IContainer rezolver, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description rezolver IContainer objectType Type serviceType Type propertyBindingBehaviour IPropertyBindingBehaviour <!-- .classchild --> RegisterType<TObject>(IContainer, IPropertyBindingBehaviour) Wrapper for the RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterType<TObject>(this IContainer rezolver, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description rezolver IContainer The rezolver. propertyBindingBehaviour IPropertyBindingBehaviour The property binding behaviour. Type Parameters Name Description TObject Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via their 'Auto' static methods and then registering them. <!-- .classchild --> RegisterType<TObject, TService>(IContainer, IPropertyBindingBehaviour) Wrapper for the , please see that method for reference for the parameters Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterType<TObject, TService>(this IContainer rezolver, IPropertyBindingBehaviour propertyBindingBehaviour = null)where TObject : TService Parameters Name Type Description rezolver IContainer propertyBindingBehaviour IPropertyBindingBehaviour Type Parameters Name Description TObject TService <!-- .classchild --> Resolve(IContainer, Type) Resolves an object of the given type Declaration public static object Resolve(this IContainer rezolver, Type type) Parameters Name Type Description rezolver IContainer The rezolver. type Type The type to be resolved. Returns Type Description Object An instance of the type . <!-- .classchild --> Resolve(IContainer, Type, IScopedContainer) Resolves an object of the given type , using the given lifetime scope for lifetime management. Declaration public static object Resolve(this IContainer rezolver, Type type, IScopedContainer scope) Parameters Name Type Description rezolver IContainer The rezolver. type Type Type to be resolved. scope IScopedContainer The lifetime scope - can be a different instance to rezolver (or the object on which the method is invoked if invoked as an extension method), e.g. when a master rezolver instance is used to create a child 'scope' which has a different lifetime to that of the master. Returns Type Description Object An instance of the requested type . <!-- .classchild --> Resolve<TObject>(IContainer) Resolves an object of type TObject Declaration public static TObject Resolve<TObject>(this IContainer rezolver) Parameters Name Type Description rezolver IContainer The rezolver. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject The type to be resolved. <!-- .classchild --> Resolve<TObject>(IContainer, IScopedContainer) Resolves an object of the type TObject , using the given lifetime scope for lifetime management. Declaration public static TObject Resolve<TObject>(this IContainer rezolver, IScopedContainer scope) Parameters Name Type Description rezolver IContainer The rezolver. scope IScopedContainer The lifetime scope - can be a different instance to rezolver (or the object on which the method is invoked if invoked as an extension method), e.g. when a master rezolver instance is used to create a child 'scope' which has a different lifetime to that of the master. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject Type to be resolved. <!-- .classchild --> TryResolve(IContainer, Type, IScopedContainer, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer rezolver, Type type, IScopedContainer scope, out object result) Parameters Name Type Description rezolver IContainer The rezolver. type Type The type to be resolved. scope IScopedContainer The lifetime scope - can be a different instance to rezolver (or the object on which the method is invoked if invoked as an extension method), e.g. when a master rezolver instance is used to create a child 'scope' which has a different lifetime to that of the master. result Object Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type, IScopedContainer) overloads <!-- .classchild --> TryResolve(IContainer, Type, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer rezolver, Type type, out object result) Parameters Name Type Description rezolver IContainer The rezolver. type Type The type to be resolved. result Object Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type) overloads <!-- .classchild --> TryResolve<TObject>(IContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer rezolver, out TObject result) Parameters Name Type Description rezolver IContainer The rezolver. result TObject Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved. <!-- .classchild --> TryResolve<TObject>(IContainer, IScopedContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer rezolver, IScopedContainer scope, out TObject result) Parameters Name Type Description rezolver IContainer The rezolver. scope IScopedContainer The lifetime scope - can be a different instance to rezolver (or the object on which the method is invoked if invoked as an extension method), e.g. when a master rezolver instance is used to create a child 'scope' which has a different lifetime to that of the master. result TObject Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IRezolveTargetScopingExtensions.html": {
    "href": "rezolver-api/Rezolver.IRezolveTargetScopingExtensions.html",
    "title": "Class IRezolveTargetScopingExtensions",
    "keywords": "Class IRezolveTargetScopingExtensions Extension method(s) to convert targets into scoped targets. Inheritance Object IRezolveTargetScopingExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class IRezolveTargetScopingExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods Scoped(ITarget) Creates a ScopedTarget from the target on which this method is invoked. Declaration public static ScopedTarget Scoped(this ITarget target) Parameters Name Type Description target ITarget Returns Type Description ScopedTarget <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IRezolveTargetSingletonExtensions.html": {
    "href": "rezolver-api/Rezolver.IRezolveTargetSingletonExtensions.html",
    "title": "Class IRezolveTargetSingletonExtensions",
    "keywords": "Class IRezolveTargetSingletonExtensions Extension method(s) to convert targets into singleton targets. Inheritance Object IRezolveTargetSingletonExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class IRezolveTargetSingletonExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods Singleton(ITarget) Constructs a SingletonTarget that wraps the target on which the method is invoked. Declaration public static SingletonTarget Singleton(this ITarget target) Parameters Name Type Description target ITarget Returns Type Description SingletonTarget <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IScopedContainer.html": {
    "href": "rezolver-api/Rezolver.IScopedContainer.html",
    "title": "Interface IScopedContainer",
    "keywords": "Interface IScopedContainer A container that's also a lifetime scope - that is, it's disposable, and will dispose of any disposable instances that it creates when it's disposed. Also, any subsequent lifetime scopes that it, or any child, creates will be disposed of when this scope is disposed. Note that while a lifetime scope can track objects of any types, it only automatically tracks disposable objects. To force a scope to track an instance, regardless of whether it's dispoable or not, you can call AddToScope(Object, RezolveContext) . This is how the default ScopedSingletonTarget works - if an object with this lifetime isn't a disposable, it is explicitly added to the scope passed to it at runtime, and then when an instance is subsequently requested, the code compiled by the scoped singleton will search the current scope, for an existing instance, before creating one. Inherited Members IContainer.CanResolve(RezolveContext) IContainer.Resolve(RezolveContext) IContainer.TryResolve(RezolveContext, Object) IContainer.CreateLifetimeScope() IContainer.FetchCompiled(RezolveContext) IServiceProvider.GetService(Type) IDisposable.Dispose() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IScopedContainer : IContainer, IServiceProvider, IDisposable <!-- <hr class=\"typeSectionDivider\" /> --> Properties ParentScope If this lifetime scope is a child of another, this will be non-null. Declaration IScopedContainer ParentScope { get; } Property Value Type Description IScopedContainer <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods AddToScope(Object, RezolveContext) Registers an instance to this scope which, if disposable, will then be disposed when this scope is disposed. Declaration void AddToScope(object obj, RezolveContext context = null) Parameters Name Type Description obj Object The object; if null, then no operation is performed. Doesn't have to be IDisposable, but if it is, then it will be tracked for disposal. context RezolveContext Optional - a rezolve context representing the conditions under which the object should be returned in the enumerable returned from a call to GetFromScope <!-- .classchild --> GetFromScope(RezolveContext) Retrieves all objects from this scope that were previously added through a call to AddToScope(Object, RezolveContext) with RezolveContexts that match the one passed. The method never returns null. Declaration IEnumerable<object> GetFromScope(RezolveContext context) Parameters Name Type Description context RezolveContext Required - the context whose properties will be used to find matching objects. Returns Type Description IEnumerable < Object > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Events Disposed This event is fired before the scope disposes This is primarily for infrastructure purposes, and not intended to be used from your code. Declaration event EventHandler Disposed Event Type Type Description EventHandler <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITarget.html": {
    "href": "rezolver-api/Rezolver.ITarget.html",
    "title": "Interface ITarget",
    "keywords": "Interface ITarget As the name suggests, the underlying target of a Rezolver call. The output of a target is an expression. This allows a target that depends on another target to chain expressions together, creating specialised expression trees (and therefore specialised delegates). The expression produced from this interface is later compiled, by an IRezolveTargetCompiler, into an ICompiledRezolveTarget - whose job it is specifically to produce object instances. Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Gets the static type produced by this target, when executing the expression returned from a call to CreateExpression(CompileContext) without providing your own explicit type to be returned. Declaration Type DeclaredType { get; } Property Value Type Description Type The type of the declared. <!-- .classchild --> UseFallback If true, it is an instruction to any consumer to consider falling back to a better target configured in a more authoritative builder. In general - almost all targets return false for this. Declaration bool UseFallback { get; } Property Value Type Description Boolean <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateExpression(CompileContext) Called to create the expression that will produce the object that is resolved by this target. The expression might be expected to handle a dynamic container being passed to it at run time to enable dynamic per-target overriding from other rezolvers. Declaration Expression CreateExpression(CompileContext context) Parameters Name Type Description context CompileContext The current compile context Returns Type Description Expression <!-- .classchild --> SupportsType(Type) Returns a boolean indicating whether the target is able to produce an instance of, or an instance that is compatible with, the passed type . Declaration bool SupportsType(Type type) Parameters Name Type Description type Type The type. Returns Type Description Boolean true if type is supported, false otherwise. Remarks It is strongly suggested that you use this method to check whether the target can construct an instance of a given type rather than performing any type checking yourself on the DeclaredType , because an ITarget might be able to support a much wider range of types other than just those which are directly compatible with its DeclaredType . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITargetAdapter.html": {
    "href": "rezolver-api/Rezolver.ITargetAdapter.html",
    "title": "Interface ITargetAdapter",
    "keywords": "Interface ITargetAdapter Interface for an object that can convert Expressions into ITarget s suitable for registration in an ITargetContainer Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITargetAdapter Remarks If you are considering manually creating an ExpressionTarget for an expression, then you should consider instead using an implementation of this interface to produce an ITarget for that expression. For example, the TargetAdapter class supplied by the framework, has the ability to convert some common code constructs into specific types of targets so as to properly leverage the power of the Rezolver framework at runtime. That class also has the ability to translate a whole lambda expression into a target, including converting any parameters for that lambda into injected variables. <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateTarget(Expression) Declaration ITarget CreateTarget(Expression expression) Parameters Name Type Description expression Expression Returns Type Description ITarget <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-10.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-10.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType DelegateTarget.CreateExpressionBase(CompileContext) TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-11.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-11.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType DelegateTarget.CreateExpressionBase(CompileContext) TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-12.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-12.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType DelegateTarget.CreateExpressionBase(CompileContext) TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-13.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-13.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType DelegateTarget.CreateExpressionBase(CompileContext) TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-14.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-14.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType DelegateTarget.CreateExpressionBase(CompileContext) TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-15.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-15.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType DelegateTarget.CreateExpressionBase(CompileContext) TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-16.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-16.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType DelegateTarget.CreateExpressionBase(CompileContext) TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) T15 The type of the 15th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-2.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-2.html",
    "title": "Class DelegateTarget<T, TResult>",
    "keywords": "Class DelegateTarget<T, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType DelegateTarget.CreateExpressionBase(CompileContext) TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T, TResult> : DelegateTarget, ITarget Type Parameters Name Description T The type of the 1st delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T, TResult>, Type) Initializes a new instance of the DelegateTarget<T, TResult> class. Declaration public DelegateTarget(Func<T, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-3.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-3.html",
    "title": "Class DelegateTarget<T1, T2, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType DelegateTarget.CreateExpressionBase(CompileContext) TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, TResult> class. Declaration public DelegateTarget(Func<T1, T2, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-4.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-4.html",
    "title": "Class DelegateTarget<T1, T2, T3, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType DelegateTarget.CreateExpressionBase(CompileContext) TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-5.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-5.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType DelegateTarget.CreateExpressionBase(CompileContext) TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-6.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-6.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType DelegateTarget.CreateExpressionBase(CompileContext) TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-7.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-7.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType DelegateTarget.CreateExpressionBase(CompileContext) TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-8.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-8.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType DelegateTarget.CreateExpressionBase(CompileContext) TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget-9.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-9.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.DeclaredType DelegateTarget.CreateExpressionBase(CompileContext) TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> factory, Type declaredType = null) Parameters Name Type Description factory Func <T1, T2, T3, T4, T5, T6, T7, T8, TResult> The factory. declaredType Type Type of the declared. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget.html",
    "title": "Class DelegateTarget",
    "keywords": "Class DelegateTarget An ITarget which resolve objects by executing a delegate with argument injection. Inheritance Object TargetBase DelegateTarget Inherited Members TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget : TargetBase, ITarget Remarks The delegate must be non-void and can have any number of parameters. Any parameters will be automatically resolved from the container, and a parameter of the type RezolveContext will receive the context passed to the current Resolve(RezolveContext) . <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Delegate, Type) Initializes a new instance of the DelegateTarget class. Declaration public DelegateTarget(Delegate factory, Type declaredType = null) Parameters Name Type Description factory Delegate Required - the factory delegate. Must have a return type and can take 0 or more parameters. As described in the remarks section of this class, parameters will be automatically resolved from the container; except parameters of the type RezolveContext , which will receive the context that was passed to the current Resolve(RezolveContext) method. declaredType Type Optional - type that will be set into the DeclaredType for the target; if not provided, then it will be derived from the factory 's return type Exceptions Type Condition System.ArgumentNullException If factory is null System.ArgumentException If the factory represents a void delegate or if declaredType is passed but the type is not compatible with the return type of factory . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Gets the declared type of object that is constructed by this target. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> Factory Gets the factory method that will be invoked by an expression built by this target. Declaration public Delegate Factory { get; } Property Value Type Description Delegate The factory. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateExpressionBase(CompileContext) Returns an expression that represents invoking the Factory method with zero or more auto-resolved arguments. Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext The current compile context Returns Type Description Expression Overrides TargetBase.CreateExpressionBase(CompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.DelegateTargetContainerExtensions.html",
    "title": "Class DelegateTargetContainerExtensions",
    "keywords": "Class DelegateTargetContainerExtensions Extension methods for ITargetContainer designed to simplify the registration of DelegateTarget and its numerous generic variants. Inheritance Object DelegateTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class DelegateTargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterDelegate(ITargetContainer, Delegate, Type) Constructs a DelegateTarget from the passed factory delegate (optionally with the given declaredType ) and registers it in the target container. Declaration public static void RegisterDelegate(this ITargetContainer targetContainer, Delegate factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Delegate declaredType Type <!-- .classchild --> RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) Creates a DelegateTarget<TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<TResult>(this ITargetContainer targetContainer, Func<TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <TResult> declaredType Type Type Parameters Name Description TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) T15 The type of the 15th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) Creates a DelegateTarget<T, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T, TResult>(this ITargetContainer targetContainer, Func<T, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T, TResult> declaredType Type Type Parameters Name Description T The type of the 1st delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) Creates a DelegateTarget<T1, T2, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, TResult>(this ITargetContainer targetContainer, Func<T1, T2, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild --> RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> factory, Type declaredType = null) Parameters Name Type Description targetContainer ITargetContainer factory Func <T1, T2, T3, T4, T5, T6, T7, T8, TResult> declaredType Type Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTargetDelegateExtensions.html": {
    "href": "rezolver-api/Rezolver.DelegateTargetDelegateExtensions.html",
    "title": "Class DelegateTargetDelegateExtensions",
    "keywords": "Class DelegateTargetDelegateExtensions Extension methods for the Delegate type to aid in the construction of DelegateTarget . Inheritance Object DelegateTargetDelegateExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class DelegateTargetDelegateExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods AsDelegateTarget(Delegate, Type) Creates a DelegateTarget from the factory which can be registered in an ITargetContainer to resolve an instance of a type compatible with the delegate's return type an, optionally, with the declaredType Declaration public static DelegateTarget AsDelegateTarget(this Delegate factory, Type declaredType = null) Parameters Name Type Description factory Delegate The delegate to be used as a factory. declaredType Type Optional type to set as the DeclaredType of the target, if not passed, then the return type of the delegate will be used. Returns Type Description DelegateTarget <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTargetExtensions.html": {
    "href": "rezolver-api/Rezolver.DelegateTargetExtensions.html",
    "title": "Class DelegateTargetExtensions",
    "keywords": "Class DelegateTargetExtensions Extension methods for creating DelegateTarget<TResult> instances. Inheritance Object DelegateTargetExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class DelegateTargetExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods AsDelegateTarget<T>(Func<T>, Type) Creates a DelegateTarget<TResult> using the delegate as the factory method to be executed. Declaration public static DelegateTarget<T> AsDelegateTarget<T>(this Func<T> factory, Type declaredType = null) Parameters Name Type Description factory Func <T> The factory. declaredType Type Optional override for the type exposed by the DelegateTarget<TResult> . See the DelegateTarget(Func<TResult>, Type) constructor for more. Returns Type Description DelegateTarget <T> Type Parameters Name Description T The type returned by the factory when executed. <!-- .classchild --> AsDelegateTarget<T>(Func<RezolveContext, T>, Type) Creates a DelegateTarget<TResult> using the delegate as the factory method to be executed. Declaration public static DelegateTarget<T> AsDelegateTarget<T>(this Func<RezolveContext, T> factory, Type declaredType = null) Parameters Name Type Description factory Func < RezolveContext , T> The factory. declaredType Type Optional override for the type exposed by the DelegateTarget<TResult> . See the Rezolver.DelegateTarget`1.#ctor(System.Func{Rezolver.RezolveContext,`0},System.Type) constructor for more. Returns Type Description DelegateTarget <T> Type Parameters Name Description T The type returned by the factory when executed. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget`1.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget`1.html",
    "title": "Class DelegateTarget<T>",
    "keywords": "Class DelegateTarget<T> Implements IRezolveTarget using factory function delegates. Inheritance Object TargetBase DelegateTarget<T> Inherited Members SuppressScopeTracking UseFallback CreateScopeTrackingExpression(CompileContext, Expression) CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) CreateScopeSelectionExpression(CompileContext, Expression) SupportsType(Type) CreateExpression(CompileContext) ToString() Equals(Object) Equals(Object, Object) ReferenceEquals(Object, Object) GetHashCode() GetType() MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T> : TargetBase, ITarget Type Parameters Name Description T <!-- <hr class=\"typeSectionDivider\" /> --> Constructors DelegateTarget(Func<T>, Type) Declaration public DelegateTarget(Func<T> factory, Type declaredType = null) Parameters Name Type Description factory Func <T> declaredType Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateExpressionBase(CompileContext) Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides CreateExpressionBase(CompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.EnumerableTargetBuilderExtensions.html": {
    "href": "rezolver-api/Rezolver.EnumerableTargetBuilderExtensions.html",
    "title": "Class EnumerableTargetBuilderExtensions",
    "keywords": "Class EnumerableTargetBuilderExtensions Inheritance Object EnumerableTargetBuilderExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class EnumerableTargetBuilderExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods EnableEnumerableResolving(TargetContainer) Declaration public static void EnableEnumerableResolving(this TargetContainer builder) Parameters Name Type Description builder TargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ExceptionResources.html": {
    "href": "rezolver-api/Rezolver.ExceptionResources.html",
    "title": "Class ExceptionResources",
    "keywords": "Class ExceptionResources A strongly-typed resource class, for looking up localized strings, etc. Inheritance Object ExceptionResources Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ExceptionResources <!-- <hr class=\"typeSectionDivider\" /> --> Properties Culture Overrides the current thread's CurrentUICulture property for all resource lookups using this strongly typed resource class. Declaration public static CultureInfo Culture { get; set; } Property Value Type Description CultureInfo <!-- .classchild --> CyclicDependencyDetectedInTargetFormat Looks up a localized string similar to Cyclic dependency detected in targets - current target of type {0} with DeclaredType of {1} has tried to include itself in its expression.. Declaration public static string CyclicDependencyDetectedInTargetFormat { get; } Property Value Type Description String <!-- .classchild --> DeclaredTypeIsNotCompatible_Format Looks up a localized string similar to The declared type {0} is not compatible with the type {1}. Declaration public static string DeclaredTypeIsNotCompatible_Format { get; } Property Value Type Description String <!-- .classchild --> LambdaBodyIsNotNewExpressionFormat Looks up a localized string similar to The body of the lambda \"{0}\" is not a NewExpression. Declaration public static string LambdaBodyIsNotNewExpressionFormat { get; } Property Value Type Description String <!-- .classchild --> LambdaBodyNewExpressionIsWrongTypeFormat Looks up a localized string similar to The expression {0} does not represent calling a constructor of the type {1}. Declaration public static string LambdaBodyNewExpressionIsWrongTypeFormat { get; } Property Value Type Description String <!-- .classchild --> MoreThanOneBestConstructorFormat Looks up a localized string similar to More than one constructor for {0} found that could be bound from the current context. Possible candidates: {1}. Declaration public static string MoreThanOneBestConstructorFormat { get; } Property Value Type Description String <!-- .classchild --> MoreThanOneConstructorFormat Looks up a localized string similar to More than one constructor for {0} qualifies as a target for Auto construction. Declaration public static string MoreThanOneConstructorFormat { get; } Property Value Type Description String <!-- .classchild --> MoreThanOneObjectFoundInScope Looks up a localized string similar to More than one matching object was found in the scope. Declaration public static string MoreThanOneObjectFoundInScope { get; } Property Value Type Description String <!-- .classchild --> NoApplicableConstructorForContextFormat Looks up a localized string similar to No constructor found on the type {0} which can be satisfied by the CompileContext. Declaration public static string NoApplicableConstructorForContextFormat { get; } Property Value Type Description String <!-- .classchild --> NoConstructorSetOnNewExpression Looks up a localized string similar to No constructor has been set on the NewExpression - this is not allowed.. Declaration public static string NoConstructorSetOnNewExpression { get; } Property Value Type Description String <!-- .classchild --> NoDefaultOrAllOptionalConstructorFormat Looks up a localized string similar to The type {0} has no default constructor, nor any constructors where all the parameters are optional.. Declaration public static string NoDefaultOrAllOptionalConstructorFormat { get; } Property Value Type Description String <!-- .classchild --> NoPublicConstructorsDefinedFormat Looks up a localized string similar to No public constructors declared on the type {0}. Declaration public static string NoPublicConstructorsDefinedFormat { get; } Property Value Type Description String <!-- .classchild --> NotRuntimeMethod Looks up a localized string similar to This method is not to be called at run-time - it is only used for static expression analysis in creating IRezolveTargets for an IRezolveBuilder. Declaration public static string NotRuntimeMethod { get; } Property Value Type Description String <!-- .classchild --> PathIsAtEnd Looks up a localized string similar to path's Next must not be null - pass path as null once it's reached the last item. Declaration public static string PathIsAtEnd { get; } Property Value Type Description String <!-- .classchild --> PathIsInvalid Looks up a localized string similar to The path {0} is invalid. All path steps must contain non-whitespace characters and be at least one character in length. Declaration public static string PathIsInvalid { get; } Property Value Type Description String <!-- .classchild --> ResourceManager Returns the cached ResourceManager instance used by this class. Declaration public static ResourceManager ResourceManager { get; } Property Value Type Description ResourceManager <!-- .classchild --> RezolverTargetEntryHasBeenRealised Looks up a localized string similar to No more targets can be added to this entry. Declaration public static string RezolverTargetEntryHasBeenRealised { get; } Property Value Type Description String <!-- .classchild --> ScopedSingletonRequiresAScope Looks up a localized string similar to A lifetime scope is required for a scoped singleton. Declaration public static string ScopedSingletonRequiresAScope { get; } Property Value Type Description String <!-- .classchild --> TargetDoesntSupportType_Format Looks up a localized string similar to The target does not support the type {0}. Declaration public static string TargetDoesntSupportType_Format { get; } Property Value Type Description String <!-- .classchild --> TargetIsNullButTypeIsNotNullable_Format Looks up a localized string similar to The type {0} is not a nullable type. Declaration public static string TargetIsNullButTypeIsNotNullable_Format { get; } Property Value Type Description String <!-- .classchild --> TargetReturnedNullExpressionFormat Looks up a localized string similar to Target of type {0} returned a null expression for context {1} - implementation is invalid, targets must never return a null expression.. Declaration public static string TargetReturnedNullExpressionFormat { get; } Property Value Type Description String <!-- .classchild --> TypeIsAlreadyRegistered Looks up a localized string similar to The type {0} has already been registered. Declaration public static string TypeIsAlreadyRegistered { get; } Property Value Type Description String <!-- .classchild --> UnableToResolveTypeFromBuilderFormat Looks up a localized string similar to Unable to resolve type {0} from builder. Declaration public static string UnableToResolveTypeFromBuilderFormat { get; } Property Value Type Description String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ExpressionHelper.html": {
    "href": "rezolver-api/Rezolver.ExpressionHelper.html",
    "title": "Class ExpressionHelper",
    "keywords": "Class ExpressionHelper This static class contains methods and properties to aid in building expressions in an implementation of the CreateExpression(CompileContext) method. Inheritance Object ExpressionHelper Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ExpressionHelper <!-- <hr class=\"typeSectionDivider\" /> --> Fields DynamicRezolverParam This parameter expression is to be used by all targets and rezolvers in this library by default to perform late binding to a container provided at run time when a caller is trying to resolve something through code built from a target. Declaration public static readonly ParameterExpression DynamicRezolverParam Field Value Type Description ParameterExpression <!-- .classchild --> RezolveContextParameterExpression The default RezolveContext parameter expression to be used during code generation in an implementation of CreateExpression(CompileContext) Declaration public static readonly ParameterExpression RezolveContextParameterExpression Field Value Type Description ParameterExpression <!-- .classchild --> Scope_GetOrAddGenericMethod A MethodInfo object representing the generic definition Declaration public static readonly MethodInfo Scope_GetOrAddGenericMethod Field Value Type Description MethodInfo <!-- .classchild --> Scope_GetScopeRootMethod A MethodInfo object representing the GetScopeRoot(IScopedContainer) method - to aid in code generation where the target scope for tracking an object is the root scope, not the current scope. Declaration public static readonly MethodInfo Scope_GetScopeRootMethod Field Value Type Description MethodInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetLambdaBodyForTarget(ITarget, CompileContext) Provides a standard way to create the method body for a lambda that, when compiled (with the correct signature) will execute code that will produce the object represented by the target. Some rewriting optimisations are applied to the expression tree, the resulting expression tree will be able to be compiled straight to a method if passed into a LambdaExpression. Declaration public static Expression GetLambdaBodyForTarget(ITarget target, CompileContext context) Parameters Name Type Description target ITarget context CompileContext Returns Type Description Expression Remarks Note that the TargetCompilerBase abstract class uses this method to get the expression tree for a target that is to be compiled, and the TargetDelegateCompiler uses that expression tree as-is. Note, however, that some compilers might override this behaviour, or rewrite the generated expression more - in which case this code wouldn't be suitable for those compilers. This method, therefore, is exposed to provide a surefire way to generate a whole lambda that can be compiled into an in-memory delegate for re-use in other targets and scenarios. The SingletonTarget, for example, uses this method during its own CreateExpression(CompileContext) implementation to get a nested lambda for the wrapped target, so that it can dynamically construct a Lazy whose factory method is the code we'd normally produce for a target. <!-- .classchild --> GetResolveLambdaForTarget(ITarget, CompileContext) First gets the lambda body using GetLambdaBodyForTarget(ITarget, CompileContext) , then passes that as the body for the returned expression, using also the RezolveContextExpression from the context parameter as the expression for the RezolveContext that's passed to the compiled method when invoked. Declaration public static Expression<Func<RezolveContext, object>> GetResolveLambdaForTarget(ITarget target, CompileContext context) Parameters Name Type Description target ITarget context CompileContext Returns Type Description Expression < Func < RezolveContext , Object >> <!-- .classchild --> Make_Scope_GetOrAddCallExpression(CompileContext, Type, LambdaExpression, Expression) Makes an expression which represents calling the GetOrAdd<T>(IScopedContainer, RezolveContext, Func<RezolveContext, T>, Boolean) function for the passed objectType . Used automatically by the built-in scope tracking behaviour, but can also be used by your own custom target if you want to take control of its scope tracking behaviour. Declaration public static Expression Make_Scope_GetOrAddCallExpression(CompileContext context, Type objectType, LambdaExpression factoryExpression, Expression iDisposableOnly = null) Parameters Name Type Description context CompileContext The compile context. objectType Type Type of the object to be stored or retrieved. factoryExpression LambdaExpression Lambda which should be executed to obtain a new instance if a matching object is not already in scope. iDisposableOnly Expression Expected to be a boolean expression indicating whether only IDisposables should be tracked in the scope. The default (if not provided) then will be set to 'true'. Returns Type Description Expression <!-- .classchild --> Make_Scope_GetScopeRootCallExpression(CompileContext) Returns an expression that represents a call to the Scope_GetScopeRootMethod extension method on the scope of the RezolveContext passed to a compiled object target. Declaration public static Expression Make_Scope_GetScopeRootCallExpression(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Microsoft.Extensions.DependencyInjection.RezolverRegistration.html": {
    "href": "rezolver-api/Rezolver.Microsoft.Extensions.DependencyInjection.RezolverRegistration.html",
    "title": "Class RezolverRegistration",
    "keywords": "Class RezolverRegistration Inheritance Object RezolverRegistration Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Microsoft.Extensions.DependencyInjection Assembly :cs.temp.dll.dll Syntax public static class RezolverRegistration <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateDefaultContainer(ITargetContainer) Declaration public static IContainer CreateDefaultContainer(ITargetContainer targetContainer) Parameters Name Type Description targetContainer ITargetContainer Returns Type Description IContainer <!-- .classchild --> Populate(ContainerBase, IServiceCollection) Declaration public static IServiceProvider Populate(this ContainerBase rezolver, IServiceCollection services) Parameters Name Type Description rezolver ContainerBase services IServiceCollection Returns Type Description IServiceProvider <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Microsoft.Extensions.DependencyInjection.html": {
    "href": "rezolver-api/Rezolver.Microsoft.Extensions.DependencyInjection.html",
    "title": "Namespace Rezolver.Microsoft.Extensions.DependencyInjection",
    "keywords": "Namespace Rezolver.Microsoft.Extensions.DependencyInjection Classes RezolverRegistration"
  },
  "rezolver-api/Rezolver.MSDIITargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.MSDIITargetContainerExtensions.html",
    "title": "Class MSDIITargetContainerExtensions",
    "keywords": "Class MSDIITargetContainerExtensions Inheritance Object MSDIITargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class MSDIITargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods Populate(ITargetContainer, IServiceCollection) Declaration public static void Populate(this ITargetContainer targets, IServiceCollection services) Parameters Name Type Description targets ITargetContainer services IServiceCollection <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.MultipleTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.MultipleTargetContainerExtensions.html",
    "title": "Class MultipleTargetContainerExtensions",
    "keywords": "Class MultipleTargetContainerExtensions Extensions for registering multiple targets individually and against the same type Inheritance Object MultipleTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class MultipleTargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterAll(ITargetContainer, ITarget[]) Performs the same operations as RegisterAll(ITargetContainer, IEnumerable<ITarget>) except via a variable number of ITarget arguments. Declaration public static void RegisterAll(this ITargetContainer targetContainer, params ITarget[] targets) Parameters Name Type Description targetContainer ITargetContainer The target container on which the registrations are to be performed. targets ITarget [] The targets to be registered. <!-- .classchild --> RegisterAll(ITargetContainer, IEnumerable<ITarget>) Batch-registers multiple targets against their DeclaredType . This is the same as calling Register(ITarget, Type) for each of the targets , except the type cannot be overriden from the target's DeclaredType. Declaration public static void RegisterAll(this ITargetContainer targetContainer, IEnumerable<ITarget> targets) Parameters Name Type Description targetContainer ITargetContainer The target container on which the registrations are to be performed. targets IEnumerable < ITarget > The targets to be registered <!-- .classchild --> RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) Called to register multiple targets against the same type. It is the same as calling Register(ITarget, Type) multiple times with the different targets. Declaration public static void RegisterMultiple(this ITargetContainer targetContainer, IEnumerable<ITarget> targets, Type commonServiceType = null) Parameters Name Type Description targetContainer ITargetContainer The container on which the registration is to be performed. targets IEnumerable < ITarget > The targets to be registered - all must support a common service type (potentially passed in the commonServiceType argument. commonServiceType Type Optional - if provided, then this will be used as the common service type for registration. If not provided, then the DeclaredType of the first target will be used. Remarks If the container has the capability to handle enumerables, then each target will be returned when an IEnumerable of the common service type is requested. This is an opt-in behaviour in Rezolver - implemented by the Rezolver.EnumerableTargetContainer and can be added to a target container with the extension method EnableEnumerableResolving(TargetContainer) . Note that default behaviour of TargetContainer is for this to be enabled. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ObjectTarget.html": {
    "href": "rezolver-api/Rezolver.ObjectTarget.html",
    "title": "Class ObjectTarget",
    "keywords": "Class ObjectTarget Implements IRezolveTarget by wrapping a single instance that's already been constructed. By default, scope tracking is disabled (since the caller owns the object, not the Rezolver framework)). If it's enabled, then scope tracking behaves exactly the same as SingletonTarget . Inheritance Object TargetBase ObjectTarget Inherited Members TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ObjectTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ObjectTarget(Object, Type, Boolean) Creates a new instance of the ObjectTarget class. Declaration public ObjectTarget(object obj, Type declaredType = null, bool suppressScopeTracking = true) Parameters Name Type Description obj Object The object to be returned by this target when resolved. declaredType Type Optional. The declared type of this target, if different from the absolute type of the obj suppressScopeTracking Boolean Optional. Controls whether the instance will be added to a scope when resolved. If true (the default) then no scope tracking is performed, and you will have to dispose of the object, if disposable. If false, then the object will be tracked by the ROOT scope of the first scope the object is resolved from. Remarks Please note - if you enable scope tracking, but the object is never resolved, then the object will not be disposed and you will need to ensure you dispose of it. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> SuppressScopeTracking Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides TargetBase.SuppressScopeTracking <!-- .classchild --> Value Gets the value that will be exposed by expressions built by this instance. Declaration public object Value { get; } Property Value Type Description Object The value. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateExpressionBase(CompileContext) Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides TargetBase.CreateExpressionBase(CompileContext) <!-- .classchild --> CreateScopeSelectionExpression(CompileContext, Expression) Declaration protected override Expression CreateScopeSelectionExpression(CompileContext context, Expression expression) Parameters Name Type Description context CompileContext expression Expression Returns Type Description Expression Overrides TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ObjectTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.ObjectTargetContainerExtensions.html",
    "title": "Class ObjectTargetContainerExtensions",
    "keywords": "Class ObjectTargetContainerExtensions Extensions for ITargetContainer relating to registering concrete instances via the ObjectTarget target. Inheritance Object ObjectTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ObjectTargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterObject<T>(ITargetContainer, T, Type, Boolean) Registers a single instance (already created) to be used when resolving a particular service type. Declaration public static void RegisterObject<T>(this ITargetContainer targetContainer, T obj, Type serviceType = null, bool suppressScopeTracking = true) Parameters Name Type Description targetContainer ITargetContainer The target container which will receive the registration. obj T The instance that will be resolved when the service type is requested. serviceType Type The service type against which this object is to be registered, if different from T . suppressScopeTracking Boolean If true (the default), then the object will not be tracked and disposed of by any IScopedContainer that might be active when the object is first resolved. In theory this should always be left as true because otherwise the object will not be usable after the first scope its contained within is disposed. Type Parameters Name Description T Type of the object - will be used as the service type for registration if serviceType is not provied. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ObjectTargetExtensions.html": {
    "href": "rezolver-api/Rezolver.ObjectTargetExtensions.html",
    "title": "Class ObjectTargetExtensions",
    "keywords": "Class ObjectTargetExtensions Extension method(s) Inheritance Object ObjectTargetExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ObjectTargetExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods AsObjectTarget<T>(T, Type, Boolean) Wraps the instance on which this is invoked as an ObjectTarget that can be registered into an ITargetContainer . The parameters are direct analogues of the parameters on the type's constructor (see ObjectTarget(Object, Type, Boolean) ). Declaration public static ObjectTarget AsObjectTarget<T>(this T obj, Type declaredType = null, bool suppressScopeTracking = true) Parameters Name Type Description obj T declaredType Type suppressScopeTracking Boolean Returns Type Description ObjectTarget A new object target that wraps the object obj . Type Parameters Name Description T <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.OptionalParameterTarget.html": {
    "href": "rezolver-api/Rezolver.OptionalParameterTarget.html",
    "title": "Class OptionalParameterTarget",
    "keywords": "Class OptionalParameterTarget Used specifically when binding arguments to method parameters when a parameter is optional and its default value is to be used when binding to it. Inheritance Object TargetBase OptionalParameterTarget Inherited Members TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class OptionalParameterTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors OptionalParameterTarget(ParameterInfo) Constructs a new instance of the OptionalParameterTarget class. Declaration public OptionalParameterTarget(ParameterInfo methodParameter) Parameters Name Type Description methodParameter ParameterInfo Required - parameter to which this target will be bound. Its property must be true . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> MethodParameter Declaration public ParameterInfo MethodParameter { get; } Property Value Type Description ParameterInfo <!-- .classchild --> SuppressScopeTracking Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides TargetBase.SuppressScopeTracking <!-- .classchild --> UseFallback Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides TargetBase.UseFallback <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateExpressionBase(CompileContext) Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides TargetBase.CreateExpressionBase(CompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.OverridingContainer.html": {
    "href": "rezolver-api/Rezolver.OverridingContainer.html",
    "title": "Class OverridingContainer",
    "keywords": "Class OverridingContainer An IContainer which can override the resolve operations of another. This is useful when you have a core application-wide container, with some objects being customised based on some ambient information, e.g. configuration, MVC Area/Controller, Brand (in a multi-tenant application for example) or more. The scoping version of this is called OverridingScopedContainer . Inheritance Object ContainerBase CachingContainerBase Container OverridingContainer Inherited Members CachingContainerBase.GetCompiledRezolveTarget(RezolveContext) ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Compiler ContainerBase.Targets ContainerBase.Resolve(RezolveContext) ContainerBase.TryResolve(RezolveContext, Object) ContainerBase.CreateLifetimeScope() ContainerBase.FetchCompiled(RezolveContext) Rezolver.ContainerBase.System.IServiceProvider.GetService(System.Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.Fetch(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.FetchAll(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer, System.Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class OverridingContainer : Container, IContainer, IServiceProvider, ITargetContainer <!-- <hr class=\"typeSectionDivider\" /> --> Constructors OverridingContainer(IContainer, ITargetContainer, ITargetCompiler) Declaration public OverridingContainer(IContainer inner, ITargetContainer builder = null, ITargetCompiler compiler = null) Parameters Name Type Description inner IContainer Required. The inner container that this one combines with. Any dependencies not served by the new combined container's own registry will be sought from this container. builder ITargetContainer Optional. A specific builder to be used for this container's own registrations. compiler ITargetCompiler Optional. A compiler to be used to create ICompiledTarget instances from this container's registrations. If this is not provided, then the default is used ( Default ) <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CanResolve(RezolveContext) Called to determine if this container is able to resolve the type specified in the passed context . Declaration public override bool CanResolve(RezolveContext context) Parameters Name Type Description context RezolveContext Required. The RezolveContext . Returns Type Description Boolean Overrides ContainerBase.CanResolve(RezolveContext) <!-- .classchild --> GetFallbackCompiledRezolveTarget(RezolveContext) Overrides the base implementation to pass the lookup for an ITarget to the inner container - this is how dependency chaining from this container to the inner container is achieved. Declaration protected override ICompiledTarget GetFallbackCompiledRezolveTarget(RezolveContext context) Parameters Name Type Description context RezolveContext Required. The RezolveContext . Returns Type Description ICompiledTarget Overrides ContainerBase.GetFallbackCompiledRezolveTarget(RezolveContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.OverridingScopedContainer.html": {
    "href": "rezolver-api/Rezolver.OverridingScopedContainer.html",
    "title": "Class OverridingScopedContainer",
    "keywords": "Class OverridingScopedContainer Inheritance Object ContainerBase CachingContainerBase Container OverridingContainer OverridingScopedContainer Inherited Members OverridingContainer.CanResolve(RezolveContext) OverridingContainer.GetFallbackCompiledRezolveTarget(RezolveContext) CachingContainerBase.GetCompiledRezolveTarget(RezolveContext) ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Compiler ContainerBase.Targets ContainerBase.Resolve(RezolveContext) ContainerBase.TryResolve(RezolveContext, Object) ContainerBase.CreateLifetimeScope() ContainerBase.FetchCompiled(RezolveContext) Rezolver.ContainerBase.System.IServiceProvider.GetService(System.Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.Fetch(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.FetchAll(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer, System.Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class OverridingScopedContainer : OverridingContainer, ITargetContainer, IScopedContainer, IContainer, IServiceProvider, IDisposable <!-- <hr class=\"typeSectionDivider\" /> --> Constructors OverridingScopedContainer(IScopedContainer, IContainer, ITargetContainer, ITargetCompiler) Constructs a new instance of the CombinedLifetimeScopeRezolver class. Declaration public OverridingScopedContainer(IScopedContainer parentScope, IContainer inner = null, ITargetContainer builder = null, ITargetCompiler compiler = null) Parameters Name Type Description parentScope IScopedContainer Can be null, but if it is, then inner must be supplied inner IContainer Can be null, but if it is, then parentScope must be supplied builder ITargetContainer compiler ITargetCompiler <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties ParentScope Declaration public IScopedContainer ParentScope { get; } Property Value Type Description IScopedContainer Implements IScopedContainer.ParentScope <!-- .classchild --> TrackedObjects Declaration protected IEnumerable<object> TrackedObjects { get; } Property Value Type Description IEnumerable < Object > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods AddToScope(Object, RezolveContext) Declaration public virtual void AddToScope(object obj, RezolveContext context = null) Parameters Name Type Description obj Object context RezolveContext Implements IScopedContainer.AddToScope(Object, RezolveContext) <!-- .classchild --> Dispose() Declaration public void Dispose() Implements IDisposable.Dispose() <!-- .classchild --> Dispose(Boolean) Declaration protected virtual void Dispose(bool disposing) Parameters Name Type Description disposing Boolean <!-- .classchild --> GetFromScope(RezolveContext) Declaration public virtual IEnumerable<object> GetFromScope(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description IEnumerable < Object > Implements IScopedContainer.GetFromScope(RezolveContext) <!-- .classchild --> OnDisposed() Declaration protected void OnDisposed() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Events Disposed Declaration public event EventHandler Disposed Event Type Type Description EventHandler Implements IScopedContainer.Disposed <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ParameterBinding.html": {
    "href": "rezolver-api/Rezolver.ParameterBinding.html",
    "title": "Class ParameterBinding",
    "keywords": "Class ParameterBinding Inheritance Object ParameterBinding Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ParameterBinding <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ParameterBinding(ParameterInfo, ITarget) Constructs a new instance of the ParameterBinding class. Declaration public ParameterBinding(ParameterInfo parameter, ITarget target = null) Parameters Name Type Description parameter ParameterInfo Required - the parameter being bound target ITarget Optional - the argument supplied for the parameter. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Fields None Represents an empty parameter bindings array. Declaration public static readonly ParameterBinding[] None Field Value Type Description ParameterBinding [] <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties IsValid Gets a boolean indicating whether the parameter binding is valid Ultimately, this returns true if Target is non-null. Declaration public bool IsValid { get; } Property Value Type Description Boolean <!-- .classchild --> Parameter The parameter to be bound Declaration public ParameterInfo Parameter { get; } Property Value Type Description ParameterInfo <!-- .classchild --> Target The initial target that was bound to this parameter. Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods BindMethod(MethodBase, IDictionary<String, ITarget>) Matches named targets in args to parameters on the passed method , creating default ParameterBinding s for any parameters for which named targets cannot be found. Declaration public static ParameterBinding[] BindMethod(MethodBase method, IDictionary<string, ITarget> args) Parameters Name Type Description method MethodBase args IDictionary < String , ITarget > Returns Type Description ParameterBinding [] <!-- .classchild --> BindOverload(MethodBase[], IDictionary<String, ITarget>, out MethodBase) Searches for a method in the methods collection whose parameters can be filled by the targets provided in the args dictionary, returning the parameter bindings, and passing out the resolved target method in resolvedMethod if found. Note - if no match can be found, or if more than one method could be bound, then an InvalidOperationException will occur. Declaration public static ParameterBinding[] BindOverload(MethodBase[] methods, IDictionary<string, ITarget> args, out MethodBase resolvedMethod) Parameters Name Type Description methods MethodBase [] The methods. args IDictionary < String , ITarget > The arguments. resolvedMethod MethodBase The resolved method. Returns Type Description ParameterBinding [] ParameterBinding[]. <!-- .classchild --> BindWithRezolvedArguments(MethodBase) Creates parameter bindings for each parameter in the passed method where each value will be resolved. For any optional parameters - their default values will be used as a fallback. Declaration public static ParameterBinding[] BindWithRezolvedArguments(MethodBase method) Parameters Name Type Description method MethodBase Returns Type Description ParameterBinding [] <!-- .classchild --> BindWithRezolvedOrOptionalDefault(MethodBase, CompileContext) This is a compile-time helper method which produces a binding for each parameter where arguments that can be resolved from the passed context will be bound with RezolvedTarget s, and those which cannot, but which are optional, will be bound with OptionalParameterTarget s. If the parameter is not optional, and no target can be resolved, then an invalid binding will be returned for that parameter. Declaration public static ParameterBinding[] BindWithRezolvedOrOptionalDefault(MethodBase method, CompileContext context) Parameters Name Type Description method MethodBase Required - the method whose parameters are to be bound. context CompileContext Required - the current compile context which will be used to test whether arguments can be resolved at compile time. If they can, then the associated parameter will be bound with a RezolvedTarget . Returns Type Description ParameterBinding [] <!-- .classchild --> CreateExpression(CompileContext) Helper method for getting the expression from the Target for the Parameter 's . Takes care of setting the correct TargetType in a new context built from the context you pass. Declaration public Expression CreateExpression(CompileContext context) Parameters Name Type Description context CompileContext The current context for the object being built whose method or constructor parameter is being bound. Returns Type Description Expression The expression built by Target for the Parameter 's . <!-- .classchild --> Resolve(CompileContext) Fetch the target that would be bound to this parameter given the passed CompileContext Declaration public virtual ITarget Resolve(CompileContext context) Parameters Name Type Description context CompileContext The current compile context - a new one is created for the Parameter type Returns Type Description ITarget The target that should be used for the parameter, or null if no target could be found. Note that if the returned target's UseFallback property is set to true , then it means either the parameter's default value is being used, or that the target fetched from the target container in the context is a stub (e.g. empty enumerable) Remarks During compilation - you should not use the target returned by this function as a direct part of your expression tree - you should <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.PropertyOrFieldBinding.html": {
    "href": "rezolver-api/Rezolver.PropertyOrFieldBinding.html",
    "title": "Class PropertyOrFieldBinding",
    "keywords": "Class PropertyOrFieldBinding Inheritance Object PropertyOrFieldBinding Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class PropertyOrFieldBinding <!-- <hr class=\"typeSectionDivider\" /> --> Constructors PropertyOrFieldBinding(MemberInfo, ITarget) Declaration public PropertyOrFieldBinding(MemberInfo member, ITarget target) Parameters Name Type Description member MemberInfo target ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Fields None Declaration public static readonly PropertyOrFieldBinding[] None Field Value Type Description PropertyOrFieldBinding [] <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Member Declaration public MemberInfo Member { get; } Property Value Type Description MemberInfo <!-- .classchild --> MemberType Declaration public Type MemberType { get; } Property Value Type Description Type <!-- .classchild --> Target Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateMemberBinding(CompileContext) Method for creating a Linq Expression MemberBinding object for the Member , to the expression produced by the Target object's CreateExpression(CompileContext) method. Declaration public MemberBinding CreateMemberBinding(CompileContext context) Parameters Name Type Description context CompileContext The CompileContext under which the generated expression will be compiled. Returns Type Description MemberBinding <!-- .classchild --> DeriveAutoPropertyBinding(Type, Boolean) Static factory method that creates bindings for all publicly writable instance properties (and, optionally, fields) of the given type. Each property/field is bound to a RezolvedTarget instance - meaning that, at runtime, values for those properties or fields will be resolved from the container by type. Declaration public static PropertyOrFieldBinding[] DeriveAutoPropertyBinding(Type type, bool includeFields = false) Parameters Name Type Description type Type The type whose properties (and, optionally, publicly writable fields) are to be bound. includeFields Boolean If true, then publicly writable fields will be bound. Returns Type Description PropertyOrFieldBinding [] <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RegisterTypeDictionaryExtensions.html": {
    "href": "rezolver-api/Rezolver.RegisterTypeDictionaryExtensions.html",
    "title": "Class RegisterTypeDictionaryExtensions",
    "keywords": "Class RegisterTypeDictionaryExtensions Extensions for ITargetContainer to provide shortcuts for the simplest cases of registering ConstructorTarget and GenericConstructorTarget targets. Inheritance Object RegisterTypeDictionaryExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class RegisterTypeDictionaryExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Registers an instance of objectType (optionally for the service type serviceType ) to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(RezolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IPropertyBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The target container on which the registration is to be performed. objectType Type The type of the object that is to be constructed when resolved. serviceType Type Optional. The type against which the registration will be performed, if different from objectType . objectType must be compatible with this type, if it's provided. propertyBindingBehaviour IPropertyBindingBehaviour Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto(Type, IPropertyBindingBehaviour) or Auto(Type, IPropertyBindingBehaviour) static methods and then registering it against the type serviceType or objectType . <!-- .classchild --> RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) Registers an instance of TObject to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(RezolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IPropertyBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType<TObject>(this ITargetContainer targetContainer, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The target container on which the registration is to be performed. propertyBindingBehaviour IPropertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto<T>(IPropertyBindingBehaviour) or Auto<TGeneric>(IPropertyBindingBehaviour) static methods and then registering it. <!-- .classchild --> RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Registers an instance of TObject for the service type TService to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(RezolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IPropertyBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType<TObject, TService>(this ITargetContainer targetContainer, IPropertyBindingBehaviour propertyBindingBehaviour = null)where TObject : TService Parameters Name Type Description targetContainer ITargetContainer The target container on which the registration is to be performed. propertyBindingBehaviour IPropertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. TService The type against which the registration will be performed. TObject must be compatible with this type. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto<T>(IPropertyBindingBehaviour) or Auto<TGeneric>(IPropertyBindingBehaviour) static methods and then registering it against the type TService . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolveContext.html": {
    "href": "rezolver-api/Rezolver.RezolveContext.html",
    "title": "Class RezolveContext",
    "keywords": "Class RezolveContext Context of a call to an IRezolver's Resolve method. The container is included in the context to allow code generated from CreateExpression(CompileContext) to refer back to the container. This also allows us to retarget compiled targets at other containers (e.g. OverridingContainer s that override existing registrations or define new ones). Inheritance Object RezolveContext Inherited Members Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolveContext : IEquatable<RezolveContext> <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RezolveContext(IContainer, Type) Declaration public RezolveContext(IContainer container, Type requestedType) Parameters Name Type Description container IContainer requestedType Type <!-- .classchild --> RezolveContext(IContainer, Type, IScopedContainer) Declaration public RezolveContext(IContainer container, Type requestedType, IScopedContainer scope) Parameters Name Type Description container IContainer requestedType Type scope IScopedContainer <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Fields EmptyContext Declaration public static readonly RezolveContext EmptyContext Field Value Type Description RezolveContext <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Container The container for this context. Declaration public IContainer Container { get; } Property Value Type Description IContainer <!-- .classchild --> RequestedType Declaration public Type RequestedType { get; } Property Value Type Description Type <!-- .classchild --> Scope Declaration public IScopedContainer Scope { get; } Property Value Type Description IScopedContainer <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateNew(IContainer) Declaration public RezolveContext CreateNew(IContainer container) Parameters Name Type Description container IContainer Returns Type Description RezolveContext <!-- .classchild --> CreateNew(IContainer, IScopedContainer) Declaration public RezolveContext CreateNew(IContainer container, IScopedContainer scope) Parameters Name Type Description container IContainer scope IScopedContainer Returns Type Description RezolveContext <!-- .classchild --> CreateNew(IContainer, Type) Declaration public RezolveContext CreateNew(IContainer container, Type requestedType) Parameters Name Type Description container IContainer requestedType Type Returns Type Description RezolveContext <!-- .classchild --> CreateNew(IContainer, Type, IScopedContainer) Declaration public RezolveContext CreateNew(IContainer container, Type requestedType, IScopedContainer scope) Parameters Name Type Description container IContainer requestedType Type scope IScopedContainer Returns Type Description RezolveContext <!-- .classchild --> CreateNew(IScopedContainer) Declaration public RezolveContext CreateNew(IScopedContainer scope) Parameters Name Type Description scope IScopedContainer Returns Type Description RezolveContext <!-- .classchild --> CreateNew(Type) Returns a clone of this context, but replaces the type, establishing the root context relationship also, either by inheriting this one's root context, or setting this as the root context. Declaration public RezolveContext CreateNew(Type requestedType) Parameters Name Type Description requestedType Type Returns Type Description RezolveContext <!-- .classchild --> CreateNew(Type, IScopedContainer) Declaration public RezolveContext CreateNew(Type requestedType, IScopedContainer scope) Parameters Name Type Description requestedType Type scope IScopedContainer Returns Type Description RezolveContext <!-- .classchild --> Equals(RezolveContext) Declaration public virtual bool Equals(RezolveContext other) Parameters Name Type Description other RezolveContext Returns Type Description Boolean Implements IEquatable<RezolveContext>.Equals(RezolveContext) <!-- .classchild --> Equals(Object) Declaration public override bool Equals(object obj) Parameters Name Type Description obj Object Returns Type Description Boolean Overrides Object.Equals(Object) <!-- .classchild --> GetHashCode() Declaration public override int GetHashCode() Returns Type Description Int32 Overrides Object.GetHashCode() <!-- .classchild --> ToString() Declaration public override string ToString() Returns Type Description String Overrides Object.ToString() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Operators Equality(RezolveContext, RezolveContext) Declaration public static bool operator ==(RezolveContext left, RezolveContext right) Parameters Name Type Description left RezolveContext right RezolveContext Returns Type Description Boolean <!-- .classchild --> Inequality(RezolveContext, RezolveContext) Declaration public static bool operator !=(RezolveContext left, RezolveContext right) Parameters Name Type Description left RezolveContext right RezolveContext Returns Type Description Boolean <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolveContextExpressionHelper.html": {
    "href": "rezolver-api/Rezolver.RezolveContextExpressionHelper.html",
    "title": "Class RezolveContextExpressionHelper",
    "keywords": "Class RezolveContextExpressionHelper Wraps a rezolve context for expression building - used principally in the ConstruuctorTarget class, but others are free to use it also. Inheritance Object RezolveContext RezolveContextExpressionHelper Inherited Members RezolveContext.EmptyContext RezolveContext.RequestedType RezolveContext.Container RezolveContext.Scope RezolveContext.ToString() RezolveContext.GetHashCode() RezolveContext.Equals(Object) RezolveContext.Equals(RezolveContext) RezolveContext.CreateNew(Type) RezolveContext.CreateNew(IContainer, Type) RezolveContext.CreateNew(Type, IScopedContainer) RezolveContext.CreateNew(IContainer, Type, IScopedContainer) RezolveContext.CreateNew(IContainer) RezolveContext.CreateNew(IScopedContainer) RezolveContext.CreateNew(IContainer, IScopedContainer) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolveContextExpressionHelper : RezolveContext, IEquatable<RezolveContext> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Resolve<T>() Declaration public T Resolve<T>() Returns Type Description T Type Parameters Name Description T <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolveContextPlaceholderExpression.html": {
    "href": "rezolver-api/Rezolver.RezolveContextPlaceholderExpression.html",
    "title": "Class RezolveContextPlaceholderExpression",
    "keywords": "Class RezolveContextPlaceholderExpression wraps an expression that represents reading or otherwise manipulating the RezolveContext that's passed into a Resolve call. Inheritance Object RezolveContextPlaceholderExpression Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolveContextPlaceholderExpression : Expression <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RezolveContextPlaceholderExpression(Expression) Declaration public RezolveContextPlaceholderExpression(Expression rezolveContextExpression) Parameters Name Type Description rezolveContextExpression Expression <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties CanReduce Declaration public override bool CanReduce { get; } Property Value Type Description Boolean <!-- .classchild --> NodeType Declaration public override ExpressionType NodeType { get; } Property Value Type Description ExpressionType <!-- .classchild --> RezolveContextExpression Declaration public Expression RezolveContextExpression { get; } Property Value Type Description Expression <!-- .classchild --> Type Declaration public override Type Type { get; } Property Value Type Description Type <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolvedTarget.html": {
    "href": "rezolver-api/Rezolver.RezolvedTarget.html",
    "title": "Class RezolvedTarget",
    "keywords": "Class RezolvedTarget Represents a target that is rezolved statically at compile time via the CompileContext , or dynamically (at 'resolve time') from the IContainer that is attached to the current RezolveContext when Resolve(RezolveContext) is called. This is the most common way that we bind constructor parameters, for example - i.e. 'I want an IService instance - go get it'. Inheritance Object TargetBase RezolvedTarget Inherited Members TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolvedTarget : TargetBase, ITarget Remarks The concept of compile-time resolving is what is typically implemented by most other IOC containers - at compile time, a target is resolved for a given type and, if found, its expression is used. If it's not found, then an error occurs. Rezolver does this, but goes further when the target can't be resolved at compile-time - in this case, it will emit a call back into the current RezolveContext 's IContainer to try and dynamically resolve the value that is required. Furthermore, the code it produces in either case also checks that the IContainer that is active at resolve-time is the same one (if applicable) that was active during compile-time. If it isn't, then it'll automatically defer resolving of the value to that container <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RezolvedTarget(Type, ITarget) Creates a new RezolvedTarget for the given type which will attempt to resolve a value at compile time and/or resolve-time and, if it can't, will either use the fallbackTarget or will throw an exception. Declaration public RezolvedTarget(Type type, ITarget fallbackTarget = null) Parameters Name Type Description type Type Required. The type to be resolved fallbackTarget ITarget Optional. The target to be used if the value cannot be resolved at either compile time or resolve-time. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType The type that will be resolved Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> FallbackTarget Gets the target that this RezolvedTarget will fallback to if a satisfactory target cannot be found at compile time. Declaration public ITarget FallbackTarget { get; } Property Value Type Description ITarget Remarks The UseFallback property is also used to determine whether this will be used. If the target resolved from the CompileContext has its UseFallback property set to true, and this property is non-null for this target, then this target will be used. Note also that extension containers such as OverridingContainer also have the ability to override the use of this fallback if they successfully resolve the type. <!-- .classchild --> SuppressScopeTracking Always returns true - we never wrap calls to a container inside a scope tracking expression. Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides TargetBase.SuppressScopeTracking <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateExpressionBase(CompileContext) Implementation of CreateExpressionBase(CompileContext) . Constructs the expression. Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides TargetBase.CreateExpressionBase(CompileContext) <!-- .classchild --> Resolve(CompileContext) Attempts to obtain the target that this RezolvedTarget resolves to for the given CompileContext . Used in the implementation of CreateExpressionBase(CompileContext) but also available to consumers to enable checking of RezolvedTargets to see if they'll succeed at compile time (useful when late-binding overloaded constructors, for example). Declaration public virtual ITarget Resolve(CompileContext context) Parameters Name Type Description context CompileContext The context from which a target is to be resolved. Returns Type Description ITarget The target resolved by this target - could be the FallbackTarget , could be null. Remarks The target that is returned depends both on the context passed and also whether a FallbackTarget has been provided to this target. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolveTargetAdapterExtensions.html": {
    "href": "rezolver-api/Rezolver.RezolveTargetAdapterExtensions.html",
    "title": "Class RezolveTargetAdapterExtensions",
    "keywords": "Class RezolveTargetAdapterExtensions Inheritance Object RezolveTargetAdapterExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class RezolveTargetAdapterExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateTarget<T>(ITargetAdapter, Expression<Func<T>>) Declaration public static ITarget CreateTarget<T>(this ITargetAdapter adapter, Expression<Func<T>> expression) Parameters Name Type Description adapter ITargetAdapter expression Expression < Func <T>> Returns Type Description ITarget Type Parameters Name Description T <!-- .classchild --> CreateTarget<T>(ITargetAdapter, Expression<Func<RezolveContextExpressionHelper, T>>) Declaration public static ITarget CreateTarget<T>(this ITargetAdapter adapter, Expression<Func<RezolveContextExpressionHelper, T>> expression) Parameters Name Type Description adapter ITargetAdapter expression Expression < Func < RezolveContextExpressionHelper , T>> Returns Type Description ITarget Type Parameters Name Description T <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolveTargetExpression.html": {
    "href": "rezolver-api/Rezolver.RezolveTargetExpression.html",
    "title": "Class RezolveTargetExpression",
    "keywords": "Class RezolveTargetExpression Makes it possible to mix expressions and targets. Inheritance Object RezolveTargetExpression Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolveTargetExpression : Expression <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RezolveTargetExpression(ITarget) Declaration public RezolveTargetExpression(ITarget target) Parameters Name Type Description target ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties CanReduce Declaration public override bool CanReduce { get; } Property Value Type Description Boolean <!-- .classchild --> NodeType Declaration public override ExpressionType NodeType { get; } Property Value Type Description ExpressionType <!-- .classchild --> Target Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> Type Declaration public override Type Type { get; } Property Value Type Description Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Reduce() Declaration public override Expression Reduce() Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ScopedContainer.html": {
    "href": "rezolver-api/Rezolver.ScopedContainer.html",
    "title": "Class ScopedContainer",
    "keywords": "Class ScopedContainer Extends the Container to implement lifetime scoping. If you want your root container to act as a lifetime scope, then you should use this class instead of using Container Inheritance Object ContainerBase CachingContainerBase Container ScopedContainer Inherited Members CachingContainerBase.GetCompiledRezolveTarget(RezolveContext) ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Compiler ContainerBase.Targets ContainerBase.Resolve(RezolveContext) ContainerBase.TryResolve(RezolveContext, Object) ContainerBase.CreateLifetimeScope() ContainerBase.FetchCompiled(RezolveContext) ContainerBase.CanResolve(RezolveContext) ContainerBase.GetFallbackCompiledRezolveTarget(RezolveContext) Rezolver.ContainerBase.System.IServiceProvider.GetService(System.Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.Fetch(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.FetchAll(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer, System.Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ScopedContainer : Container, ITargetContainer, IScopedContainer, IContainer, IServiceProvider, IDisposable Remarks The implementation of this class is very similar to the OverridingScopedContainer , The main difference being that that class can accept additional registrations independent of those in the container that it's created from, whereas with this class, it is the container. This type is therefore suited only for standalone Rezolvers for which you want lifetime scoping and disposable handling; whereas the OverridingScopedContainer is primarily suited for use as a child lifetime scope for another container. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ScopedContainer(ITargetContainer, ITargetCompiler) Declaration public ScopedContainer(ITargetContainer builder = null, ITargetCompiler compiler = null) Parameters Name Type Description builder ITargetContainer compiler ITargetCompiler <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties ParentScope Declaration public IScopedContainer ParentScope { get; } Property Value Type Description IScopedContainer Implements IScopedContainer.ParentScope <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods AddToScope(Object, RezolveContext) Declaration public virtual void AddToScope(object obj, RezolveContext context = null) Parameters Name Type Description obj Object context RezolveContext Implements IScopedContainer.AddToScope(Object, RezolveContext) <!-- .classchild --> Dispose() Declaration public void Dispose() Implements IDisposable.Dispose() <!-- .classchild --> Dispose(Boolean) Declaration protected virtual void Dispose(bool disposing) Parameters Name Type Description disposing Boolean <!-- .classchild --> GetFromScope(RezolveContext) Declaration public virtual IEnumerable<object> GetFromScope(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description IEnumerable < Object > Implements IScopedContainer.GetFromScope(RezolveContext) <!-- .classchild --> OnDisposed() Declaration protected void OnDisposed() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Events Disposed Declaration public event EventHandler Disposed Event Type Type Description EventHandler Implements IScopedContainer.Disposed <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ScopedTarget.html": {
    "href": "rezolver-api/Rezolver.ScopedTarget.html",
    "title": "Class ScopedTarget",
    "keywords": "Class ScopedTarget A target that produces a single instance of an object within a lifetime scope. Inheritance Object TargetBase ScopedTarget Inherited Members TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ScopedTarget : TargetBase, ITarget Remarks On its own, this target doesn't do anything - it's designed to wrap another target such that the code generated from the expression it produces is executed only once for each lifetime scope. Outside of that, the target generates wrapper code that forcibly caches the instance that is produced (whether it's IDiposable or not) into the current scope's cache (using AddToScope(Object, RezolveContext) ) and retrieves previous instances from that scope (using GetFromScope(RezolveContext) . <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ScopedTarget(ITarget) Declaration public ScopedTarget(ITarget innerTarget) Parameters Name Type Description innerTarget ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> SuppressScopeTracking Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides TargetBase.SuppressScopeTracking <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateExpressionBase(CompileContext) Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides TargetBase.CreateExpressionBase(CompileContext) <!-- .classchild --> SupportsType(Type) Declaration public override bool SupportsType(Type type) Parameters Name Type Description type Type Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ScopedTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.ScopedTargetContainerExtensions.html",
    "title": "Class ScopedTargetContainerExtensions",
    "keywords": "Class ScopedTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for registering constructor-injected types whose lifetimes are slaved to that of a parent IScopedContainer . All of the extension methods ultimately create a ScopedTarget Inheritance Object ScopedTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ScopedTargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterScoped(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Registers an explicitly instance of objectType (optionally for the service type serviceType ) to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(RezolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IPropertyBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterScoped(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The target container on which the registration is to be performed. objectType Type The type of the object that is to be constructed when resolved. serviceType Type Optional. The type against which the registration will be performed, if different from objectType . objectType must be compatible with this type, if it's provided. propertyBindingBehaviour IPropertyBindingBehaviour Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto(Type, IPropertyBindingBehaviour) or Auto(Type, IPropertyBindingBehaviour) static methods, wrapping it with a ScopedTarget and then registering it against the type serviceType or objectType . <!-- .classchild --> RegisterScoped<TObject>(ITargetContainer, IPropertyBindingBehaviour) Registers an explicitly scoped instance of TObject to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(RezolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IPropertyBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterScoped<TObject>(this ITargetContainer targetContainer, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The target container on which the registration is to be performed. propertyBindingBehaviour IPropertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto<T>(IPropertyBindingBehaviour) or Auto<TGeneric>(IPropertyBindingBehaviour) static methods, wrapping it with a ScopedTarget and registering it. <!-- .classchild --> RegisterScoped<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Registers an explicitly scoped instance of TObject for the service type TService to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(RezolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IPropertyBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterScoped<TObject, TService>(this ITargetContainer targetContainer, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targetContainer ITargetContainer The target container on which the registration is to be performed. propertyBindingBehaviour IPropertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. TService The type against which the registration will be performed. TObject must be compatible with this type. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto<T>(IPropertyBindingBehaviour) or Auto<TGeneric>(IPropertyBindingBehaviour) static methods, wrapping it with a ScopedTarget and then registering it against the type TService . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.SingletonTarget.html": {
    "href": "rezolver-api/Rezolver.SingletonTarget.html",
    "title": "Class SingletonTarget",
    "keywords": "Class SingletonTarget A target which applies the singleton pattern to any ITarget . The inner target is available from the InnerTarget property. Inheritance Object TargetBase SingletonTarget Inherited Members TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class SingletonTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors SingletonTarget(ITarget) Constructs a new instance of the SingletonTarget class. Declaration public SingletonTarget(ITarget innerTarget) Parameters Name Type Description innerTarget ITarget The target whose result (when compiled) is to be used as the singleton instance. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Override of DeclaredType - always returns the DeclaredType of the InnerTarget Declaration public override Type DeclaredType { get; } Property Value Type Description Type The type of the declared. Overrides TargetBase.DeclaredType <!-- .classchild --> InnerTarget Gets the inner target for this singleton. Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget <!-- .classchild --> SuppressScopeTracking Overrides the base class to ensure that automatic generation of the scope tracking code by TargetBase is disabled. For the singleton, it's important that the scope tracking call occurs within the lazy's callback. Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides TargetBase.SuppressScopeTracking <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateExpressionBase(CompileContext) Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides TargetBase.CreateExpressionBase(CompileContext) <!-- .classchild --> CreateScopeSelectionExpression(CompileContext, Expression) Declaration protected override Expression CreateScopeSelectionExpression(CompileContext context, Expression expression) Parameters Name Type Description context CompileContext expression Expression Returns Type Description Expression Overrides TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) <!-- .classchild --> SupportsType(Type) Called to check whether a target can create an expression that builds an instance of the given type . The base implementation always passes the call on to the InnerTarget Declaration public override bool SupportsType(Type type) Parameters Name Type Description type Type Required Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ObjectTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.ObjectTargetMetadata.html",
    "title": "Class ObjectTargetMetadata",
    "keywords": "Class ObjectTargetMetadata Standard implementation of ObjectTargetMetadataBase , to encapsulate object references that are to be baked into a container as targets. Inheritance Object RezolveTargetMetadataBase ObjectTargetMetadataBase ObjectTargetMetadata Inherited Members ObjectTargetMetadataBase.CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) RezolveTargetMetadataBase.Type RezolveTargetMetadataBase.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) RezolveTargetMetadataBase.Bind(ITypeReference[]) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ObjectTargetMetadata : ObjectTargetMetadataBase, IObjectTargetMetadata, IRezolveTargetMetadata Remarks This class accepts either an object reference that is to be returned when the target is resolved; or a delegate that will be called with the desired type (passed in from GetObject(Type) ). <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ObjectTargetMetadata(Func<Type, Object>) Initializes a new instance of the ObjectTargetMetadata class. Declaration public ObjectTargetMetadata(Func<Type, object> valueProvider) Parameters Name Type Description valueProvider Func < Type , Object > The value provider that will be called. <!-- .classchild --> ObjectTargetMetadata(Object) Initializes a new instance of the ObjectTargetMetadata class. Declaration public ObjectTargetMetadata(object obj) Parameters Name Type Description obj Object The object that is to be returned from GetObject(Type) . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides RezolveTargetMetadataBase.DeclaredType Implements IRezolveTargetMetadata.DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides RezolveTargetMetadataBase.BindBase(ITypeReference[]) <!-- .classchild --> GetObject(Type) Called to get the object that will be registered in the IRezolveTargetContainer to be returned when a caller requests one of its registered types. The method can construct an object anew everytime it is called, or it can always return the same instance; this behaviour is implementation-dependant. Declaration public override object GetObject(Type type) Parameters Name Type Description type Type The type of object that is desired. The implementation determines whether this parameter is required. If it is, and you pass null, then an ArgumentNullException will be thrown. If you pass an argument, the implementation is not bound to check or honour the type. Its purpose is to provide a hint only, not a guarantee that the object returned is compatible with the type. Returns Type Description Object An object. Note - if the operation returns null this is not an error. Overrides ObjectTargetMetadataBase.GetObject(Type) Implements IObjectTargetMetadata.GetObject(Type) Exceptions Type Condition System.ArgumentNullException type <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ObjectTargetMetadataBase.html": {
    "href": "rezolver-api/Rezolver.Configuration.ObjectTargetMetadataBase.html",
    "title": "Class ObjectTargetMetadataBase",
    "keywords": "Class ObjectTargetMetadataBase Abstract base class for metadata that builds an object target. Inheritance Object RezolveTargetMetadataBase ObjectTargetMetadataBase Inherited Members RezolveTargetMetadataBase.Type RezolveTargetMetadataBase.DeclaredType RezolveTargetMetadataBase.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) RezolveTargetMetadataBase.Bind(ITypeReference[]) RezolveTargetMetadataBase.BindBase(ITypeReference[]) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public abstract class ObjectTargetMetadataBase : RezolveTargetMetadataBase, IObjectTargetMetadata, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ObjectTargetMetadataBase() Declaration public ObjectTargetMetadataBase() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description ITarget Overrides RezolveTargetMetadataBase.CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild --> GetObject(Type) Called to get the object that will be registered in the IRezolveTargetContainer to be returned when a caller requests one of its registered types. The method can construct an object anew everytime it is called, or it can always return the same instance; this behaviour is implementation-dependant. Declaration public abstract object GetObject(Type type) Parameters Name Type Description type Type The type of object that is desired. The implementation determines whether this parameter is required. If it is, and you pass null, then an ArgumentNullException will be thrown. If you pass an argument, the implementation is not bound to check or honour the type. Its purpose is to provide a hint only, not a guarantee that the object returned is compatible with the type. Returns Type Description Object An object. Note - if the operation returns null this is not an error. Implements IObjectTargetMetadata.GetObject(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RegisterInstruction.html": {
    "href": "rezolver-api/Rezolver.Configuration.RegisterInstruction.html",
    "title": "Class RegisterInstruction",
    "keywords": "Class RegisterInstruction The basic workhorse of a parsed configuration - an instruction to register a target in an IRezolveTargetContainer instance against one or more types with a given name. Inheritance Object RezolverBuilderInstruction RegisterInstruction Inherited Members RezolverBuilderInstruction.Entry Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class RegisterInstruction : RezolverBuilderInstruction <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RegisterInstruction(IEnumerable<Type>, ITarget, IConfigurationEntry) Constructs a new instance of the RegisterInstruction class. Declaration public RegisterInstruction(IEnumerable<Type> targetTypes, ITarget target, IConfigurationEntry entry) Parameters Name Type Description targetTypes IEnumerable < Type > The types that the target will be registered with target ITarget The target to be registered. entry IConfigurationEntry The original configuration entry from which this instruction was built. Exceptions Type Condition System.ArgumentNullException targetTypes or target System.ArgumentException List must contain one or more types;targetTypes or All types in list must be non-null;targetTypes <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Target The target that is to be registered. Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> TargetTypes The types that the target will be registered with Declaration public IEnumerable<Type> TargetTypes { get; } Property Value Type Description IEnumerable < Type > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Apply(ITargetContainer) The implementation will register the target for the given types. In the case of multiple types, the target is registered directly against that type, and aliases are registered for all the others. Declaration public override void Apply(ITargetContainer builder) Parameters Name Type Description builder ITargetContainer Overrides RezolverBuilderInstruction.Apply(ITargetContainer) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RegisterMultipleInstruction.html": {
    "href": "rezolver-api/Rezolver.Configuration.RegisterMultipleInstruction.html",
    "title": "Class RegisterMultipleInstruction",
    "keywords": "Class RegisterMultipleInstruction Similar to the RegisterInstruction except this specifically wraps the method. Construction is largely identical, except where in the aforementioned class you pass a single target, here you pass multiple targets in a list. Inheritance Object RezolverBuilderInstruction RegisterMultipleInstruction Inherited Members RezolverBuilderInstruction.Entry Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class RegisterMultipleInstruction : RezolverBuilderInstruction <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RegisterMultipleInstruction(IEnumerable<Type>, IEnumerable<ITarget>, IConfigurationEntry) Initializes a new instance of the RegisterMultipleInstruction class. Declaration public RegisterMultipleInstruction(IEnumerable<Type> targetTypes, IEnumerable<ITarget> targets, IConfigurationEntry entry) Parameters Name Type Description targetTypes IEnumerable < Type > The target types for the registration. targets IEnumerable < ITarget > The targets. Note that this is a list to support modification after the instruction is created; since this is a configuration API. entry IConfigurationEntry The source entry for this instruction - allows the system to track the instruction back to the configuration it was loaded from. Exceptions Type Condition System.ArgumentNullException targetTypes or targets System.ArgumentException List must contain one or more types;targetTypes or All types in list must be non-null;targetTypes or List must contain one or more targets;targets or All targets in list must be non-null;targets <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Targets Gets the targets that'll be used for the registration. Declaration public IEnumerable<ITarget> Targets { get; } Property Value Type Description IEnumerable < ITarget > The targets. <!-- .classchild --> TargetTypes The types that the target will be registered with Declaration public IEnumerable<Type> TargetTypes { get; } Property Value Type Description IEnumerable < Type > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Apply(ITargetContainer) Declaration public override void Apply(ITargetContainer builder) Parameters Name Type Description builder ITargetContainer Overrides RezolverBuilderInstruction.Apply(ITargetContainer) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RezolverBuilderInstruction.html": {
    "href": "rezolver-api/Rezolver.Configuration.RezolverBuilderInstruction.html",
    "title": "Class RezolverBuilderInstruction",
    "keywords": "Class RezolverBuilderInstruction An instruction to perform an operation on a container builder from an IConfigurationEntry that's been parsed from a configuration source (and which has been retrieved from an IConfiguration instance). Inheritance Object RezolverBuilderInstruction Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public abstract class RezolverBuilderInstruction <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RezolverBuilderInstruction(IConfigurationEntry) Inheritance constructor. Declaration protected RezolverBuilderInstruction(IConfigurationEntry entry) Parameters Name Type Description entry IConfigurationEntry The entry that built this instruction. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Entry The source configuration entry for this instruction. Declaration public IConfigurationEntry Entry { get; } Property Value Type Description IConfigurationEntry <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Apply(ITargetContainer) Abstract method which performs whatever instruction this instance represents on the passed builder. Declaration public abstract void Apply(ITargetContainer builder) Parameters Name Type Description builder ITargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataBase.html": {
    "href": "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataBase.html",
    "title": "Class RezolveTargetMetadataBase",
    "keywords": "Class RezolveTargetMetadataBase Suggested base class for implementations of IRezolveTargetMetadata . Inheritance Object RezolveTargetMetadataBase Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public abstract class RezolveTargetMetadataBase : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RezolveTargetMetadataBase(RezolveTargetMetadataType) Initializes a new instance of the RezolveTargetMetadataBase class. Declaration protected RezolveTargetMetadataBase(RezolveTargetMetadataType type) Parameters Name Type Description type RezolveTargetMetadataType The type of target. Exceptions Type Condition System.ArgumentException If type is RezolveTargetMetadataType.Extension this instance must implement IRezolveTargetMetadataExtension <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Gets the declared type of the object that will be created by an IRezolveTarget created by this metadata. Note - this isn't always known, or always fixed, since configuration systems will allow developers to avoid being specific about the types that are to be built. Declaration public abstract ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference The type of the declared. Implements IRezolveTargetMetadata.DeclaredType <!-- .classchild --> Type The type of rezolve target that is expected to be produced from this metadata Declaration public RezolveTargetMetadataType Type { get; } Property Value Type Description RezolveTargetMetadataType The type. Implements IRezolveTargetMetadata.Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Bind(ITypeReference[]) Declaration public virtual IRezolveTargetMetadata Bind(ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Implements IRezolveTargetMetadata.Bind(ITypeReference[]) <!-- .classchild --> BindBase(ITypeReference[]) Creates a new instance (clone) of this metadata that's bound to the target types (although, typically, you'll only ever pick the first target type that is in the array). Only ever called if DeclaredType is unbound Declaration protected abstract IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] The target types. Returns Type Description IRezolveTargetMetadata IRezolveTargetMetadata. <!-- .classchild --> CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Implementation of CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) - see that documentation for more detail about the intentions of this method. This implementation will check all the arguments (for nulls etc), including that all targetTypes have a common base; then it will invoke the abstract method CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) . Declaration public virtual ITarget CreateRezolveTarget(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry = null) Parameters Name Type Description targetTypes Type [] Required. One or more target types that the returned target is expected to be compatible with (i.e. able to build an instance of). Generally, this will be the target types for the configuration entry that is passed in entry . context ConfigurationAdapterContext The current context - provides access to the builder currently being constructed, as well as methods for resolving type names from ITypeReference instances or strings (and more). entry IConfigurationEntry If provided, this is a reference to the configuration entry (typically an ITypeRegistrationEntry ) against which this target will be registered. Please note - this doesn't mean that the target that is returned will become the target of the registration. It might be that the target is one that is used by a parent target that will become the target of the registration. Returns Type Description ITarget IRezolveTarget. Implements IRezolveTargetMetadata.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Exceptions Type Condition System.ArgumentNullException context or targetTypes System.ArgumentException Array must contain at least one target type;targetTypes or All items in the array must be non-null;targetTypes <!-- .classchild --> CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Called by CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) to create the rezolve target that will be registered into the ITargetContainer currently being built (available on the context ) If an error occurs, you indicate that by adding to the context 's errors collection, and return null. You can also throw an exception, which will be caught and added to the errors collection for you. Declaration protected abstract ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] The target types. context ConfigurationAdapterContext The context. entry IConfigurationEntry The entry. Returns Type Description ITarget IRezolveTarget. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataList.html": {
    "href": "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataList.html",
    "title": "Class RezolveTargetMetadataList",
    "keywords": "Class RezolveTargetMetadataList Inheritance Object RezolveTargetMetadataBase RezolveTargetMetadataList Inherited Members RezolveTargetMetadataBase.Type RezolveTargetMetadataBase.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class RezolveTargetMetadataList : RezolveTargetMetadataBase, IRezolveTargetMetadataList, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RezolveTargetMetadataList() Declaration public RezolveTargetMetadataList() <!-- .classchild --> RezolveTargetMetadataList(IEnumerable<IRezolveTargetMetadata>) Declaration public RezolveTargetMetadataList(IEnumerable<IRezolveTargetMetadata> range) Parameters Name Type Description range IEnumerable < IRezolveTargetMetadata > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides RezolveTargetMetadataBase.DeclaredType Implements IRezolveTargetMetadata.DeclaredType <!-- .classchild --> Targets Declaration public IList<IRezolveTargetMetadata> Targets { get; } Property Value Type Description IList < IRezolveTargetMetadata > Implements IRezolveTargetMetadataList.Targets <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Bind(ITypeReference[]) Declaration public override IRezolveTargetMetadata Bind(ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides RezolveTargetMetadataBase.Bind(ITypeReference[]) Implements IRezolveTargetMetadata.Bind(ITypeReference[]) <!-- .classchild --> BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides RezolveTargetMetadataBase.BindBase(ITypeReference[]) <!-- .classchild --> CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description ITarget Overrides RezolveTargetMetadataBase.CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild --> CreateRezolveTargets(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration public IEnumerable<ITarget> CreateRezolveTargets(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description IEnumerable < ITarget > Implements IRezolveTargetMetadataList.CreateRezolveTargets(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataType.html": {
    "href": "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataType.html",
    "title": "Enum RezolveTargetMetadataType",
    "keywords": "Enum RezolveTargetMetadataType Types of IRezolveTargetMetadata that can be expressed in configuration Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public enum RezolveTargetMetadataType <!-- <hr class=\"typeSectionDivider\" /> --> Fields Constructor Binding to a constructor of a type to create new instances of that type when the object is resolved Declaration Constructor = 2 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> Extension A custom metadata - the instance should also have the interface IRezolveTargetMetadataExtension Declaration Extension = 2147483647 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> List A list or array whose items are individually specified as resolve targets and eventually loaded into a ListTarget. This enables configuration files to hand-crank a list directly and when multiple registration is not applicable. Declaration List = 4 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> MetadataList Describes a list of IRezolveTargetMetadata instances - to be used for metadata objects that require multiple metadata objects. Can be created to feed a multiple instance registration for a single type (e.g. registering multiple instances of IFoo to a container, so that you can resolve all of them by resolving IEnumerable<IFoo>), or simply as a collection of targets that are to be used to build an array that is to be passed as a constructor argument or property. Declaration MetadataList = 5 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> Object A physical instance to be returned when a resolve operation is performed Declaration Object = 1 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> Singleton A singleton - only one object will ever be created from the target that this metadata builds. A singleton might also be scoped - i.e. that the lifetime is limited to the lifetime of an external scope. Declaration Singleton = 3 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> Unknown Declaration Unknown = 0 Field Value Type Description RezolveTargetMetadataType <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RuntimeTypeReference.html": {
    "href": "rezolver-api/Rezolver.Configuration.RuntimeTypeReference.html",
    "title": "Class RuntimeTypeReference",
    "keywords": "Class RuntimeTypeReference An ITypeReference that has been built directly from a runtime type. Inheritance Object RuntimeTypeReference Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public sealed class RuntimeTypeReference : ITypeReference, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors RuntimeTypeReference(Type) Declaration public RuntimeTypeReference(Type runtimeType) Parameters Name Type Description runtimeType Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties EndLineNo Declaration public int ? EndLineNo { get; } Property Value Type Description Nullable < Int32 > Implements IConfigurationLineInfo.EndLineNo <!-- .classchild --> EndLinePos Declaration public int ? EndLinePos { get; } Property Value Type Description Nullable < Int32 > Implements IConfigurationLineInfo.EndLinePos <!-- .classchild --> GenericArguments Declaration public ITypeReference[] GenericArguments { get; } Property Value Type Description ITypeReference [] Implements ITypeReference.GenericArguments <!-- .classchild --> IsArray Declaration public bool IsArray { get; } Property Value Type Description Boolean Implements ITypeReference.IsArray <!-- .classchild --> IsOpenGenericTypeArgument Declaration public bool IsOpenGenericTypeArgument { get; } Property Value Type Description Boolean Implements ITypeReference.IsOpenGenericTypeArgument <!-- .classchild --> IsUnbound Declaration public bool IsUnbound { get; } Property Value Type Description Boolean Implements ITypeReference.IsUnbound <!-- .classchild --> RuntimeType Declaration public Type RuntimeType { get; } Property Value Type Description Type <!-- .classchild --> StartLineNo Declaration public int ? StartLineNo { get; } Property Value Type Description Nullable < Int32 > Implements IConfigurationLineInfo.StartLineNo <!-- .classchild --> StartLinePos Declaration public int ? StartLinePos { get; } Property Value Type Description Nullable < Int32 > Implements IConfigurationLineInfo.StartLinePos <!-- .classchild --> TypeName Declaration public string TypeName { get; } Property Value Type Description String Implements ITypeReference.TypeName <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.SingletonTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.SingletonTargetMetadata.html",
    "title": "Class SingletonTargetMetadata",
    "keywords": "Class SingletonTargetMetadata Inheritance Object RezolveTargetMetadataBase SingletonTargetMetadata Inherited Members RezolveTargetMetadataBase.Type RezolveTargetMetadataBase.CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) RezolveTargetMetadataBase.Bind(ITypeReference[]) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class SingletonTargetMetadata : RezolveTargetMetadataBase, ISingletonTargetMetadata, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors SingletonTargetMetadata(IRezolveTargetMetadata, Boolean) Initializes a new instance of the SingletonTargetMetadata class. Declaration public SingletonTargetMetadata(IRezolveTargetMetadata inner, bool scoped = false) Parameters Name Type Description inner IRezolveTargetMetadata The inner target that will be turned into a singleton. scoped Boolean if set to true [scoped]. Exceptions Type Condition System.ArgumentNullException inner <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Gets the declared type of the object that will be created by an IRezolveTarget created by this metadata. Note - this isn't always known, or always fixed, since configuration systems will allow developers to avoid being specific about the types that are to be built. Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference The type of the declared. Overrides RezolveTargetMetadataBase.DeclaredType Implements IRezolveTargetMetadata.DeclaredType <!-- .classchild --> Inner Metadata for the inner target that is turned into a scoped singleton Declaration public IRezolveTargetMetadata Inner { get; } Property Value Type Description IRezolveTargetMetadata Implements ISingletonTargetMetadata.Inner <!-- .classchild --> Scoped If true, then the singleton object should be scope-compatible, i.e. with a lifetime limited to the lifetime of an external scope rather than to the AppDomain's lifetime. Declaration public bool Scoped { get; } Property Value Type Description Boolean Implements ISingletonTargetMetadata.Scoped <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods BindBase(ITypeReference[]) Creates a new instance (clone) of this metadata that's bound to the target types (although, typically, you'll only ever pick the first target type that is in the array). Only ever called if DeclaredType is unbound Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] The target types. Returns Type Description IRezolveTargetMetadata IRezolveTargetMetadata. Overrides RezolveTargetMetadataBase.BindBase(ITypeReference[]) <!-- .classchild --> CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Implementation of the abstract method from the base class of the same name. If Scoped is true, then this creates a new ScopedTarget ; if false, it creates a new SingletonTarget Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes Type [] The target types. context ConfigurationAdapterContext The context. entry IConfigurationEntry The entry. Returns Type Description ITarget Overrides RezolveTargetMetadataBase.CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.TypeReference.html": {
    "href": "rezolver-api/Rezolver.Configuration.TypeReference.html",
    "title": "Class TypeReference",
    "keywords": "Class TypeReference Concrete implementation of the TypeReferenceBase abstract class, and the default implementation of ITypeReference to use when parsing configuration. Inheritance Object TypeReferenceBase TypeReference Inherited Members TypeReferenceBase.StartLineNo TypeReferenceBase.StartLinePos TypeReferenceBase.EndLineNo TypeReferenceBase.EndLinePos TypeReferenceBase.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class TypeReference : TypeReferenceBase, ITypeReference, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TypeReference(String, IConfigurationLineInfo, ITypeReference[]) Initializes a new instance of the TypeReference class. Declaration public TypeReference(string typeName, IConfigurationLineInfo lineInfo, params ITypeReference[] genericArguments) Parameters Name Type Description typeName String Name of the type. lineInfo IConfigurationLineInfo Optional. genericArguments ITypeReference [] The generic arguments. <!-- .classchild --> TypeReference(String, IConfigurationLineInfo, Boolean, ITypeReference[]) Declaration public TypeReference(string typeName, IConfigurationLineInfo lineInfo, bool isArray, params ITypeReference[] genericArguments) Parameters Name Type Description typeName String lineInfo IConfigurationLineInfo isArray Boolean genericArguments ITypeReference [] <!-- .classchild --> TypeReference(String, IConfigurationLineInfo, Boolean, Boolean, ITypeReference[]) Initializes a new instance of the TypeReference class, allowing you to create an explicitly 'unbound' type, which is expected to be replaced by whichever type is required by another component, later. Declaration public TypeReference(string typeName, IConfigurationLineInfo lineInfo, bool isArray, bool isUnbound, params ITypeReference[] genericArguments) Parameters Name Type Description typeName String Name of the type. lineInfo IConfigurationLineInfo The line information. isArray Boolean if set to true [is array]. isUnbound Boolean if set to true [is unbound]. genericArguments ITypeReference [] The generic arguments. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Fields NoGenericArguments Declaration public static readonly ITypeReference[] NoGenericArguments Field Value Type Description ITypeReference [] <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties GenericArguments Declaration public override ITypeReference[] GenericArguments { get; } Property Value Type Description ITypeReference [] Overrides TypeReferenceBase.GenericArguments <!-- .classchild --> IsArray Declaration public override bool IsArray { get; } Property Value Type Description Boolean Overrides TypeReferenceBase.IsArray <!-- .classchild --> IsOpenGenericTypeArgument Gets a value indicating whether this instance represents an open generic type argument (e.g. the 'T' from List<T>). Declaration public override bool IsOpenGenericTypeArgument { get; } Property Value Type Description Boolean true if this instance is an open generic type argument; otherwise, false . Overrides TypeReferenceBase.IsOpenGenericTypeArgument <!-- .classchild --> IsUnbound Gets a value indicating whether this instance represents the Unbound special type reference. Declaration public override bool IsUnbound { get; } Property Value Type Description Boolean true if this instance is unbound; otherwise, false . Overrides TypeReferenceBase.IsUnbound <!-- .classchild --> OpenGenericTypeArgument The one-and-only open generic argument instance. The only way to fetch a non-derived TypeReference that returns true for IsOpenGenericTypeArgument is to use the reference from this field. Declaration public static ITypeReference OpenGenericTypeArgument { get; } Property Value Type Description ITypeReference The open generic type argument. <!-- .classchild --> TypeName Gets the name of the type. Declaration public override string TypeName { get; } Property Value Type Description String The name of the type. Overrides TypeReferenceBase.TypeName <!-- .classchild --> Unbound A static Unbound TypeReference that can be used in cases where a simple instance of an unbound type is required. You can also, of course, create explicitly unbound type references using the greediest constructor on this type. Declaration public static ITypeReference Unbound { get; } Property Value Type Description ITypeReference The unbound. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.TypeReferenceBase.html": {
    "href": "rezolver-api/Rezolver.Configuration.TypeReferenceBase.html",
    "title": "Class TypeReferenceBase",
    "keywords": "Class TypeReferenceBase abstract base class to serve as a starting point for implementing the ITypeReference interface. Inheritance Object TypeReferenceBase Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public abstract class TypeReferenceBase : ITypeReference, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TypeReferenceBase() Initializes a new instance of the TypeReferenceBase class. Declaration protected TypeReferenceBase() <!-- .classchild --> TypeReferenceBase(IConfigurationLineInfo) Initializes a new instance of the TypeReferenceBase class, copying the passed line information into this object, if provided. Declaration protected TypeReferenceBase(IConfigurationLineInfo lineInfo) Parameters Name Type Description lineInfo IConfigurationLineInfo Optional. The line information. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties EndLineNo Gets the line number within the configuration source that sees the end of the text from which this object was parsed. Used in conjunction with EndLinePos , it allows you to zero-in on the exact ending of this parsed object. Declaration public int ? EndLineNo { get; } Property Value Type Description Nullable < Int32 > The end line number. Implements IConfigurationLineInfo.EndLineNo <!-- .classchild --> EndLinePos Gets the position from the start of the line, indicated by EndLineNo , where the configuration text ends for this parsed object. Declaration public int ? EndLinePos { get; } Property Value Type Description Nullable < Int32 > The end line position. Implements IConfigurationLineInfo.EndLinePos <!-- .classchild --> GenericArguments Any explicitly provided generic arguments are stored here. Note that it might turn out that the TypeName refers to a whole closed generic type, in which case the referenced type could still be generic even if this array is empty. It's also the case that arguments could be passed here when the root type name resolves to a non-generic type definition, in which case type resolution will likely fail. Declaration public abstract ITypeReference[] GenericArguments { get; } Property Value Type Description ITypeReference [] The generic arguments. Implements ITypeReference.GenericArguments <!-- .classchild --> IsArray Gets a value indicating whether the type ultimately represented by this instance is an array of the type described by the rest of this instance's properties. Declaration public abstract bool IsArray { get; } Property Value Type Description Boolean true if this instance represents an array type; otherwise, false . Implements ITypeReference.IsArray <!-- .classchild --> IsOpenGenericTypeArgument True if this type represents an open generic argument - this is how to explicitly reference an open generic type in a type reference: you specify a base type, then have one or more open generic arguments specified in the GenericArguments array. If all are open generic arguments, then you have created a reference to the fully open generic type. You only need to provide all-open arguments if the base TypeName could be ambiguous between a non generic and generic type, or there are multiple generic types with the same base name. Equally, you can do this to create references to partially open generics, which may or may not be supported by the adapter or the target that is built. Declaration public abstract bool IsOpenGenericTypeArgument { get; } Property Value Type Description Boolean true if this instance is open generic type argument; otherwise, false . Implements ITypeReference.IsOpenGenericTypeArgument <!-- .classchild --> IsUnbound Gets a value indicating whether this instance represents a type that is to be late-bound for a specific target type. Declaration public abstract bool IsUnbound { get; } Property Value Type Description Boolean true if this instance is unbound; otherwise, false . Implements ITypeReference.IsUnbound <!-- .classchild --> StartLineNo Gets the line number within the configuration source that contains the start of the text from which this object was parsed. Used in conjunction with StartLinePos , it allows you to zero-in on the exact starting point of this parsed object. Declaration public int ? StartLineNo { get; } Property Value Type Description Nullable < Int32 > The start line number. Implements IConfigurationLineInfo.StartLineNo <!-- .classchild --> StartLinePos Gets the position from the start of the line, indicated by StartLineNo , where the configuration text begins for this parsed object. Declaration public int ? StartLinePos { get; } Property Value Type Description Nullable < Int32 > The start line position. Implements IConfigurationLineInfo.StartLinePos <!-- .classchild --> TypeName The root type name. Declaration public abstract string TypeName { get; } Property Value Type Description String The name of the type. Implements ITypeReference.TypeName <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods ToString() Produces a string representation of the type name, including generic arguments. Please note - this is not intended to produce a type name that can be fed to System.Type.GetType, even if occasionally it does. Declaration public override string ToString() Returns Type Description String Overrides Object.ToString() <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.TypeRegistrationEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.TypeRegistrationEntry.html",
    "title": "Class TypeRegistrationEntry",
    "keywords": "Class TypeRegistrationEntry Inheritance Object ConfigurationEntryBase TypeRegistrationEntry Inherited Members ConfigurationEntryBase.Type ConfigurationEntryBase.StartLineNo ConfigurationEntryBase.StartLinePos ConfigurationEntryBase.EndLineNo ConfigurationEntryBase.EndLinePos Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class TypeRegistrationEntry : ConfigurationEntryBase, ITypeRegistrationEntry, IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors TypeRegistrationEntry(ITypeReference[], IRezolveTargetMetadata, Boolean, IConfigurationLineInfo) Declaration public TypeRegistrationEntry(ITypeReference[] types, IRezolveTargetMetadata targetMetadata, bool isMultipleRegistration, IConfigurationLineInfo lineInfo = null) Parameters Name Type Description types ITypeReference [] targetMetadata IRezolveTargetMetadata isMultipleRegistration Boolean lineInfo IConfigurationLineInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties IsMultipleRegistration Declaration public bool IsMultipleRegistration { get; } Property Value Type Description Boolean Implements ITypeRegistrationEntry.IsMultipleRegistration <!-- .classchild --> TargetMetadata Declaration public IRezolveTargetMetadata TargetMetadata { get; } Property Value Type Description IRezolveTargetMetadata Implements ITypeRegistrationEntry.TargetMetadata <!-- .classchild --> Types Declaration public ITypeReference[] Types { get; } Property Value Type Description ITypeReference [] Implements ITypeRegistrationEntry.Types <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.html": {
    "href": "rezolver-api/Rezolver.Configuration.html",
    "title": "Namespace Rezolver.Configuration",
    "keywords": "Namespace Rezolver.Configuration Classes AssemblyReferenceEntry ConfigurationAdapter Standard implementation of the IConfigurationAdapter interface. ConfigurationAdapter.ConfigurationEntryProcessOrderer Used by the ConfigurationAdapter class to sort configuration entries for processing. It ensures that Assembly Reference entries are given priority, followed by Namespace Imports, and then finally all the rest. ConfigurationAdapterContext This class is used to store the intermediate state for the default IConfigurationAdapter implementation's ( ConfigurationAdapter ) parsing operation on an IConfiguration instance. If you are extending the default adapter you might need also to extend this class to ensure any additional state you require is maintained. ConfigurationAdapterContext.UnresolvedType Used as a sentinel type by the ResolveType(String, Nullable<Int32>) method when the type search fails. ConfigurationAdapterContextFactory The standard Singleton implementation of the IConfigurationAdapterContextFactory interface, and one which you can use as the starting point of your own factory. By default, it creates a new instance of the ConfigurationAdapterContext class (using the virtual method CreateContext(ConfigurationAdapter, IConfiguration) , and then instructs it to add its default assembly references. ConfigurationEntryBase suggested starting point for implementing your own configuration entries. ConfigurationError ConfigurationException ConstructorTargetMetadata ListTargetMetadata Standard implementation of the IListTargetMetadata interface. ObjectTargetMetadata Standard implementation of ObjectTargetMetadataBase , to encapsulate object references that are to be baked into a container as targets. ObjectTargetMetadataBase Abstract base class for metadata that builds an object target. RegisterInstruction The basic workhorse of a parsed configuration - an instruction to register a target in an IRezolveTargetContainer instance against one or more types with a given name. RegisterMultipleInstruction Similar to the RegisterInstruction except this specifically wraps the method. Construction is largely identical, except where in the aforementioned class you pass a single target, here you pass multiple targets in a list. RezolverBuilderInstruction An instruction to perform an operation on a container builder from an IConfigurationEntry that's been parsed from a configuration source (and which has been retrieved from an IConfiguration instance). RezolveTargetMetadataBase Suggested base class for implementations of IRezolveTargetMetadata . RezolveTargetMetadataList RuntimeTypeReference An ITypeReference that has been built directly from a runtime type. SingletonTargetMetadata TypeReference Concrete implementation of the TypeReferenceBase abstract class, and the default implementation of ITypeReference to use when parsing configuration. TypeReferenceBase abstract base class to serve as a starting point for implementing the ITypeReference interface. TypeRegistrationEntry Interfaces IAssemblyReferenceEntry A configuration entry instructing the configuration adapter to load an assembly before resolving types. IConfiguration IConfigurationAdapter Represents an object that is responsible for transforming configuration data into target containers. IConfigurationAdapterContextFactory Used by this library's default implementation of IConfigurationAdapter, the ConfigurationAdapter class, to create an instance of the ConfigurationAdapterContext class for a given adapter that's processing a given configuration. IConfigurationEntry IConfigurationError Interface for an error that originates from a configuration file. IConfigurationExtensionEntry IConfigurationLineInfo Encapsulates information about where a particular object, parsed from a configuration file, can be found. IConstructorTargetMetadata IListTargetMetadata Configuration metadata for building a ListTarget in a RezolverBuilder. IObjectTargetMetadata Interface for metadata for constructing an ObjectTarget IRezolveTarget. IRezolveTargetMetadata Represents an instruction to create an IRezolveTarget from parsed configuration. IRezolveTargetMetadataExtension IRezolveTargetMetadataList Represents a list of IRezolveTargetMetadata instances - for when you want to register multiple targets against a single type. Note - although the interface IRezolveTargetMetadata is included by this interface, instances are not expected to be able to create a single target through the CreateRezolveTarget method - because by definition, multiple targets are produced by this. Use the CreateRezolveTargets method instead. The Bind method, however, will be expected to produce a new instance of the implementing type if any underlying targets are not bound to a specific type. ISingletonTargetMetadata Interface for Singleton metadata. ITypeReference Captures a reference to a type made in a configuration file. It does not guarantee that the type can be located, it simply provides a common interface for storing the type information written in a configuration file. An IConfigurationAdapter instance will need to resolve the actual runtime type from this when registering targets from a configuration file. ITypeRegistrationEntry Represents an instruction to register one or more targets in an ITargetContainer against one or more types. Think of it as wrapping a single call to one of the builder's Register methods. Enums ConfigurationEntryType Types of configuration entry that can be parsed from a configuration file RezolveTargetMetadataType Types of IRezolveTargetMetadata that can be expressed in configuration"
  },
  "rezolver-api/Rezolver.ConstructorTarget.html": {
    "href": "rezolver-api/Rezolver.ConstructorTarget.html",
    "title": "Class ConstructorTarget",
    "keywords": "Class ConstructorTarget A target that binds to a type's constructor with zero or more arguments supplied by other ITarget s and, optionally binding to the new instance's writeable properties. Inheritance Object TargetBase ConstructorTarget Inherited Members TargetBase.SuppressScopeTracking TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ConstructorTarget : TargetBase, ITarget Remarks Although you can create this target directly through the constructor, you're more likely to create it through factory methods such as Auto<T>(IPropertyBindingBehaviour) or, more likely still, extension methods such as during your application's container setup phase. The expression built by this class' implementation of CreateExpressionBase(CompileContext) will be an expression tree that ultimately creates a new instance of the DeclaredType . <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ConstructorTarget(ConstructorInfo, IPropertyBindingBehaviour, ParameterBinding[]) Initializes a new instance of the ConstructorTarget class. Declaration public ConstructorTarget(ConstructorInfo ctor, IPropertyBindingBehaviour propertyBindingBehaviour = null, ParameterBinding[] parameterBindings = null) Parameters Name Type Description ctor ConstructorInfo Required - the constructor that is to be bound. The DeclaredType of the new instance will be derived from this. propertyBindingBehaviour IPropertyBindingBehaviour Optional. If provided, can be used to select properties which are to be initialised from the container. parameterBindings ParameterBinding [] Optional, although can only be supplied if ctor is provided. Specific bindings for the parameters of the given ctor which should be used during code generation. <!-- .classchild --> ConstructorTarget(Type, IPropertyBindingBehaviour, IDictionary<String, ITarget>) Initializes a late-bound instance of the ConstructorTarget class which will locate the best constructor to be called at compile-time. Declaration public ConstructorTarget(Type type, IPropertyBindingBehaviour propertyBindingBehaviour = null, IDictionary<string, ITarget> namedArgs = null) Parameters Name Type Description type Type Required. The type to be constructed when resolved in a container. propertyBindingBehaviour IPropertyBindingBehaviour Optional. If provided, can be used to select properties which are to be initialised from the container. namedArgs IDictionary < String , ITarget > Optional. The named arguments which will be provided to the best-matched constructor. These are taken into account when the constructor is sought - with the constructor that the most parameters matched being selected. Remarks The best available constructor on the type is determined when CreateExpression(CompileContext) is called (which ultimately calls CreateExpressionBase(CompileContext) ). The best available constructor is defined as the constructor with the most parameters for which arguments can be resolved from the CompileContext at compile-time (i.e. when CreateExpressionBase(CompileContext) is called) to the fewest number of ITarget objects whose UseFallback is false (for example - when an IEnumerable of a service is requested, but no registrations are found, a target is returned with UseFallback set to true , and whose expression will equate to an empty enumerable). This allows the system to bind to different constructors automatically based on the other registrations that are present in the ITargetContainer of the active Container when code is compiled in response to a call to Resolve(RezolveContext) . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Ctor Can be null. Gets the constructor that this target is bound to, if known at construction time. Declaration public ConstructorInfo Ctor { get; } Property Value Type Description ConstructorInfo Remarks ConstructorTargets can be bound to a particular constructor in advance, or they can search for a best-match constructor at the point where CreateExpression(CompileContext) is called. This property will only be set ultimately if it was passed to the ConstructorTarget(ConstructorInfo, IPropertyBindingBehaviour, ParameterBinding[]) constructor, possibly by a factory method like WithArgs(ConstructorInfo, IDictionary<String, ITarget>) , or FromNewExpression(Type, NewExpression, ITargetAdapter) , where the constructor is captured within the expression. <!-- .classchild --> DeclaredType Implementation of DeclaredType . Always equal to the type whose constructor will be bound by this target. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> NamedArgs Named arguments (as ITarget objects) to be supplied to the object on construction, also aiding the search for a constructor. Declaration public IReadOnlyDictionary<string, ITarget> NamedArgs { get; } Property Value Type Description IReadOnlyDictionary < String , ITarget > Remarks Note the difference between this and ParameterBindings - this property might be used when the constructor is not known in advance, whereas ParameterBindings is used when it is. <!-- .classchild --> ParameterBindings If this target was created with a specific constructor then this might contain argument bindings for that constructor's parameters. Declaration public IReadOnlyList<ParameterBinding> ParameterBindings { get; } Property Value Type Description IReadOnlyList < ParameterBinding > Remarks This is not the same as NamedArgs - as is noted by the documentation on that property. This property is for when the constructor is known in advance; whereas NamedArgs is for when it's not. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Auto(Type, IPropertyBindingBehaviour) Creates a late bound ConstructorTarget or GenericConstructorTarget for the given type . Declaration public static ITarget Auto(Type type, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description type Type The type that is to be constructed when this target is compiled and executed. propertyBindingBehaviour IPropertyBindingBehaviour Optional. An object which selects properties on the new instance which are to be bound from the container. Returns Type Description ITarget Either a ConstructorTarget or GenericConstructorTarget , depending on whether the type is a generic type definition. Remarks This factory is merely a shortcut for calling the ConstructorTarget(Type, IPropertyBindingBehaviour, IDictionary<String, ITarget>) with only the type and propertyBindingBehaviour arguments supplied. When creating a GenericConstructorTarget , the function uses the GenericConstructorTarget(Type, IPropertyBindingBehaviour) constructor. <!-- .classchild --> Auto<T>(IPropertyBindingBehaviour) Generic version of the Auto(Type, IPropertyBindingBehaviour) method. Declaration public static ITarget Auto<T>(IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description propertyBindingBehaviour IPropertyBindingBehaviour See the documentation for the propertyBindingBehaviour parameter on the non-generic version of this method. Returns Type Description ITarget Either a ConstructorTarget or GenericConstructorTarget , depending on whether T is a generic type definition. Type Parameters Name Description T The type that is to be constructed when the new target is compiled and executed. <!-- .classchild --> CreateExpressionBase(CompileContext) Implementation of CreateExpressionBase(CompileContext) Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext The current compile context Returns Type Description Expression Overrides TargetBase.CreateExpressionBase(CompileContext) <!-- .classchild --> FromNewExpression(Type, NewExpression, ITargetAdapter) Non-generic version of FromNewExpression<T>(Expression<Func<T>>, ITargetAdapter) . See the documentation on that method for more. Declaration public static ITarget FromNewExpression(Type declaredType, NewExpression newExpr, ITargetAdapter adapter = null) Parameters Name Type Description declaredType Type The of the object to be created by the new ConstructorTarget newExpr NewExpression adapter ITargetAdapter Returns Type Description ITarget <!-- .classchild --> FromNewExpression<T>(Expression<Func<T>>, ITargetAdapter) Creates a new ConstructorTarget from the passed lambda expression (whose must be a ) Declaration public static ITarget FromNewExpression<T>(Expression<Func<T>> newExpr, ITargetAdapter adapter = null) Parameters Name Type Description newExpr Expression < Func <T>> Required. The expression from which to create the target. adapter ITargetAdapter Optional. The adapter to be used to convert any additional expressions in the lambda into ITarget instances (e.g. for argument values). If not provided, then the Default will be used. Returns Type Description ITarget An ITarget that actually be an intstance of ConstructorTarget Type Parameters Name Description T The type of the object to be created by the new ConstructorTarget Remarks This method does not support member binding expressions - e.g. c => new MyObject() { A = \"hello\" } - these can be converted into targets using a (compliant) ITargetAdapter object's CreateTarget(Expression) method. At least, the supplied TargetAdapter class does support them. When providing custom expressions to be used as targets in an ITargetContainer , it is possible to explicitly define properties/arguments as being resolved from the container itself, in exactly the same way as generated by the other factory methods such as Auto<T>(IPropertyBindingBehaviour) and . To do this, simply call the Resolve<T>() function on the object passed into your expression (see the signature of the lambda newExpr ), and Rezolver will convert that call into a RezolvedTarget . Exceptions Type Condition System.ArgumentNullException If newExpr is null. System.ArgumentException If the newExpr does not have a NewExpression as its root (Body) node, or if the type of that expression does not equal T <!-- .classchild --> WithArgs(ConstructorInfo, IDictionary<String, ITarget>) Similar to WithArgs(Type, IDictionary<String, ITarget>) except this one creates a ConstructorTarget that is specifically bound to a particular constructor on a given type, using any matched argument bindings from the provided namedArgs dictionary, and using RezolvedTarget targets for any that are not matched. Declaration public static ITarget WithArgs(ConstructorInfo ctor, IDictionary<string, ITarget> namedArgs) Parameters Name Type Description ctor ConstructorInfo Required. The constructor to be bound. namedArgs IDictionary < String , ITarget > Optional. Any arguments to be supplied to parameters on the ctor by name. Any parameters for which matches are not found in this dictionary will be automatically bound either from compile-time defaults or by resolving those types dynamically. Returns Type Description ITarget Remarks Although this overload accepts a dictionary of arguments, note that it will not result in the NamedArgs property being set on the target that is created - it's just an alternative for deriving the ParameterBindings with which the target will be created. Also, this function will not fail if the args dictionary contains named arguments that cannot be matched to parameters on the ctor . <!-- .classchild --> WithArgs(ConstructorInfo, Object) Performs the same operation as WithArgs(ConstructorInfo, IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration public static ITarget WithArgs(ConstructorInfo ctor, object namedArgs) Parameters Name Type Description ctor ConstructorInfo Required. The constructor to be bound. namedArgs Object An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Remarks Although this overload accepts a dictionary of arguments, note that it will not result in the NamedArgs property being set on the target that is created - it's just an alternative for deriving the ParameterBindings with which the target will be created. Also, this function will not fail if the args dictionary contains named arguments that cannot be matched to parameters on the ctor . <!-- .classchild --> WithArgs(Type, IDictionary<String, ITarget>) Non-generic version of WithArgs<T>(IDictionary<String, ITarget>) . Creates a ConstructorTarget with a set of named targets which will be used like named arguments to late-bind the constructor when code-generation occurs. Declaration public static ITarget WithArgs(Type declaredType, IDictionary<string, ITarget> namedArgs) Parameters Name Type Description declaredType Type The type whose constructor is to be bound. namedArgs IDictionary < String , ITarget > The named arguments to be used when building the expression. Returns Type Description ITarget Remarks Both versions of this method will create a target which will try to find the best-matching constructor where all of the named arguments match, and with the fewest number of auto-resolved arguments. So, a class with a constructor such as Foo(IService1 s1, IService2 s2) Can happily be bound if you only provide a named argument for 's1'; the target will simply attempt to auto-resolve the argument for the IService2 s2 parameter when constructing the object - and will fail only if it can't be resolved at that point. <!-- .classchild --> WithArgs(Type, Object) Performs the same operation as WithArgs(Type, IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration public static ITarget WithArgs(Type declaredType, object namedArgs) Parameters Name Type Description declaredType Type The type whose constructor is to be bound. namedArgs Object An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Remarks This overload exists to simplify the process of creating a ConstructorTarget with argument bindings by removing the need to create an argument dictionary in advance. An anonymous type can instead be used to supply the arguments. Examples This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a ConstructorTarget for the type 'MyType': ConstructorTarget.WithArgs(typeof(MyType), new { param1 = new ObjectTarget(\"Hello World\") }); <!-- .classchild --> WithArgs<T>(IDictionary<String, ITarget>) Creates a ConstructorTarget with a set of named targets which will be used like named arguments to late-bind the constructor when code-generation occurs. Declaration public static ITarget WithArgs<T>(IDictionary<string, ITarget> namedArgs) Parameters Name Type Description namedArgs IDictionary < String , ITarget > The named arguments to be used when building the expression. Returns Type Description ITarget Type Parameters Name Description T The type whose constructor is to be bound Remarks Both versions of this method will create a target which will try to find the best-matching constructor where all of the named arguments match, and with the fewest number of auto-resolved arguments. So, a class with a constructor such as Foo(IService1 s1, IService2 s2) Can happily be bound if you only provide a named argument for 's1'; the target will simply attempt to auto-resolve the argument for the IService2 s2 parameter when constructing the object - and will fail only if it can't be resolved at that point. <!-- .classchild --> WithArgs<T>(Object) Performs the same operation as WithArgs<T>(IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration public static ITarget WithArgs<T>(object namedArgs) Parameters Name Type Description namedArgs Object An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Type Parameters Name Description T Remarks This overload exists to simplify the process of creating a ConstructorTarget with argument bindings by removing the need to create an argument dictionary in advance. An anonymous type can instead be used to supply the arguments. Examples This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a ConstructorTarget for the type 'MyType': ConstructorTarget.WithArgs<MyType>(new { param1 = new ObjectTarget(\"Hello World\") }); <!-- .classchild -->"
  },
  "index.html": {
    "href": "index.html",
    "title": "Rezolver",
    "keywords": "Improve this Doc Rezolver Welcome to the home of Rezolver - here you'll find guides, walkthroughs, deep-dives and reference for all of the APIs and functionality in the Rezolver library. What is Rezolver? Rezolver is (yet another :)) open source IOC container. It supports many of the features supported by most other popular IOC containers out there, integrates into the new .Net Core 1.0 framework (supporting NetStandard1.1) (and therefore supports Asp.Net Core), and supports some unique functionality too. It's very fast, extensible and reliable, and should slot nicely into any project in which you already have another IOC container. Quick Links Getting Started Nuget Packages API Reference Please note - this documentation is a work in progress! We're working on filling out our guides and how-tos as we go along, as well as filling out the API documentation. So, keep coming back! We'll get there :) If you're the kind of person who likes to learn from seeing the code - then check out the Rezolver repo on Github , there are some example applications on there, and you can look at the unit tests to get an idea of how to create and configure containers."
  },
  "rezolver-api/index.html": {
    "href": "rezolver-api/index.html",
    "title": "Rezolver API reference",
    "keywords": "Improve this Doc Rezolver API reference Looking for documentation on individual classes or methods in the Rezolver project? You've come to the right place! Crucial types to look at are: TargetContainer (implements ITargetContainer ): Stores ITarget instances, and is the main class you'll use for your 'registration' phase Container (implements IContainer ): The standard, non-scoped, container you'll use in your composition root - you can create child scopes from this by calling its implementation of CreateLifetimeScope() . This class requires an ITargetContainer for its registrations"
  },
  "rezolver-usage/details1.html": {
    "href": "rezolver-usage/details1.html",
    "title": "Details 1",
    "keywords": "Improve this Doc Details 1 This is the first details page."
  },
  "rezolver-usage/details2.html": {
    "href": "rezolver-usage/details2.html",
    "title": "Details 2",
    "keywords": "Improve this Doc Details 2 This is the second details page. And the same image underneath:"
  },
  "rezolver-usage/details3.html": {
    "href": "rezolver-usage/details3.html",
    "title": "Details 3",
    "keywords": "Improve this Doc Details 3 This is the third details page - getting a bit boring now huh?"
  },
  "rezolver-usage/index.html": {
    "href": "rezolver-usage/index.html",
    "title": "1. Getting started",
    "keywords": "Improve this Doc 1. Getting started As with many open source .Net projects, there are two primary ways to get Rezolver integrated into your project. The easiest is via the Nuget packages By using the Nuget packages, you ensure that you're using the latest (hopefully stable!) releases. Alpha packages will also be made available for in-development features. Fork or download the source from Github Use this if you can't integrate nuget into your build pipeline, or if you'd like to customise or contribute to the project. If you're looking to customise, though, then there should be enough extensibility points in the framework to allow you to do so without having to change core types. If that's not the case, post an issue on the Github project so we can get it added in and make it better for everyone! Once you've got the main assembly referenced (Rezolver.dll) - then you can create a Container , register targets against its internal ITargetContainer target container, and then grab objects from it! ITarget t = new ObjectTarget(null); ITargetContainer r = new TargetContainer(); r.Register(t, serviceType: typeof(object)); var t2 = r.Fetch(typeof(object)); Assert.Same(t, t2); More code using Rezolver.Tests.TestTypes; using System; using System.Collections.Generic; using System.Linq; using System.Net; using System.Threading.Tasks; using Xunit; namespace Rezolver.Tests { public class ConstructorTargetTests : TestsBase { [Fact] public void ShouldAutomaticallyFindDefaultConstructor() { var target = ConstructorTarget.Auto<DefaultConstructor>(); var result = GetValueFromTarget<DefaultConstructor>(target); Assert.Equal(DefaultConstructor.ExpectedValue, result.Value); } [Fact] public void ShouldFindConstructorWithOptionalParameters() { //This test demonstrates whether a constructor with all-default parameters will be treated equally //to a default constructor if no default constructor is present on the type. var target = ConstructorTarget.Auto<ConstructorWithDefaults>(); var result = GetValueFromTarget<ConstructorWithDefaults>(target); Assert.Equal(ConstructorWithDefaults.ExpectedValue, result.Value); } //this test now moves into specifically selecting a constructor and extracting the parameter bindings directly //from the caller. We get to automatically deriving parameter bindings for required parameters later. [Fact] public void ShouldAllowAllConstructorParametersToBeProvided() { var container = CreateContainer(); container.RegisterExpression(context => new NoDefaultConstructor(NoDefaultConstructor.ExpectedValue)); var result = container.Resolve<NoDefaultConstructor>(); Assert.Equal(NoDefaultConstructor.ExpectedValue, result.Value); } [Fact] public void ShouldAllowAConstructorParameterToBeExplicitlyRezolved() { //NOTE - used to use mocks, but in the end there is greater value in examining the class' behaviour with //the toher types in the library... //this is where the action starts to heat up! //if we can get explicitly resolved arguments to work, then we can get easily get //automatically injected arguments - by simply emitting the correct expression to do the same. //note that we pass the RezolveTargetAdapter singleton instance here to ensure consistent expression //parsing. However - note that if any tests in the RezolveTargetAdapterTests suite are failing, then //tests like this might also fail. I probably should isolate that - but I actually want to test ConstructorTarget's //integration with the default adapter here. var intTarget = NoDefaultConstructor.ExpectedRezolvedValue.AsObjectTarget(); var container = CreateContainer(); container.RegisterExpression(context => new NoDefaultConstructor(Functions.Resolve<int>())); container.Register(intTarget, typeof(int)); var result = container.Resolve<NoDefaultConstructor>(); Assert.Equal(NoDefaultConstructor.ExpectedRezolvedValue, result.Value); } [Fact] public void ShouldAutoRezolveAConstructor() { //basically the same as above - except this doesn't provide the constructor call explicitly. var target = ConstructorTarget.Auto<NoDefaultConstructor>(); var intTarget = NoDefaultConstructor.ExpectedRezolvedValue.AsObjectTarget(); var container = CreateContainer(); container.Register(intTarget, typeof(int)); var result = GetValueFromTarget<NoDefaultConstructor>(target, container); Assert.Equal(NoDefaultConstructor.ExpectedRezolvedValue, result.Value); } [Fact] public void ShouldBindConstructorJIT() { //instead of binding the constructor with the most parameters, it'll bind the constructor just-in-time based //on the services that are actually available from the container when the target is compiled. var target = ConstructorTarget.Auto<NoDefaultConstructor2>(); var intTarget = NoDefaultConstructor2.ExpectedBestValue.AsObjectTarget(); var container = CreateContainer(); container.Register(intTarget); container.Register(target); var result = container.Resolve<NoDefaultConstructor2>(); Assert.Equal(NoDefaultConstructor2.ExpectedBestValue, result.Value); Assert.Equal(NoDefaultConstructor2.ExpectedDefaultMessage, result.Message); } public static int ReturnsInt(int input) { return NoDefaultConstructor.ExpectedDynamicExpressionMultiplier * input; } [Fact] public void ShouldAllowAPropertyToBeSet() { Container container = new Container(compiler: new TargetDelegateCompiler()); container.RegisterExpression(c => new HasProperty() { Value = 1 }); var result = (HasProperty)container.Resolve(typeof(HasProperty)); Assert.Equal(1, result.Value); } [Fact] public void ShouldAllowAPropertyToBeResolved() { Container container = new Container(compiler: new TargetDelegateCompiler()); container.Register((10).AsObjectTarget()); container.RegisterExpression(c => new HasProperty() { Value = Functions.Resolve<int>() }); var result = (HasProperty)container.Resolve(typeof(HasProperty)); Assert.Equal(10, result.Value); } [Fact] public void ShouldAutoDiscoverProperties() { Container container = new Container(compiler: new TargetDelegateCompiler()); container.Register((25).AsObjectTarget()); container.Register(ConstructorTarget.Auto<HasProperty>(DefaultPropertyBindingBehaviour.Instance)); var result = (HasProperty)container.Resolve(typeof(HasProperty)); Assert.Equal(25, result.Value); } [Fact] public void ShouldAutoDiscoverFields() { Container container = new Container(compiler: new TargetDelegateCompiler()); container.Register(\"Hello world\".AsObjectTarget()); container.Register(ConstructorTarget.Auto<HasField>(DefaultPropertyBindingBehaviour.Instance)); var result = (HasField)container.Resolve(typeof(HasField)); Assert.Equal(\"Hello world\", result.StringField); } [Fact] public void ShouldIgnoreFieldsAndProperties() { Container container = new Container(compiler: new TargetDelegateCompiler()); container.Register((100).AsObjectTarget()); container.RegisterType<IgnoredPropertyAndField>(DefaultPropertyBindingBehaviour.Instance); var result = container.Resolve<IgnoredPropertyAndField>(); Assert.Equal(1, result.GetIgnoredField()); Assert.Equal(2, result.IgnoredProperty1); Assert.Equal(3, result.IgnoredProperty2); } [Fact] public void ShouldChainAutoDiscoveredPropertiesAndFields() { Container container = new Container(compiler: new TargetDelegateCompiler()); container.Register(\"hello universe\".AsObjectTarget()); container.Register((500).AsObjectTarget()); container.Register(ConstructorTarget.Auto<HasField>(DefaultPropertyBindingBehaviour.Instance)); container.Register(ConstructorTarget.Auto<HasProperty>(DefaultPropertyBindingBehaviour.Instance)); container.Register(ConstructorTarget.Auto<NestedPropertiesAndFields>(DefaultPropertyBindingBehaviour.Instance)); var result = (NestedPropertiesAndFields)container.Resolve(typeof(NestedPropertiesAndFields)); Assert.NotNull(result.Field_HasProperty); Assert.NotNull(result.Property_HasField); Assert.Equal(500, result.Field_HasProperty.Value); Assert.Equal(\"hello universe\", result.Property_HasField.StringField); } [Fact] public void ShouldBindExplicitParameters() { var example = new System.Net.NetworkCredential(\"hello\", \"world\"); var userName = \"username\".AsObjectTarget(); var password = \"password\".AsObjectTarget(); var args = new Dictionary<string, ITarget>(); args[\"userName\"] = userName; args[\"password\"] = password; var target = ConstructorTarget.WithArgs<NetworkCredential>(args); var result = GetValueFromTarget<NetworkCredential>(target); Assert.Equal(\"username\", result.UserName); Assert.Equal(\"password\", result.Password); } } }"
  },
  "rezolver-usage/advanced/index.html": {
    "href": "rezolver-usage/advanced/index.html",
    "title": "",
    "keywords": "Improve this Doc In addition to the standard functionality you'd expect from an IOC container, Rezolver supports many additional features which require some extra discussion."
  },
  "rezolver-usage/advanced/rezolving-with-expressions.html": {
    "href": "rezolver-usage/advanced/rezolving-with-expressions.html",
    "title": "",
    "keywords": "Improve this Doc TODO: Article covering functions such as the RegisterExpression<T>(ITargetContainer, Expression<Func<RezolveContextExpressionHelper, T>>, Type, ITargetAdapter) method"
  },
  "rezolver-usage/nuget-packages/index.html": {
    "href": "rezolver-usage/nuget-packages/index.html",
    "title": "Rezolver Nuget Packages",
    "keywords": "Improve this Doc Rezolver Nuget Packages Rezolver is primarily distributed as a suite of Nuget packages whose functionality stacks one on top of another. Depending on the level of functionality you require, there should be a Nuget package which contains only the code you need. All the core nuget packages support the new .NetStandard 1.3 profile (don't know what this is? Learn more ), .Net 4.5.1 and .Net 4.6. Where a package has a dependency on a third party package (such as Newtonsoft's Json.Net or .Net Core's Microsoft.Extensions.DependencyInjection packages), then we try to maintain full support for the same frameworks and profiles that those packages support. List of packages Rezolver . Rezolver.Configuration"
  },
  "rezolver-usage/nuget-packages/rezolver.configuration.html": {
    "href": "rezolver-usage/nuget-packages/rezolver.configuration.html",
    "title": "Nuget Package: Rezolver.Configuration",
    "keywords": "Improve this Doc Nuget Package: Rezolver.Configuration This package provides the Rezolver configuration object model, whose purpose is to describe how a Target Container should be constructed and configured based on a configuration file/script loaded at runtime. It doesn't define any specific code for parsing configuration files - but it does provide a standard implementation of the IConfigurationAdapter , whose job it is to create a ITargetContainer from a IConfiguration instance. You can implement your own configuration file formats with this simply by writing code to read your desired format and getting your parser to create an instance of IConfiguration"
  },
  "rezolver-usage/nuget-packages/rezolver.html": {
    "href": "rezolver-usage/nuget-packages/rezolver.html",
    "title": "Nuget Package: Rezolver",
    "keywords": "Improve this Doc Nuget Package: Rezolver See package page on nuget . The core nuget package for using Rezolver in your class library or application, includes all the core abstractions and classes required to create @TargetContainer objects and @Container objects in your composition root. Also contains the core ITarget implementations and logic which allow you to create/retrieve objects in numerous ways: Binding generic and non-generic class constructors using dynamically resolved arguments ( ConstructorTarget , GenericConstructorTarget and @Rezolver.RezolvedTarget) Invoking pre-built delegates (@Rezolver.DelegateTarget) Pre-built objects (@Rezolver.ObjectTarget) Dynamic code built from custom expression trees (@Rezolver.ExpressionTarget) Decoration (@Rezolver.DecoratorTarget) Singleton objects (@Rezolver.SingletonTarget) Scoped objects (@Rezolver.ScopedTarget)"
  },
  "rezolver-api/toc.html": {
    "href": "rezolver-api/toc.html",
    "title": "Table of Content",
    "keywords": ""
  },
  "toc.html": {
    "href": "toc.html",
    "title": "Table of Content",
    "keywords": ""
  },
  "rezolver-usage/toc.html": {
    "href": "rezolver-usage/toc.html",
    "title": "Table of Content",
    "keywords": ""
  },
  "rezolver-api/Microsoft.Extensions.DependencyInjection.IServiceCollectionExtensions.html": {
    "href": "rezolver-api/Microsoft.Extensions.DependencyInjection.IServiceCollectionExtensions.html",
    "title": "Class IServiceCollectionExtensions",
    "keywords": "Class IServiceCollectionExtensions Rezolver interop extension methods for the IServiceCollection class in Microsoft.Extensions.DependencyInjection Inheritance Object IServiceCollectionExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Microsoft.Extensions.DependencyInjection Assembly :cs.temp.dll.dll Syntax public static class IServiceCollectionExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateRezolverContainer(IServiceCollection) Creates a new default and registers the services in services as targets. Declaration public static IContainer CreateRezolverContainer(this IServiceCollection services) Parameters Name Type Description services IServiceCollection The services to be registered. Returns Type Description IContainer An instance Exceptions Type Condition System.ArgumentNullException If services is null. <!-- .classchild --> RegisterTargets(IServiceCollection, ITargetContainer) Registers services in services as targets in the passed targetContainer Declaration public static void RegisterTargets(this IServiceCollection services, ITargetContainer targetContainer) Parameters Name Type Description services IServiceCollection The services to b registered. targetContainer ITargetContainer The target container that is to receive the new registrations. Remarks This extension method just uses the method also found in this library. Exceptions Type Condition System.ArgumentNullException If either services or targetContainer are null. <!-- .classchild -->"
  },
  "rezolver-api/Microsoft.Extensions.DependencyInjection.RezolverServiceCollectionExtensions.html": {
    "href": "rezolver-api/Microsoft.Extensions.DependencyInjection.RezolverServiceCollectionExtensions.html",
    "title": "Class RezolverServiceCollectionExtensions",
    "keywords": "Class RezolverServiceCollectionExtensions Rezolver interop extension methods for the IServiceCollection class in Microsoft.Extensions.DependencyInjection Inheritance Object RezolverServiceCollectionExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Microsoft.Extensions.DependencyInjection Assembly :cs.temp.dll.dll Syntax public static class RezolverServiceCollectionExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateRezolverContainer(IServiceCollection) Creates a new default and registers the services in services as targets. Declaration public static IContainer CreateRezolverContainer(this IServiceCollection services) Parameters Name Type Description services IServiceCollection The services to be registered. Returns Type Description IContainer An instance Exceptions Type Condition System.ArgumentNullException If services is null. <!-- .classchild --> RegisterTargets(IServiceCollection, ITargetContainer) Registers services in services as targets in the passed targetContainer Declaration public static void RegisterTargets(this IServiceCollection services, ITargetContainer targetContainer) Parameters Name Type Description services IServiceCollection The services to be registered. targetContainer ITargetContainer The target container that is to receive the new registrations. Remarks This extension method just uses the method also found in this library. Exceptions Type Condition System.ArgumentNullException If either services or targetContainer are null. <!-- .classchild -->"
  },
  "rezolver-api/Microsoft.Extensions.DependencyInjection.html": {
    "href": "rezolver-api/Microsoft.Extensions.DependencyInjection.html",
    "title": "Namespace Microsoft.Extensions.DependencyInjection",
    "keywords": "Namespace Microsoft.Extensions.DependencyInjection Classes RezolverServiceCollectionExtensions Rezolver interop extension methods for the IServiceCollection class in Microsoft.Extensions.DependencyInjection"
  },
  "rezolver-api/Rezolver.AliasTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.AliasTargetContainerExtensions.html",
    "title": "Class AliasTargetContainerExtensions",
    "keywords": "Class AliasTargetContainerExtensions Contains extension methods for ITargetContainer to create targets which alias others by different types. Inheritance Object AliasTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class AliasTargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterAlias(ITargetContainer, Type, Type) Registers an alias for one type to another type. The created entry will effectively represent a second Resolve call into the container for the aliased type. Declaration public static void RegisterAlias(this ITargetContainer targetContainer, Type aliasType, Type originalType) Parameters Name Type Description targetContainer ITargetContainer The builder in which the alias is to be registered aliasType Type The type to be registered as an alias originalType Type The type being aliased. Remarks Use this when it's important that a given target type is always served through the same compiled target, even when the consumer expects it to be of a different type. A very common scenario is when you have a singleton instance of the originalType , and need to serve that same instance for aliasType . If you register the same singleton for both types, you get two separate singletons for each type, whereas if you create an alias, both will be served by the same alias. <!-- .classchild --> RegisterAlias<TAlias, TOriginal>(ITargetContainer) Generic version of RegisterAlias(ITargetContainer, Type, Type) , see that method for more. Declaration public static void RegisterAlias<TAlias, TOriginal>(this ITargetContainer targetContainer) Parameters Name Type Description targetContainer ITargetContainer The target container in which the alias is to be registered Type Parameters Name Description TAlias Type being registered as an alias to another type TOriginal The target type of the alias. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Builder.html": {
    "href": "rezolver-api/Rezolver.Builder.html",
    "title": "Class Builder",
    "keywords": "Class Builder Stores and retrieves registrations of ITarget s, is also Generic type aware, unlike its base class - TargetDictionaryContainer . Should be used as the root target container for implementations of IContainer . Inheritance Object TargetDictionaryContainer Builder Inherited Members Fetch(Type) FetchAll(Type) CombineWith(ITargetContainer, Type) ToString() Equals(Object) Equals(Object, Object) ReferenceEquals(Object, Object) GetHashCode() GetType() MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class Builder : TargetDictionaryContainer, ITargetContainerOwner, ITargetContainer Remarks This is the type used by default for the Rezolver.IContainer.Builder of the Container and ScopedContainer when you don't supply an instance of an ITargetContainer explicitly on construction. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors Builder(Boolean) Constructs a new instance of the Builder class Declaration public Builder(bool autoRezolveIEnumerable = true) Parameters Name Type Description autoRezolveIEnumerable Boolean If true, then IEnumerable<T> will be automatically resolved as a concatenation of all the ITarget s that are registered against a particular type. Note - this parameter might be removed in a future version - you can achieve the same thing by using the extension method Rezolver.EnumerableTargetBuilderExtensions.EnableEnumerableResolving(Rezolver.Builder) <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateContainer(Type, ITarget) Called to create and register a container for the given serviceType and target . This class overrides the base version ( CreateContainer(Type, ITarget) ) to create a specialised container for generic types ( GenericTargetContainer ) if serviceType if a generic type or generic type definition. Declaration protected override ITargetContainer CreateContainer(Type serviceType, ITarget target) Parameters Name Type Description serviceType Type The type for which a container is to be created and registered. target ITarget Optional. The target that will be added to the container that is returned. Returns Type Description ITargetContainer An ITargetContainer in which the passed target will be registered. Overrides CreateContainer(Type, ITarget) Remarks The main caller for this method will be the base Register method, which will create a new container for a target that's being registered against a new type. It is, however, also called by this class' implementation of RegisterContainer(Type, ITargetContainer) when the type is a generic type - as all generics must have a container registered against their generic type definitions as a starting point. <!-- .classchild --> CreateGenericTypeDefContainer(Type, ITarget) Called by CreateContainer(Type, ITarget) to create a container suitable for handling targets that are registered against generic types. Declaration protected virtual ITargetContainer CreateGenericTypeDefContainer(Type genericTypeDefinition, ITarget target) Parameters Name Type Description genericTypeDefinition Type Will be an open generic type (generic type definition) target ITarget Optional. The initial target for which the container is being constructed Returns Type Description ITargetContainer The base implementation always creates an instance of CreateGenericTypeDefContainer(Type, ITarget) <!-- .classchild --> FetchContainer(Type) Retrieves Declaration public override ITargetContainer FetchContainer(Type type) Parameters Name Type Description type Type Returns Type Description ITargetContainer Overrides FetchContainer(Type) <!-- .classchild --> Register(ITarget, Type) Declaration public override void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget serviceType Type Overrides Register(ITarget, Type) <!-- .classchild --> RegisterContainer(Type, ITargetContainer) Overrides the base method so that if type is a generic type, then the container will be registered inside another which will be registered for the generic type definition first. Declaration public override void RegisterContainer(Type type, ITargetContainer container) Parameters Name Type Description type Type container ITargetContainer Overrides RegisterContainer(Type, ITargetContainer) <!-- .classchild --> RegisterContainerDirect(Type, ITargetContainer) Version of RegisterContainer(Type, ITargetContainer) which does not interrogate the type to see if it's generic - simply registers the passed container directly against the passed type (it just chains through directly to the RegisterContainer(Type, ITargetContainer) method non-virtually. Declaration protected virtual void RegisterContainerDirect(Type type, ITargetContainer container) Parameters Name Type Description type Type container ITargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.CachingContainerBase.html": {
    "href": "rezolver-api/Rezolver.CachingContainerBase.html",
    "title": "Class CachingContainerBase",
    "keywords": "Class CachingContainerBase Builds on the ContainerBase base class to introduce thread-safe caching of compiled targets so they are only compiled once per requested type. Only creatable through inheritance. Inheritance Object ContainerBase CachingContainerBase Inherited Members ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Compiler ContainerBase.Targets ContainerBase.Resolve(RezolveContext) ContainerBase.TryResolve(RezolveContext, Object) ContainerBase.CreateLifetimeScope() ContainerBase.FetchCompiled(RezolveContext) ContainerBase.CanResolve(RezolveContext) ContainerBase.GetFallbackCompiledRezolveTarget(RezolveContext) Rezolver.ContainerBase.System.IServiceProvider.GetService(System.Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.Fetch(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.FetchAll(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer, System.Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class CachingContainerBase : ContainerBase, IContainer, IServiceProvider, ITargetContainer Remarks Internally, the class uses a to store ICompiledTarget s keyed by the requested type. All the main IContainer implementations used directly in an application should inherit from this class, because otherwise every Resolve(RezolveContext) operation would require a compilation phase before the object could be returned, which would be incredibly slow. It's because of this caching that registering new targets in any ITargetContainer used by this class is not recommended: because after the first request for a particular type is made, the resultant ICompiledTarget is fixed until the container is thrown away. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors CachingContainerBase(ITargetContainer, ITargetCompiler) Initializes a new instance of the CachingContainerBase class. Declaration protected CachingContainerBase(ITargetContainer targets = null, ITargetCompiler compiler = null) Parameters Name Type Description targets ITargetContainer Optional. Contains the targets that will be used to create the ICompiledTarget s that this container will use to produce objects when requested. If not provided, then the base class' default (see ContainerBase(ITargetContainer, ITargetCompiler) ) will be used. compiler ITargetCompiler Optional. The compiler that will be used to compile the ITarget s in the targets container into ICompiledTarget s. If not provided, then the base class' default (see ContainerBase(ITargetContainer, ITargetCompiler) ) will be used. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetCompiledRezolveTarget(RezolveContext) Obtains an ICompiledTarget for the given context . Declaration protected override ICompiledTarget GetCompiledRezolveTarget(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description ICompiledTarget Overrides ContainerBase.GetCompiledRezolveTarget(RezolveContext) Remarks The method is called by Resolve(RezolveContext) to get the compiled target whose GetObject(RezolveContext) method is to be used to get the instance that is to be resolved for a given request. The internal cache is examined first to see if an entry exists for the RequestedType type and, if not, then the result of the base class' GetCompiledRezolveTarget(RezolveContext) is cached and returned. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ChangeTypeTarget.html": {
    "href": "rezolver-api/Rezolver.ChangeTypeTarget.html",
    "title": "Class ChangeTypeTarget",
    "keywords": "Class ChangeTypeTarget This target is specifically used for explicitly casting the result of one target to another type. It's effectively the same as inserting a ConvertExpression around an expression. Its use is rare. Inheritance Object TargetBase ChangeTypeTarget Inherited Members TargetBase.UseFallback TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ChangeTypeTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ChangeTypeTarget(ITarget, Type) Creates a new instance of the ChangeTypeTarget class. Declaration public ChangeTypeTarget(ITarget innerTarget, Type targetType) Parameters Name Type Description innerTarget ITarget Required. See InnerTarget targetType Type Required. See DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties DeclaredType Always returns the target type that was passed in the ChangeTypeTarget(ITarget, Type) constructor. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> InnerTarget The target whose type will be changed to DeclaredType . Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget <!-- .classchild --> SuppressScopeTracking Always returns true. Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides TargetBase.SuppressScopeTracking <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateExpressionBase(CompileContext) Returns a Linq Convert expression ( created through the factory method) whose inner expression is the expression built by the InnerTarget for its DeclaredType . Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides TargetBase.CreateExpressionBase(CompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ChildBuilder.html": {
    "href": "rezolver-api/Rezolver.ChildBuilder.html",
    "title": "Class ChildBuilder",
    "keywords": "Class ChildBuilder A Builder which acts as a child of another builder. When it's looking to find an entry for a type, if it cannot find one within its own registrations, it will forward the call on to its Parent . This means that a child builder can override any registrations that are present in its parent. Inheritance Object TargetDictionaryContainer Builder ChildBuilder Inherited Members CreateContainer(Type, ITarget) CreateGenericTypeDefContainer(Type, ITarget) FetchContainer(Type) Register(ITarget, Type) RegisterContainer(Type, ITargetContainer) RegisterContainerDirect(Type, ITargetContainer) CombineWith(ITargetContainer, Type) ToString() Equals(Object) Equals(Object, Object) ReferenceEquals(Object, Object) GetHashCode() GetType() MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ChildBuilder : Builder, ITargetContainerOwner, IChildTargetContainer, ITargetContainer <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ChildBuilder(ITargetContainer) Declaration public ChildBuilder(ITargetContainer parent) Parameters Name Type Description parent ITargetContainer <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties Parent Declaration public ITargetContainer Parent { get; } Property Value Type Description ITargetContainer Implements Parent <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods Fetch(Type) Declaration public override ITarget Fetch(Type type) Parameters Name Type Description type Type Returns Type Description ITarget Overrides Fetch(Type) Implements Fetch(Type) <!-- .classchild --> FetchAll(Type) Declaration public override IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type Type Returns Type Description IEnumerable < ITarget > Overrides FetchAll(Type) Implements FetchAll(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITargetCompiler.html": {
    "href": "rezolver-api/Rezolver.ITargetCompiler.html",
    "title": "Interface ITargetCompiler",
    "keywords": "Interface ITargetCompiler An object that produces ICompiledTarget s from ITarget s given a particular CompileContext . Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITargetCompiler <!-- <hr class=\"typeSectionDivider\" /> --> Methods CompileTarget(ITarget, CompileContext) Create the ICompiledTarget for the given target using the context to inform the type of object that is to be built, and for compile-time dependency resolution. Declaration ICompiledTarget CompileTarget(ITarget target, CompileContext context) Parameters Name Type Description target ITarget Required. The target to be compiled. context CompileContext Required. The current compilation context. Returns Type Description ICompiledTarget A compiled target which can then be used to get produce objects represented by the target . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITargetContainer.html": {
    "href": "rezolver-api/Rezolver.ITargetContainer.html",
    "title": "Interface ITargetContainer",
    "keywords": "Interface ITargetContainer Stores and retrieves ITarget instances, keyed by the type of service that the targets are registered against. Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITargetContainer Remarks You do not resolve objects from a target container, instead, it holds the ITarget s which will later be compiled to produce the objects. An IContainer typically uses this as the source of the registrations that it uses to resolve objects in its Resolve(RezolveContext) method via it's property. Note that there are multiple implementations of this interface in the framework, however the two you will use most commonly are TargetContainer and ChildTargetContainer . <!-- <hr class=\"typeSectionDivider\" /> --> Methods CombineWith(ITargetContainer, Type) If supported by the implementation, this gets the container built from combining this container with an existing container as part of a registration inside another ITargetContainerOwner . Declaration ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer The existing ITargetContainer instance that this instance is to be combined with type Type The type that the combined container owner will be registered under. Returns Type Description ITargetContainer Remarks Used most frequently in implementations of RegisterContainer(Type, ITargetContainer) when a container owner is already registered against the type, and a new container owner is then registered against the same type. This behaviour is used to implement open generics and decorators, and can be used to implement more besides. Exceptions Type Condition System.NotSupportedException If this container doesn't support being combined with another. <!-- .classchild --> Fetch(Type) Retrieves a target for a particular type, or null if no target is registered against that type. Declaration ITarget Fetch(Type type) Parameters Name Type Description type Type Required. The type for which an ITarget is to be retrieved. Returns Type Description ITarget The target for the given type , or null if no target is found. Remarks The target you receive from this method depends entirely on the implementation. It could be the last target to be registered against the type or the first, or another target entirely. As mentioned in the documentation for the Register(ITarget, Type) method - the only guarantee is that if at least one target has been registered for the same type, then this method should return a valid target. <!-- .classchild --> FetchAll(Type) Retrieves an enumerable of all targets that have been registered for a particular type . Declaration IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type Type Required. The type for which the ITarget s are to be retrieved. Returns Type Description IEnumerable < ITarget > An enumerable containing all the targets that have been registered against the given type , or, an empty enumerable if no targets have been registered. Remarks As with Fetch(Type) , the only guarantee is that if a target has been registered for the type through a call to Register(ITarget, Type) , then the returned enumerable will contain at least one valid target. <!-- .classchild --> Register(ITarget, Type) Registers a target, either for the serviceType specified or, if null, the DeclaredType of the target . Declaration void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget Required. The target to be registered serviceType Type Optional. The type the target is to be registered against, if different from the DeclaredType of the target . If provided, then the target must be compatible with this type. Remarks The interface does not define the behaviour for when multiple targets are registered against the same type - although the default behaviour of the framework (via the TargetContainer class) is to allow this, with the last registered target being treated as the 'default' for that type. The only guarantee expected by the framework from implementations of this interface is that if a target is registered against a given type with this method, then a Fetch(Type) operation with the same type should return a valid target, and a FetchAll(Type) operation should return a non-empty enumerable of targets. Exceptions Type Condition System.ArgumentException If serviceType is non-null and the target 's SupportsType(Type) method returns false for that type. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.ITargetContainerExtensions.html",
    "title": "Class ITargetContainerExtensions",
    "keywords": "Class ITargetContainerExtensions Extension methods for implementations of ITargetContainer . Inheritance Object ITargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ITargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods RegisterAlias(ITargetContainer, Type, Type) Registers an alias for one type to another type. The created entry will effectively represent a second Resolve call into the container for the aliased type. Declaration public static void RegisterAlias(this ITargetContainer builder, Type aliasType, Type aliasedType) Parameters Name Type Description builder ITargetContainer The builder in which the alias is to be registered aliasType Type The type to be registered as an alias aliasedType Type The type being aliased. Remarks Use this when it's important that a given target type is always served through the same compiled target, even when the consumer expects it to be of a different type. A very common scenario is when you have a singleton instance of the aliasedType , and need to serve that same instance for aliasType . If you register the same singleton for both types, you get two separate singletons for each type. <!-- .classchild --> RegisterAlias<TAlias, TAliased>(ITargetContainer) Generic version of , see that method for more. Declaration public static void RegisterAlias<TAlias, TAliased>(this ITargetContainer builder) Parameters Name Type Description builder ITargetContainer RegisterAlias<TAlias, TAliased>(ITargetContainer) Type Parameters Name Description TAlias Type being registered as an alias to another type TAliased The target type of the alias. <!-- .classchild --> RegisterAll(ITargetContainer, ITarget[]) Batch-registers multiple targets with different contracts. This is like calling multiple times, once for each of the targets in the array. Declaration public static void RegisterAll(this ITargetContainer builder, params ITarget[] targets) Parameters Name Type Description builder ITargetContainer The builder. targets ITarget [] The targets to be registered. <!-- .classchild --> RegisterAll(ITargetContainer, IEnumerable<ITarget>) Batch-registers multiple targets with different contracts. This is like calling multiple times, once for each of the targets in the enumerable. Declaration public static void RegisterAll(this ITargetContainer builder, IEnumerable<ITarget> targets) Parameters Name Type Description builder ITargetContainer The builder. targets IEnumerable < ITarget > The targets to be registered <!-- .classchild --> RegisterDecorator(ITargetContainerOwner, Type, Type) Declaration public static void RegisterDecorator(this ITargetContainerOwner builder, Type decoratorType, Type decoratedType) Parameters Name Type Description builder ITargetContainerOwner decoratorType Type decoratedType Type <!-- .classchild --> RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) Declaration public static void RegisterDecorator<TDecorator, TDecorated>(this ITargetContainerOwner builder) Parameters Name Type Description builder ITargetContainerOwner Type Parameters Name Description TDecorator TDecorated <!-- .classchild --> RegisterExpression<T>(ITargetContainer, Expression<Func<RezolveContextExpressionHelper, T>>, Type, ITargetAdapter) Registers an expression to be used as a factory for obtaining an instance when the registration matches a resolve request. Declaration public static void RegisterExpression<T>(this ITargetContainer builder, Expression<Func<RezolveContextExpressionHelper, T>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description builder ITargetContainer expression Expression < Func < RezolveContextExpressionHelper , T>> The expression to be analysed and used as a factory. The argument that is received by this expression can be used to emit explicit calls back into the resolver to indicate that a particular argument/property value or whatever should be resolved. type Type Optional. The type against which the registration is to be made, if different from T . adapter ITargetAdapter Optional. The adapter that will be used to convert the expression into an ITarget . This defaults to Default . Extending this is an advanced topic and shouldn't be required in most cases. Type Parameters Name Description T Remarks This is not the same as registering a factory delegate for creating objects - where the code you supply is already compiled and ready to go. The expression that is passed is analysed by the adapter (or the default) and rewritten according to the expressions container within. In general, there is a one to one mapping between the code you provide and the code that's produced, but it's not guaranteed. In particular, calls back to the resolver to resolve dependencies are identified and turned into a different representation internally, so that dependency resolution works inside your code in just the same way as it does when using the higher-level targets. <!-- .classchild --> RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) Called to register multiple rezolve targets against a shared contract, optionally replacing any existing registration(s) or extending them. It is analogous to calling Register(ITarget, Type) multiple times with the different targets. Declaration public static void RegisterMultiple(this ITargetContainer builder, IEnumerable<ITarget> targets, Type commonServiceType = null) Parameters Name Type Description builder ITargetContainer The builder in which the registration is to be performed. targets IEnumerable < ITarget > The targets to be registered - all must support a common service type (potentially passed in the commonServiceType argument. commonServiceType Type Optional - instead of determining the common service type automatically, you can provide it in advance through this parameter. Note that all targets must support this type. <!-- .classchild --> RegisterObject<T>(ITargetContainer, T, Type, Boolean) Registers a single instance (already created) to be used when resolving a particular service type. If using a scope, then the object will be tracked in the rootmost scope so that, if it's disposable, it will be disposed when the root scope is disposed. Declaration public static void RegisterObject<T>(this ITargetContainer builder, T obj, Type serviceType = null, bool suppressScopeTracking = true) Parameters Name Type Description builder ITargetContainer obj T The object to be returned when resolving. serviceType Type The service type against which this object is to be registered, if different from T . suppressScopeTracking Boolean Type Parameters Name Description T Type of the object - will be used as the service type for registration if serviceType is not provied. <!-- .classchild --> RegisterScoped(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Version of RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) that creates instances that are scoped to the active IScopedContainer at the time Resolve(RezolveContext) (or TryResolve(RezolveContext, out Object) ) is called. Declaration public static void RegisterScoped(this ITargetContainer builder, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer objectType Type RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) serviceType Type RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) propertyBindingBehaviour IPropertyBindingBehaviour RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) <!-- .classchild --> RegisterScoped<TObject>(ITargetContainer, IPropertyBindingBehaviour) Version of RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) that creates instances that are scoped to the active IScopedContainer at the time Resolve(RezolveContext) (or TryResolve(RezolveContext, out Object) ) is called. Declaration public static void RegisterScoped<TObject>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour See RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) <!-- .classchild --> RegisterScoped<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Version of RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) that creates instances that are scoped to the active IScopedContainer at the time Resolve(RezolveContext) (or TryResolve(RezolveContext, out Object) ) is called. Declaration public static void RegisterScoped<TObject, TService>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) TService See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) <!-- .classchild --> RegisterSingleton(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Version of RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) that creates singleton instances that are also scoped to the root scope of the active IScopedContainer at the time Resolve(RezolveContext) (or TryResolve(RezolveContext, out Object) ) is called. Declaration public static void RegisterSingleton(this ITargetContainer builder, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer objectType Type RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) serviceType Type RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) propertyBindingBehaviour IPropertyBindingBehaviour RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) <!-- .classchild --> RegisterSingleton<TObject>(ITargetContainer, IPropertyBindingBehaviour) Version of RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) that creates singleton instances that are also scoped to the root scope of the active IScopedContainer at the time Resolve(RezolveContext) (or TryResolve(RezolveContext, out Object) ) is called. Declaration public static void RegisterSingleton<TObject>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour See RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) <!-- .classchild --> RegisterSingleton<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Version of RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) that creates singleton instances that are also scoped to the root scope of the active IScopedContainer at the time Resolve(RezolveContext) (or TryResolve(RezolveContext, out Object) ) is called. Declaration public static void RegisterSingleton<TObject, TService>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) TService See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) <!-- .classchild --> RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Non-generic version of RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) . Declaration public static void RegisterType(this ITargetContainer targets, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targets ITargetContainer objectType Type Required. Type of object to be constructed serviceType Type See Register(ITarget, Type) propertyBindingBehaviour IPropertyBindingBehaviour RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) <!-- .classchild --> RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) Registers a type to be created by the Rezolver via construction. The registration will auto-bind a constructor (most greedy) on the type and optionally bind any properties/fields on the new object, depending on the IPropertyBindingBehaviour object passed. Note that this method supports open generics. Declaration public static void RegisterType<TObject>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour The property binding behaviour. If null, then no properties are bound. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via their 'Auto' static methods and then registering them. <!-- .classchild --> RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) This is the same as RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) , except the TService type parameter allows you to explicitly set the type against which the registration is to be made. Declaration public static void RegisterType<TObject, TService>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null)where TObject : TService Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) TService The type against which the registration is to be made in the builder. E.g. 'IFoo' when TObject is 'Foo'. Remarks Please note the generic parameter constraints on this method: TService must have TObject as a base or interface in order for your code to compile. Note that if you use the RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) overload, then this is not the case. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITargetContainerMSDIExtensions.html": {
    "href": "rezolver-api/Rezolver.ITargetContainerMSDIExtensions.html",
    "title": "Class ITargetContainerMSDIExtensions",
    "keywords": "Class ITargetContainerMSDIExtensions Inheritance Object ITargetContainerMSDIExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ITargetContainerMSDIExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods Populate(ITargetContainer, IServiceCollection) Declaration public static void Populate(this ITargetContainer targets, IServiceCollection services) Parameters Name Type Description targets ITargetContainer services IServiceCollection <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITargetContainerOwner.html": {
    "href": "rezolver-api/Rezolver.ITargetContainerOwner.html",
    "title": "Interface ITargetContainerOwner",
    "keywords": "Interface ITargetContainerOwner Interface for an ITargetContainer which also contains other target containers. Inherited Members ITargetContainer.Register(ITarget, Type) ITargetContainer.Fetch(Type) ITargetContainer.FetchAll(Type) ITargetContainer.CombineWith(ITargetContainer, Type) Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITargetContainerOwner : ITargetContainer <!-- <hr class=\"typeSectionDivider\" /> --> Methods FetchContainer(Type) Retrieves an existing container registered against the given type , or null if not found. Declaration ITargetContainer FetchContainer(Type type) Parameters Name Type Description type Type Returns Type Description ITargetContainer <!-- .classchild --> RegisterContainer(Type, ITargetContainer) Registers a container against a given type . If a container already exists against this type, and the new container is an ITargetContainerOwner , then the container that is returned by its method will replace the existing one. Declaration void RegisterContainer(Type type, ITargetContainer container) Parameters Name Type Description type Type container ITargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.LifetimeScopeRezolverExtensions.html": {
    "href": "rezolver-api/Rezolver.LifetimeScopeRezolverExtensions.html",
    "title": "Class LifetimeScopeRezolverExtensions",
    "keywords": "Class LifetimeScopeRezolverExtensions Inheritance Object LifetimeScopeRezolverExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class LifetimeScopeRezolverExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods GetOrAdd<T>(IScopedContainer, RezolveContext, Func<RezolveContext, T>, Boolean) Declaration public static T GetOrAdd<T>(this IScopedContainer scope, RezolveContext context, Func<RezolveContext, T> factory, bool disposableOnly = true) Parameters Name Type Description scope IScopedContainer context RezolveContext factory Func < RezolveContext , T> disposableOnly Boolean Returns Type Description T Type Parameters Name Description T <!-- .classchild --> GetScopeRoot(IScopedContainer) As the name suggests - this grabs the root scope for the scope on which this method is invoked. Declaration public static IScopedContainer GetScopeRoot(this IScopedContainer scope) Parameters Name Type Description scope IScopedContainer The scope whose root scope is sought. If null, then the method also returns null. Returns Type Description IScopedContainer An IScopedContainer reference representing the top-level (root) scope for the passed scope. <!-- .classchild --> GetSingleFromScope(IScopedContainer, RezolveContext) Retrieves a single instance that was previously added to the scope (or, optionally parent scopes) through a call to AddToScope(Object, RezolveContext) with a RezolveContext matching the one passed. Note - if multiple matches are found in a single scope, an InvalidOperationException will be thrown. Declaration public static object GetSingleFromScope(this IScopedContainer scope, RezolveContext context) Parameters Name Type Description scope IScopedContainer Required. The scope to be searched and optionally whose parent scopes are to be searched. context RezolveContext Required. The context whose properties will be used to find the matching disposable. Returns Type Description Object <!-- .classchild --> TrackIfScopedAndDisposableAndReturn<T>(IScopedContainer, T) This is primarily used by the dynamic code generated by RezolveTargetBase - if the scope is non-null and the instance is an IDiposable, then the object will be added to the scope. The instance , either way, is returned to simplify the function's use in dynamic code produced from expression trees. Declaration public static T TrackIfScopedAndDisposableAndReturn<T>(this IScopedContainer scope, T instance) Parameters Name Type Description scope IScopedContainer instance T Returns Type Description T Type Parameters Name Description T <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ListTarget.html": {
    "href": "rezolver-api/Rezolver.ListTarget.html",
    "title": "Class ListTarget",
    "keywords": "Class ListTarget This exists primarily for the configuration system. This target produces arrays or lists whose individual items are built by IRezolveTarget instances. If you are setting up your container environment from code - e.g. using expressions, then you shouldn't need to use this unless you have some pretty extreme requirements for the different targets that will contribute each element of your list/array. Inheritance Object TargetBase ListTarget Inherited Members TargetBase.SuppressScopeTracking TargetBase.CreateScopeTrackingExpression(CompileContext, Expression) TargetBase.CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) TargetBase.CreateScopeSelectionExpression(CompileContext, Expression) TargetBase.SupportsType(Type) TargetBase.CreateExpression(CompileContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ListTarget : TargetBase, ITarget Remarks The element type you feed on construction determines the type of array or the generic argument to List<T>. Each of the rezolve targets that you then pass must support that type. You can control whether the created instance is an array or a List<T> with the 'asArray' boolean constructor argument. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors ListTarget(Type, IEnumerable<ITarget>, Boolean) Initializes a new instance of the ListTarget class. Declaration public ListTarget(Type elementType, IEnumerable<ITarget> items, bool asArray = false) Parameters Name Type Description elementType Type Required. Type of the elements in the array or list. items IEnumerable < ITarget > Required. The targets that will create each the individual items. asArray Boolean A boolean indicating whether the target will build an array ( true ) or a list ( false ). Exceptions Type Condition System.ArgumentNullException elementType or items System.ArgumentException All targets in the items enumerable must be non-null;items or All targets in the items enumerable must support the element type elementType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties AsArray Gets a value indicating whether the target will build an array ( true ) or a list ( false ). Declaration public bool AsArray { get; } Property Value Type Description Boolean <!-- .classchild --> DeclaredType Implementation of the abstract property from the base. This will always return either a type equal to an array of ElementType , or List<T> with ElementType as the generic parameter. This is controlled by the AsArray property. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType <!-- .classchild --> ElementType Gets the declared type of each element in the array or list that will be constructed. The DeclaredType returned by this instance will either be ElementType[] or List<ElementType> depending on the value of AsArray . Declaration public Type ElementType { get; } Property Value Type Description Type The declared type of each element. <!-- .classchild --> Items Gets the rezolve targets that will build each individual item in the resulting list or array. Declaration public IEnumerable<ITarget> Items { get; } Property Value Type Description IEnumerable < ITarget > The items. <!-- .classchild --> UseFallback Returns true if the Items enumerable is empty. Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides TargetBase.UseFallback <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods CreateExpressionBase(CompileContext) Constructs an expression that represents building an array of ElementType or List< ElementType > depending on the value of AsArray . Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext The current compile context Returns Type Description Expression System.Linq.Expressions.Expression. Overrides TargetBase.CreateExpressionBase(CompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.MethodCallExtractor.html": {
    "href": "rezolver-api/Rezolver.MethodCallExtractor.html",
    "title": "Class MethodCallExtractor",
    "keywords": "Class MethodCallExtractor Inheritance Object MethodCallExtractor Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public sealed class MethodCallExtractor : ExpressionVisitor <!-- <hr class=\"typeSectionDivider\" /> --> Properties CalledConstructor Declaration public ConstructorInfo CalledConstructor { get; } Property Value Type Description ConstructorInfo <!-- .classchild --> CalledMethod Declaration public MethodInfo CalledMethod { get; } Property Value Type Description MethodInfo <!-- .classchild --> CallExpression Declaration public MethodCallExpression CallExpression { get; } Property Value Type Description MethodCallExpression <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods ExtractCalledMethod(Expression<Action>) Declaration public static MethodInfo ExtractCalledMethod(Expression<Action> expr) Parameters Name Type Description expr Expression < System.Action > Returns Type Description MethodInfo <!-- .classchild --> ExtractCalledMethod<T>(Expression<Action<T>>) Declaration public static MethodInfo ExtractCalledMethod<T>(Expression<Action<T>> expr) Parameters Name Type Description expr Expression < System.Action <T>> Returns Type Description MethodInfo Type Parameters Name Description T <!-- .classchild --> ExtractCalledMethod<TResult>(Expression<Func<TResult>>) Declaration public static MethodInfo ExtractCalledMethod<TResult>(Expression<Func<TResult>> expr) Parameters Name Type Description expr Expression < Func <TResult>> Returns Type Description MethodInfo Type Parameters Name Description TResult <!-- .classchild --> ExtractCalledMethod<TInstance, TResult>(Expression<Func<TInstance, TResult>>) Declaration public static MethodInfo ExtractCalledMethod<TInstance, TResult>(Expression<Func<TInstance, TResult>> expr) Parameters Name Type Description expr Expression < Func <TInstance, TResult>> Returns Type Description MethodInfo Type Parameters Name Description TInstance TResult <!-- .classchild --> ExtractConstructorCall(Expression<Action>) Declaration public static ConstructorInfo ExtractConstructorCall(Expression<Action> expr) Parameters Name Type Description expr Expression < System.Action > Returns Type Description ConstructorInfo <!-- .classchild --> ExtractConstructorCall<T>(Expression<Action<T>>) Declaration public static ConstructorInfo ExtractConstructorCall<T>(Expression<Action<T>> expr) Parameters Name Type Description expr Expression < System.Action <T>> Returns Type Description ConstructorInfo Type Parameters Name Description T <!-- .classchild --> ExtractConstructorCall<TResult>(Expression<Func<TResult>>) Declaration public static ConstructorInfo ExtractConstructorCall<TResult>(Expression<Func<TResult>> expr) Parameters Name Type Description expr Expression < Func <TResult>> Returns Type Description ConstructorInfo Type Parameters Name Description TResult <!-- .classchild --> ExtractConstructorCall<TInstance, TResult>(Expression<Func<TInstance, TResult>>) Declaration public static ConstructorInfo ExtractConstructorCall<TInstance, TResult>(Expression<Func<TInstance, TResult>> expr) Parameters Name Type Description expr Expression < Func <TInstance, TResult>> Returns Type Description ConstructorInfo Type Parameters Name Description TInstance TResult <!-- .classchild --> VisitMethodCall(MethodCallExpression) Declaration protected override Expression VisitMethodCall(MethodCallExpression node) Parameters Name Type Description node MethodCallExpression Returns Type Description Expression <!-- .classchild --> VisitNew(NewExpression) Declaration protected override Expression VisitNew(NewExpression node) Parameters Name Type Description node NewExpression Returns Type Description Expression <!-- .classchild -->"
  }
}