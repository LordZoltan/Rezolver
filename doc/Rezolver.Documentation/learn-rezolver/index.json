{
  "rezolver-api/Rezolver.Configuration.IConfigurationAdapter.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationAdapter.html",
    "title": "Interface IConfigurationAdapter",
    "keywords": "Improve this Doc Interface IConfigurationAdapter Represents an object that is responsible for transforming configuration data into target containers. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationAdapter <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateTargetContainer(IConfiguration) Creates an ITargetContainer instance from an IConfiguration instance. Declaration ITargetContainer CreateTargetContainer(IConfiguration configuration) Parameters Name Type Description configuration IConfiguration Required - the configuration object that is to be used to build a container. Returns Type Description ITargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfiguration.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfiguration.html",
    "title": "Interface IConfiguration",
    "keywords": "Improve this Doc Interface IConfiguration Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfiguration <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Entries Declaration IEnumerable<IConfigurationEntry> Entries { get; } Property Value Type Description System.Collections.Generic.IEnumerable < IConfigurationEntry > <!-- .classchild --> | Improve this Doc FileName Declaration string FileName { get; } Property Value Type Description System.String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IAssemblyReferenceEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.IAssemblyReferenceEntry.html",
    "title": "Interface IAssemblyReferenceEntry",
    "keywords": "Improve this Doc Interface IAssemblyReferenceEntry A configuration entry instructing the configuration adapter to load an assembly before resolving types. Inherited Members Type StartLineNo StartLinePos EndLineNo EndLinePos Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IAssemblyReferenceEntry : IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc AssemblyName Declaration string AssemblyName { get; } Property Value Type Description System.String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConstructorTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConstructorTargetMetadata.html",
    "title": "Class ConstructorTargetMetadata",
    "keywords": "Improve this Doc Class ConstructorTargetMetadata Inheritance System.Object RezolveTargetMetadataBase ConstructorTargetMetadata Inherited Members Type CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Bind(ITypeReference[]) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConstructorTargetMetadata : RezolveTargetMetadataBase, IConstructorTargetMetadata, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ConstructorTargetMetadata(ITypeReference[], ITypeReference[], IDictionary<String, IRezolveTargetMetadata>) Constructs a new instance of the ConstructorTargetMetadata class. Declaration public ConstructorTargetMetadata(ITypeReference[] typesToBuild, ITypeReference[] signatureTypes = null, IDictionary<string, IRezolveTargetMetadata> args = null) Parameters Name Type Description typesToBuild ITypeReference [] The types to build. signatureTypes ITypeReference [] The types of the parameters for the constructor that is to be bound. If null, then the constructor is to be sought by finding the best match based on the arguments (if provided). This is typically required if you have an ambiguity when matching purely by name. args System.Collections.Generic.IDictionary < System.String , IRezolveTargetMetadata > The arguments. Remarks Please note that although the typesToBuild parameter is an array, in practise only one type can ever be built. Multiple types are accepted to cover scenarios where a class, its bases and zero or more interfaces are all referenced as target registration types, and these types are passed directly to the constructor target. In building such a target from the metadata an adapter will typically find the most derived type of the group and bind to that only. Note that if one or more types are not related to the rest of the group, then an adapter is free to throw a runtime error. Exceptions Type Condition System.ArgumentNullException typesToBuild System.ArgumentException The array cannot be empty;typesToBuild or All entries in the array must be non-null;typesToBuild <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Arguments Declaration public IDictionary<string, IRezolveTargetMetadata> Arguments { get; } Property Value Type Description System.Collections.Generic.IDictionary < System.String , IRezolveTargetMetadata > Implements Arguments <!-- .classchild --> | Improve this Doc DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides DeclaredType Implements DeclaredType <!-- .classchild --> | Improve this Doc SignatureTypes Declaration public ITypeReference[] SignatureTypes { get; } Property Value Type Description ITypeReference [] Implements SignatureTypes <!-- .classchild --> | Improve this Doc TypesToBuild Remember - the intention is that only one of these types will actually be bound on constructing the constructor target. Declaration public ITypeReference[] TypesToBuild { get; } Property Value Type Description ITypeReference [] Implements TypesToBuild <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides BindBase(ITypeReference[]) <!-- .classchild --> | Improve this Doc CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes System.Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description ITarget Overrides CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationException.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationException.html",
    "title": "Class ConfigurationException",
    "keywords": "Improve this Doc Class ConfigurationException Inheritance System.Object System.Exception ConfigurationException Inherited Members System.Exception.GetBaseException() System.Exception.ToString() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.Data System.Exception.InnerException System.Exception.TargetSite System.Exception.StackTrace System.Exception.HelpLink System.Exception.Source System.Exception.HResult System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationException : Exception, ISerializable, _Exception <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ConfigurationException(ConfigurationAdapterContext) Declaration public ConfigurationException(ConfigurationAdapterContext context) Parameters Name Type Description context ConfigurationAdapterContext <!-- .classchild --> | Improve this Doc ConfigurationException(IConfiguration, IEnumerable<IConfigurationError>) Declaration public ConfigurationException(IConfiguration configuration, IEnumerable<IConfigurationError> errors) Parameters Name Type Description configuration IConfiguration errors System.Collections.Generic.IEnumerable < IConfigurationError > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Message Declaration public override string Message { get; } Property Value Type Description System.String Overrides System.Exception.Message <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationError.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationError.html",
    "title": "Class ConfigurationError",
    "keywords": "Improve this Doc Class ConfigurationError Inheritance System.Object ConfigurationError Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationError : IConfigurationError <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ConfigurationError(Exception, IConfigurationLineInfo) Declaration public ConfigurationError(Exception exception, IConfigurationLineInfo lineInfo) Parameters Name Type Description exception System.Exception lineInfo IConfigurationLineInfo <!-- .classchild --> | Improve this Doc ConfigurationError(String, IConfigurationLineInfo) Declaration public ConfigurationError(string errorMessage, IConfigurationLineInfo lineInfo) Parameters Name Type Description errorMessage System.String lineInfo IConfigurationLineInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc ErrorMessage Declaration public string ErrorMessage { get; } Property Value Type Description System.String Implements ErrorMessage <!-- .classchild --> | Improve this Doc ErrorMessageWithLineInfo Declaration public string ErrorMessageWithLineInfo { get; } Property Value Type Description System.String Implements ErrorMessageWithLineInfo <!-- .classchild --> | Improve this Doc Exception Declaration public Exception Exception { get; } Property Value Type Description System.Exception <!-- .classchild --> | Improve this Doc IsException Declaration public bool IsException { get; } Property Value Type Description System.Boolean <!-- .classchild --> | Improve this Doc LineInfo Declaration public IConfigurationLineInfo LineInfo { get; } Property Value Type Description IConfigurationLineInfo Implements LineInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc UnexpectedMetadataType(RezolveTargetMetadataType, Type, Type, IConfigurationLineInfo) Declaration public static ConfigurationError UnexpectedMetadataType(RezolveTargetMetadataType type, Type expected, Type actual, IConfigurationLineInfo lineInfo) Parameters Name Type Description type RezolveTargetMetadataType expected System.Type actual System.Type lineInfo IConfigurationLineInfo Returns Type Description ConfigurationError <!-- .classchild --> | Improve this Doc UnresolvedType(ITypeReference) Declaration public static ConfigurationError UnresolvedType(ITypeReference typeReference) Parameters Name Type Description typeReference ITypeReference Returns Type Description ConfigurationError <!-- .classchild --> | Improve this Doc UnresolvedType(String, IConfigurationLineInfo) Declaration public static ConfigurationError UnresolvedType(string typeName, IConfigurationLineInfo lineInfo) Parameters Name Type Description typeName System.String lineInfo IConfigurationLineInfo Returns Type Description ConfigurationError <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationEntryType.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationEntryType.html",
    "title": "Enum ConfigurationEntryType",
    "keywords": "Improve this Doc Enum ConfigurationEntryType Types of configuration entry that can be parsed from a configuration file Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public enum ConfigurationEntryType <!-- <hr class=\"typeSectionDivider\" /> --> Fields | Improve this Doc AssemblyReference An instruction to load one or more assemblies before any type registrations are processed Depending on the runtime environment, to be sure of the type binder finding namespace-qualified types mentioned in a configuration file, then any assemblies you might be referencing should be included in your configuration file. Equally, you can use this to load assemblies that wouldn't normally be found (e.g. a la unity) Note that types which would usually be found with a simple call to Type.GetType do not need their parent assemblies explicitly referenced. Declaration AssemblyReference = 1 Field Value Type Description ConfigurationEntryType <!-- .classchild --> | Improve this Doc Extension A custom entry - the instance should also have the interface IConfigurationExtensionEntry Declaration Extension = 2147483647 Field Value Type Description ConfigurationEntryType <!-- .classchild --> | Improve this Doc NamedBuilder An instruction to create a named builder in the target builder, within which further named builders or type registrations might be performed. Declaration NamedBuilder = 11 Field Value Type Description ConfigurationEntryType <!-- .classchild --> | Improve this Doc NamespaceImport Just like 'using' or 'import' in C# or VB, this allows you to specify namespaces that you will be using in your type names elsewhere in a configuration file. Declaration NamespaceImport = 2 Field Value Type Description ConfigurationEntryType <!-- .classchild --> | Improve this Doc TypeRegistration The most common type - an instruction to generate one or more type registrations in the target builder Declaration TypeRegistration = 10 Field Value Type Description ConfigurationEntryType <!-- .classchild --> | Improve this Doc Unknown Declaration Unknown = 0 Field Value Type Description ConfigurationEntryType <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationEntryBase.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationEntryBase.html",
    "title": "Class ConfigurationEntryBase",
    "keywords": "Improve this Doc Class ConfigurationEntryBase suggested starting point for implementing your own configuration entries. Inheritance System.Object ConfigurationEntryBase Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationEntryBase : IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ConfigurationEntryBase(ConfigurationEntryType, IConfigurationLineInfo) Declaration protected ConfigurationEntryBase(ConfigurationEntryType type, IConfigurationLineInfo lineInfo) Parameters Name Type Description type ConfigurationEntryType lineInfo IConfigurationLineInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc EndLineNo Declaration public int ? EndLineNo { get; } Property Value Type Description System.Nullable < System.Int32 > Implements EndLineNo <!-- .classchild --> | Improve this Doc EndLinePos Declaration public int ? EndLinePos { get; } Property Value Type Description System.Nullable < System.Int32 > Implements EndLinePos <!-- .classchild --> | Improve this Doc StartLineNo Declaration public int ? StartLineNo { get; } Property Value Type Description System.Nullable < System.Int32 > Implements StartLineNo <!-- .classchild --> | Improve this Doc StartLinePos Declaration public int ? StartLinePos { get; } Property Value Type Description System.Nullable < System.Int32 > Implements StartLinePos <!-- .classchild --> | Improve this Doc Type Declaration public ConfigurationEntryType Type { get; } Property Value Type Description ConfigurationEntryType Implements Type <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContextFactory.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContextFactory.html",
    "title": "Class ConfigurationAdapterContextFactory",
    "keywords": "Improve this Doc Class ConfigurationAdapterContextFactory The standard Singleton implementation of the IConfigurationAdapterContextFactory interface, and one which you can use as the starting point of your own factory. By default, it creates a new instance of the ConfigurationAdapterContext class (using the virtual method CreateContext(ConfigurationAdapter, IConfiguration) , and then instructs it to add its default assembly references. Inheritance System.Object ConfigurationAdapterContextFactory Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationAdapterContextFactory : IConfigurationAdapterContextFactory <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ConfigurationAdapterContextFactory() Creation of new instances of this class, outside of the Instance instance, is only through inheritance. Declaration protected ConfigurationAdapterContextFactory() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Instance The one and only instance of this context factory. Note that this is also the default application-wide context factory that is used by the standard ConfigurationAdapter class when converting configuration data into rezolvers (by virtue of the DefaultContextFactory property, which you can change). Declaration public static ConfigurationAdapterContextFactory Instance { get; } Property Value Type Description ConfigurationAdapterContextFactory <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateContext(ConfigurationAdapter, IConfiguration) Implements the IConfigurationAdapterContextFactory method of the same name. The base behaviour is to create an instance of the ConfigurationAdapterContext class, passing the configuration and the default set of assembly references returned by GetDefaultAssemblyReferences() . Declaration public virtual ConfigurationAdapterContext CreateContext(ConfigurationAdapter adapter, IConfiguration configuration) Parameters Name Type Description adapter ConfigurationAdapter The adapter. configuration IConfiguration The configuration. Returns Type Description ConfigurationAdapterContext Implements CreateContext(ConfigurationAdapter, IConfiguration) <!-- .classchild --> | Improve this Doc GetDefaultAssemblyReferences() Gets the assemblies that are to be used for new contexts as the default set of references. The base behaviour is to add mscorlib, System and System.Core although, depending on the target platform, the list might be less. Declaration protected virtual IEnumerable<Assembly> GetDefaultAssemblyReferences() Returns Type Description System.Collections.Generic.IEnumerable < Assembly > <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContext.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContext.html",
    "title": "Class ConfigurationAdapterContext",
    "keywords": "Improve this Doc Class ConfigurationAdapterContext This class is used to store the intermediate state for the default IConfigurationAdapter implementation's ( ConfigurationAdapter ) parsing operation on an IConfiguration instance. If you are extending the default adapter you might need also to extend this class to ensure any additional state you require is maintained. Inheritance System.Object ConfigurationAdapterContext Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationAdapterContext <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ConfigurationAdapterContext(IConfigurationAdapter, IConfiguration, IEnumerable<Assembly>) Constructs a new instance of the ConfigurationAdapterContext class. Declaration public ConfigurationAdapterContext(IConfigurationAdapter adapter, IConfiguration configuration, IEnumerable<Assembly> defaultAssemblyReferences = null) Parameters Name Type Description adapter IConfigurationAdapter The adapter that will create the ITargetContainer from the configuration. configuration IConfiguration Required. The configuration that is being processed by the adapter for which this context is being constructed defaultAssemblyReferences System.Collections.Generic.IEnumerable < Assembly > Optional. Default set of assemblies that are to be searched for types when type references are processed. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Adapter Declaration public IConfigurationAdapter Adapter { get; } Property Value Type Description IConfigurationAdapter <!-- .classchild --> | Improve this Doc Configuration Gets the configuration that is being processed by the adapter that is working within this context. Declaration public IConfiguration Configuration { get; } Property Value Type Description IConfiguration The configuration. <!-- .classchild --> | Improve this Doc ErrorCount Retrieves the number of errors currently in the Errors enumerable. Declaration public int ErrorCount { get; } Property Value Type Description System.Int32 <!-- .classchild --> | Improve this Doc Errors Retrieves a snapshot of the current errors list. If further errors are added while you are enumerating the enumerable returned by this property, no exception will occur, and the newly added items will not be included. Declaration public IEnumerable<IConfigurationError> Errors { get; } Property Value Type Description System.Collections.Generic.IEnumerable < IConfigurationError > <!-- .classchild --> | Improve this Doc Instructions Retrieves a snapshot of the instructions currently present in the context. Declaration public IEnumerable<RezolverBuilderInstruction> Instructions { get; } Property Value Type Description System.Collections.Generic.IEnumerable < RezolverBuilderInstruction > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc AddAssemblyReference(Assembly) Called to add an assembly reference to this context - the assembly will then be included in the search for types that are not fully qualified. Declaration public void AddAssemblyReference(Assembly assembly) Parameters Name Type Description assembly Assembly Required - the assembly to be added as a reference. <!-- .classchild --> | Improve this Doc AddAssemblyReference(IAssemblyReferenceEntry) Adds an assembly reference from an IAssemblyReferenceEntry obtained directly from an IConfiguration instance. The default behaviour is to attempt to load an assembly with the given name and, if found, add that using the overload that accepts an Assembly reference. Declaration public virtual void AddAssemblyReference(IAssemblyReferenceEntry entry) Parameters Name Type Description entry IAssemblyReferenceEntry <!-- .classchild --> | Improve this Doc AddAssemblyReferenceBase(Assembly) The core method for adding an assembly reference. The method will never be called (by the base at least) with a null argument. Declaration protected virtual void AddAssemblyReferenceBase(Assembly assembly) Parameters Name Type Description assembly Assembly <!-- .classchild --> | Improve this Doc AddAssemblyReferences(IEnumerable<Assembly>) Declaration public virtual void AddAssemblyReferences(IEnumerable<Assembly> assemblies) Parameters Name Type Description assemblies System.Collections.Generic.IEnumerable < Assembly > <!-- .classchild --> | Improve this Doc AddError(IConfigurationError) Declaration public void AddError(IConfigurationError error) Parameters Name Type Description error IConfigurationError <!-- .classchild --> | Improve this Doc AddErrors(IEnumerable<IConfigurationError>) Declaration public void AddErrors(IEnumerable<IConfigurationError> errors) Parameters Name Type Description errors System.Collections.Generic.IEnumerable < IConfigurationError > <!-- .classchild --> | Improve this Doc AppendInstruction(RezolverBuilderInstruction) Declaration public void AppendInstruction(RezolverBuilderInstruction instruction) Parameters Name Type Description instruction RezolverBuilderInstruction <!-- .classchild --> | Improve this Doc GetNamespacePrefixedTypeNames(String) Declaration protected IEnumerable<string> GetNamespacePrefixedTypeNames(string typeName) Parameters Name Type Description typeName System.String Returns Type Description System.Collections.Generic.IEnumerable < System.String > <!-- .classchild --> | Improve this Doc GetReferencedAssemblies() Gets an enumerable of all the assemblies that are referenced by this configuration file. This is used when resolving types. Declaration protected virtual IEnumerable<Assembly> GetReferencedAssemblies() Returns Type Description System.Collections.Generic.IEnumerable < Assembly > <!-- .classchild --> | Improve this Doc GetUsingNamespaces() Gets an enumerable of strings of all the namespaces (using dotted separators) that are imported for the configuration. This is used, by default, to project a list of type names to search for during type resolution. Declaration protected virtual IEnumerable<string> GetUsingNamespaces() Returns Type Description System.Collections.Generic.IEnumerable < System.String > <!-- .classchild --> | Improve this Doc InsertAfter(RezolverBuilderInstruction, RezolverBuilderInstruction) Allows for explicit ordering of instructions Declaration public void InsertAfter(RezolverBuilderInstruction instruction, RezolverBuilderInstruction after) Parameters Name Type Description instruction RezolverBuilderInstruction after RezolverBuilderInstruction <!-- .classchild --> | Improve this Doc InsertBefore(RezolverBuilderInstruction, RezolverBuilderInstruction) Allows for explicit ordering of instructions Declaration public void InsertBefore(RezolverBuilderInstruction instruction, RezolverBuilderInstruction before) Parameters Name Type Description instruction RezolverBuilderInstruction before RezolverBuilderInstruction <!-- .classchild --> | Improve this Doc InsertRangeAfter(IEnumerable<RezolverBuilderInstruction>, RezolverBuilderInstruction) Declaration public void InsertRangeAfter(IEnumerable<RezolverBuilderInstruction> instructions, RezolverBuilderInstruction after) Parameters Name Type Description instructions System.Collections.Generic.IEnumerable < RezolverBuilderInstruction > after RezolverBuilderInstruction <!-- .classchild --> | Improve this Doc InsertRangeBefore(IEnumerable<RezolverBuilderInstruction>, RezolverBuilderInstruction) Declaration public void InsertRangeBefore(IEnumerable<RezolverBuilderInstruction> instructions, RezolverBuilderInstruction before) Parameters Name Type Description instructions System.Collections.Generic.IEnumerable < RezolverBuilderInstruction > before RezolverBuilderInstruction <!-- .classchild --> | Improve this Doc ResolveType(String, Nullable<Int32>) Resolves a particular type name given this context's assembly references and, potentially, any namespace imports. This is designed to be used by a configuration adapter during the process of creating a container builder from a set of configuration entries. Declaration public virtual Type ResolveType(string typeName, int ? genericParameterCount = null) Parameters Name Type Description typeName System.String The typename genericParameterCount System.Nullable < System.Int32 > Used as a hint when multiple versions of the same type exist with open generic parameters and potentially with no generic parameters. Null means that either a generic or non-generic type can match. Zero means that only a non-generic type (or a closed generic type) can match. Any other positive value means that only an open generic type with that exact number of parameters can match. Returns Type Description System.Type A Type reference if the type is located, otherwise null. Exceptions Type Condition System.Reflection.AmbiguousMatchException If more than one type could be matched with the given name, typically due to namespace imports being used and more than type being available which has the same <!-- .classchild --> | Improve this Doc TryParseTypeReference(ITypeReference, out Type) Attempts to convert the passed typeReference into a Type . Errors are added to this context's Errors if the method returns false. Declaration public virtual bool TryParseTypeReference(ITypeReference typeReference, out Type type) Parameters Name Type Description typeReference ITypeReference The type reference. type System.Type The type that is identified, if successful. Returns Type Description System.Boolean true if the type reference is successfully parsed, false otherwise (with errors being added to the Errors collection). <!-- .classchild --> | Improve this Doc TryParseTypeReferences(IEnumerable<ITypeReference>, out Type[]) Tries to parse all type references, returning an overall success flag, with successfully parsed types being added to a list that is returned in the types output parameter. Declaration public bool TryParseTypeReferences(IEnumerable<ITypeReference> typeReferences, out Type[] types) Parameters Name Type Description typeReferences System.Collections.Generic.IEnumerable < ITypeReference > The type references. types System.Type [] Receives the types that are parsed. Note that if the method returns true, then this list will contain the same number of types as there are references in typeReferences , in the same order. If the method returns false, however, then the number of results in this list is undefined and you will not be able to marry up the input type reference to its output type. Returns Type Description System.Boolean true if all type references could be parsed, otherwise false . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContext.UnresolvedType.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContext.UnresolvedType.html",
    "title": "Class ConfigurationAdapterContext.UnresolvedType",
    "keywords": "Improve this Doc Class ConfigurationAdapterContext.UnresolvedType Used as a sentinel type by the ResolveType(String, Nullable ) method when the type search fails. Inheritance System.Object ConfigurationAdapterContext.UnresolvedType Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax protected class UnresolvedType"
  },
  "rezolver-api/Rezolver.ChildTargetContainer.html": {
    "href": "rezolver-api/Rezolver.ChildTargetContainer.html",
    "title": "Class ChildTargetContainer",
    "keywords": "Improve this Doc Class ChildTargetContainer A version of TargetContainer which overrides the registrations of another (the Parent ). Inheritance System.Object TargetDictionaryContainer TargetContainer ChildTargetContainer Inherited Members CreateContainer(Type, ITarget) CreateGenericTypeDefContainer(Type, ITarget) FetchContainer(Type) Register(ITarget, Type) RegisterContainer(Type, ITargetContainer) RegisterContainerDirect(Type, ITargetContainer) CombineWith(ITargetContainer, Type) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ChildTargetContainer : TargetContainer, ITargetContainerOwner, IChildTargetContainer, ITargetContainer Remarks When it's looking to find an entry for a type, if it cannot find one within its own registrations, it will forward the call on to its Parent . <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ChildTargetContainer(ITargetContainer) Declaration public ChildTargetContainer(ITargetContainer parent) Parameters Name Type Description parent ITargetContainer <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Parent Declaration public ITargetContainer Parent { get; } Property Value Type Description ITargetContainer Implements Parent <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Fetch(Type) Declaration public override ITarget Fetch(Type type) Parameters Name Type Description type System.Type Returns Type Description ITarget Overrides Fetch(Type) Implements Fetch(Type) <!-- .classchild --> | Improve this Doc FetchAll(Type) Declaration public override IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type System.Type Returns Type Description System.Collections.Generic.IEnumerable < ITarget > Overrides FetchAll(Type) Implements FetchAll(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ChangeTypeTarget.html": {
    "href": "rezolver-api/Rezolver.ChangeTypeTarget.html",
    "title": "Class ChangeTypeTarget",
    "keywords": "Improve this Doc Class ChangeTypeTarget This target is specifically used for explicitly typing another target. It's effectively the same as inserting a ConvertExpression around another Expression tree Its use is rare. Inheritance System.Object TargetBase ChangeTypeTarget Inherited Members UseFallback CreateScopeTrackingExpression(CompileContext, Expression) CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) CreateScopeSelectionExpression(CompileContext, Expression) SupportsType(Type) CreateExpression(CompileContext) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ChangeTypeTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ChangeTypeTarget(ITarget, Type) Creates a new instance of the ChangeTypeTarget class. Declaration public ChangeTypeTarget(ITarget innerTarget, Type targetType) Parameters Name Type Description innerTarget ITarget Required. See InnerTarget targetType System.Type Required. See Rezolver.ChangeTypeTarget._targetType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description System.Type Overrides DeclaredType <!-- .classchild --> | Improve this Doc InnerTarget The target whose type will be changed to Rezolver.ChangeTypeTarget._targetType . Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget <!-- .classchild --> | Improve this Doc SuppressScopeTracking Always returns true. Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description System.Boolean Overrides SuppressScopeTracking <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateExpressionBase(CompileContext) Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides CreateExpressionBase(CompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.CachingContainerBase.html": {
    "href": "rezolver-api/Rezolver.CachingContainerBase.html",
    "title": "Class CachingContainerBase",
    "keywords": "Improve this Doc Class CachingContainerBase Builds on the ContainerBase base class to introduce thread-safe caching of compiled targets so they are only compiled once per requested type. Only creatable through inheritance. Inheritance System.Object ContainerBase CachingContainerBase Inherited Members GetMissingTarget(Type) IsMissingTarget(ICompiledTarget) Compiler Targets Resolve(RezolveContext) TryResolve(RezolveContext, out Object) CreateLifetimeScope() FetchCompiled(RezolveContext) CanResolve(RezolveContext) GetFallbackCompiledRezolveTarget(RezolveContext) Rezolver.ContainerBase.System.IServiceProvider.GetService(System.Type) GetService(Type) Register(ITarget, Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.Fetch(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.FetchAll(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer, System.Type) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class CachingContainerBase : ContainerBase, IContainer, IServiceProvider, ITargetContainer Remarks Internally, the class uses a to store ICompiledTarget s keyed by the requested type. All the main IContainer implementations used directly in an application inherit from this class, because otherwise every Resolve(RezolveContext) operation would require a compilation phase before the object could be returned, which would be incredibly slow. It's because of this caching that registering new targets in any ITargetContainer used by this class is not recommended: because after the first request for a particular type is made, the resultant ICompiledTarget is fixed until the container is thrown away. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc CachingContainerBase(ITargetContainer, ITargetCompiler) Initializes a new instance of the CachingContainerBase class. Declaration protected CachingContainerBase(ITargetContainer targets = null, ITargetCompiler compiler = null) Parameters Name Type Description targets ITargetContainer Optional. Contains the targets that will be used to create the ICompiledTarget s that this container will use to produce objects when requested. If not provided, then the base class' default (see Rezolver.ContainerBase. ) will be used. compiler ITargetCompiler Optional. The compiler that will be used to compile the ITarget s in the targets container into ICompiledTarget s. If not provided, then the base class' default (see Rezolver.ContainerBase. will be used. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc GetCompiledRezolveTarget(RezolveContext) Obtains an ICompiledTarget for the given context . Declaration protected override ICompiledTarget GetCompiledRezolveTarget(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description ICompiledTarget Overrides GetCompiledRezolveTarget(RezolveContext) Remarks The method is called by Resolve(RezolveContext) to get the compiled target whose GetObject(RezolveContext) method is to be used to get the instance that is to be resolved for a given request. The internal cache is examined first to see if an entry exists for the RequestedType type and, if not, then the result of the base class' GetCompiledRezolveTarget(RezolveContext) is cached and returned. <!-- .classchild -->"
  },
  "rezolver-usage/toc.html": {
    "href": "rezolver-usage/toc.html",
    "title": "Table of Content",
    "keywords": ""
  },
  "toc.html": {
    "href": "toc.html",
    "title": "Table of Content",
    "keywords": ""
  },
  "rezolver-api/toc.html": {
    "href": "rezolver-api/toc.html",
    "title": "Table of Content",
    "keywords": ""
  },
  "rezolver-usage/nuget-packages/rezolver.html": {
    "href": "rezolver-usage/nuget-packages/rezolver.html",
    "title": "Nuget Package: Rezolver",
    "keywords": "Improve this Doc Nuget Package: Rezolver See package page on nuget . The core nuget package for using Rezolver in your class library or application, includes all the core abstractions and classes required to create @TargetContainer objects and @Container objects in your composition root. Also contains the core ITarget implementations and logic which allow you to create/retrieve objects in numerous ways: Binding generic and non-generic class constructors using dynamically resolved arguments ( ConstructorTarget , GenericConstructorTarget and @Rezolver.RezolvedTarget) Invoking pre-built delegates (@Rezolver.DelegateTarget) Pre-built objects (@Rezolver.ObjectTarget) Dynamic code built from custom expression trees (@Rezolver.ExpressionTarget) Decoration (@Rezolver.DecoratorTarget) Singleton objects (@Rezolver.SingletonTarget) Scoped objects (@Rezolver.ScopedTarget)"
  },
  "rezolver-usage/nuget-packages/rezolver.configuration.html": {
    "href": "rezolver-usage/nuget-packages/rezolver.configuration.html",
    "title": "Nuget Package: Rezolver.Configuration",
    "keywords": "Improve this Doc Nuget Package: Rezolver.Configuration This package provides the Rezolver configuration object model, whose purpose is to describe how a Target Container should be constructed and configured based on a configuration file/script loaded at runtime. It doesn't define any specific code for parsing configuration files - but it does provide a standard implementation of the IConfigurationAdapter , whose job it is to create a ITargetContainer from a IConfiguration instance. You can implement your own configuration file formats with this simply by writing code to read your desired format and getting your parser to create an instance of IConfiguration"
  },
  "rezolver-usage/nuget-packages/index.html": {
    "href": "rezolver-usage/nuget-packages/index.html",
    "title": "Rezolver Nuget Packages",
    "keywords": "Improve this Doc Rezolver Nuget Packages Rezolver is primarily distributed as a suite of Nuget packages whose functionality stacks one on top of another. Depending on the level of functionality you require, there should be a Nuget package which contains only the code you need. All the core nuget packages support the new .NetStandard 1.3 profile (don't know what this is? Learn more ), .Net 4.5.1 and .Net 4.6. Where a package has a dependency on a third party package (such as Newtonsoft's Json.Net or .Net Core's Microsoft.Extensions.DependencyInjection packages), then we try to maintain full support for the same frameworks and profiles that those packages support. List of packages Rezolver . Rezolver.Configuration"
  },
  "rezolver-usage/advanced/rezolving-with-expressions.html": {
    "href": "rezolver-usage/advanced/rezolving-with-expressions.html",
    "title": "",
    "keywords": "Improve this Doc TODO: Article covering functions such as the RegisterExpression (ITargetContainer, Expression >, Type, ITargetAdapter) method"
  },
  "rezolver-usage/advanced/index.html": {
    "href": "rezolver-usage/advanced/index.html",
    "title": "",
    "keywords": "Improve this Doc In addition to the standard functionality you'd expect from an IOC container, Rezolver supports many additional features which require some extra discussion."
  },
  "rezolver-usage/index.html": {
    "href": "rezolver-usage/index.html",
    "title": "1. Getting started",
    "keywords": "Improve this Doc 1. Getting started As with many open source .Net projects, there are two primary ways to get Rezolver integrated into your project. The easiest is via the Nuget packages By using the Nuget packages, you ensure that you're using the latest (hopefully stable!) releases. Alpha packages will also be made available for in-development features. Fork or download the source from Github Use this if you can't integrate nuget into your build pipeline, or if you'd like to customise or contribute to the project. If you're looking to customise, though, then there should be enough extensibility points in the framework to allow you to do so without having to change core types. If that's not the case, post an issue on the Github project so we can get it added in and make it better for everyone! Once you've got the main assembly referenced (Rezolver.dll) - then you can create a Container , register targets against its internal ITargetContainer target container, and then grab objects from it! ITarget t = new ObjectTarget(null); ITargetContainer r = new TargetContainer(); r.Register(t, serviceType: typeof(object)); var t2 = r.Fetch(typeof(object)); Assert.Same(t, t2);"
  },
  "rezolver-usage/details3.html": {
    "href": "rezolver-usage/details3.html",
    "title": "Details 3",
    "keywords": "Improve this Doc Details 3 This is the third details page - getting a bit boring now huh?"
  },
  "rezolver-usage/details2.html": {
    "href": "rezolver-usage/details2.html",
    "title": "Details 2",
    "keywords": "Improve this Doc Details 2 This is the second details page. And the same image underneath:"
  },
  "rezolver-usage/details1.html": {
    "href": "rezolver-usage/details1.html",
    "title": "Details 1",
    "keywords": "Improve this Doc Details 1 This is the first details page."
  },
  "rezolver-api/index.html": {
    "href": "rezolver-api/index.html",
    "title": "Rezolver API reference",
    "keywords": "Improve this Doc Rezolver API reference Looking for documentation on individual classes or methods in the Rezolver project? You've come to the right place! Crucial types to look at are: TargetContainer (implements ITargetContainer ): Stores ITarget instances, and is the main class you'll use for your 'registration' phase Container (implements IContainer ): The standard, non-scoped, container you'll use in your composition root - you can create child scopes from this by calling its implementation of CreateLifetimeScope() . This class requires an ITargetContainer for its registrations"
  },
  "index.html": {
    "href": "index.html",
    "title": "Rezolver",
    "keywords": "Improve this Doc Rezolver Welcome to the home of Rezolver - here you'll find guides, walkthroughs, deep-dives and reference for all of the APIs and functionality in the Rezolver library. What is Rezolver? Rezolver is (yet another :)) open source IOC container. It supports many of the features supported by most other popular IOC containers out there, integrates into the new .Net Core 1.0 framework (supporting NetStandard1.1) (and therefore supports Asp.Net Core), and supports some unique functionality too. It's very fast, extensible and reliable, and should slot nicely into any project in which you already have another IOC container. Quick Links Getting Started Nuget Packages API Reference"
  },
  "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataList.html": {
    "href": "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataList.html",
    "title": "Class RezolveTargetMetadataList",
    "keywords": "Improve this Doc Class RezolveTargetMetadataList Inheritance System.Object RezolveTargetMetadataBase RezolveTargetMetadataList Inherited Members Type CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class RezolveTargetMetadataList : RezolveTargetMetadataBase, IRezolveTargetMetadataList, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc RezolveTargetMetadataList() Declaration public RezolveTargetMetadataList() <!-- .classchild --> | Improve this Doc RezolveTargetMetadataList(IEnumerable<IRezolveTargetMetadata>) Declaration public RezolveTargetMetadataList(IEnumerable<IRezolveTargetMetadata> range) Parameters Name Type Description range System.Collections.Generic.IEnumerable < IRezolveTargetMetadata > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides DeclaredType Implements DeclaredType <!-- .classchild --> | Improve this Doc Targets Declaration public IList<IRezolveTargetMetadata> Targets { get; } Property Value Type Description System.Collections.Generic.IList < IRezolveTargetMetadata > Implements Targets <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Bind(ITypeReference[]) Declaration public override IRezolveTargetMetadata Bind(ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides Bind(ITypeReference[]) Implements Bind(ITypeReference[]) <!-- .classchild --> | Improve this Doc BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides BindBase(ITypeReference[]) <!-- .classchild --> | Improve this Doc CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes System.Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description ITarget Overrides CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild --> | Improve this Doc CreateRezolveTargets(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration public IEnumerable<ITarget> CreateRezolveTargets(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes System.Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description System.Collections.Generic.IEnumerable < ITarget > Implements CreateRezolveTargets(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataBase.html": {
    "href": "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataBase.html",
    "title": "Class RezolveTargetMetadataBase",
    "keywords": "Improve this Doc Class RezolveTargetMetadataBase Suggested base class for implementations of IRezolveTargetMetadata . Inheritance System.Object RezolveTargetMetadataBase Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public abstract class RezolveTargetMetadataBase : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc RezolveTargetMetadataBase(RezolveTargetMetadataType) Initializes a new instance of the RezolveTargetMetadataBase class. Declaration protected RezolveTargetMetadataBase(RezolveTargetMetadataType type) Parameters Name Type Description type RezolveTargetMetadataType The type of target. Exceptions Type Condition System.ArgumentException If type is RezolveTargetMetadataType.Extension this instance must implement IRezolveTargetMetadataExtension <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Gets the declared type of the object that will be created by an IRezolveTarget created by this metadata. Note - this isn't always known, or always fixed, since configuration systems will allow developers to avoid being specific about the types that are to be built. Declaration public abstract ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference The type of the declared. Implements DeclaredType <!-- .classchild --> | Improve this Doc Type The type of rezolve target that is expected to be produced from this metadata Declaration public RezolveTargetMetadataType Type { get; } Property Value Type Description RezolveTargetMetadataType The type. Implements Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Bind(ITypeReference[]) Declaration public virtual IRezolveTargetMetadata Bind(ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Implements Bind(ITypeReference[]) <!-- .classchild --> | Improve this Doc BindBase(ITypeReference[]) Creates a new instance (clone) of this metadata that's bound to the target types (although, typically, you'll only ever pick the first target type that is in the array). Only ever called if DeclaredType is unbound Declaration protected abstract IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] The target types. Returns Type Description IRezolveTargetMetadata IRezolveTargetMetadata. <!-- .classchild --> | Improve this Doc CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Implementation of CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) - see that documentation for more detail about the intentions of this method. This implementation will check all the arguments (for nulls etc), including that all targetTypes have a common base; then it will invoke the abstract method CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) . Declaration public virtual ITarget CreateRezolveTarget(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry = null) Parameters Name Type Description targetTypes System.Type [] Required. One or more target types that the returned target is expected to be compatible with (i.e. able to build an instance of). Generally, this will be the target types for the configuration entry that is passed in entry . context ConfigurationAdapterContext The current context - provides access to the builder currently being constructed, as well as methods for resolving type names from ITypeReference instances or strings (and more). entry IConfigurationEntry If provided, this is a reference to the configuration entry (typically an ITypeRegistrationEntry ) against which this target will be registered. Please note - this doesn't mean that the target that is returned will become the target of the registration. It might be that the target is one that is used by a parent target that will become the target of the registration. Returns Type Description ITarget IRezolveTarget. Implements CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Exceptions Type Condition System.ArgumentNullException context or targetTypes System.ArgumentException Array must contain at least one target type;targetTypes or All items in the array must be non-null;targetTypes <!-- .classchild --> | Improve this Doc CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Called by CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) to create the rezolve target that will be registered into the ITargetContainer currently being built (available on the context ) If an error occurs, you indicate that by adding to the context 's errors collection, and return null. You can also throw an exception, which will be caught and added to the errors collection for you. Declaration protected abstract ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes System.Type [] The target types. context ConfigurationAdapterContext The context. entry IConfigurationEntry The entry. Returns Type Description ITarget IRezolveTarget. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RezolverBuilderInstruction.html": {
    "href": "rezolver-api/Rezolver.Configuration.RezolverBuilderInstruction.html",
    "title": "Class RezolverBuilderInstruction",
    "keywords": "Improve this Doc Class RezolverBuilderInstruction An instruction to perform an operation on a container builder from an IConfigurationEntry that's been parsed from a configuration source (and which has been retrieved from an IConfiguration instance). Inheritance System.Object RezolverBuilderInstruction Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public abstract class RezolverBuilderInstruction <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc RezolverBuilderInstruction(IConfigurationEntry) Inheritance constructor. Declaration protected RezolverBuilderInstruction(IConfigurationEntry entry) Parameters Name Type Description entry IConfigurationEntry The entry that built this instruction. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Entry The source configuration entry for this instruction. Declaration public IConfigurationEntry Entry { get; } Property Value Type Description IConfigurationEntry <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Apply(ITargetContainer) Abstract method which performs whatever instruction this instance represents on the passed builder. Declaration public abstract void Apply(ITargetContainer builder) Parameters Name Type Description builder ITargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RegisterMultipleInstruction.html": {
    "href": "rezolver-api/Rezolver.Configuration.RegisterMultipleInstruction.html",
    "title": "Class RegisterMultipleInstruction",
    "keywords": "Improve this Doc Class RegisterMultipleInstruction Similar to the RegisterInstruction except this specifically wraps the method. Construction is largely identical, except where in the aforementioned class you pass a single target, here you pass multiple targets in a list. Inheritance System.Object RezolverBuilderInstruction RegisterMultipleInstruction Inherited Members Entry System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class RegisterMultipleInstruction : RezolverBuilderInstruction <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc RegisterMultipleInstruction(IEnumerable<Type>, IEnumerable<ITarget>, IConfigurationEntry) Initializes a new instance of the RegisterMultipleInstruction class. Declaration public RegisterMultipleInstruction(IEnumerable<Type> targetTypes, IEnumerable<ITarget> targets, IConfigurationEntry entry) Parameters Name Type Description targetTypes System.Collections.Generic.IEnumerable < System.Type > The target types for the registration. targets System.Collections.Generic.IEnumerable < ITarget > The targets. Note that this is a list to support modification after the instruction is created; since this is a configuration API. entry IConfigurationEntry The source entry for this instruction - allows the system to track the instruction back to the configuration it was loaded from. Exceptions Type Condition System.ArgumentNullException targetTypes or targets System.ArgumentException List must contain one or more types;targetTypes or All types in list must be non-null;targetTypes or List must contain one or more targets;targets or All targets in list must be non-null;targets <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Targets Gets the targets that'll be used for the registration. Declaration public IEnumerable<ITarget> Targets { get; } Property Value Type Description System.Collections.Generic.IEnumerable < ITarget > The targets. <!-- .classchild --> | Improve this Doc TargetTypes The types that the target will be registered with Declaration public IEnumerable<Type> TargetTypes { get; } Property Value Type Description System.Collections.Generic.IEnumerable < System.Type > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Apply(ITargetContainer) Declaration public override void Apply(ITargetContainer builder) Parameters Name Type Description builder ITargetContainer Overrides Apply(ITargetContainer) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RegisterInstruction.html": {
    "href": "rezolver-api/Rezolver.Configuration.RegisterInstruction.html",
    "title": "Class RegisterInstruction",
    "keywords": "Improve this Doc Class RegisterInstruction The basic workhorse of a parsed configuration - an instruction to register a target in an IRezolveTargetContainer instance against one or more types with a given name. Inheritance System.Object RezolverBuilderInstruction RegisterInstruction Inherited Members Entry System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class RegisterInstruction : RezolverBuilderInstruction <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc RegisterInstruction(IEnumerable<Type>, ITarget, IConfigurationEntry) Constructs a new instance of the RegisterInstruction class. Declaration public RegisterInstruction(IEnumerable<Type> targetTypes, ITarget target, IConfigurationEntry entry) Parameters Name Type Description targetTypes System.Collections.Generic.IEnumerable < System.Type > The types that the target will be registered with target ITarget The target to be registered. entry IConfigurationEntry The original configuration entry from which this instruction was built. Exceptions Type Condition System.ArgumentNullException targetTypes or target System.ArgumentException List must contain one or more types;targetTypes or All types in list must be non-null;targetTypes <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Target The target that is to be registered. Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> | Improve this Doc TargetTypes The types that the target will be registered with Declaration public IEnumerable<Type> TargetTypes { get; } Property Value Type Description System.Collections.Generic.IEnumerable < System.Type > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Apply(ITargetContainer) The implementation will register the target for the given types. In the case of multiple types, the target is registered directly against that type, and aliases are registered for all the others. Declaration public override void Apply(ITargetContainer builder) Parameters Name Type Description builder ITargetContainer Overrides Apply(ITargetContainer) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ObjectTargetMetadataBase.html": {
    "href": "rezolver-api/Rezolver.Configuration.ObjectTargetMetadataBase.html",
    "title": "Class ObjectTargetMetadataBase",
    "keywords": "Improve this Doc Class ObjectTargetMetadataBase Abstract base class for metadata that builds an object target. Inheritance System.Object RezolveTargetMetadataBase ObjectTargetMetadataBase Inherited Members Type DeclaredType CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Bind(ITypeReference[]) BindBase(ITypeReference[]) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public abstract class ObjectTargetMetadataBase : RezolveTargetMetadataBase, IObjectTargetMetadata, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ObjectTargetMetadataBase() Declaration public ObjectTargetMetadataBase() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes System.Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description ITarget Overrides CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild --> | Improve this Doc GetObject(Type) Called to get the object that will be registered in the IRezolveTargetContainer to be returned when a caller requests one of its registered types. The method can construct an object anew everytime it is called, or it can always return the same instance; this behaviour is implementation-dependant. Declaration public abstract object GetObject(Type type) Parameters Name Type Description type System.Type The type of object that is desired. The implementation determines whether this parameter is required. If it is, and you pass null, then an ArgumentNullException will be thrown. If you pass an argument, the implementation is not bound to check or honour the type. Its purpose is to provide a hint only, not a guarantee that the object returned is compatible with the type. Returns Type Description System.Object An object. Note - if the operation returns null this is not an error. Implements GetObject(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ObjectTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.ObjectTargetMetadata.html",
    "title": "Class ObjectTargetMetadata",
    "keywords": "Improve this Doc Class ObjectTargetMetadata Standard implementation of ObjectTargetMetadataBase , to encapsulate object references that are to be baked into a container as targets. Inheritance System.Object RezolveTargetMetadataBase ObjectTargetMetadataBase ObjectTargetMetadata Inherited Members CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Type CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Bind(ITypeReference[]) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ObjectTargetMetadata : ObjectTargetMetadataBase, IObjectTargetMetadata, IRezolveTargetMetadata Remarks This class accepts either an object reference that is to be returned when the target is resolved; or a delegate that will be called with the desired type (passed in from GetObject(Type) ). <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ObjectTargetMetadata(Func<Type, Object>) Initializes a new instance of the ObjectTargetMetadata class. Declaration public ObjectTargetMetadata(Func<Type, object> valueProvider) Parameters Name Type Description valueProvider System.Func < System.Type , System.Object > The value provider that will be called. <!-- .classchild --> | Improve this Doc ObjectTargetMetadata(Object) Initializes a new instance of the ObjectTargetMetadata class. Declaration public ObjectTargetMetadata(object obj) Parameters Name Type Description obj System.Object The object that is to be returned from GetObject(Type) . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides DeclaredType Implements DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides BindBase(ITypeReference[]) <!-- .classchild --> | Improve this Doc GetObject(Type) Called to get the object that will be registered in the IRezolveTargetContainer to be returned when a caller requests one of its registered types. The method can construct an object anew everytime it is called, or it can always return the same instance; this behaviour is implementation-dependant. Declaration public override object GetObject(Type type) Parameters Name Type Description type System.Type The type of object that is desired. The implementation determines whether this parameter is required. If it is, and you pass null, then an ArgumentNullException will be thrown. If you pass an argument, the implementation is not bound to check or honour the type. Its purpose is to provide a hint only, not a guarantee that the object returned is compatible with the type. Returns Type Description System.Object An object. Note - if the operation returns null this is not an error. Overrides GetObject(Type) Implements GetObject(Type) Exceptions Type Condition System.ArgumentNullException type <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ListTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.ListTargetMetadata.html",
    "title": "Class ListTargetMetadata",
    "keywords": "Improve this Doc Class ListTargetMetadata Standard implementation of the IListTargetMetadata interface. Inheritance System.Object RezolveTargetMetadataBase ListTargetMetadata Inherited Members Type CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ListTargetMetadata : RezolveTargetMetadataBase, IListTargetMetadata, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ListTargetMetadata(ITypeReference, IRezolveTargetMetadataList, Boolean) Initializes a new instance of the ListTargetMetadata class. Declaration public ListTargetMetadata(ITypeReference elementType, IRezolveTargetMetadataList items, bool isArray) Parameters Name Type Description elementType ITypeReference Type of the elements of the eventual array/list. items IRezolveTargetMetadataList Metadata for the targets that will eventually create the items for the array or list. isArray System.Boolean if set to true then an array is to be built, otherwise a list is to be built. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides DeclaredType Implements DeclaredType <!-- .classchild --> | Improve this Doc ElementType Gets the declared element type of the array or list that will be created from this metadata. Declaration public ITypeReference ElementType { get; } Property Value Type Description ITypeReference The type of the element. Implements ElementType Exceptions Type Condition System.NotImplementedException <!-- .classchild --> | Improve this Doc IsArray Maps to the AsArray property. If true, then an array of ElementType will be created, otherwise a List< ElementType > will be created by the ListTarget created from this metadata. Declaration public bool IsArray { get; } Property Value Type Description System.Boolean true if this instance represents a ListTarget that will create an array; otherwise, false . Implements IsArray <!-- .classchild --> | Improve this Doc Items Gets the metadata for the targets that will be used for the items that'll be returned in the Array or List that will be created by the ListTarget created from this metadata. Declaration public IRezolveTargetMetadataList Items { get; } Property Value Type Description IRezolveTargetMetadataList The elements. Implements Items <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Bind(ITypeReference[]) Declaration public override IRezolveTargetMetadata Bind(ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides Bind(ITypeReference[]) Implements Bind(ITypeReference[]) <!-- .classchild --> | Improve this Doc BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides BindBase(ITypeReference[]) <!-- .classchild --> | Improve this Doc CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes System.Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description ITarget Overrides CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ObjectTarget.html": {
    "href": "rezolver-api/Rezolver.ObjectTarget.html",
    "title": "Class ObjectTarget",
    "keywords": "Improve this Doc Class ObjectTarget Implements IRezolveTarget by wrapping a single instance that's already been constructed. By default, scope tracking is disabled (since the caller owns the object, not the Rezolver framework)). If it's enabled, then scope tracking behaves exactly the same as SingletonTarget . Inheritance System.Object TargetBase ObjectTarget Inherited Members UseFallback CreateScopeTrackingExpression(CompileContext, Expression) CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) SupportsType(Type) CreateExpression(CompileContext) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ObjectTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ObjectTarget(Object, Type, Boolean) Creates a new instance of the ObjectTarget class. Declaration public ObjectTarget(object obj, Type declaredType = null, bool suppressScopeTracking = true) Parameters Name Type Description obj System.Object The object to be returned by this target when resolved. declaredType System.Type Optional. The declared type of this target, if different from the absolute type of the obj suppressScopeTracking System.Boolean Optional. Controls whether the instance will be added to a scope when resolved. If true (the default) then no scope tracking is performed, and you will have to dispose of the object, if disposable. If false, then the object will be tracked by the ROOT scope of the first scope the object is resolved from. Remarks Please note - if you enable scope tracking, but the object is never resolved, then the object will not be disposed and you will need to ensure you dispose of it. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description System.Type Overrides DeclaredType <!-- .classchild --> | Improve this Doc SuppressScopeTracking Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description System.Boolean Overrides SuppressScopeTracking <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateExpressionBase(CompileContext) Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides CreateExpressionBase(CompileContext) <!-- .classchild --> | Improve this Doc CreateScopeSelectionExpression(CompileContext, Expression) Declaration protected override Expression CreateScopeSelectionExpression(CompileContext context, Expression expression) Parameters Name Type Description context CompileContext expression Expression Returns Type Description Expression Overrides CreateScopeSelectionExpression(CompileContext, Expression) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Microsoft.Extensions.DependencyInjection.html": {
    "href": "rezolver-api/Rezolver.Microsoft.Extensions.DependencyInjection.html",
    "title": "Namespace Rezolver.Microsoft.Extensions.DependencyInjection",
    "keywords": "Improve this Doc Namespace Rezolver.Microsoft.Extensions.DependencyInjection Classes RezolverRegistration"
  },
  "rezolver-api/Rezolver.Microsoft.Extensions.DependencyInjection.RezolverRegistration.html": {
    "href": "rezolver-api/Rezolver.Microsoft.Extensions.DependencyInjection.RezolverRegistration.html",
    "title": "Class RezolverRegistration",
    "keywords": "Improve this Doc Class RezolverRegistration Inheritance System.Object RezolverRegistration Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Microsoft.Extensions.DependencyInjection Assembly :cs.temp.dll.dll Syntax public class RezolverRegistration <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateDefaultContainer(ITargetContainer) Declaration public static IContainer CreateDefaultContainer(ITargetContainer targetContainer) Parameters Name Type Description targetContainer ITargetContainer Returns Type Description IContainer <!-- .classchild --> | Improve this Doc Populate(ContainerBase, IServiceCollection) Declaration public static IServiceProvider Populate(this ContainerBase rezolver, IServiceCollection services) Parameters Name Type Description rezolver ContainerBase services IServiceCollection Returns Type Description System.IServiceProvider <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.MethodCallExtractor.html": {
    "href": "rezolver-api/Rezolver.MethodCallExtractor.html",
    "title": "Class MethodCallExtractor",
    "keywords": "Improve this Doc Class MethodCallExtractor Inheritance System.Object MethodCallExtractor Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public sealed class MethodCallExtractor : ExpressionVisitor <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc CalledConstructor Declaration public ConstructorInfo CalledConstructor { get; } Property Value Type Description ConstructorInfo <!-- .classchild --> | Improve this Doc CalledMethod Declaration public MethodInfo CalledMethod { get; } Property Value Type Description MethodInfo <!-- .classchild --> | Improve this Doc CallExpression Declaration public MethodCallExpression CallExpression { get; } Property Value Type Description MethodCallExpression <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc ExtractCalledMethod(Expression<Action>) Declaration public static MethodInfo ExtractCalledMethod(Expression<Action> expr) Parameters Name Type Description expr Expression < System.Action > Returns Type Description MethodInfo <!-- .classchild --> | Improve this Doc ExtractCalledMethod<T>(Expression<Action<T>>) Declaration public static MethodInfo ExtractCalledMethod<T>(Expression<Action<T>> expr) Parameters Name Type Description expr Expression < System.Action <T>> Returns Type Description MethodInfo Type Parameters Name Description T <!-- .classchild --> | Improve this Doc ExtractCalledMethod<TResult>(Expression<Func<TResult>>) Declaration public static MethodInfo ExtractCalledMethod<TResult>(Expression<Func<TResult>> expr) Parameters Name Type Description expr Expression < System.Func <TResult>> Returns Type Description MethodInfo Type Parameters Name Description TResult <!-- .classchild --> | Improve this Doc ExtractCalledMethod<TInstance, TResult>(Expression<Func<TInstance, TResult>>) Declaration public static MethodInfo ExtractCalledMethod<TInstance, TResult>(Expression<Func<TInstance, TResult>> expr) Parameters Name Type Description expr Expression < System.Func <TInstance, TResult>> Returns Type Description MethodInfo Type Parameters Name Description TInstance TResult <!-- .classchild --> | Improve this Doc ExtractConstructorCall(Expression<Action>) Declaration public static ConstructorInfo ExtractConstructorCall(Expression<Action> expr) Parameters Name Type Description expr Expression < System.Action > Returns Type Description ConstructorInfo <!-- .classchild --> | Improve this Doc ExtractConstructorCall<T>(Expression<Action<T>>) Declaration public static ConstructorInfo ExtractConstructorCall<T>(Expression<Action<T>> expr) Parameters Name Type Description expr Expression < System.Action <T>> Returns Type Description ConstructorInfo Type Parameters Name Description T <!-- .classchild --> | Improve this Doc ExtractConstructorCall<TResult>(Expression<Func<TResult>>) Declaration public static ConstructorInfo ExtractConstructorCall<TResult>(Expression<Func<TResult>> expr) Parameters Name Type Description expr Expression < System.Func <TResult>> Returns Type Description ConstructorInfo Type Parameters Name Description TResult <!-- .classchild --> | Improve this Doc ExtractConstructorCall<TInstance, TResult>(Expression<Func<TInstance, TResult>>) Declaration public static ConstructorInfo ExtractConstructorCall<TInstance, TResult>(Expression<Func<TInstance, TResult>> expr) Parameters Name Type Description expr Expression < System.Func <TInstance, TResult>> Returns Type Description ConstructorInfo Type Parameters Name Description TInstance TResult <!-- .classchild --> | Improve this Doc VisitMethodCall(MethodCallExpression) Declaration protected override Expression VisitMethodCall(MethodCallExpression node) Parameters Name Type Description node MethodCallExpression Returns Type Description Expression <!-- .classchild --> | Improve this Doc VisitNew(NewExpression) Declaration protected override Expression VisitNew(NewExpression node) Parameters Name Type Description node NewExpression Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ListTarget.html": {
    "href": "rezolver-api/Rezolver.ListTarget.html",
    "title": "Class ListTarget",
    "keywords": "Improve this Doc Class ListTarget This exists primarily for the configuration system. This target produces arrays or lists whose individual items are built by IRezolveTarget instances. If you are setting up your container environment from code - e.g. using expressions, then you shouldn't need to use this unless you have some pretty extreme requirements for the different targets that will contribute each element of your list/array. Inheritance System.Object TargetBase ListTarget Inherited Members SuppressScopeTracking CreateScopeTrackingExpression(CompileContext, Expression) CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) CreateScopeSelectionExpression(CompileContext, Expression) SupportsType(Type) CreateExpression(CompileContext) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ListTarget : TargetBase, ITarget Remarks The element type you feed on construction determines the type of array or the generic argument to List . Each of the rezolve targets that you then pass must support that type. You can control whether the created instance is an array or a List with the 'asArray' boolean constructor argument. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ListTarget(Type, IEnumerable<ITarget>, Boolean) Initializes a new instance of the ListTarget class. Declaration public ListTarget(Type elementType, IEnumerable<ITarget> items, bool asArray = false) Parameters Name Type Description elementType System.Type Required. Type of the elements in the array or list. items System.Collections.Generic.IEnumerable < ITarget > Required. The targets that will create each the individual items. asArray System.Boolean A boolean indicating whether the target will build an array ( true ) or a list ( false ). Exceptions Type Condition System.ArgumentNullException elementType or items System.ArgumentException All targets in the items enumerable must be non-null;items or All targets in the items enumerable must support the element type elementType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc AsArray Gets a value indicating whether the target will build an array ( true ) or a list ( false ). Declaration public bool AsArray { get; } Property Value Type Description System.Boolean <!-- .classchild --> | Improve this Doc DeclaredType Implementation of the abstract property from the base. This will always return either a type equal to an array of ElementType , or List with ElementType as the generic parameter. This is controlled by the AsArray property. Declaration public override Type DeclaredType { get; } Property Value Type Description System.Type Overrides DeclaredType <!-- .classchild --> | Improve this Doc ElementType Gets the declared type of each element in the array or list that will be constructed. The DeclaredType returned by this instance will either be ElementType[] or List depending on the value of AsArray . Declaration public Type ElementType { get; } Property Value Type Description System.Type The declared type of each element. <!-- .classchild --> | Improve this Doc Items Gets the rezolve targets that will build each individual item in the resulting list or array. Declaration public IEnumerable<ITarget> Items { get; } Property Value Type Description System.Collections.Generic.IEnumerable < ITarget > The items. <!-- .classchild --> | Improve this Doc UseFallback Returns true if the Items enumerable is empty. Declaration public override bool UseFallback { get; } Property Value Type Description System.Boolean Overrides UseFallback <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateExpressionBase(CompileContext) Constructs an expression that represents building an array of ElementType or List< ElementType > depending on the value of AsArray . Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext The current compile context Returns Type Description System.Linq.Expressions.Expression System.Linq.Expressions.Expression. Overrides CreateExpressionBase(CompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.LifetimeScopeRezolverExtensions.html": {
    "href": "rezolver-api/Rezolver.LifetimeScopeRezolverExtensions.html",
    "title": "Class LifetimeScopeRezolverExtensions",
    "keywords": "Improve this Doc Class LifetimeScopeRezolverExtensions Inheritance System.Object LifetimeScopeRezolverExtensions Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class LifetimeScopeRezolverExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc GetOrAdd<T>(IScopedContainer, RezolveContext, Func<RezolveContext, T>, Boolean) Declaration public static T GetOrAdd<T>(this IScopedContainer scope, RezolveContext context, Func<RezolveContext, T> factory, bool disposableOnly = true) Parameters Name Type Description scope IScopedContainer context RezolveContext factory System.Func < RezolveContext , T> disposableOnly System.Boolean Returns Type Description T Type Parameters Name Description T <!-- .classchild --> | Improve this Doc GetScopeRoot(IScopedContainer) As the name suggests - this grabs the root scope for the scope on which this method is invoked. Declaration public static IScopedContainer GetScopeRoot(this IScopedContainer scope) Parameters Name Type Description scope IScopedContainer The scope whose root scope is sought. If null, then the method also returns null. Returns Type Description IScopedContainer An IScopedContainer reference representing the top-level (root) scope for the passed scope. <!-- .classchild --> | Improve this Doc GetSingleFromScope(IScopedContainer, RezolveContext) Retrieves a single instance that was previously added to the scope (or, optionally parent scopes) through a call to AddToScope(Object, RezolveContext) with a RezolveContext matching the one passed. Note - if multiple matches are found in a single scope, an InvalidOperationException will be thrown. Declaration public static object GetSingleFromScope(this IScopedContainer scope, RezolveContext context) Parameters Name Type Description scope IScopedContainer Required. The scope to be searched and optionally whose parent scopes are to be searched. context RezolveContext Required. The context whose properties will be used to find the matching disposable. Returns Type Description System.Object <!-- .classchild --> | Improve this Doc TrackIfScopedAndDisposableAndReturn<T>(IScopedContainer, T) This is primarily used by the dynamic code generated by RezolveTargetBase - if the scope is non-null and the instance is an IDiposable, then the object will be added to the scope. The instance , either way, is returned to simplify the function's use in dynamic code produced from expression trees. Declaration public static T TrackIfScopedAndDisposableAndReturn<T>(this IScopedContainer scope, T instance) Parameters Name Type Description scope IScopedContainer instance T Returns Type Description T Type Parameters Name Description T <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITargetContainerOwner.html": {
    "href": "rezolver-api/Rezolver.ITargetContainerOwner.html",
    "title": "Interface ITargetContainerOwner",
    "keywords": "Improve this Doc Interface ITargetContainerOwner Interface for an ITargetContainer which also contains other target containers. Inherited Members Register(ITarget, Type) Fetch(Type) FetchAll(Type) CombineWith(ITargetContainer, Type) Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITargetContainerOwner : ITargetContainer <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc FetchContainer(Type) Retrieves an existing container registered against the given type , or null if not found. Declaration ITargetContainer FetchContainer(Type type) Parameters Name Type Description type System.Type Returns Type Description ITargetContainer <!-- .classchild --> | Improve this Doc RegisterContainer(Type, ITargetContainer) Registers a container against a given type . If a container already exists against this type, and the new container is an ITargetContainerOwner , then the container that is returned by its method will replace the existing one. Declaration void RegisterContainer(Type type, ITargetContainer container) Parameters Name Type Description type System.Type container ITargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.ITargetContainerExtensions.html",
    "title": "Class ITargetContainerExtensions",
    "keywords": "Improve this Doc Class ITargetContainerExtensions Extension methods for implementations of ITargetContainer . Inheritance System.Object ITargetContainerExtensions Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ITargetContainerExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc RegisterAlias(ITargetContainer, Type, Type) Registers an alias for one type to another type. The created entry will effectively represent a second Resolve call into the container for the aliased type. Declaration public static void RegisterAlias(this ITargetContainer builder, Type aliasType, Type aliasedType) Parameters Name Type Description builder ITargetContainer The builder in which the alias is to be registered aliasType System.Type The type to be registered as an alias aliasedType System.Type The type being aliased. Remarks Use this when it's important that a given target type is always served through the same compiled target, even when the consumer expects it to be of a different type. A very common scenario is when you have a singleton instance of the aliasedType , and need to serve that same instance for aliasType . If you register the same singleton for both types, you get two separate singletons for each type. <!-- .classchild --> | Improve this Doc RegisterAlias<TAlias, TAliased>(ITargetContainer) Generic version of , see that method for more. Declaration public static void RegisterAlias<TAlias, TAliased>(this ITargetContainer builder) Parameters Name Type Description builder ITargetContainer RegisterAlias (ITargetContainer) Type Parameters Name Description TAlias Type being registered as an alias to another type TAliased The target type of the alias. <!-- .classchild --> | Improve this Doc RegisterAll(ITargetContainer, ITarget[]) Batch-registers multiple targets with different contracts. This is like calling multiple times, once for each of the targets in the array. Declaration public static void RegisterAll(this ITargetContainer builder, params ITarget[] targets) Parameters Name Type Description builder ITargetContainer The builder. targets ITarget [] The targets to be registered. <!-- .classchild --> | Improve this Doc RegisterAll(ITargetContainer, IEnumerable<ITarget>) Batch-registers multiple targets with different contracts. This is like calling multiple times, once for each of the targets in the enumerable. Declaration public static void RegisterAll(this ITargetContainer builder, IEnumerable<ITarget> targets) Parameters Name Type Description builder ITargetContainer The builder. targets System.Collections.Generic.IEnumerable < ITarget > The targets to be registered <!-- .classchild --> | Improve this Doc RegisterDecorator(ITargetContainerOwner, Type, Type) Declaration public static void RegisterDecorator(this ITargetContainerOwner builder, Type decoratorType, Type decoratedType) Parameters Name Type Description builder ITargetContainerOwner decoratorType System.Type decoratedType System.Type <!-- .classchild --> | Improve this Doc RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) Declaration public static void RegisterDecorator<TDecorator, TDecorated>(this ITargetContainerOwner builder) Parameters Name Type Description builder ITargetContainerOwner Type Parameters Name Description TDecorator TDecorated <!-- .classchild --> | Improve this Doc RegisterExpression<T>(ITargetContainer, Expression<Func<RezolveContextExpressionHelper, T>>, Type, ITargetAdapter) Registers an expression to be used as a factory for obtaining an instance when the registration matches a resolve request. Declaration public static void RegisterExpression<T>(this ITargetContainer builder, Expression<Func<RezolveContextExpressionHelper, T>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Name Type Description builder ITargetContainer expression Expression < System.Func < RezolveContextExpressionHelper , T>> The expression to be analysed and used as a factory. The argument that is received by this expression can be used to emit explicit calls back into the resolver to indicate that a particular argument/property value or whatever should be resolved. type System.Type Optional. The type against which the registration is to be made, if different from T . adapter ITargetAdapter Optional. The adapter that will be used to convert the expression into an ITarget . This defaults to Default . Extending this is an advanced topic and shouldn't be required in most cases. Type Parameters Name Description T Remarks This is not the same as registering a factory delegate for creating objects - where the code you supply is already compiled and ready to go. The expression that is passed is analysed by the adapter (or the default) and rewritten according to the expressions container within. In general, there is a one to one mapping between the code you provide and the code that's produced, but it's not guaranteed. In particular, calls back to the resolver to resolve dependencies are identified and turned into a different representation internally, so that dependency resolution works inside your code in just the same way as it does when using the higher-level targets. <!-- .classchild --> | Improve this Doc RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) Called to register multiple rezolve targets against a shared contract, optionally replacing any existing registration(s) or extending them. It is analogous to calling Register(ITarget, Type) multiple times with the different targets. Declaration public static void RegisterMultiple(this ITargetContainer builder, IEnumerable<ITarget> targets, Type commonServiceType = null) Parameters Name Type Description builder ITargetContainer The builder in which the registration is to be performed. targets System.Collections.Generic.IEnumerable < ITarget > The targets to be registered - all must support a common service type (potentially passed in the commonServiceType argument. commonServiceType System.Type Optional - instead of determining the common service type automatically, you can provide it in advance through this parameter. Note that all targets must support this type. <!-- .classchild --> | Improve this Doc RegisterObject<T>(ITargetContainer, T, Type, Boolean) Registers a single instance (already created) to be used when resolving a particular service type. If using a scope, then the object will be tracked in the rootmost scope so that, if it's disposable, it will be disposed when the root scope is disposed. Declaration public static void RegisterObject<T>(this ITargetContainer builder, T obj, Type serviceType = null, bool suppressScopeTracking = true) Parameters Name Type Description builder ITargetContainer obj T The object to be returned when resolving. serviceType System.Type The service type against which this object is to be registered, if different from T . suppressScopeTracking System.Boolean Type Parameters Name Description T Type of the object - will be used as the service type for registration if serviceType is not provied. <!-- .classchild --> | Improve this Doc RegisterScoped(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Version of RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) that creates instances that are scoped to the active IScopedContainer at the time Resolve(RezolveContext) (or TryResolve(RezolveContext, out Object) ) is called. Declaration public static void RegisterScoped(this ITargetContainer builder, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer objectType System.Type RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) serviceType System.Type RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) propertyBindingBehaviour IPropertyBindingBehaviour RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) <!-- .classchild --> | Improve this Doc RegisterScoped<TObject>(ITargetContainer, IPropertyBindingBehaviour) Version of RegisterType (ITargetContainer, IPropertyBindingBehaviour) that creates instances that are scoped to the active IScopedContainer at the time Resolve(RezolveContext) (or TryResolve(RezolveContext, out Object) ) is called. Declaration public static void RegisterScoped<TObject>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour See RegisterType (ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType (ITargetContainer, IPropertyBindingBehaviour) <!-- .classchild --> | Improve this Doc RegisterScoped<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Version of RegisterType (ITargetContainer, IPropertyBindingBehaviour) that creates instances that are scoped to the active IScopedContainer at the time Resolve(RezolveContext) (or TryResolve(RezolveContext, out Object) ) is called. Declaration public static void RegisterScoped<TObject, TService>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour See RegisterType (ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType (ITargetContainer, IPropertyBindingBehaviour) TService See RegisterType (ITargetContainer, IPropertyBindingBehaviour) <!-- .classchild --> | Improve this Doc RegisterSingleton(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Version of RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) that creates singleton instances that are also scoped to the root scope of the active IScopedContainer at the time Resolve(RezolveContext) (or TryResolve(RezolveContext, out Object) ) is called. Declaration public static void RegisterSingleton(this ITargetContainer builder, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer objectType System.Type RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) serviceType System.Type RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) propertyBindingBehaviour IPropertyBindingBehaviour RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) <!-- .classchild --> | Improve this Doc RegisterSingleton<TObject>(ITargetContainer, IPropertyBindingBehaviour) Version of RegisterType (ITargetContainer, IPropertyBindingBehaviour) that creates singleton instances that are also scoped to the root scope of the active IScopedContainer at the time Resolve(RezolveContext) (or TryResolve(RezolveContext, out Object) ) is called. Declaration public static void RegisterSingleton<TObject>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour See RegisterType (ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType (ITargetContainer, IPropertyBindingBehaviour) <!-- .classchild --> | Improve this Doc RegisterSingleton<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Version of RegisterType (ITargetContainer, IPropertyBindingBehaviour) that creates singleton instances that are also scoped to the root scope of the active IScopedContainer at the time Resolve(RezolveContext) (or TryResolve(RezolveContext, out Object) ) is called. Declaration public static void RegisterSingleton<TObject, TService>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour See RegisterType (ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType (ITargetContainer, IPropertyBindingBehaviour) TService See RegisterType (ITargetContainer, IPropertyBindingBehaviour) <!-- .classchild --> | Improve this Doc RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Non-generic version of RegisterType (ITargetContainer, IPropertyBindingBehaviour) . Declaration public static void RegisterType(this ITargetContainer targets, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description targets ITargetContainer objectType System.Type Required. Type of object to be constructed serviceType System.Type See Register(ITarget, Type) propertyBindingBehaviour IPropertyBindingBehaviour RegisterType (ITargetContainer, IPropertyBindingBehaviour) <!-- .classchild --> | Improve this Doc RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) Registers a type to be created by the Rezolver via construction. The registration will auto-bind a constructor (most greedy) on the type and optionally bind any properties/fields on the new object, depending on the IPropertyBindingBehaviour object passed. Note that this method supports open generics. Declaration public static void RegisterType<TObject>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour The property binding behaviour. If null, then no properties are bound. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via their 'Auto' static methods and then registering them. <!-- .classchild --> | Improve this Doc RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) This is the same as RegisterType (ITargetContainer, IPropertyBindingBehaviour) , except the TService type parameter allows you to explicitly set the type against which the registration is to be made. Declaration public static void RegisterType<TObject, TService>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null)where TObject : TService Parameters Name Type Description builder ITargetContainer propertyBindingBehaviour IPropertyBindingBehaviour RegisterType (ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType (ITargetContainer, IPropertyBindingBehaviour) TService The type against which the registration is to be made in the builder. E.g. 'IFoo' when TObject is 'Foo'. Remarks Please note the generic parameter constraints on this method: TService must have TObject as a base or interface in order for your code to compile. Note that if you use the RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) overload, then this is not the case. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITargetContainer.html": {
    "href": "rezolver-api/Rezolver.ITargetContainer.html",
    "title": "Interface ITargetContainer",
    "keywords": "Improve this Doc Interface ITargetContainer Stores and retrieves ITarget instances, keyed by the type of service that the targets are registered against. Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITargetContainer Remarks You do not resolve objects from a target container, instead, it holds the ITarget s which will later be compiled to produce the objects. An IContainer typically uses this as the source of the registrations that it uses to resolve objects in its Resolve(RezolveContext) method via it's property. Note that there are multiple implementations of this interface in the framework, however the two you will use most commonly are TargetContainer and ChildTargetContainer . <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CombineWith(ITargetContainer, Type) If supported by the implementation, this gets the container built from combining this container with an existing container as part of a registration inside another ITargetContainerOwner . Used most frequently in implementations of RegisterContainer(Type, ITargetContainer) when a container owner is already registered against the type, and a new container owner is then registered against the same type. Declaration ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer The existing ITargetContainer instance that this instance is to be combined with type System.Type The type that the combined container owner will be registered under. Returns Type Description ITargetContainer Exceptions Type Condition System.NotSupportedException If this container doesn't support being combined with another. <!-- .classchild --> | Improve this Doc Fetch(Type) Retrieves a target for a particular type, or null if no target is registered against that type. Declaration ITarget Fetch(Type type) Parameters Name Type Description type System.Type Required. The type for which an ITarget is to be retrieved. Returns Type Description ITarget The target for the given type , or null if no target is found. Remarks The target you receive from this method depends entirely on the implementation. It could be the last target to be registered against the type or the first, or another target entirely. As mentioned in the documentation for the Register(ITarget, Type) method - the only guarantee is that if at least one target has been registered for the same type, then this method should return a valid target. <!-- .classchild --> | Improve this Doc FetchAll(Type) Retrieves an enumerable of all targets that have been registered for a particular type . Declaration IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type System.Type Required. The type for which the ITarget s are to be retrieved. Returns Type Description System.Collections.Generic.IEnumerable < ITarget > An enumerable containing all the targets that have been registered against the given type , or, an empty enumerable if no targets have been registered. Remarks As with Fetch(Type) , the only guarantee is that if a target has been registered for the type through a call to Register(ITarget, Type) , then the returned enumerable will contain at least one valid target. <!-- .classchild --> | Improve this Doc Register(ITarget, Type) Registers a target, either for the serviceType specified or, if null, the DeclaredType of the target . Declaration void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget Required. The target to be registered serviceType System.Type Optional. The type the target is to be registered against, if different from the DeclaredType of the target . If provided, then the target must be compatible with this type. Remarks The interface does not define the behaviour for when multiple targets are registered against the same type - although the default behaviour of the framework (via the TargetContainer class) is to allow this, with the last registered target being treated as the 'default' for that type. The only guarantee expected by the framework from implementations of this interface is that if a target is registered against a given type with this method, then a Fetch(Type) operation with the same type should return a valid target, and a FetchAll(Type) operation should return a non-empty enumerable of targets. Exceptions Type Condition System.ArgumentException If serviceType is non-null and the target 's SupportsType(Type) method returns false for that type. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITargetCompiler.html": {
    "href": "rezolver-api/Rezolver.ITargetCompiler.html",
    "title": "Interface ITargetCompiler",
    "keywords": "Improve this Doc Interface ITargetCompiler An object that produces ICompiledTarget s from ITarget s given a particular CompileContext . Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITargetCompiler <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CompileTarget(ITarget, CompileContext) Create the ICompiledTarget for the given target using the context to inform the type of object that is to be built, and for compile-time dependency resolution. Declaration ICompiledTarget CompileTarget(ITarget target, CompileContext context) Parameters Name Type Description target ITarget Required. The target to be compiled. context CompileContext Required. The current compilation context. Returns Type Description ICompiledTarget A compiled target which can then be used to get produce objects represented by the target . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITargetAdapter.html": {
    "href": "rezolver-api/Rezolver.ITargetAdapter.html",
    "title": "Interface ITargetAdapter",
    "keywords": "Improve this Doc Interface ITargetAdapter Interface for an object that is responsible for converting Expressions into ITarget s. Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITargetAdapter <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateTarget(Expression) Declaration ITarget CreateTarget(Expression expression) Parameters Name Type Description expression Expression Returns Type Description ITarget <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ITarget.html": {
    "href": "rezolver-api/Rezolver.ITarget.html",
    "title": "Interface ITarget",
    "keywords": "Improve this Doc Interface ITarget As the name suggests, the underlying target of a Rezolver call. The output of a target is an expression. This allows a target that depends on another target to chain expressions together, creating specialised expression trees (and therefore specialised delegates). The expression produced from this interface is later compiled, by an IRezolveTargetCompiler, into an ICompiledRezolveTarget - whose job it is specifically to produce object instances. Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Gets the static type produced by this target, when executing the expression returned from a call to CreateExpression(CompileContext) without providing your own explicit type to be returned. Declaration Type DeclaredType { get; } Property Value Type Description System.Type The type of the declared. <!-- .classchild --> | Improve this Doc UseFallback If true, it is an instruction to any consumer to consider falling back to a better target configured in a more authoritative builder. In general - almost all targets return false for this. Declaration bool UseFallback { get; } Property Value Type Description System.Boolean <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateExpression(CompileContext) Called to create the expression that will produce the object that is resolved by this target. The expression might be expected to handle a dynamic container being passed to it at run time to enable dynamic per-target overriding from other rezolvers. Declaration Expression CreateExpression(CompileContext context) Parameters Name Type Description context CompileContext The current compile context Returns Type Description Expression <!-- .classchild --> | Improve this Doc SupportsType(Type) Returns a boolean indicating whether the target is able to produce an instance of, or an instance that is compatible with, the passed type . Declaration bool SupportsType(Type type) Parameters Name Type Description type System.Type The type. Returns Type Description System.Boolean true if type is supported, false otherwise. Remarks It is strongly suggested that you use this method to check whether the target can construct an instance of a given type rather than performing any type checking yourself on the DeclaredType , because an ITarget might be able to support a much wider range of types other than just those which are directly compatible with its DeclaredType . <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IScopedContainer.html": {
    "href": "rezolver-api/Rezolver.IScopedContainer.html",
    "title": "Interface IScopedContainer",
    "keywords": "Improve this Doc Interface IScopedContainer A container that's also a lifetime scope - that is, it's disposable, and will dispose of any disposable instances that it creates when it's disposed. Also, any subsequent lifetime scopes that it, or any child, creates will be disposed of when this scope is disposed. Note that while a lifetime scope can track objects of any types, it only automatically tracks disposable objects. To force a scope to track an instance, regardless of whether it's dispoable or not, you can call AddToScope(Object, RezolveContext) . This is how the default ScopedSingletonTarget works - if an object with this lifetime isn't a disposable, it is explicitly added to the scope passed to it at runtime, and then when an instance is subsequently requested, the code compiled by the scoped singleton will search the current scope, for an existing instance, before creating one. Inherited Members CanResolve(RezolveContext) Resolve(RezolveContext) TryResolve(RezolveContext, out Object) CreateLifetimeScope() FetchCompiled(RezolveContext) System.IServiceProvider.GetService(System.Type) System.IDisposable.Dispose() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IScopedContainer : IContainer, IServiceProvider, IDisposable <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc ParentScope If this lifetime scope is a child of another, this will be non-null. Declaration IScopedContainer ParentScope { get; } Property Value Type Description IScopedContainer <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc AddToScope(Object, RezolveContext) Registers an instance to this scope which, if disposable, will then be disposed when this scope is disposed. Declaration void AddToScope(object obj, RezolveContext context = null) Parameters Name Type Description obj System.Object The object; if null, then no operation is performed. Doesn't have to be IDisposable, but if it is, then it will be tracked for disposal. context RezolveContext Optional - a rezolve context representing the conditions under which the object should be returned in the enumerable returned from a call to GetFromScope <!-- .classchild --> | Improve this Doc GetFromScope(RezolveContext) Retrieves all objects from this scope that were previously added through a call to AddToScope(Object, RezolveContext) with RezolveContexts that match the one passed. The method never returns null. Declaration IEnumerable<object> GetFromScope(RezolveContext context) Parameters Name Type Description context RezolveContext Required - the context whose properties will be used to find matching objects. Returns Type Description System.Collections.Generic.IEnumerable < System.Object > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Events | Improve this Doc Disposed This event is fired before the scope disposes This is primarily for infrastructure purposes, and not intended to be used from your code. Declaration event EventHandler Disposed Event Type Type Description System.EventHandler <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IRezolveTargetSingletonExtensions.html": {
    "href": "rezolver-api/Rezolver.IRezolveTargetSingletonExtensions.html",
    "title": "Class IRezolveTargetSingletonExtensions",
    "keywords": "Improve this Doc Class IRezolveTargetSingletonExtensions Extension method(s) to convert targets into singleton targets. Inheritance System.Object IRezolveTargetSingletonExtensions Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class IRezolveTargetSingletonExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Singleton(ITarget) Constructs a SingletonTarget that wraps the target on which the method is invoked. Declaration public static SingletonTarget Singleton(this ITarget target) Parameters Name Type Description target ITarget Returns Type Description SingletonTarget <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IRezolveTargetScopingExtensions.html": {
    "href": "rezolver-api/Rezolver.IRezolveTargetScopingExtensions.html",
    "title": "Class IRezolveTargetScopingExtensions",
    "keywords": "Improve this Doc Class IRezolveTargetScopingExtensions Extension method(s) to convert targets into scoped targets. Inheritance System.Object IRezolveTargetScopingExtensions Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class IRezolveTargetScopingExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Scoped(ITarget) Creates a ScopedTarget from the target on which this method is invoked. Declaration public static ScopedTarget Scoped(this ITarget target) Parameters Name Type Description target ITarget Returns Type Description ScopedTarget <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IPropertyBindingBehaviour.html": {
    "href": "rezolver-api/Rezolver.IPropertyBindingBehaviour.html",
    "title": "Interface IPropertyBindingBehaviour",
    "keywords": "Improve this Doc Interface IPropertyBindingBehaviour Describes a type which discovers property/field bindings Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IPropertyBindingBehaviour <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc GetPropertyBindings(CompileContext, Type) Retrieves the property and/or field bindings for the given type based on the given CompileContext Declaration PropertyOrFieldBinding[] GetPropertyBindings(CompileContext context, Type type) Parameters Name Type Description context CompileContext type System.Type Returns Type Description PropertyOrFieldBinding [] <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IContainerRezolveExtensions.html": {
    "href": "rezolver-api/Rezolver.IContainerRezolveExtensions.html",
    "title": "Class IContainerRezolveExtensions",
    "keywords": "Improve this Doc Class IContainerRezolveExtensions Inheritance System.Object IContainerRezolveExtensions Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class IContainerRezolveExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Resolve(IContainer, Type) Resolves an object of the given type Declaration public static object Resolve(this IContainer container, Type type) Parameters Name Type Description container IContainer The container. type System.Type The type to be resolved. Returns Type Description System.Object An instance of the type . <!-- .classchild --> | Improve this Doc Resolve(IContainer, Type, IScopedContainer) Resolves an object of the given type , using the given lifetime scope for lifetime management. Declaration public static object Resolve(this IContainer container, Type type, IScopedContainer scope) Parameters Name Type Description container IContainer The container. type System.Type Type to be resolved. scope IScopedContainer The lifetime scope - can be a different instance to container (or the object on which the method is invoked if invoked as an extension method), e.g. when a master container instance is used to create a child 'scope' which has a different lifetime to that of the master. Returns Type Description System.Object An instance of the requested type . <!-- .classchild --> | Improve this Doc Resolve<TObject>(IContainer) Resolves an object of type TObject Declaration public static TObject Resolve<TObject>(this IContainer container) Parameters Name Type Description container IContainer The container. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject The type to be resolved. <!-- .classchild --> | Improve this Doc Resolve<TObject>(IContainer, IScopedContainer) Resolves an object of the type TObject , using the given lifetime scope for lifetime management. Declaration public static TObject Resolve<TObject>(this IContainer container, IScopedContainer scope) Parameters Name Type Description container IContainer The container. scope IScopedContainer The lifetime scope - can be a different instance to container (or the object on which the method is invoked if invoked as an extension method), e.g. when a master container instance is used to create a child 'scope' which has a different lifetime to that of the master. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject Type to be resolved. <!-- .classchild --> | Improve this Doc TryResolve(IContainer, Type, IScopedContainer, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer container, Type type, IScopedContainer scope, out object result) Parameters Name Type Description container IContainer The container. type System.Type The type to be resolved. scope IScopedContainer The lifetime scope - can be a different instance to container (or the object on which the method is invoked if invoked as an extension method), e.g. when a master container instance is used to create a child 'scope' which has a different lifetime to that of the master. result System.Object Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description System.Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type, IScopedContainer) overloads <!-- .classchild --> | Improve this Doc TryResolve(IContainer, Type, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer container, Type type, out object result) Parameters Name Type Description container IContainer The container. type System.Type The type to be resolved. result System.Object Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description System.Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type) overloads <!-- .classchild --> | Improve this Doc TryResolve<TObject>(IContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer container, out TObject result) Parameters Name Type Description container IContainer The container. result TObject Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description System.Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved. <!-- .classchild --> | Improve this Doc TryResolve<TObject>(IContainer, IScopedContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer container, IScopedContainer scope, out TObject result) Parameters Name Type Description container IContainer The container. scope IScopedContainer The lifetime scope - can be a different instance to container (or the object on which the method is invoked if invoked as an extension method), e.g. when a master container instance is used to create a child 'scope' which has a different lifetime to that of the master. result TObject Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description System.Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IContainer.html": {
    "href": "rezolver-api/Rezolver.IContainer.html",
    "title": "Interface IContainer",
    "keywords": "Improve this Doc Interface IContainer Represents the primary IOC container in the Rezolver framework. Inherited Members System.IServiceProvider.GetService(System.Type) Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IContainer : IServiceProvider Remarks Instances of objects are resolved via the Resolve(RezolveContext) or TryResolve(RezolveContext, out Object) methods. You can introspect the container to check in advance whether a given type can be resolved through the CanResolve(RezolveContext) method. Lifetime scoping (where IDisposable objects are created within a scope and destroyed when that scope is destroyed) can be achieved by obtaining a new scope through the CreateLifetimeScope() method. Many of the functions which accept a RezolveContext also have alternatives (in the form of extension methods) in the IContainerRezolveExtensions class. <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CanResolve(RezolveContext) Returns true if a resolve operation for the given context will succeed. If you're going to be calling Resolve(RezolveContext) immediately afterwards, consider using the TryResolve method instead, which allows you to check and obtain the result at the same time. Declaration bool CanResolve(RezolveContext context) Parameters Name Type Description context RezolveContext The context. Returns Type Description System.Boolean true if this instance can resolve the specified context; otherwise, false . <!-- .classchild --> | Improve this Doc CreateLifetimeScope() Called to create a lifetime scope with the same configuration as this container that will track, and dispose of, any disposable objects that are created via calls to its Resolve(RezolveContext) Declaration IScopedContainer CreateLifetimeScope() Returns Type Description IScopedContainer An IScopedContainer instance that will use this resolver to resolve objects, but which will impose its own lifetime restrictions on those instances. <!-- .classchild --> | Improve this Doc FetchCompiled(RezolveContext) Fetches the compiled target for the given context. This is not typically a method that consumers of an IContainer are likely to use; it's more typically used by code generation code (or even generated code) to interoperate between two resolvers, or indeed over other object. Declaration ICompiledTarget FetchCompiled(RezolveContext context) Parameters Name Type Description context RezolveContext The context. Returns Type Description ICompiledTarget ICompiledRezolveTarget. <!-- .classchild --> | Improve this Doc Resolve(RezolveContext) The core 'resolve' operation for a Rezolver container. The object is resolved using state from the passed context , including any active lifetime scope and a reference to the original container instance that was called, which could be a different container to this one. Declaration object Resolve(RezolveContext context) Parameters Name Type Description context RezolveContext The context. Returns Type Description System.Object The resolved object, if successful. Exceptions Type Condition System.InvalidOperationException If the requested type cannot be resolved. <!-- .classchild --> | Improve this Doc TryResolve(RezolveContext, out Object) Merges the CanResolve and Resolve operations into one call. Declaration bool TryResolve(RezolveContext context, out object result) Parameters Name Type Description context RezolveContext The context. result System.Object The result. Returns Type Description System.Boolean true if the operation succeeded (the resolved object will be set into the result parameter); false otherwise. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ICompiledTarget.html": {
    "href": "rezolver-api/Rezolver.ICompiledTarget.html",
    "title": "Interface ICompiledTarget",
    "keywords": "Improve this Doc Interface ICompiledTarget Provides an abstraction for creating objects based on a given RezolveContext . As the name suggests, it typically represents a compiled ITarget , which, in the standard IContainer implementation ( Container ) is the final stage before its ready to be used to start producing objects. An ITargetCompiler is responsible for creating these from one or more ITarget s. Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ICompiledTarget <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc GetObject(RezolveContext) Called to get/create an object, potentially using the passed context to aid resolve additional dependencies. Declaration object GetObject(RezolveContext context) Parameters Name Type Description context RezolveContext The current rezolve context. Returns Type Description System.Object The object that is constructed. The return value can legitimately be null. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.IChildTargetContainer.html": {
    "href": "rezolver-api/Rezolver.IChildTargetContainer.html",
    "title": "Interface IChildTargetContainer",
    "keywords": "Improve this Doc Interface IChildTargetContainer An IRezolveTargetContainer that is a logical child of another. A child container, if it cannot resolve a particular type, will defer to its parent for fallback. Inherited Members Register(ITarget, Type) Fetch(Type) FetchAll(Type) CombineWith(ITargetContainer, Type) Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IChildTargetContainer : ITargetContainer <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Parent Declaration ITargetContainer Parent { get; } Property Value Type Description ITargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.GenericTargetContainer.html": {
    "href": "rezolver-api/Rezolver.GenericTargetContainer.html",
    "title": "Class GenericTargetContainer",
    "keywords": "Improve this Doc Class GenericTargetContainer Inheritance System.Object TargetDictionaryContainer GenericTargetContainer Inherited Members FetchContainer(Type) RegisterContainer(Type, ITargetContainer) CreateContainer(Type, ITarget) CombineWith(ITargetContainer, Type) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class GenericTargetContainer : TargetDictionaryContainer, ITargetContainerOwner, ITargetContainer <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc GenericTargetContainer(Type) Declaration public GenericTargetContainer(Type genericType) Parameters Name Type Description genericType System.Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Fetch(Type) Declaration public override ITarget Fetch(Type type) Parameters Name Type Description type System.Type Returns Type Description ITarget Overrides Fetch(Type) <!-- .classchild --> | Improve this Doc FetchAll(Type) Declaration public override IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type System.Type Returns Type Description System.Collections.Generic.IEnumerable < ITarget > Overrides FetchAll(Type) <!-- .classchild --> | Improve this Doc Register(ITarget, Type) Declaration public override void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget serviceType System.Type Overrides Register(ITarget, Type) <!-- .classchild -->"
  },
  "rezolver-api/System.Linq.Expressions.html": {
    "href": "rezolver-api/System.Linq.Expressions.html",
    "title": "Namespace System.Linq.Expressions",
    "keywords": "Improve this Doc Namespace System.Linq.Expressions Classes ExpressionExtensions"
  },
  "rezolver-api/System.Linq.Expressions.ExpressionExtensions.html": {
    "href": "rezolver-api/System.Linq.Expressions.ExpressionExtensions.html",
    "title": "Class ExpressionExtensions",
    "keywords": "Improve this Doc Class ExpressionExtensions Inheritance System.Object ExpressionExtensions Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :System.Linq.Expressions Assembly :cs.temp.dll.dll Syntax public class ExpressionExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc AsRezolveTarget(Expression, ITargetAdapter) Declaration public static ITarget AsRezolveTarget(this Expression expression, ITargetAdapter adapter = null) Parameters Name Type Description expression Expression adapter ITargetAdapter Returns Type Description ITarget <!-- .classchild -->"
  },
  "rezolver-api/System.DelegateExtensions.html": {
    "href": "rezolver-api/System.DelegateExtensions.html",
    "title": "Class DelegateExtensions",
    "keywords": "Improve this Doc Class DelegateExtensions Inheritance System.Object DelegateExtensions Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :System Assembly :cs.temp.dll.dll Syntax public class DelegateExtensions"
  },
  "rezolver-api/Rezolver.GenericConstructorTarget.html": {
    "href": "rezolver-api/Rezolver.GenericConstructorTarget.html",
    "title": "Class GenericConstructorTarget",
    "keywords": "Improve this Doc Class GenericConstructorTarget Inheritance System.Object TargetBase GenericConstructorTarget Inherited Members SuppressScopeTracking UseFallback CreateScopeTrackingExpression(CompileContext, Expression) CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) CreateScopeSelectionExpression(CompileContext, Expression) CreateExpression(CompileContext) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class GenericConstructorTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc GenericConstructorTarget(Type, IPropertyBindingBehaviour) Declaration public GenericConstructorTarget(Type genericType, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description genericType System.Type The type of the object that is to be built (open generic of course) propertyBindingBehaviour IPropertyBindingBehaviour Optional. The IPropertyBindingBehaviour to be used for binding properties and/or fields on the 'new' expression that is generated. If null, then no property or fields will be bound on construction. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Implementation of the abstract base property. Will retrn the unbound generic type passed to this object on construction. Declaration public override Type DeclaredType { get; } Property Value Type Description System.Type Overrides DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Auto(Type, IPropertyBindingBehaviour) Declaration public static ITarget Auto(Type type, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description type System.Type propertyBindingBehaviour IPropertyBindingBehaviour Returns Type Description ITarget <!-- .classchild --> | Improve this Doc Auto<TGeneric>(IPropertyBindingBehaviour) Equivalent of Auto (IPropertyBindingBehaviour) for generic type definitions although, note that it's not possible to bind this generic method in C# directly from source code. Declaration public static ITarget Auto<TGeneric>(IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description propertyBindingBehaviour IPropertyBindingBehaviour Returns Type Description ITarget Type Parameters Name Description TGeneric <!-- .classchild --> | Improve this Doc CreateExpressionBase(CompileContext) Determines the generic type to be bound, and then generates a for that type. Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description System.Linq.Expressions.Expression Overrides CreateExpressionBase(CompileContext) <!-- .classchild --> | Improve this Doc SupportsType(Type) Override - introduces additional logic to cope with generic types not generally supported by the majority of other targets. Declaration public override bool SupportsType(Type type) Parameters Name Type Description type System.Type Returns Type Description System.Boolean Overrides SupportsType(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ExpressionTarget.html": {
    "href": "rezolver-api/Rezolver.ExpressionTarget.html",
    "title": "Class ExpressionTarget",
    "keywords": "Improve this Doc Class ExpressionTarget A generic target for all expressions not explicitly supported by a particular target. Inheritance System.Object TargetBase ExpressionTarget Inherited Members SuppressScopeTracking UseFallback CreateScopeTrackingExpression(CompileContext, Expression) CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) CreateScopeSelectionExpression(CompileContext, Expression) SupportsType(Type) CreateExpression(CompileContext) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ExpressionTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ExpressionTarget(Expression, ITargetAdapter) Declaration public ExpressionTarget(Expression expression, ITargetAdapter adapter = null) Parameters Name Type Description expression Expression adapter ITargetAdapter <!-- .classchild --> | Improve this Doc ExpressionTarget(Func<CompileContext, Expression>, Type, ITargetAdapter) Declaration public ExpressionTarget(Func<CompileContext, Expression> expressionFactory, Type declaredType, ITargetAdapter adapter = null) Parameters Name Type Description expressionFactory System.Func < CompileContext , Expression > declaredType System.Type adapter ITargetAdapter <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description System.Type Overrides DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateExpressionBase(CompileContext) Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides CreateExpressionBase(CompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ExpressionHelper.html": {
    "href": "rezolver-api/Rezolver.ExpressionHelper.html",
    "title": "Class ExpressionHelper",
    "keywords": "Improve this Doc Class ExpressionHelper This static class contains methods and properties to aid in building expressions in the CreateExpression(CompileContext) method. Inheritance System.Object ExpressionHelper Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ExpressionHelper <!-- <hr class=\"typeSectionDivider\" /> --> Fields | Improve this Doc DynamicRezolverParam This parameter expression is to be used by all targets and rezolvers in this library by default to perform late binding to a container provided at run time when a caller is trying to resolve something through code built from a target. Declaration public static readonly ParameterExpression DynamicRezolverParam Field Value Type Description ParameterExpression <!-- .classchild --> | Improve this Doc RezolveContextParameter Declaration public static readonly ParameterExpression RezolveContextParameter Field Value Type Description ParameterExpression <!-- .classchild --> | Improve this Doc Scope_GetOrAddGenericMethod A MethodInfo object representing the generic definition Declaration public static readonly MethodInfo Scope_GetOrAddGenericMethod Field Value Type Description MethodInfo <!-- .classchild --> | Improve this Doc Scope_GetScopeRootMethod A MethodInfo object representing the GetScopeRoot(IScopedContainer) method - to aid in code generation where the target scope for tracking an object is the root scope, not the current scope. Declaration public static readonly MethodInfo Scope_GetScopeRootMethod Field Value Type Description MethodInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc GetLambdaBodyForTarget(ITarget, CompileContext) Provides a standard way to create the method body for a lambda that, when compiled (with the correct signature) will execute code that will produce the object represented by the target. Some rewriting optimisations are applied to the expression tree, the resulting expression tree will be able to be compiled straight to a method if passed into a LambdaExpression. Declaration public static Expression GetLambdaBodyForTarget(ITarget target, CompileContext context) Parameters Name Type Description target ITarget context CompileContext Returns Type Description Expression Remarks Note that the TargetCompilerBase abstract class uses this method to get the expression tree for a target that is to be compiled, and the TargetDelegateCompiler uses that expression tree as-is. Note, however, that some compilers might override this behaviour, or rewrite the generated expression more - in which case this code wouldn't be suitable for those compilers. This method, therefore, is exposed to provide a surefire way to generate a whole lambda that can be compiled into an in-memory delegate for re-use in other targets and scenarios. The SingletonTarget, for example, uses this method during its own CreateExpression(CompileContext) implementation to get a nested lambda for the wrapped target, so that it can dynamically construct a Lazy whose factory method is the code we'd normally produce for a target. <!-- .classchild --> | Improve this Doc GetResolveLambdaForTarget(ITarget, CompileContext) First gets the lambda body using GetLambdaBodyForTarget(ITarget, CompileContext) , then passes that as the body for the returned expression, using also the RezolveContextParameter from the context parameter as the expression for the RezolveContext that's passed to the compiled method when invoked. Declaration public static Expression<Func<RezolveContext, object>> GetResolveLambdaForTarget(ITarget target, CompileContext context) Parameters Name Type Description target ITarget context CompileContext Returns Type Description Expression < System.Func < RezolveContext , System.Object >> <!-- .classchild --> | Improve this Doc Make_Scope_GetOrAddCallExpression(CompileContext, Type, LambdaExpression, Expression) Declaration public static Expression Make_Scope_GetOrAddCallExpression(CompileContext context, Type objectType, LambdaExpression factoryExpression, Expression iDisposableOnly = null) Parameters Name Type Description context CompileContext objectType System.Type factoryExpression LambdaExpression iDisposableOnly Expression Returns Type Description Expression <!-- .classchild --> | Improve this Doc Make_Scope_GetScopeRootCallExpression(CompileContext) Returns an expression that represents a call to the Scope_GetScopeRootMethod extension method on the scope of the RezolveContext passed to a compiled object target. Declaration public static Expression Make_Scope_GetScopeRootCallExpression(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.JsonConfiguration.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.JsonConfiguration.html",
    "title": "Class JsonConfiguration",
    "keywords": "Improve this Doc Class JsonConfiguration Class JsonConfiguration. Inheritance System.Object JsonConfiguration Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class JsonConfiguration : IConfiguration <!-- <hr class=\"typeSectionDivider\" /> --> Fields | Improve this Doc UnboundType The typename to use on a type entry when you want to register a constructor target directly for the type that is registered. E.g. { 'MyNamespace.Foo' : { 'type' : \"$auto' } } Which registers MyNamespace.Foo with a constructor target that binds to the same type. Is also used - where supported - to refer to a type from a parent object which you want to reference, but without having to specify the whole typename. Declaration public const string UnboundType = \"$auto\" Field Value Type Description System.String <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Entries Gets the entries. Declaration public IEnumerable<IConfigurationEntry> Entries { get; } Property Value Type Description System.Collections.Generic.IEnumerable < IConfigurationEntry > The entries. Implements Entries <!-- .classchild --> | Improve this Doc FileName Gets the name of the file. Declaration public string FileName { get; } Property Value Type Description System.String The name of the file. Implements FileName <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.JsonConfiguration.JsonConfigurationConverter.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.JsonConfiguration.JsonConfigurationConverter.html",
    "title": "Class JsonConfiguration.JsonConfigurationConverter",
    "keywords": "Improve this Doc Class JsonConfiguration.JsonConfigurationConverter Class for loading JsonConfiguration from Json through Json.Net. Inheritance System.Object JsonConfiguration.JsonConfigurationConverter Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class JsonConfigurationConverter : JsonConverter <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc CanWrite Gets a value indicating whether this Newtonsoft.Json.JsonConverter can write JSON. Declaration public override bool CanWrite { get; } Property Value Type Description System.Boolean true if this Newtonsoft.Json.JsonConverter can write JSON; otherwise, false . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CanConvert(Type) Determines whether this instance can convert the specified object type. Declaration public override bool CanConvert(Type objectType) Parameters Name Type Description objectType System.Type Type of the object. Returns Type Description System.Boolean true if this instance can convert the specified object type; otherwise, false . <!-- .classchild --> | Improve this Doc ReadJson(JsonReader, Type, Object, JsonSerializer) Reads the JSON representation of the object. Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Name Type Description reader JsonReader The Newtonsoft.Json.JsonReader to read from. objectType System.Type Type of the object. existingValue System.Object The existing value of object being read. serializer JsonSerializer The calling serializer. Returns Type Description System.Object The object value. <!-- .classchild --> | Improve this Doc WriteJson(JsonWriter, Object, JsonSerializer) Writes the JSON representation of the object. Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Name Type Description writer JsonWriter The Newtonsoft.Json.JsonWriter to write to. value System.Object The value. serializer JsonSerializer The calling serializer. Exceptions Type Condition System.NotImplementedException <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.ConfigurationEntryConverter.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.ConfigurationEntryConverter.html",
    "title": "Class ConfigurationEntryConverter",
    "keywords": "Improve this Doc Class ConfigurationEntryConverter JSON converter for IConfigurationEntry The converter defaults to looking for type registrations; to enable it to look for a different entry type, you must instruct Json.Net to create an instance of it using the constructor that accepts a ConfigurationEntryType Inheritance System.Object ConfigurationEntryConverter Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class ConfigurationEntryConverter : JsonConverter <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ConfigurationEntryConverter() Declaration public ConfigurationEntryConverter() <!-- .classchild --> | Improve this Doc ConfigurationEntryConverter(ConfigurationEntryType) Declaration public ConfigurationEntryConverter(ConfigurationEntryType expectedType) Parameters Name Type Description expectedType ConfigurationEntryType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc CanWrite Declaration public override bool CanWrite { get; } Property Value Type Description System.Boolean <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CanConvert(Type) Declaration public override bool CanConvert(Type objectType) Parameters Name Type Description objectType System.Type Returns Type Description System.Boolean <!-- .classchild --> | Improve this Doc ReadJson(JsonReader, Type, Object, JsonSerializer) Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Name Type Description reader JsonReader objectType System.Type existingValue System.Object serializer JsonSerializer Returns Type Description System.Object <!-- .classchild --> | Improve this Doc WriteJson(JsonWriter, Object, JsonSerializer) Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Name Type Description writer JsonWriter value System.Object serializer JsonSerializer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapter.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapter.html",
    "title": "Class ConfigurationAdapter",
    "keywords": "Improve this Doc Class ConfigurationAdapter Standard implementation of the IConfigurationAdapter interface. Inheritance System.Object ConfigurationAdapter Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationAdapter : IConfigurationAdapter <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ConfigurationAdapter(IConfigurationAdapterContextFactory) Creates a new instance of the ConfigurationAdapter class. Declaration public ConfigurationAdapter(IConfigurationAdapterContextFactory contextFactory = null) Parameters Name Type Description contextFactory IConfigurationAdapterContextFactory The factory that is, by default, used to create a new context to be used while transforming an IConfiguration instance. If you pass null, then the DefaultContextFactory will be used. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc ContextFactory Declaration protected IConfigurationAdapterContextFactory ContextFactory { get; } Property Value Type Description IConfigurationAdapterContextFactory <!-- .classchild --> | Improve this Doc DefaultContextFactory Gets or sets the default context factory. The uninitialised default is Instance . Note - this can never be a null reference. Declaration public static IConfigurationAdapterContextFactory DefaultContextFactory { get; set; } Property Value Type Description IConfigurationAdapterContextFactory The default context factory. Exceptions Type Condition System.ArgumentNullException If you try to set the property to null. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc AppendInstructions(ConfigurationAdapterContext) Called to add instructions into the context from the configuration entries in the configuration within the passed context. Declaration protected virtual void AppendInstructions(ConfigurationAdapterContext context) Parameters Name Type Description context ConfigurationAdapterContext The context for this operation - provides access to the configuration whose entries are to be processed, and acts as the target for the processing instructions. <!-- .classchild --> | Improve this Doc CreateBuilderInstance(IConfiguration) Called to construct the instance of the ITargetContainer into which registrations are to be loaded. Declaration protected virtual ITargetContainer CreateBuilderInstance(IConfiguration configuration) Parameters Name Type Description configuration IConfiguration The configuration instance for which a builder is to be created. Returns Type Description ITargetContainer Remarks No parsing of the configuration is to be done here (except, perhaps, if the actual implementation of ITargetContainer that is used is dependant upon, say, the type of configuration object. The base behaviour is simply to create an instance of TargetContainer . <!-- .classchild --> | Improve this Doc CreateContext(IConfiguration) Creates the context that will be used while the passed configuration is processed. The default implementation forwards this call onto the context factory that was supplied on construction. Declaration protected virtual ConfigurationAdapterContext CreateContext(IConfiguration configuration) Parameters Name Type Description configuration IConfiguration Returns Type Description ConfigurationAdapterContext <!-- .classchild --> | Improve this Doc CreateTargetContainer(IConfiguration) Attempts to create an IRezolveTargetContainer instance from the passed configuration object. If the operation succeeds, then a builder will be returned, which you can then use to construct a new Rezolver. If the operation fails, then a ConfigurationException will be thrown. Declaration public virtual ITargetContainer CreateTargetContainer(IConfiguration configuration) Parameters Name Type Description configuration IConfiguration The parsed configuration to be loaded. Returns Type Description ITargetContainer An IRezolveTargetContainer instance ready to be used to construct a new IRezolver. Implements CreateTargetContainer(IConfiguration) Exceptions Type Condition ConfigurationException If any part of the passed configuration is invalid (e.g. bad type references) or cannot be handled by this adapter (e.g. custom IConfigurationEntry instances or custom IRezolveTargetMetadata instances). <!-- .classchild --> | Improve this Doc TransformAssemblyReferenceEntry(IConfigurationEntry, ConfigurationAdapterContext) Transforms an IConfigurationEntry with a Type of AssemblyReference by attempting to convert the entry to an IAssemblyReferenceEntry , and then passing that to the current context as an assembly reference to be added. Declaration protected virtual RezolverBuilderInstruction TransformAssemblyReferenceEntry(IConfigurationEntry entry, ConfigurationAdapterContext context) Parameters Name Type Description entry IConfigurationEntry The entry to be processed. context ConfigurationAdapterContext The context for the operation Returns Type Description RezolverBuilderInstruction The default implementation returns null Remarks The default behaviour of this method is not to return anything - instead the entry is passed to the context to be treated as an Assembly Reference. The function signature still allows the returning of an instruction, however, in case derived classes want to tie this operation to an action being performed on the ITargetContainer later on. <!-- .classchild --> | Improve this Doc TransformEntry(IConfigurationEntry, ConfigurationAdapterContext) Called to transform a configuration entry into an instruction that will later be performed on the builder that is constructed by the configuration adapter. Declaration protected virtual RezolverBuilderInstruction TransformEntry(IConfigurationEntry entry, ConfigurationAdapterContext context) Parameters Name Type Description entry IConfigurationEntry The entry to be transformed into an instruction. context ConfigurationAdapterContext The context for the operation. Returns Type Description RezolverBuilderInstruction An instance of RezolverBuilderInstruction if successful, otherwise null. If errors occur, they are added to the context. <!-- .classchild --> | Improve this Doc TransformTypeRegistrationEntry(IConfigurationEntry, ConfigurationAdapterContext) Transforms an IConfigurationEntry with a Type of TypeRegistration into a RezolverBuilderInstruction . Declaration protected virtual RezolverBuilderInstruction TransformTypeRegistrationEntry(IConfigurationEntry entry, ConfigurationAdapterContext context) Parameters Name Type Description entry IConfigurationEntry The entry to be transformed. context ConfigurationAdapterContext The context for the operation. Returns Type Description RezolverBuilderInstruction If the entry can be converted into a RezolverBuilderInstruction , then an instance of that type, otherwise null. Remarks The default behaviour is to: Attempt to convert the entry to an ITypeRegistrationEntry Parsing its type references in Types Constructing an ITarget from the entry's TargetMetadata through a call to its CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) method. If that returns a non-null target, then a RegisterInstruction is created and returned. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapter.ConfigurationEntryProcessOrderer.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapter.ConfigurationEntryProcessOrderer.html",
    "title": "Class ConfigurationAdapter.ConfigurationEntryProcessOrderer",
    "keywords": "Improve this Doc Class ConfigurationAdapter.ConfigurationEntryProcessOrderer Used by the ConfigurationAdapter class to sort configuration entries for processing. It ensures that Assembly Reference entries are given priority, followed by Namespace Imports, and then finally all the rest. Inheritance System.Object ConfigurationAdapter.ConfigurationEntryProcessOrderer Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax protected class ConfigurationEntryProcessOrderer : IComparer<IConfigurationEntry> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Compare(IConfigurationEntry, IConfigurationEntry) Declaration public int Compare(IConfigurationEntry x, IConfigurationEntry y) Parameters Name Type Description x IConfigurationEntry y IConfigurationEntry Returns Type Description System.Int32 Implements System.Collections.Generic.IComparer<Rezolver.Configuration.IConfigurationEntry>.Compare(Rezolver.Configuration.IConfigurationEntry, Rezolver.Configuration.IConfigurationEntry) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.AssemblyReferenceEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.AssemblyReferenceEntry.html",
    "title": "Class AssemblyReferenceEntry",
    "keywords": "Improve this Doc Class AssemblyReferenceEntry Inheritance System.Object ConfigurationEntryBase AssemblyReferenceEntry Inherited Members Type StartLineNo StartLinePos EndLineNo EndLinePos System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class AssemblyReferenceEntry : ConfigurationEntryBase, IAssemblyReferenceEntry, IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc AssemblyReferenceEntry(String, IConfigurationLineInfo) Declaration public AssemblyReferenceEntry(string assemblyName, IConfigurationLineInfo lineInfo = null) Parameters Name Type Description assemblyName System.String lineInfo IConfigurationLineInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc AssemblyName Declaration public string AssemblyName { get; } Property Value Type Description System.String Implements AssemblyName <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ConditionalRewriter.html": {
    "href": "rezolver-api/Rezolver.ConditionalRewriter.html",
    "title": "Class ConditionalRewriter",
    "keywords": "Improve this Doc Class ConditionalRewriter Reorders an expression tree where duplicate conditional expressions are found in multiple places throughout that expression tree. Those duplicated conditionals are moved further up the expression tree into one conditional. Inheritance System.Object ConditionalRewriter Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ConditionalRewriter : ExpressionVisitor <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ConditionalRewriter(Expression, IEnumerable<Expression>) Declaration public ConditionalRewriter(Expression expression, IEnumerable<Expression> candidateTests) Parameters Name Type Description expression Expression candidateTests System.Collections.Generic.IEnumerable < Expression > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Rewrite() Declaration public Expression Rewrite() Returns Type Description Expression <!-- .classchild --> | Improve this Doc Visit(Expression) Declaration public override Expression Visit(Expression node) Parameters Name Type Description node Expression Returns Type Description Expression <!-- .classchild --> | Improve this Doc VisitConditional(ConditionalExpression) Declaration protected override Expression VisitConditional(ConditionalExpression node) Parameters Name Type Description node ConditionalExpression Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.CompiledTargetBase.html": {
    "href": "rezolver-api/Rezolver.CompiledTargetBase.html",
    "title": "Class CompiledTargetBase",
    "keywords": "Improve this Doc Class CompiledTargetBase Standard starting point for an implementation of ICompiledTarget where the target is built directly from an ITarget . Inheritance System.Object CompiledTargetBase Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public abstract class CompiledTargetBase : ICompiledTarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc CompiledTargetBase(ITarget) Initialises the CompiledTargetBase abstract class. Declaration protected CompiledTargetBase(ITarget originalTarget) Parameters Name Type Description originalTarget ITarget Required - the target that was compiled into this instance. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc OriginalTarget The target that was compiled into this instance. Will not be null. Declaration protected ITarget OriginalTarget { get; } Property Value Type Description ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc GetObject(RezolveContext) Abstract implementation of GetObject(RezolveContext) Declaration public abstract object GetObject(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description System.Object Implements GetObject(RezolveContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.CompileContext.html": {
    "href": "rezolver-api/Rezolver.CompileContext.html",
    "title": "Class CompileContext",
    "keywords": "Improve this Doc Class CompileContext Provides support and compile-time state for the compilation of an ITarget by an ITargetCompiler . THIS CLASS IS NOT THREAD-SAFE Inheritance System.Object CompileContext Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class CompileContext : ITargetContainer Remarks The class implements the ITargetContainer interface also to facilitate dependency lookups during compilation time - indeed, all operations to find targets during compilation should be directed through this class' implementation. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc CompileContext(CompileContext, Type, Boolean, Boolean) Creates a new CompileContext using an existing one as a template. Declaration public CompileContext(CompileContext parentContext, Type targetType = null, bool inheritSharedExpressions = true, bool suppressScopeTracking = false) Parameters Name Type Description parentContext CompileContext Used to seed the compilation stack, container, rezolve context parameter and optionally the target type (if you pass null for targetType . targetType System.Type The target type that is expected to be compiled, or null to inherit the parentContext 's TargetType property. inheritSharedExpressions System.Boolean If true (the default), then the SharedExpressions for this context will be shared from the parent context - meaning that any new additions will be added back to the parent context again. This is the most common behaviour when chaining multiple targets' expressions together. Passing false for this parameter is only required in rare situations. suppressScopeTracking System.Boolean If true, then any expressions constructed from ITarget objects should not contain automatically generated code to track objects in an enclosing scope. The default is false. This is typically only enabled when one target is explicitly using expressions created from other targets, and has its own scope tracking code, or expects to be surrounded by automatically generated scope tracking code itself. <!-- .classchild --> | Improve this Doc CompileContext(IContainer, ITargetContainer, Type, ParameterExpression, IEnumerable<ITarget>) Creates a new CompileContext Declaration public CompileContext(IContainer container, ITargetContainer dependencyTargetContainer, Type targetType = null, ParameterExpression rezolveContextParameter = null, IEnumerable<ITarget> compilingTargets = null) Parameters Name Type Description container IContainer Required. The container for which compilation is being performed. Will be set into the Container property. dependencyTargetContainer ITargetContainer Required - An ITargetContainer that contains the ITarget s that will be required to complete compilation. Note - this argument is passed to a new ChildTargetContainer that is created and proxied by this class' implementation of ITargetContainer . As a result, it's possible to register new targets directly into the context via the Register(ITarget, Type) method, without modifying the underlying targets in the container you pass. Some of the core ITarget s exposed by this library take advantage of that functionality (notably, the DecoratorTarget ). targetType System.Type Optional. Will be set into the TargetType property. rezolveContextParameter ParameterExpression Optional. Will be set into the RezolveContextParameter property. compilingTargets System.Collections.Generic.IEnumerable < ITarget > Optional. Allows you to seed the stack of compiling targets from creation. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc CompilingTargets An enumerable representing the current stack of targets that are being compiled. The underlying stack is not exposed through this enumerable. Declaration public IEnumerable<ITarget> CompilingTargets { get; } Property Value Type Description System.Collections.Generic.IEnumerable < ITarget > <!-- .classchild --> | Improve this Doc Container The container that is considered the current compilation 'scope' - i.e. the container for which the compilation is being performed and, usually, the one on which the Resolve(RezolveContext) method was originally called. For compile-time dependency resolution (i.e. other ITarget s) you should use this class' implementation of ITargetContainer . Declaration public IContainer Container { get; } Property Value Type Description IContainer <!-- .classchild --> | Improve this Doc ContainerExpression Represents an expression that equals the Container that is active for this context. Declaration public Expression ContainerExpression { get; } Property Value Type Description Expression <!-- .classchild --> | Improve this Doc ContextContainerPropertyExpression Returns an expression that represents reading the Container property of the RezolveContextParameter during the execution of an ICompiledTarget 's GetObject(RezolveContext) method. This IS NOT the same as the ContainerExpression property. Always non-null. Declaration public MemberExpression ContextContainerPropertyExpression { get; } Property Value Type Description MemberExpression <!-- .classchild --> | Improve this Doc ContextScopePropertyExpression Returns an expression that represents reading the Scope property of the RezolveContext Declaration public MemberExpression ContextScopePropertyExpression { get; } Property Value Type Description MemberExpression <!-- .classchild --> | Improve this Doc RezolveContextParameter An expression to be used to bind to the RezolveContext that will be passed to the generated code at runtime (effectively, the context parameter to GetObject(RezolveContext) which is typically invoked by containers). If this is never set, then the framework will use RezolveContextParameter by default. In theory, you should never need to set this to anything else, unless you're doing something very interesting with the generated expressions. Declaration public ParameterExpression RezolveContextParameter { get; } Property Value Type Description ParameterExpression <!-- .classchild --> | Improve this Doc SharedExpressions Shared expressions are expressions that targets add to the compile context as they are compiled, enabling them to generate code which is both more efficient at runtime (e.g. avoiding the creation of redundant locals for blocks which can reuse a pre-existing local) and that can be more efficiently rewritten due to the reuse of identical expression references for things like conditional checks and so on. A compiler MUST handle the case where this enumerable contains ParameterExpressions, as they will need to be added as local variables to an all-encompassing BlockExpression around the root of an expression tree that is to be compiled. Declaration public IEnumerable<Expression> SharedExpressions { get; } Property Value Type Description System.Collections.Generic.IEnumerable < Expression > <!-- .classchild --> | Improve this Doc SuppressScopeTracking If true, then any target that is compiling within this scope should not generate any runtime code to fetch the object from, or track the object in, the current scope. Declaration public bool SuppressScopeTracking { get; } Property Value Type Description System.Boolean Remarks This is currently used, for example, by wrapper targets that generate their own scope tracking code (specifically, the SingletonTarget and ScopedTarget . It's therefore very important that any custom ITarget implementations honour this flag in their implementation of CreateExpression(CompileContext) . The TargetBase class does honour this flag. <!-- .classchild --> | Improve this Doc TargetType The desired type to be returned by the generated code. Declaration public Type TargetType { get; } Property Value Type Description System.Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CombineWith(ITargetContainer, Type) Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer type System.Type Returns Type Description ITargetContainer Implements CombineWith(ITargetContainer, Type) <!-- .classchild --> | Improve this Doc Fetch(Type) Declaration public ITarget Fetch(Type type) Parameters Name Type Description type System.Type Returns Type Description ITarget Implements Fetch(Type) <!-- .classchild --> | Improve this Doc FetchAll(Type) Declaration public IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type System.Type Returns Type Description System.Collections.Generic.IEnumerable < ITarget > Implements FetchAll(Type) <!-- .classchild --> | Improve this Doc GetOrAddSharedExpression(Type, String, Func<Expression>, Type) Declaration public Expression GetOrAddSharedExpression(Type type, string name, Func<Expression> expressionFactory, Type requestingType = null) Parameters Name Type Description type System.Type name System.String expressionFactory System.Func < Expression > requestingType System.Type Returns Type Description Expression <!-- .classchild --> | Improve this Doc GetOrAddSharedLocal(Type, String, Type) Retrieves Declaration public ParameterExpression GetOrAddSharedLocal(Type type, string name, Type requestingType = null) Parameters Name Type Description type System.Type name System.String requestingType System.Type Returns Type Description ParameterExpression <!-- .classchild --> | Improve this Doc IsCompiling(ITarget) Call this to find out if a target is currently compiling without trying to also add it to the stack. Declaration public bool IsCompiling(ITarget target) Parameters Name Type Description target ITarget Returns Type Description System.Boolean <!-- .classchild --> | Improve this Doc New(Type, Boolean, Boolean) Spawns a new context for the passed targetType , with everything else being inherited from this context by default. Declaration public CompileContext New(Type targetType, bool inheritSharedExpressions = true, bool suppressScopeTracking = false) Parameters Name Type Description targetType System.Type Required. The type to be compiled. inheritSharedExpressions System.Boolean suppressScopeTracking System.Boolean Returns Type Description CompileContext A new CompileContext Remarks This is a convenience method which simply wraps the Rezolver.CompileContext. constructor, except in this method the targetType is required. <!-- .classchild --> | Improve this Doc PopCompileStack() Pops a target from the stack and returns it. Note that if there are no targets on the stack, an InvalidOperationException will occur. Declaration public ITarget PopCompileStack() Returns Type Description ITarget <!-- .classchild --> | Improve this Doc PushCompileStack(ITarget) Adds the target to the compilation stack if it doesn't already exist. The method returns whether the target was added. Declaration public bool PushCompileStack(ITarget toCompile) Parameters Name Type Description toCompile ITarget Returns Type Description System.Boolean <!-- .classchild --> | Improve this Doc Register(ITarget, Type) Declaration public void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget serviceType System.Type Implements Register(ITarget, Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.CompileContext.SharedExpressionKey.html": {
    "href": "rezolver-api/Rezolver.CompileContext.SharedExpressionKey.html",
    "title": "Class CompileContext.SharedExpressionKey",
    "keywords": "Improve this Doc Class CompileContext.SharedExpressionKey Key for a shared expression used during expression tree generation Inheritance System.Object CompileContext.SharedExpressionKey Inherited Members System.Object.ToString() System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class SharedExpressionKey : IEquatable<CompileContext.SharedExpressionKey> <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc SharedExpressionKey(Type, String, Type) Declaration public SharedExpressionKey(Type targetType, string name, Type requestingType = null) Parameters Name Type Description targetType System.Type name System.String requestingType System.Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Name Declaration public string Name { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc RequestingType Declaration public Type RequestingType { get; } Property Value Type Description System.Type <!-- .classchild --> | Improve this Doc TargetType Declaration public Type TargetType { get; } Property Value Type Description System.Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Equals(CompileContext.SharedExpressionKey) Declaration public bool Equals(CompileContext.SharedExpressionKey other) Parameters Name Type Description other CompileContext.SharedExpressionKey Returns Type Description System.Boolean Implements System.IEquatable<Rezolver.CompileContext.SharedExpressionKey>.Equals(Rezolver.CompileContext.SharedExpressionKey) <!-- .classchild --> | Improve this Doc Equals(Object) Declaration public override bool Equals(object obj) Parameters Name Type Description obj System.Object Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) <!-- .classchild --> | Improve this Doc GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolveTargetExpression.html": {
    "href": "rezolver-api/Rezolver.RezolveTargetExpression.html",
    "title": "Class RezolveTargetExpression",
    "keywords": "Improve this Doc Class RezolveTargetExpression Makes it possible to mix expressions and targets. Inheritance System.Object RezolveTargetExpression Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolveTargetExpression : Expression <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc RezolveTargetExpression(ITarget) Declaration public RezolveTargetExpression(ITarget target) Parameters Name Type Description target ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc CanReduce Declaration public override bool CanReduce { get; } Property Value Type Description System.Boolean <!-- .classchild --> | Improve this Doc NodeType Declaration public override ExpressionType NodeType { get; } Property Value Type Description ExpressionType <!-- .classchild --> | Improve this Doc Target Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> | Improve this Doc Type Declaration public override Type Type { get; } Property Value Type Description System.Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Reduce() Declaration public override Expression Reduce() Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolveTargetAdapterExtensions.html": {
    "href": "rezolver-api/Rezolver.RezolveTargetAdapterExtensions.html",
    "title": "Class RezolveTargetAdapterExtensions",
    "keywords": "Improve this Doc Class RezolveTargetAdapterExtensions Inheritance System.Object RezolveTargetAdapterExtensions Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolveTargetAdapterExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateTarget<T>(ITargetAdapter, Expression<Func<T>>) Declaration public static ITarget CreateTarget<T>(this ITargetAdapter adapter, Expression<Func<T>> expression) Parameters Name Type Description adapter ITargetAdapter expression Expression < System.Func <T>> Returns Type Description ITarget Type Parameters Name Description T <!-- .classchild --> | Improve this Doc CreateTarget<T>(ITargetAdapter, Expression<Func<RezolveContextExpressionHelper, T>>) Declaration public static ITarget CreateTarget<T>(this ITargetAdapter adapter, Expression<Func<RezolveContextExpressionHelper, T>> expression) Parameters Name Type Description adapter ITargetAdapter expression Expression < System.Func < RezolveContextExpressionHelper , T>> Returns Type Description ITarget Type Parameters Name Description T <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolvedTarget.html": {
    "href": "rezolver-api/Rezolver.RezolvedTarget.html",
    "title": "Class RezolvedTarget",
    "keywords": "Improve this Doc Class RezolvedTarget Represents a target that is rezolved statically at compile time via the CompileContext , or dynamically (at 'resolve time') from the IContainer that is attached to the current RezolveContext when Resolve(RezolveContext) is called. This is the most common way that we bind constructor parameters, for example - i.e. 'I want an IService instance - go get it'. Inheritance System.Object TargetBase RezolvedTarget Inherited Members UseFallback CreateScopeTrackingExpression(CompileContext, Expression) CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) CreateScopeSelectionExpression(CompileContext, Expression) SupportsType(Type) CreateExpression(CompileContext) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolvedTarget : TargetBase, ITarget Remarks The concept of compile-time resolving is what is typically implemented by most other IOC containers - at compile time, a target is resolved for a given type and, if found, its expression is used. If it's not found, then an error occurs. Rezolver does this, but goes further when the target can't be resolved at compile-time - in this case, it will emit a call back into the current RezolveContext 's IContainer to try and dynamically resolve the value that is required. Furthermore, the code it produces in either case also checks that the IContainer that is active at resolve-time is the same one (if applicable) that was active during compile-time. If it isn't, then it'll automatically defer resolving of the value to that container <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc RezolvedTarget(Type, ITarget) Creates a new RezolvedTarget for the given type which will attempt to resolve a value at compile time and/or resolve-time and, if it can't, will either use the fallbackTarget or will throw an exception. Declaration public RezolvedTarget(Type type, ITarget fallbackTarget = null) Parameters Name Type Description type System.Type Required. The type to be resolved fallbackTarget ITarget Optional. The target to be used if the value cannot be resolved at either compile time or resolve-time. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType The type that will be resolved Declaration public override Type DeclaredType { get; } Property Value Type Description System.Type Overrides DeclaredType <!-- .classchild --> | Improve this Doc FallbackTarget Gets the target that this RezolvedTarget will fallback to if a satisfactory target cannot be found at compile time. Declaration public ITarget FallbackTarget { get; } Property Value Type Description ITarget Remarks The UseFallback property is also used to determine whether this will be used. If the target resolved from the CompileContext has its UseFallback property set to true, and this property is non-null for this target, then this target will be used. Note also that extension containers such as OverridingContainer also have the ability to override the use of this fallback if they successfully resolve the type. <!-- .classchild --> | Improve this Doc SuppressScopeTracking Always returns true - we never wrap calls to a container inside a scope tracking expression. Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description System.Boolean Overrides SuppressScopeTracking <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateExpressionBase(CompileContext) Implementation of CreateExpressionBase(CompileContext) . Constructs the expression. Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides CreateExpressionBase(CompileContext) <!-- .classchild --> | Improve this Doc Resolve(CompileContext) Attempts to obtain the target that this RezolvedTarget resolves to for the given CompileContext . Used in the implementation of CreateExpressionBase(CompileContext) but also available to consumers to enable checking of RezolvedTargets to see if they'll succeed at compile time (useful when late-binding overloaded constructors, for example). Declaration public virtual ITarget Resolve(CompileContext context) Parameters Name Type Description context CompileContext The context from which a target is to be resolved. Returns Type Description ITarget The target resolved by this target - could be the FallbackTarget , could be null. Remarks The target that is returned depends both on the context passed and also whether a FallbackTarget has been provided to this target. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolveContextPlaceholderExpression.html": {
    "href": "rezolver-api/Rezolver.RezolveContextPlaceholderExpression.html",
    "title": "Class RezolveContextPlaceholderExpression",
    "keywords": "Improve this Doc Class RezolveContextPlaceholderExpression wraps an expression that represents reading or otherwise manipulating the RezolveContext that's passed into a Resolve call. Inheritance System.Object RezolveContextPlaceholderExpression Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolveContextPlaceholderExpression : Expression <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc RezolveContextPlaceholderExpression(Expression) Declaration public RezolveContextPlaceholderExpression(Expression rezolveContextExpression) Parameters Name Type Description rezolveContextExpression Expression <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc CanReduce Declaration public override bool CanReduce { get; } Property Value Type Description System.Boolean <!-- .classchild --> | Improve this Doc NodeType Declaration public override ExpressionType NodeType { get; } Property Value Type Description ExpressionType <!-- .classchild --> | Improve this Doc RezolveContextExpression Declaration public Expression RezolveContextExpression { get; } Property Value Type Description Expression <!-- .classchild --> | Improve this Doc Type Declaration public override Type Type { get; } Property Value Type Description System.Type <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolveContextExpressionHelper.html": {
    "href": "rezolver-api/Rezolver.RezolveContextExpressionHelper.html",
    "title": "Class RezolveContextExpressionHelper",
    "keywords": "Improve this Doc Class RezolveContextExpressionHelper Wraps a rezolve context for expression building - used principally in the ConstruuctorTarget class, but others are free to use it also. Inheritance System.Object RezolveContext RezolveContextExpressionHelper Inherited Members EmptyContext RequestedType Container Scope ToString() GetHashCode() Equals(Object) Equals(RezolveContext) CreateNew(Type) CreateNew(IContainer, Type) CreateNew(Type, IScopedContainer) CreateNew(IContainer, Type, IScopedContainer) CreateNew(IContainer) CreateNew(IScopedContainer) CreateNew(IContainer, IScopedContainer) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolveContextExpressionHelper : RezolveContext, IEquatable<RezolveContext> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Resolve<T>() Declaration public T Resolve<T>() Returns Type Description T Type Parameters Name Description T <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.RezolveContext.html": {
    "href": "rezolver-api/Rezolver.RezolveContext.html",
    "title": "Class RezolveContext",
    "keywords": "Improve this Doc Class RezolveContext Context of a call to an IRezolver's Resolve method. The container is included in the context to allow code generated from CreateExpression(CompileContext) to refer back to the container. This also allows us to retarget compiled targets at other containers (e.g. OverridingContainer s that override existing registrations or define new ones). Inheritance System.Object RezolveContext Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolveContext : IEquatable<RezolveContext> <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc RezolveContext(IContainer, Type) Declaration public RezolveContext(IContainer container, Type requestedType) Parameters Name Type Description container IContainer requestedType System.Type <!-- .classchild --> | Improve this Doc RezolveContext(IContainer, Type, IScopedContainer) Declaration public RezolveContext(IContainer container, Type requestedType, IScopedContainer scope) Parameters Name Type Description container IContainer requestedType System.Type scope IScopedContainer <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Fields | Improve this Doc EmptyContext Declaration public static readonly RezolveContext EmptyContext Field Value Type Description RezolveContext <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Container The container for this context. Declaration public IContainer Container { get; } Property Value Type Description IContainer <!-- .classchild --> | Improve this Doc RequestedType Declaration public Type RequestedType { get; } Property Value Type Description System.Type <!-- .classchild --> | Improve this Doc Scope Declaration public IScopedContainer Scope { get; } Property Value Type Description IScopedContainer <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateNew(IContainer) Declaration public RezolveContext CreateNew(IContainer container) Parameters Name Type Description container IContainer Returns Type Description RezolveContext <!-- .classchild --> | Improve this Doc CreateNew(IContainer, IScopedContainer) Declaration public RezolveContext CreateNew(IContainer container, IScopedContainer scope) Parameters Name Type Description container IContainer scope IScopedContainer Returns Type Description RezolveContext <!-- .classchild --> | Improve this Doc CreateNew(IContainer, Type) Declaration public RezolveContext CreateNew(IContainer container, Type requestedType) Parameters Name Type Description container IContainer requestedType System.Type Returns Type Description RezolveContext <!-- .classchild --> | Improve this Doc CreateNew(IContainer, Type, IScopedContainer) Declaration public RezolveContext CreateNew(IContainer container, Type requestedType, IScopedContainer scope) Parameters Name Type Description container IContainer requestedType System.Type scope IScopedContainer Returns Type Description RezolveContext <!-- .classchild --> | Improve this Doc CreateNew(IScopedContainer) Declaration public RezolveContext CreateNew(IScopedContainer scope) Parameters Name Type Description scope IScopedContainer Returns Type Description RezolveContext <!-- .classchild --> | Improve this Doc CreateNew(Type) Returns a clone of this context, but replaces the type, establishing the root context relationship also, either by inheriting this one's root context, or setting this as the root context. Declaration public RezolveContext CreateNew(Type requestedType) Parameters Name Type Description requestedType System.Type Returns Type Description RezolveContext <!-- .classchild --> | Improve this Doc CreateNew(Type, IScopedContainer) Declaration public RezolveContext CreateNew(Type requestedType, IScopedContainer scope) Parameters Name Type Description requestedType System.Type scope IScopedContainer Returns Type Description RezolveContext <!-- .classchild --> | Improve this Doc Equals(RezolveContext) Declaration public virtual bool Equals(RezolveContext other) Parameters Name Type Description other RezolveContext Returns Type Description System.Boolean Implements System.IEquatable<Rezolver.RezolveContext>.Equals(Rezolver.RezolveContext) <!-- .classchild --> | Improve this Doc Equals(Object) Declaration public override bool Equals(object obj) Parameters Name Type Description obj System.Object Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) <!-- .classchild --> | Improve this Doc GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() <!-- .classchild --> | Improve this Doc ToString() Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Operators | Improve this Doc Equality(RezolveContext, RezolveContext) Declaration public static bool operator ==(RezolveContext left, RezolveContext right) Parameters Name Type Description left RezolveContext right RezolveContext Returns Type Description System.Boolean <!-- .classchild --> | Improve this Doc Inequality(RezolveContext, RezolveContext) Declaration public static bool operator !=(RezolveContext left, RezolveContext right) Parameters Name Type Description left RezolveContext right RezolveContext Returns Type Description System.Boolean <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.PropertyOrFieldBinding.html": {
    "href": "rezolver-api/Rezolver.PropertyOrFieldBinding.html",
    "title": "Class PropertyOrFieldBinding",
    "keywords": "Improve this Doc Class PropertyOrFieldBinding Inheritance System.Object PropertyOrFieldBinding Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class PropertyOrFieldBinding <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc PropertyOrFieldBinding(MemberInfo, ITarget) Declaration public PropertyOrFieldBinding(MemberInfo member, ITarget target) Parameters Name Type Description member MemberInfo target ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Fields | Improve this Doc None Declaration public static readonly PropertyOrFieldBinding[] None Field Value Type Description PropertyOrFieldBinding [] <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Member Declaration public MemberInfo Member { get; } Property Value Type Description MemberInfo <!-- .classchild --> | Improve this Doc MemberType Declaration public Type MemberType { get; } Property Value Type Description System.Type <!-- .classchild --> | Improve this Doc Target Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateMemberBinding(CompileContext) Method for creating a Linq Expression MemberBinding object for the Member , to the expression produced by the Target object's CreateExpression(CompileContext) method. Declaration public MemberBinding CreateMemberBinding(CompileContext context) Parameters Name Type Description context CompileContext The CompileContext under which the generated expression will be compiled. Returns Type Description MemberBinding <!-- .classchild --> | Improve this Doc DeriveAutoPropertyBinding(Type, Boolean) Static factory method that creates bindings for all publicly writable instance properties (and, optionally, fields) of the given type. Each property/field is bound to a RezolvedTarget instance - meaning that, at runtime, values for those properties or fields will be resolved from the container by type. Declaration public static PropertyOrFieldBinding[] DeriveAutoPropertyBinding(Type type, bool includeFields = false) Parameters Name Type Description type System.Type The type whose properties (and, optionally, publicly writable fields) are to be bound. includeFields System.Boolean If true, then publicly writable fields will be bound. Returns Type Description PropertyOrFieldBinding [] <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ParameterBinding.html": {
    "href": "rezolver-api/Rezolver.ParameterBinding.html",
    "title": "Class ParameterBinding",
    "keywords": "Improve this Doc Class ParameterBinding Inheritance System.Object ParameterBinding Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ParameterBinding <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ParameterBinding(ParameterInfo, ITarget) Constructs a new instance of the ParameterBinding class. Declaration public ParameterBinding(ParameterInfo parameter, ITarget target = null) Parameters Name Type Description parameter ParameterInfo Required - the parameter being bound target ITarget Optional - the argument supplied for the parameter. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Fields | Improve this Doc None Represents an empty parameter bindings array. Declaration public static readonly ParameterBinding[] None Field Value Type Description ParameterBinding [] <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc IsValid Gets a boolean indicating whether the parameter binding is valid Ultimately, this returns true if Target is non-null. Declaration public bool IsValid { get; } Property Value Type Description System.Boolean <!-- .classchild --> | Improve this Doc Parameter The parameter to be bound Declaration public ParameterInfo Parameter { get; } Property Value Type Description ParameterInfo <!-- .classchild --> | Improve this Doc Target The initial target that was bound to this parameter. Declaration public ITarget Target { get; } Property Value Type Description ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc BindMethod(MethodBase, IDictionary<String, ITarget>) Matches named targets in args to parameters on the passed method , creating default ParameterBinding s for any parameters for which named targets cannot be found. Declaration public static ParameterBinding[] BindMethod(MethodBase method, IDictionary<string, ITarget> args) Parameters Name Type Description method MethodBase args System.Collections.Generic.IDictionary < System.String , ITarget > Returns Type Description ParameterBinding [] <!-- .classchild --> | Improve this Doc BindOverload(MethodBase[], IDictionary<String, ITarget>, out MethodBase) Searches for a method in the methods collection whose parameters can be filled by the targets provided in the args dictionary, returning the parameter bindings, and passing out the resolved target method in resolvedMethod if found. Note - if no match can be found, or if more than one method could be bound, then an InvalidOperationException will occur. Declaration public static ParameterBinding[] BindOverload(MethodBase[] methods, IDictionary<string, ITarget> args, out MethodBase resolvedMethod) Parameters Name Type Description methods MethodBase [] The methods. args System.Collections.Generic.IDictionary < System.String , ITarget > The arguments. resolvedMethod MethodBase The resolved method. Returns Type Description ParameterBinding [] ParameterBinding[]. <!-- .classchild --> | Improve this Doc BindWithRezolvedArguments(MethodBase) Creates parameter bindings for each parameter in the passed method where each value will be resolved. For any optional parameters - their default values will be used as a fallback. Declaration public static ParameterBinding[] BindWithRezolvedArguments(MethodBase method) Parameters Name Type Description method MethodBase Returns Type Description ParameterBinding [] <!-- .classchild --> | Improve this Doc BindWithRezolvedOrOptionalDefault(MethodBase, CompileContext) This is a compile-time helper method which produces a binding for each parameter where arguments that can be resolved from the passed context will be bound with RezolvedTarget s, and those which cannot, but which are optional, will be bound with OptionalParameterTarget s. If the parameter is not optional, and no target can be resolved, then an invalid binding will be returned for that parameter. Declaration public static ParameterBinding[] BindWithRezolvedOrOptionalDefault(MethodBase method, CompileContext context) Parameters Name Type Description method MethodBase Required - the method whose parameters are to be bound. context CompileContext Required - the current compile context which will be used to test whether arguments can be resolved at compile time. If they can, then the associated parameter will be bound with a RezolvedTarget . Returns Type Description ParameterBinding [] <!-- .classchild --> | Improve this Doc CreateExpression(CompileContext) Helper method for getting the expression from the Target for the Parameter 's . Takes care of setting the correct TargetType in a new context built from the context you pass. Declaration public Expression CreateExpression(CompileContext context) Parameters Name Type Description context CompileContext The current context for the object being built whose method or constructor parameter is being bound. Returns Type Description Expression The expression built by Target for the Parameter 's . <!-- .classchild --> | Improve this Doc Resolve(CompileContext) Fetch the target that would be bound to this parameter given the passed CompileContext Declaration public virtual ITarget Resolve(CompileContext context) Parameters Name Type Description context CompileContext The current compile context - a new one is created for the Parameter type Returns Type Description ITarget The target that should be used for the parameter, or null if no target could be found. Note that if the returned target's UseFallback property is set to true , then it means either the parameter's default value is being used, or that the target fetched from the target container in the context is a stub (e.g. empty enumerable) Remarks During compilation - you should not use the target returned by this function as a direct part of your expression tree - you should <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.OverridingScopedContainer.html": {
    "href": "rezolver-api/Rezolver.OverridingScopedContainer.html",
    "title": "Class OverridingScopedContainer",
    "keywords": "Improve this Doc Class OverridingScopedContainer Inheritance System.Object ContainerBase CachingContainerBase Container OverridingContainer OverridingScopedContainer Inherited Members CanResolve(RezolveContext) GetFallbackCompiledRezolveTarget(RezolveContext) GetCompiledRezolveTarget(RezolveContext) GetMissingTarget(Type) IsMissingTarget(ICompiledTarget) Compiler Targets Resolve(RezolveContext) TryResolve(RezolveContext, out Object) CreateLifetimeScope() FetchCompiled(RezolveContext) Rezolver.ContainerBase.System.IServiceProvider.GetService(System.Type) GetService(Type) Register(ITarget, Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.Fetch(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.FetchAll(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer, System.Type) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class OverridingScopedContainer : OverridingContainer, ITargetContainer, IScopedContainer, IContainer, IServiceProvider, IDisposable <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc OverridingScopedContainer(IScopedContainer, IContainer, ITargetContainer, ITargetCompiler) Constructs a new instance of the CombinedLifetimeScopeRezolver class. Declaration public OverridingScopedContainer(IScopedContainer parentScope, IContainer inner = null, ITargetContainer builder = null, ITargetCompiler compiler = null) Parameters Name Type Description parentScope IScopedContainer Can be null, but if it is, then inner must be supplied inner IContainer Can be null, but if it is, then parentScope must be supplied builder ITargetContainer compiler ITargetCompiler <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc ParentScope Declaration public IScopedContainer ParentScope { get; } Property Value Type Description IScopedContainer Implements ParentScope <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc AddToScope(Object, RezolveContext) Declaration public virtual void AddToScope(object obj, RezolveContext context = null) Parameters Name Type Description obj System.Object context RezolveContext Implements AddToScope(Object, RezolveContext) <!-- .classchild --> | Improve this Doc Dispose() Declaration public void Dispose() Implements System.IDisposable.Dispose() <!-- .classchild --> | Improve this Doc Dispose(Boolean) Declaration protected virtual void Dispose(bool disposing) Parameters Name Type Description disposing System.Boolean <!-- .classchild --> | Improve this Doc GetFromScope(RezolveContext) Declaration public virtual IEnumerable<object> GetFromScope(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description System.Collections.Generic.IEnumerable < System.Object > Implements GetFromScope(RezolveContext) <!-- .classchild --> | Improve this Doc OnDisposed() Declaration protected void OnDisposed() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Events | Improve this Doc Disposed Declaration public event EventHandler Disposed Event Type Type Description System.EventHandler Implements Disposed <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.OverridingContainer.html": {
    "href": "rezolver-api/Rezolver.OverridingContainer.html",
    "title": "Class OverridingContainer",
    "keywords": "Improve this Doc Class OverridingContainer An IContainer which can override the resolve operations of another. This is useful when you have a core application-wide container, with some objects being customised based on some ambient information, e.g. configuration, MVC Area/Controller, Brand (in a multi-tenant application for example) or more. The scoping version of this is called OverridingScopedContainer . Inheritance System.Object ContainerBase CachingContainerBase Container OverridingContainer Inherited Members GetCompiledRezolveTarget(RezolveContext) GetMissingTarget(Type) IsMissingTarget(ICompiledTarget) Compiler Targets Resolve(RezolveContext) TryResolve(RezolveContext, out Object) CreateLifetimeScope() FetchCompiled(RezolveContext) Rezolver.ContainerBase.System.IServiceProvider.GetService(System.Type) GetService(Type) Register(ITarget, Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.Fetch(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.FetchAll(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer, System.Type) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class OverridingContainer : Container, IContainer, IServiceProvider, ITargetContainer <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc OverridingContainer(IContainer, ITargetContainer, ITargetCompiler) Declaration public OverridingContainer(IContainer inner, ITargetContainer builder = null, ITargetCompiler compiler = null) Parameters Name Type Description inner IContainer Required. The inner container that this one combines with. Any dependencies not served by the new combined container's own registry will be sought from this container. builder ITargetContainer Optional. A specific builder to be used for this container's own registrations. compiler ITargetCompiler Optional. A compiler to be used to create ICompiledTarget instances from this container's registrations. If this is not provided, then the default is used ( Default ) <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CanResolve(RezolveContext) Called to determine if this container is able to resolve the type specified in the passed context . Declaration public override bool CanResolve(RezolveContext context) Parameters Name Type Description context RezolveContext Required. The RezolveContext . Returns Type Description System.Boolean Overrides CanResolve(RezolveContext) <!-- .classchild --> | Improve this Doc GetFallbackCompiledRezolveTarget(RezolveContext) Overrides the base implementation to pass the lookup for an ITarget to the inner container - this is how dependency chaining from this container to the inner container is achieved. Declaration protected override ICompiledTarget GetFallbackCompiledRezolveTarget(RezolveContext context) Parameters Name Type Description context RezolveContext Required. The RezolveContext . Returns Type Description ICompiledTarget Overrides GetFallbackCompiledRezolveTarget(RezolveContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.OptionalParameterTarget.html": {
    "href": "rezolver-api/Rezolver.OptionalParameterTarget.html",
    "title": "Class OptionalParameterTarget",
    "keywords": "Improve this Doc Class OptionalParameterTarget Used specifically when binding arguments to method parameters when a parameter is optional and its default value is to be used when binding to it. Inheritance System.Object TargetBase OptionalParameterTarget Inherited Members CreateScopeTrackingExpression(CompileContext, Expression) CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) CreateScopeSelectionExpression(CompileContext, Expression) SupportsType(Type) CreateExpression(CompileContext) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class OptionalParameterTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc OptionalParameterTarget(ParameterInfo) Constructs a new instance of the OptionalParameterTarget class. Declaration public OptionalParameterTarget(ParameterInfo methodParameter) Parameters Name Type Description methodParameter ParameterInfo Required - parameter to which this target will be bound. Its property must be true . <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description System.Type Overrides DeclaredType <!-- .classchild --> | Improve this Doc MethodParameter Declaration public ParameterInfo MethodParameter { get; } Property Value Type Description ParameterInfo <!-- .classchild --> | Improve this Doc SuppressScopeTracking Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description System.Boolean Overrides SuppressScopeTracking <!-- .classchild --> | Improve this Doc UseFallback Declaration public override bool UseFallback { get; } Property Value Type Description System.Boolean Overrides UseFallback <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateExpressionBase(CompileContext) Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides CreateExpressionBase(CompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ObjectTargetExtensions.html": {
    "href": "rezolver-api/Rezolver.ObjectTargetExtensions.html",
    "title": "Class ObjectTargetExtensions",
    "keywords": "Improve this Doc Class ObjectTargetExtensions Extension method(s) Inheritance System.Object ObjectTargetExtensions Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ObjectTargetExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc AsObjectTarget<T>(T, Type, Boolean) Wraps the instance on which this is invoked as an ObjectTarget that can be registered into an ITargetContainer . The parameters are direct analogues of the parameters on the type's constructor (see Rezolver.ObjectTarget. ). Declaration public static ObjectTarget AsObjectTarget<T>(this T obj, Type declaredType = null, bool suppressScopeTracking = true) Parameters Name Type Description obj T declaredType System.Type suppressScopeTracking System.Boolean Returns Type Description ObjectTarget A new object target that wraps the object obj . Type Parameters Name Description T <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationAdapterContextFactory.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationAdapterContextFactory.html",
    "title": "Interface IConfigurationAdapterContextFactory",
    "keywords": "Improve this Doc Interface IConfigurationAdapterContextFactory Used by this library's default implementation of IConfigurationAdapter, the ConfigurationAdapter class, to create an instance of the ConfigurationAdapterContext class for a given adapter that's processing a given configuration. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationAdapterContextFactory <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateContext(ConfigurationAdapter, IConfiguration) Declaration ConfigurationAdapterContext CreateContext(ConfigurationAdapter adapter, IConfiguration configuration) Parameters Name Type Description adapter ConfigurationAdapter configuration IConfiguration Returns Type Description ConfigurationAdapterContext <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ExceptionResources.html": {
    "href": "rezolver-api/Rezolver.ExceptionResources.html",
    "title": "Class ExceptionResources",
    "keywords": "Improve this Doc Class ExceptionResources A strongly-typed resource class, for looking up localized strings, etc. Inheritance System.Object ExceptionResources Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax [DebuggerNonUserCode] [CompilerGenerated] public class ExceptionResources <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Culture Overrides the current thread's CurrentUICulture property for all resource lookups using this strongly typed resource class. Declaration public static CultureInfo Culture { get; set; } Property Value Type Description System.Globalization.CultureInfo <!-- .classchild --> | Improve this Doc CyclicDependencyDetectedInTargetFormat Looks up a localized string similar to Cyclic dependency detected in targets - current target of type {0} with DeclaredType of {1} has tried to include itself in its expression.. Declaration public static string CyclicDependencyDetectedInTargetFormat { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc DeclaredTypeIsNotCompatible_Format Looks up a localized string similar to The declared type {0} is not compatible with the type {1}. Declaration public static string DeclaredTypeIsNotCompatible_Format { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc LambdaBodyIsNotNewExpressionFormat Looks up a localized string similar to The body of the lambda \"{0}\" is not a NewExpression. Declaration public static string LambdaBodyIsNotNewExpressionFormat { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc LambdaBodyNewExpressionIsWrongTypeFormat Looks up a localized string similar to The expression {0} does not represent calling a constructor of the type {1}. Declaration public static string LambdaBodyNewExpressionIsWrongTypeFormat { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc MoreThanOneBestConstructorFormat Looks up a localized string similar to More than one constructor for {0} found that could be bound from the current context. Possible candidates: {1}. Declaration public static string MoreThanOneBestConstructorFormat { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc MoreThanOneConstructorFormat Looks up a localized string similar to More than one constructor for {0} qualifies as a target for Auto construction. Declaration public static string MoreThanOneConstructorFormat { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc MoreThanOneObjectFoundInScope Looks up a localized string similar to More than one matching object was found in the scope. Declaration public static string MoreThanOneObjectFoundInScope { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc NoApplicableConstructorForContextFormat Looks up a localized string similar to No constructor found on the type {0} which can be satisfied by the CompileContext. Declaration public static string NoApplicableConstructorForContextFormat { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc NoConstructorSetOnNewExpression Looks up a localized string similar to No constructor has been set on the NewExpression - this is not allowed.. Declaration public static string NoConstructorSetOnNewExpression { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc NoDefaultOrAllOptionalConstructorFormat Looks up a localized string similar to The type {0} has no default constructor, nor any constructors where all the parameters are optional.. Declaration public static string NoDefaultOrAllOptionalConstructorFormat { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc NoPublicConstructorsDefinedFormat Looks up a localized string similar to No public constructors declared on the type {0}. Declaration public static string NoPublicConstructorsDefinedFormat { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc NotRuntimeMethod Looks up a localized string similar to This method is not to be called at run-time - it is only used for static expression analysis in creating IRezolveTargets for an IRezolveBuilder. Declaration public static string NotRuntimeMethod { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc PathIsAtEnd Looks up a localized string similar to path's Next must not be null - pass path as null once it's reached the last item. Declaration public static string PathIsAtEnd { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc PathIsInvalid Looks up a localized string similar to The path {0} is invalid. All path steps must contain non-whitespace characters and be at least one character in length. Declaration public static string PathIsInvalid { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc ResourceManager Returns the cached ResourceManager instance used by this class. Declaration public static ResourceManager ResourceManager { get; } Property Value Type Description System.Resources.ResourceManager <!-- .classchild --> | Improve this Doc RezolverTargetEntryHasBeenRealised Looks up a localized string similar to No more targets can be added to this entry. Declaration public static string RezolverTargetEntryHasBeenRealised { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc ScopedSingletonRequiresAScope Looks up a localized string similar to A lifetime scope is required for a scoped singleton. Declaration public static string ScopedSingletonRequiresAScope { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc TargetDoesntSupportType_Format Looks up a localized string similar to The target does not support the type {0}. Declaration public static string TargetDoesntSupportType_Format { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc TargetIsNullButTypeIsNotNullable_Format Looks up a localized string similar to The type {0} is not a nullable type. Declaration public static string TargetIsNullButTypeIsNotNullable_Format { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc TargetReturnedNullExpressionFormat Looks up a localized string similar to Target of type {0} returned a null expression for context {1} - implementation is invalid, targets must never return a null expression.. Declaration public static string TargetReturnedNullExpressionFormat { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc TypeIsAlreadyRegistered Looks up a localized string similar to The type {0} has already been registered. Declaration public static string TypeIsAlreadyRegistered { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc UnableToResolveTypeFromBuilderFormat Looks up a localized string similar to Unable to resolve type {0} from builder. Declaration public static string UnableToResolveTypeFromBuilderFormat { get; } Property Value Type Description System.String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.EnumerableTargetBuilderExtensions.html": {
    "href": "rezolver-api/Rezolver.EnumerableTargetBuilderExtensions.html",
    "title": "Class EnumerableTargetBuilderExtensions",
    "keywords": "Improve this Doc Class EnumerableTargetBuilderExtensions Inheritance System.Object EnumerableTargetBuilderExtensions Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class EnumerableTargetBuilderExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc EnableEnumerableResolving(TargetContainer) Declaration public static void EnableEnumerableResolving(this TargetContainer builder) Parameters Name Type Description builder TargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTarget`1.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget`1.html",
    "title": "Class DelegateTarget<T>",
    "keywords": "Improve this Doc Class DelegateTarget<T> Implements IRezolveTarget using factory function delegates. Inheritance System.Object TargetBase DelegateTarget<T> Inherited Members SuppressScopeTracking UseFallback CreateScopeTrackingExpression(CompileContext, Expression) CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) CreateScopeSelectionExpression(CompileContext, Expression) SupportsType(Type) CreateExpression(CompileContext) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T> : TargetBase, ITarget Type Parameters Name Description T <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc DelegateTarget(Func<T>, Type) Declaration public DelegateTarget(Func<T> factory, Type declaredType = null) Parameters Name Type Description factory System.Func <T> declaredType System.Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description System.Type Overrides DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateExpressionBase(CompileContext) Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides CreateExpressionBase(CompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DelegateTargetExtensions.html": {
    "href": "rezolver-api/Rezolver.DelegateTargetExtensions.html",
    "title": "Class DelegateTargetExtensions",
    "keywords": "Improve this Doc Class DelegateTargetExtensions Inheritance System.Object DelegateTargetExtensions Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTargetExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc AsDelegateTarget<T>(Func<T>, Type) Declaration public static DelegateTarget<T> AsDelegateTarget<T>(this Func<T> factory, Type declaredType = null) Parameters Name Type Description factory System.Func <T> declaredType System.Type Returns Type Description DelegateTarget <T> Type Parameters Name Description T <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DefaultTarget.html": {
    "href": "rezolver-api/Rezolver.DefaultTarget.html",
    "title": "Class DefaultTarget",
    "keywords": "Improve this Doc Class DefaultTarget A target that simply creates a default instance of a given type. I.e. the same as doing default(type) in C#. Inheritance System.Object TargetBase DefaultTarget Inherited Members SuppressScopeTracking UseFallback CreateScopeTrackingExpression(CompileContext, Expression) CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) CreateScopeSelectionExpression(CompileContext, Expression) SupportsType(Type) CreateExpression(CompileContext) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DefaultTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc DefaultTarget(Type) Declaration public DefaultTarget(Type type) Parameters Name Type Description type System.Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description System.Type Overrides DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateExpressionBase(CompileContext) Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides CreateExpressionBase(CompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DefaultPropertyBindingBehaviour.html": {
    "href": "rezolver-api/Rezolver.DefaultPropertyBindingBehaviour.html",
    "title": "Class DefaultPropertyBindingBehaviour",
    "keywords": "Improve this Doc Class DefaultPropertyBindingBehaviour Inheritance System.Object DefaultPropertyBindingBehaviour Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DefaultPropertyBindingBehaviour : IPropertyBindingBehaviour <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Instance Declaration public static DefaultPropertyBindingBehaviour Instance { get; } Property Value Type Description DefaultPropertyBindingBehaviour <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc BindProperties(Type, IEnumerable<PropertyInfo>) Declaration protected virtual IEnumerable<PropertyOrFieldBinding> BindProperties(Type type, IEnumerable<PropertyInfo> properties) Parameters Name Type Description type System.Type properties System.Collections.Generic.IEnumerable < PropertyInfo > Returns Type Description System.Collections.Generic.IEnumerable < PropertyOrFieldBinding > <!-- .classchild --> | Improve this Doc CreateBinding(Type, FieldInfo) Declaration protected virtual PropertyOrFieldBinding CreateBinding(Type type, FieldInfo field) Parameters Name Type Description type System.Type field FieldInfo Returns Type Description PropertyOrFieldBinding <!-- .classchild --> | Improve this Doc CreateBinding(Type, PropertyInfo) Declaration protected virtual PropertyOrFieldBinding CreateBinding(Type type, PropertyInfo prop) Parameters Name Type Description type System.Type prop PropertyInfo Returns Type Description PropertyOrFieldBinding <!-- .classchild --> | Improve this Doc GetBindableFields(Type) Declaration protected virtual IEnumerable<FieldInfo> GetBindableFields(Type type) Parameters Name Type Description type System.Type Returns Type Description System.Collections.Generic.IEnumerable < FieldInfo > <!-- .classchild --> | Improve this Doc GetBindableProperties(Type) Declaration protected virtual IEnumerable<PropertyInfo> GetBindableProperties(Type type) Parameters Name Type Description type System.Type Returns Type Description System.Collections.Generic.IEnumerable < PropertyInfo > <!-- .classchild --> | Improve this Doc GetPropertyBindings(CompileContext, Type) Declaration public virtual PropertyOrFieldBinding[] GetPropertyBindings(CompileContext context, Type type) Parameters Name Type Description context CompileContext type System.Type Returns Type Description PropertyOrFieldBinding [] Implements GetPropertyBindings(CompileContext, Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.DecoratorTarget.html": {
    "href": "rezolver-api/Rezolver.DecoratorTarget.html",
    "title": "Class DecoratorTarget",
    "keywords": "Improve this Doc Class DecoratorTarget Implements service decoration in an ITargetContainer . The best way to add a decorator to your target container is to use the extension method RegisterDecorator (ITargetContainerOwner) or its non-generic equivalent. Inheritance System.Object DecoratorTarget Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DecoratorTarget : ITargetContainerOwner, ITargetContainer <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc DecoratorTarget(Type, Type) Declaration public DecoratorTarget(Type decoratorType, Type decoratedType) Parameters Name Type Description decoratorType System.Type decoratedType System.Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CombineWith(ITargetContainer, Type) Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer type System.Type Returns Type Description ITargetContainer Implements CombineWith(ITargetContainer, Type) <!-- .classchild --> | Improve this Doc Fetch(Type) Declaration public ITarget Fetch(Type type) Parameters Name Type Description type System.Type Returns Type Description ITarget Implements Fetch(Type) <!-- .classchild --> | Improve this Doc FetchAll(Type) Declaration public IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type System.Type Returns Type Description System.Collections.Generic.IEnumerable < ITarget > Implements FetchAll(Type) <!-- .classchild --> | Improve this Doc FetchContainer(Type) Declaration public ITargetContainer FetchContainer(Type type) Parameters Name Type Description type System.Type Returns Type Description ITargetContainer Implements FetchContainer(Type) <!-- .classchild --> | Improve this Doc Register(ITarget, Type) Declaration public void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget serviceType System.Type Implements Register(ITarget, Type) <!-- .classchild --> | Improve this Doc RegisterContainer(Type, ITargetContainer) Declaration public void RegisterContainer(Type type, ITargetContainer container) Parameters Name Type Description type System.Type container ITargetContainer Implements RegisterContainer(Type, ITargetContainer) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ContainerBase.html": {
    "href": "rezolver-api/Rezolver.ContainerBase.html",
    "title": "Class ContainerBase",
    "keywords": "Improve this Doc Class ContainerBase Starting point for implementations of IContainer - only creatable through inheritance. Inheritance System.Object ContainerBase Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ContainerBase : IContainer, IServiceProvider, ITargetContainer Remarks Note that the class also implements ITargetContainer by proxying the Targets that are provided to it on construction. All methods are implemented explicitly except the Register(ITarget, Type) method, which available through the class' public API. Note: IContainer s are generally not expected to implement ITargetContainer , and the framework will never assume they do. The reason this class does is to make it easier to create a new container and to register targets into it without having to worry about managing a separate ITargetContainer instance in your application root - because all the registration extension methods defined in ITargetContainerExtensions will be available to developers in code which has a reference to this class, or one derived from it. Note also that calling CombineWith(ITargetContainer, Type) on an instance of this type will always cause a System.NotSupportedException to be thrown. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ContainerBase(ITargetContainer, ITargetCompiler) blah blah Declaration protected ContainerBase(ITargetContainer targets = null, ITargetCompiler compiler = null) Parameters Name Type Description targets ITargetContainer compiler ITargetCompiler <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Compiler The compiler that will be used to compile ITarget instances, obtained from the Targets container during Resolve(RezolveContext) and TryResolve(RezolveContext, out Object) operations, into ICompiledTarget instances that will actually provide the objects that are resolved. Declaration protected ITargetCompiler Compiler { get; } Property Value Type Description ITargetCompiler Remarks Notes to implementers: This property must NEVER be null. <!-- .classchild --> | Improve this Doc Targets Provides the ITarget instances that will be compiled by the Compiler into ICompiledTarget instances. Declaration protected ITargetContainer Targets { get; } Property Value Type Description ITargetContainer Remarks Notes to implementers: This property must NEVER be null. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CanResolve(RezolveContext) Declaration public virtual bool CanResolve(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description System.Boolean Implements CanResolve(RezolveContext) <!-- .classchild --> | Improve this Doc CreateLifetimeScope() Declaration public virtual IScopedContainer CreateLifetimeScope() Returns Type Description IScopedContainer Implements CreateLifetimeScope() <!-- .classchild --> | Improve this Doc FetchCompiled(RezolveContext) Declaration public virtual ICompiledTarget FetchCompiled(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description ICompiledTarget Implements FetchCompiled(RezolveContext) <!-- .classchild --> | Improve this Doc GetCompiledRezolveTarget(RezolveContext) Declaration protected virtual ICompiledTarget GetCompiledRezolveTarget(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description ICompiledTarget <!-- .classchild --> | Improve this Doc GetFallbackCompiledRezolveTarget(RezolveContext) Called by GetCompiledRezolveTarget(RezolveContext) if no valid ITarget can be found for the context or if the one found has its UseFallback property set to true . Declaration protected virtual ICompiledTarget GetFallbackCompiledRezolveTarget(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description ICompiledTarget An ICompiledTarget to be used as the result of a Resolve(RezolveContext) operation where the search for a valid target either fails or is inconclusive (e.g. - empty enumerables). Remarks The base implementation always returns an instance of the ContainerBase.MissingCompiledTarget via the GetMissingTarget(Type) static method. <!-- .classchild --> | Improve this Doc GetMissingTarget(Type) Declaration protected static ICompiledTarget GetMissingTarget(Type target) Parameters Name Type Description target System.Type Returns Type Description ICompiledTarget <!-- .classchild --> | Improve this Doc GetService(Type) Protected virtual implementation of GetService(Type) . Declaration protected virtual object GetService(Type serviceType) Parameters Name Type Description serviceType System.Type Returns Type Description System.Object <!-- .classchild --> | Improve this Doc IsMissingTarget(ICompiledTarget) Declaration protected static bool IsMissingTarget(ICompiledTarget target) Parameters Name Type Description target ICompiledTarget Returns Type Description System.Boolean <!-- .classchild --> | Improve this Doc Register(ITarget, Type) Implementation of Register(ITarget, Type) - simply proxies the call to the target container referenced by the Targets property. Declaration public void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget serviceType System.Type Implements Register(ITarget, Type) Remarks Remember: registering new targets into an ITargetContainer after an IContainer has started compiling targets within it can yield unpredictable results. If you create a new container and perform all your registrations before you use it, however, then everything will work as expected. Note also the other ITargetContainer interface methods are implemented explicitly so as to hide them from the list of class members. <!-- .classchild --> | Improve this Doc Resolve(RezolveContext) Declaration public virtual object Resolve(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description System.Object Implements Resolve(RezolveContext) <!-- .classchild --> | Improve this Doc TryResolve(RezolveContext, out Object) Declaration public virtual bool TryResolve(RezolveContext context, out object result) Parameters Name Type Description context RezolveContext result System.Object Returns Type Description System.Boolean Implements TryResolve(RezolveContext, out Object) <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Explicit Interface Implementations | Improve this Doc ITargetContainer.CombineWith(ITargetContainer, Type) Declaration ITargetContainer ITargetContainer.CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer type System.Type Returns Type Description ITargetContainer Implements CombineWith(ITargetContainer, Type) <!-- .classchild --> | Improve this Doc ITargetContainer.Fetch(Type) Declaration ITarget ITargetContainer.Fetch(Type type) Parameters Name Type Description type System.Type Returns Type Description ITarget Implements Fetch(Type) <!-- .classchild --> | Improve this Doc ITargetContainer.FetchAll(Type) Declaration IEnumerable<ITarget> ITargetContainer.FetchAll(Type type) Parameters Name Type Description type System.Type Returns Type Description System.Collections.Generic.IEnumerable < ITarget > Implements FetchAll(Type) <!-- .classchild --> | Improve this Doc IServiceProvider.GetService(Type) Declaration object IServiceProvider.GetService(Type serviceType) Parameters Name Type Description serviceType System.Type Returns Type Description System.Object Implements System.IServiceProvider.GetService(System.Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ContainerBase.MissingCompiledTarget.html": {
    "href": "rezolver-api/Rezolver.ContainerBase.MissingCompiledTarget.html",
    "title": "Class ContainerBase.MissingCompiledTarget",
    "keywords": "Improve this Doc Class ContainerBase.MissingCompiledTarget Inheritance System.Object ContainerBase.MissingCompiledTarget Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax protected class MissingCompiledTarget : ICompiledTarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc MissingCompiledTarget(Type) Declaration public MissingCompiledTarget(Type type) Parameters Name Type Description type System.Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc GetObject(RezolveContext) Declaration public object GetObject(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description System.Object Implements GetObject(RezolveContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Container.html": {
    "href": "rezolver-api/Rezolver.Container.html",
    "title": "Class Container",
    "keywords": "Improve this Doc Class Container Inheritance System.Object ContainerBase CachingContainerBase Container Inherited Members GetCompiledRezolveTarget(RezolveContext) GetMissingTarget(Type) IsMissingTarget(ICompiledTarget) Compiler Targets Resolve(RezolveContext) TryResolve(RezolveContext, out Object) CreateLifetimeScope() FetchCompiled(RezolveContext) CanResolve(RezolveContext) GetFallbackCompiledRezolveTarget(RezolveContext) Rezolver.ContainerBase.System.IServiceProvider.GetService(System.Type) GetService(Type) Register(ITarget, Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.Fetch(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.FetchAll(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer, System.Type) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class Container : CachingContainerBase, IContainer, IServiceProvider, ITargetContainer <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc Container(ITargetContainer, ITargetCompiler) Main IOC container class. Requires an ITargetContainer to provide the ITarget s which will be compiled when resolving objects. Declaration public Container(ITargetContainer targets = null, ITargetCompiler compiler = null) Parameters Name Type Description targets ITargetContainer The targets which will be used to resolve objects. If left null, then a new will be created. compiler ITargetCompiler The compiler to be used to turn the ITarget s obtained from the targets into ICompiledTarget <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ConstructorTarget.html": {
    "href": "rezolver-api/Rezolver.ConstructorTarget.html",
    "title": "Class ConstructorTarget",
    "keywords": "Improve this Doc Class ConstructorTarget The most common target used for building new objects. Represents binding to a type's constructor with zero or more arguments supplied by other ITarget s. In addition to using the Rezolver.ConstructorTarget. constructor you can also use the factory methods - such as Auto (IPropertyBindingBehaviour) . Inheritance System.Object TargetBase ConstructorTarget Inherited Members SuppressScopeTracking UseFallback CreateScopeTrackingExpression(CompileContext, Expression) CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) CreateScopeSelectionExpression(CompileContext, Expression) SupportsType(Type) CreateExpression(CompileContext) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ConstructorTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ConstructorTarget(Type, ConstructorInfo, IPropertyBindingBehaviour, ParameterBinding[]) Declaration public ConstructorTarget(Type type, ConstructorInfo ctor, IPropertyBindingBehaviour propertyBindingBehaviour, ParameterBinding[] parameterBindings) Parameters Name Type Description type System.Type ctor ConstructorInfo propertyBindingBehaviour IPropertyBindingBehaviour parameterBindings ParameterBinding [] <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description System.Type Overrides DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Auto(Type, IPropertyBindingBehaviour) Creates a target that will create a new concrete instance of the type . Note - if the type is a generic type definition, t Declaration public static ITarget Auto(Type type, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description type System.Type propertyBindingBehaviour IPropertyBindingBehaviour Returns Type Description ITarget <!-- .classchild --> | Improve this Doc Auto<T>(IPropertyBindingBehaviour) Declaration public static ITarget Auto<T>(IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Name Type Description propertyBindingBehaviour IPropertyBindingBehaviour Returns Type Description ITarget Type Parameters Name Description T <!-- .classchild --> | Improve this Doc CreateExpressionBase(CompileContext) Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides CreateExpressionBase(CompileContext) <!-- .classchild --> | Improve this Doc FromNewExpression(Type, NewExpression, ITargetAdapter) Declaration public static ITarget FromNewExpression(Type declaredType, NewExpression newExpr, ITargetAdapter adapter = null) Parameters Name Type Description declaredType System.Type newExpr NewExpression adapter ITargetAdapter Returns Type Description ITarget <!-- .classchild --> | Improve this Doc FromNewExpression<T>(Expression<Func<RezolveContextExpressionHelper, T>>, ITargetAdapter) Constructs an constructor target that's reconstructed from a , including any parameter bindings. Declaration public static ITarget FromNewExpression<T>(Expression<Func<RezolveContextExpressionHelper, T>> newExpr, ITargetAdapter adapter = null) Parameters Name Type Description newExpr Expression < System.Func < RezolveContextExpressionHelper , T>> adapter ITargetAdapter Returns Type Description ITarget Type Parameters Name Description T <!-- .classchild --> | Improve this Doc WithArgs(Type, ConstructorInfo, IDictionary<String, ITarget>) Declaration public static ITarget WithArgs(Type declaredType, ConstructorInfo ctor, IDictionary<string, ITarget> args) Parameters Name Type Description declaredType System.Type ctor ConstructorInfo args System.Collections.Generic.IDictionary < System.String , ITarget > Returns Type Description ITarget <!-- .classchild --> | Improve this Doc WithArgs(Type, IDictionary<String, ITarget>) Declaration public static ITarget WithArgs(Type declaredType, IDictionary<string, ITarget> args) Parameters Name Type Description declaredType System.Type args System.Collections.Generic.IDictionary < System.String , ITarget > Returns Type Description ITarget <!-- .classchild --> | Improve this Doc WithArgs<T>(IDictionary<String, ITarget>) Declaration public static ITarget WithArgs<T>(IDictionary<string, ITarget> args) Parameters Name Type Description args System.Collections.Generic.IDictionary < System.String , ITarget > Returns Type Description ITarget Type Parameters Name Description T <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.html": {
    "href": "rezolver-api/Rezolver.Configuration.html",
    "title": "Namespace Rezolver.Configuration",
    "keywords": "Improve this Doc Namespace Rezolver.Configuration Classes AssemblyReferenceEntry ConfigurationAdapter Standard implementation of the IConfigurationAdapter interface. ConfigurationAdapter.ConfigurationEntryProcessOrderer Used by the ConfigurationAdapter class to sort configuration entries for processing. It ensures that Assembly Reference entries are given priority, followed by Namespace Imports, and then finally all the rest. ConfigurationAdapterContext This class is used to store the intermediate state for the default IConfigurationAdapter implementation's ( ConfigurationAdapter ) parsing operation on an IConfiguration instance. If you are extending the default adapter you might need also to extend this class to ensure any additional state you require is maintained. ConfigurationAdapterContext.UnresolvedType Used as a sentinel type by the ResolveType(String, Nullable ) method when the type search fails. ConfigurationAdapterContextFactory The standard Singleton implementation of the IConfigurationAdapterContextFactory interface, and one which you can use as the starting point of your own factory. By default, it creates a new instance of the ConfigurationAdapterContext class (using the virtual method CreateContext(ConfigurationAdapter, IConfiguration) , and then instructs it to add its default assembly references. ConfigurationEntryBase suggested starting point for implementing your own configuration entries. ConfigurationError ConfigurationException ConstructorTargetMetadata ListTargetMetadata Standard implementation of the IListTargetMetadata interface. ObjectTargetMetadata Standard implementation of ObjectTargetMetadataBase , to encapsulate object references that are to be baked into a container as targets. ObjectTargetMetadataBase Abstract base class for metadata that builds an object target. RegisterInstruction The basic workhorse of a parsed configuration - an instruction to register a target in an IRezolveTargetContainer instance against one or more types with a given name. RegisterMultipleInstruction Similar to the RegisterInstruction except this specifically wraps the method. Construction is largely identical, except where in the aforementioned class you pass a single target, here you pass multiple targets in a list. RezolverBuilderInstruction An instruction to perform an operation on a container builder from an IConfigurationEntry that's been parsed from a configuration source (and which has been retrieved from an IConfiguration instance). RezolveTargetMetadataBase Suggested base class for implementations of IRezolveTargetMetadata . RezolveTargetMetadataList RuntimeTypeReference An ITypeReference that has been built directly from a runtime type. SingletonTargetMetadata TypeReference Concrete implementation of the TypeReferenceBase abstract class, and the default implementation of ITypeReference to use when parsing configuration. TypeReferenceBase abstract base class to serve as a starting point for implementing the ITypeReference interface. TypeRegistrationEntry Interfaces IAssemblyReferenceEntry A configuration entry instructing the configuration adapter to load an assembly before resolving types. IConfiguration IConfigurationAdapter Represents an object that is responsible for transforming configuration data into target containers. IConfigurationAdapterContextFactory Used by this library's default implementation of IConfigurationAdapter, the ConfigurationAdapter class, to create an instance of the ConfigurationAdapterContext class for a given adapter that's processing a given configuration. IConfigurationEntry IConfigurationError Interface for an error that originates from a configuration file. IConfigurationExtensionEntry IConfigurationLineInfo Encapsulates information about where a particular object, parsed from a configuration file, can be found. IConstructorTargetMetadata IListTargetMetadata Configuration metadata for building a ListTarget in a RezolverBuilder. IObjectTargetMetadata Interface for metadata for constructing an ObjectTarget IRezolveTarget. IRezolveTargetMetadata Represents an instruction to create an IRezolveTarget from parsed configuration. IRezolveTargetMetadataExtension IRezolveTargetMetadataList Represents a list of IRezolveTargetMetadata instances - for when you want to register multiple targets against a single type. Note - although the interface IRezolveTargetMetadata is included by this interface, instances are not expected to be able to create a single target through the CreateRezolveTarget method - because by definition, multiple targets are produced by this. Use the CreateRezolveTargets method instead. The Bind method, however, will be expected to produce a new instance of the implementing type if any underlying targets are not bound to a specific type. ISingletonTargetMetadata Interface for Singleton metadata. ITypeReference Captures a reference to a type made in a configuration file. It does not guarantee that the type can be located, it simply provides a common interface for storing the type information written in a configuration file. An IConfigurationAdapter instance will need to resolve the actual runtime type from this when registering targets from a configuration file. ITypeRegistrationEntry Represents an instruction to register one or more targets in an ITargetContainer against one or more types. Think of it as wrapping a single call to one of the builder's Register methods. Enums ConfigurationEntryType Types of configuration entry that can be parsed from a configuration file RezolveTargetMetadataType Types of IRezolveTargetMetadata that can be expressed in configuration"
  },
  "rezolver-api/Rezolver.Configuration.TypeRegistrationEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.TypeRegistrationEntry.html",
    "title": "Class TypeRegistrationEntry",
    "keywords": "Improve this Doc Class TypeRegistrationEntry Inheritance System.Object ConfigurationEntryBase TypeRegistrationEntry Inherited Members Type StartLineNo StartLinePos EndLineNo EndLinePos System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class TypeRegistrationEntry : ConfigurationEntryBase, ITypeRegistrationEntry, IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc TypeRegistrationEntry(ITypeReference[], IRezolveTargetMetadata, Boolean, IConfigurationLineInfo) Declaration public TypeRegistrationEntry(ITypeReference[] types, IRezolveTargetMetadata targetMetadata, bool isMultipleRegistration, IConfigurationLineInfo lineInfo = null) Parameters Name Type Description types ITypeReference [] targetMetadata IRezolveTargetMetadata isMultipleRegistration System.Boolean lineInfo IConfigurationLineInfo <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc IsMultipleRegistration Declaration public bool IsMultipleRegistration { get; } Property Value Type Description System.Boolean Implements IsMultipleRegistration <!-- .classchild --> | Improve this Doc TargetMetadata Declaration public IRezolveTargetMetadata TargetMetadata { get; } Property Value Type Description IRezolveTargetMetadata Implements TargetMetadata <!-- .classchild --> | Improve this Doc Types Declaration public ITypeReference[] Types { get; } Property Value Type Description ITypeReference [] Implements Types <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.TypeReferenceBase.html": {
    "href": "rezolver-api/Rezolver.Configuration.TypeReferenceBase.html",
    "title": "Class TypeReferenceBase",
    "keywords": "Improve this Doc Class TypeReferenceBase abstract base class to serve as a starting point for implementing the ITypeReference interface. Inheritance System.Object TypeReferenceBase Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public abstract class TypeReferenceBase : ITypeReference, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc TypeReferenceBase() Initializes a new instance of the TypeReferenceBase class. Declaration protected TypeReferenceBase() <!-- .classchild --> | Improve this Doc TypeReferenceBase(IConfigurationLineInfo) Initializes a new instance of the TypeReferenceBase class, copying the passed line information into this object, if provided. Declaration protected TypeReferenceBase(IConfigurationLineInfo lineInfo) Parameters Name Type Description lineInfo IConfigurationLineInfo Optional. The line information. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc EndLineNo Gets the line number within the configuration source that sees the end of the text from which this object was parsed. Used in conjunction with EndLinePos , it allows you to zero-in on the exact ending of this parsed object. Declaration public int ? EndLineNo { get; } Property Value Type Description System.Nullable < System.Int32 > The end line number. Implements EndLineNo <!-- .classchild --> | Improve this Doc EndLinePos Gets the position from the start of the line, indicated by EndLineNo , where the configuration text ends for this parsed object. Declaration public int ? EndLinePos { get; } Property Value Type Description System.Nullable < System.Int32 > The end line position. Implements EndLinePos <!-- .classchild --> | Improve this Doc GenericArguments Any explicitly provided generic arguments are stored here. Note that it might turn out that the TypeName refers to a whole closed generic type, in which case the referenced type could still be generic even if this array is empty. It's also the case that arguments could be passed here when the root type name resolves to a non-generic type definition, in which case type resolution will likely fail. Declaration public abstract ITypeReference[] GenericArguments { get; } Property Value Type Description ITypeReference [] The generic arguments. Implements GenericArguments <!-- .classchild --> | Improve this Doc IsArray Gets a value indicating whether the type ultimately represented by this instance is an array of the type described by the rest of this instance's properties. Declaration public abstract bool IsArray { get; } Property Value Type Description System.Boolean true if this instance represents an array type; otherwise, false . Implements IsArray <!-- .classchild --> | Improve this Doc IsOpenGenericTypeArgument True if this type represents an open generic argument - this is how to explicitly reference an open generic type in a type reference: you specify a base type, then have one or more open generic arguments specified in the GenericArguments array. If all are open generic arguments, then you have created a reference to the fully open generic type. You only need to provide all-open arguments if the base TypeName could be ambiguous between a non generic and generic type, or there are multiple generic types with the same base name. Equally, you can do this to create references to partially open generics, which may or may not be supported by the adapter or the target that is built. Declaration public abstract bool IsOpenGenericTypeArgument { get; } Property Value Type Description System.Boolean true if this instance is open generic type argument; otherwise, false . Implements IsOpenGenericTypeArgument <!-- .classchild --> | Improve this Doc IsUnbound Gets a value indicating whether this instance represents a type that is to be late-bound for a specific target type. Declaration public abstract bool IsUnbound { get; } Property Value Type Description System.Boolean true if this instance is unbound; otherwise, false . Implements IsUnbound <!-- .classchild --> | Improve this Doc StartLineNo Gets the line number within the configuration source that contains the start of the text from which this object was parsed. Used in conjunction with StartLinePos , it allows you to zero-in on the exact starting point of this parsed object. Declaration public int ? StartLineNo { get; } Property Value Type Description System.Nullable < System.Int32 > The start line number. Implements StartLineNo <!-- .classchild --> | Improve this Doc StartLinePos Gets the position from the start of the line, indicated by StartLineNo , where the configuration text begins for this parsed object. Declaration public int ? StartLinePos { get; } Property Value Type Description System.Nullable < System.Int32 > The start line position. Implements StartLinePos <!-- .classchild --> | Improve this Doc TypeName The root type name. Declaration public abstract string TypeName { get; } Property Value Type Description System.String The name of the type. Implements TypeName <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc ToString() Produces a string representation of the type name, including generic arguments. Please note - this is not intended to produce a type name that can be fed to System.Type.GetType, even if occasionally it does. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.TypeReference.html": {
    "href": "rezolver-api/Rezolver.Configuration.TypeReference.html",
    "title": "Class TypeReference",
    "keywords": "Improve this Doc Class TypeReference Concrete implementation of the TypeReferenceBase abstract class, and the default implementation of ITypeReference to use when parsing configuration. Inheritance System.Object TypeReferenceBase TypeReference Inherited Members StartLineNo StartLinePos EndLineNo EndLinePos ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class TypeReference : TypeReferenceBase, ITypeReference, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc TypeReference(String, IConfigurationLineInfo, ITypeReference[]) Initializes a new instance of the TypeReference class. Declaration public TypeReference(string typeName, IConfigurationLineInfo lineInfo, params ITypeReference[] genericArguments) Parameters Name Type Description typeName System.String Name of the type. lineInfo IConfigurationLineInfo Optional. genericArguments ITypeReference [] The generic arguments. <!-- .classchild --> | Improve this Doc TypeReference(String, IConfigurationLineInfo, Boolean, ITypeReference[]) Declaration public TypeReference(string typeName, IConfigurationLineInfo lineInfo, bool isArray, params ITypeReference[] genericArguments) Parameters Name Type Description typeName System.String lineInfo IConfigurationLineInfo isArray System.Boolean genericArguments ITypeReference [] <!-- .classchild --> | Improve this Doc TypeReference(String, IConfigurationLineInfo, Boolean, Boolean, ITypeReference[]) Initializes a new instance of the TypeReference class, allowing you to create an explicitly 'unbound' type, which is expected to be replaced by whichever type is required by another component, later. Declaration public TypeReference(string typeName, IConfigurationLineInfo lineInfo, bool isArray, bool isUnbound, params ITypeReference[] genericArguments) Parameters Name Type Description typeName System.String Name of the type. lineInfo IConfigurationLineInfo The line information. isArray System.Boolean if set to true [is array]. isUnbound System.Boolean if set to true [is unbound]. genericArguments ITypeReference [] The generic arguments. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Fields | Improve this Doc NoGenericArguments Declaration public static readonly ITypeReference[] NoGenericArguments Field Value Type Description ITypeReference [] <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc GenericArguments Declaration public override ITypeReference[] GenericArguments { get; } Property Value Type Description ITypeReference [] Overrides GenericArguments <!-- .classchild --> | Improve this Doc IsArray Declaration public override bool IsArray { get; } Property Value Type Description System.Boolean Overrides IsArray <!-- .classchild --> | Improve this Doc IsOpenGenericTypeArgument Gets a value indicating whether this instance represents an open generic type argument (e.g. the 'T' from List ). Declaration public override bool IsOpenGenericTypeArgument { get; } Property Value Type Description System.Boolean true if this instance is an open generic type argument; otherwise, false . Overrides IsOpenGenericTypeArgument <!-- .classchild --> | Improve this Doc IsUnbound Gets a value indicating whether this instance represents the Unbound special type reference. Declaration public override bool IsUnbound { get; } Property Value Type Description System.Boolean true if this instance is unbound; otherwise, false . Overrides IsUnbound <!-- .classchild --> | Improve this Doc OpenGenericTypeArgument The one-and-only open generic argument instance. The only way to fetch a non-derived TypeReference that returns true for IsOpenGenericTypeArgument is to use the reference from this field. Declaration public static ITypeReference OpenGenericTypeArgument { get; } Property Value Type Description ITypeReference The open generic type argument. <!-- .classchild --> | Improve this Doc TypeName Gets the name of the type. Declaration public override string TypeName { get; } Property Value Type Description System.String The name of the type. Overrides TypeName <!-- .classchild --> | Improve this Doc Unbound A static Unbound TypeReference that can be used in cases where a simple instance of an unbound type is required. You can also, of course, create explicitly unbound type references using the greediest constructor on this type. Declaration public static ITypeReference Unbound { get; } Property Value Type Description ITypeReference The unbound. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.html",
    "title": "Namespace Rezolver.Configuration.Json",
    "keywords": "Improve this Doc Namespace Rezolver.Configuration.Json Classes AdvancedConfigurationAdapterContextFactory An advanced factory which automatically loads and references all assemblies that are deployed in the application's base directory and any subfolders determined by the System.AppDomain 's SetupInformation's PrivateBinBath. This is a singleton - accessed through the Instance property. ConfigurationEntryConverter JSON converter for IConfigurationEntry The converter defaults to looking for type registrations; to enable it to look for a different entry type, you must instruct Json.Net to create an instance of it using the constructor that accepts a ConfigurationEntryType JsonConfiguration Class JsonConfiguration. JsonConfiguration.JsonConfigurationConverter Class for loading JsonConfiguration from Json through Json.Net. JsonConfigurationException Thrown when a Json container configuration file is invalid. JsonConfigurationParser LazyJsonObjectTargetMetadata Special version of IObjectTargetMetadata which creates an instance of the requested type from a JToken. Some more work might be required here to RezolveTargetMetadataConverter This converter is registered against the type RezolveTargetMetadataWrapper RezolveTargetMetadataWrapper Metadata wrapper to accommodate the nature of how JSON configuration is deserialized. Of little practical use outside of the Json configuration library, unless you are creating your own metadata types which need the Unwrap semantics TypeReferenceConverter Responsible for converting Json to a Rezolver Configuration TypeReference"
  },
  "rezolver-api/Rezolver.Configuration.Json.TypeReferenceConverter.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.TypeReferenceConverter.html",
    "title": "Class TypeReferenceConverter",
    "keywords": "Improve this Doc Class TypeReferenceConverter Responsible for converting Json to a Rezolver Configuration TypeReference Inheritance System.Object TypeReferenceConverter Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class TypeReferenceConverter : JsonConverter <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc CanWrite Declaration public override bool CanWrite { get; } Property Value Type Description System.Boolean <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CanConvert(Type) Declaration public override bool CanConvert(Type objectType) Parameters Name Type Description objectType System.Type Returns Type Description System.Boolean <!-- .classchild --> | Improve this Doc ReadJson(JsonReader, Type, Object, JsonSerializer) Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Name Type Description reader JsonReader objectType System.Type existingValue System.Object serializer JsonSerializer Returns Type Description System.Object <!-- .classchild --> | Improve this Doc WriteJson(JsonWriter, Object, JsonSerializer) Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Name Type Description writer JsonWriter value System.Object serializer JsonSerializer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.RezolveTargetMetadataWrapper.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.RezolveTargetMetadataWrapper.html",
    "title": "Class RezolveTargetMetadataWrapper",
    "keywords": "Improve this Doc Class RezolveTargetMetadataWrapper Metadata wrapper to accommodate the nature of how JSON configuration is deserialized. Of little practical use outside of the Json configuration library, unless you are creating your own metadata types which need the Unwrap semantics Inheritance System.Object RezolveTargetMetadataBase RezolveTargetMetadataWrapper Inherited Members Type CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Bind(ITypeReference[]) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax [Obsolete(\"no longer required\", true)] public class RezolveTargetMetadataWrapper : RezolveTargetMetadataBase, IRezolveTargetMetadataExtension, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc RezolveTargetMetadataWrapper(IRezolveTargetMetadata) Declaration public RezolveTargetMetadataWrapper(IRezolveTargetMetadata wrapped) Parameters Name Type Description wrapped IRezolveTargetMetadata <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Fields | Improve this Doc ExtensionTypeName Declaration public const string ExtensionTypeName = \"#JSONWRAPPER#\" Field Value Type Description System.String <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides DeclaredType Implements DeclaredType <!-- .classchild --> | Improve this Doc ExtensionType Declaration public string ExtensionType { get; } Property Value Type Description System.String Implements ExtensionType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides BindBase(ITypeReference[]) <!-- .classchild --> | Improve this Doc CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Implementation of CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) , except this implementation always throws a System.NotSupportedException , because it must be unwrapped (through a call to UnwrapMetadata(ITypeReference[]) ) before it can be used to create an ITarget . Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes System.Type [] context ConfigurationAdapterContext entry IConfigurationEntry Returns Type Description ITarget Overrides CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild --> | Improve this Doc UnwrapConstructorMetadata(IRezolveTargetMetadata, ITypeReference[]) Unwraps an IConstructorTargetMetadata object by binding it to the forTargetTypes . Declaration protected virtual IRezolveTargetMetadata UnwrapConstructorMetadata(IRezolveTargetMetadata meta, ITypeReference[] forTargetTypes) Parameters Name Type Description meta IRezolveTargetMetadata forTargetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata <!-- .classchild --> | Improve this Doc UnwrapExtensionMetadata(IRezolveTargetMetadata, ITypeReference[]) Special case version of UnwrapMetadata(ITypeReference[]) for metadata with the type Extension . The base implementation supports instances of the RezolveTargetMetadataWrapper type only - and simply chain the call through to its UnwrapMetadata method. Declaration protected virtual IRezolveTargetMetadata UnwrapExtensionMetadata(IRezolveTargetMetadata meta, ITypeReference[] forTargetTypes) Parameters Name Type Description meta IRezolveTargetMetadata forTargetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata <!-- .classchild --> | Improve this Doc UnwrapListMetadata(IRezolveTargetMetadata, ITypeReference[]) Unwraps a list metadata (and any inner target metadata) for the target types. Declaration protected virtual IRezolveTargetMetadata UnwrapListMetadata(IRezolveTargetMetadata meta, ITypeReference[] forTargetTypes) Parameters Name Type Description meta IRezolveTargetMetadata forTargetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata <!-- .classchild --> | Improve this Doc UnwrapMetadata(ITypeReference[]) Unwraps the metadata contained within this wrapper for the passed target types in readiness to be pushed into an IConfigurationEntry. Note - if the metadata can't be unwrapped, then the method will simply return this instance. Declaration public virtual IRezolveTargetMetadata UnwrapMetadata(ITypeReference[] forTargetTypes) Parameters Name Type Description forTargetTypes ITypeReference [] Type references that the unwrapped metadata should support. Returns Type Description IRezolveTargetMetadata Remarks Unwrapping is the process whereby a type declared for registration is back-referenced using the '$auto' unbound type name in configuration for, say a constructor target or similar. <!-- .classchild --> | Improve this Doc UnwrapMetadataList(IRezolveTargetMetadata, ITypeReference[]) Unwraps a series of metadata objects stored in the list (passed in the meta parameter) for the target types, returning another metadata list containing the unwrapped metadata objects. Declaration protected IRezolveTargetMetadataList UnwrapMetadataList(IRezolveTargetMetadata meta, ITypeReference[] forTargetTypes) Parameters Name Type Description meta IRezolveTargetMetadata forTargetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadataList <!-- .classchild --> | Improve this Doc UnwrapMetadataList(IRezolveTargetMetadataList, ITypeReference[]) Strongly-typed virtual method for unwrapping metadata lists (invoked by UnwrapMetadataList(IRezolveTargetMetadata, ITypeReference[]) after confirming that the metadata passed to it is of the correct type. Declaration protected virtual IRezolveTargetMetadataList UnwrapMetadataList(IRezolveTargetMetadataList listMeta, ITypeReference[] forTargetTypes) Parameters Name Type Description listMeta IRezolveTargetMetadataList forTargetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadataList <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.RezolveTargetMetadataConverter.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.RezolveTargetMetadataConverter.html",
    "title": "Class RezolveTargetMetadataConverter",
    "keywords": "Improve this Doc Class RezolveTargetMetadataConverter This converter is registered against the type RezolveTargetMetadataWrapper Inheritance System.Object RezolveTargetMetadataConverter Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class RezolveTargetMetadataConverter : JsonConverter <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc CanWrite Declaration public override bool CanWrite { get; } Property Value Type Description System.Boolean <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CanConvert(Type) Declaration public override bool CanConvert(Type objectType) Parameters Name Type Description objectType System.Type Returns Type Description System.Boolean <!-- .classchild --> | Improve this Doc ReadJson(JsonReader, Type, Object, JsonSerializer) Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Name Type Description reader JsonReader objectType System.Type existingValue System.Object serializer JsonSerializer Returns Type Description System.Object <!-- .classchild --> | Improve this Doc WriteJson(JsonWriter, Object, JsonSerializer) Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Name Type Description writer JsonWriter value System.Object serializer JsonSerializer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.LazyJsonObjectTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.LazyJsonObjectTargetMetadata.html",
    "title": "Class LazyJsonObjectTargetMetadata",
    "keywords": "Improve this Doc Class LazyJsonObjectTargetMetadata Special version of IObjectTargetMetadata which creates an instance of the requested type from a JToken. Some more work might be required here to Inheritance System.Object RezolveTargetMetadataBase ObjectTargetMetadataBase LazyJsonObjectTargetMetadata Inherited Members CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Type CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Bind(ITypeReference[]) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class LazyJsonObjectTargetMetadata : ObjectTargetMetadataBase, IObjectTargetMetadata, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides DeclaredType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] Returns Type Description IRezolveTargetMetadata Overrides BindBase(ITypeReference[]) <!-- .classchild --> | Improve this Doc GetObject(Type) Declaration public override object GetObject(Type type) Parameters Name Type Description type System.Type Returns Type Description System.Object Overrides GetObject(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.JsonConfigurationParser.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.JsonConfigurationParser.html",
    "title": "Class JsonConfigurationParser",
    "keywords": "Improve this Doc Class JsonConfigurationParser Inheritance System.Object JsonConfigurationParser Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class JsonConfigurationParser <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateJsonSerializerSettings() Declaration public virtual JsonSerializerSettings CreateJsonSerializerSettings() Returns Type Description JsonSerializerSettings <!-- .classchild --> | Improve this Doc CreateSerializer(JsonSerializerSettings) Declaration public virtual JsonSerializer CreateSerializer(JsonSerializerSettings settings) Parameters Name Type Description settings JsonSerializerSettings Returns Type Description JsonSerializer <!-- .classchild --> | Improve this Doc Parse(String) Declaration public IConfiguration Parse(string json) Parameters Name Type Description json System.String Returns Type Description IConfiguration <!-- .classchild --> | Improve this Doc Parse(String, JsonSerializer) Declaration public virtual IConfiguration Parse(string json, JsonSerializer jsonSerializer) Parameters Name Type Description json System.String jsonSerializer JsonSerializer Returns Type Description IConfiguration <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.Json.JsonConfigurationException.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.JsonConfigurationException.html",
    "title": "Class JsonConfigurationException",
    "keywords": "Improve this Doc Class JsonConfigurationException Thrown when a Json container configuration file is invalid. Inheritance System.Object System.Exception JsonConfigurationException Inherited Members System.Exception.GetBaseException() System.Exception.ToString() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.Data System.Exception.InnerException System.Exception.TargetSite System.Exception.StackTrace System.Exception.HelpLink System.Exception.Source System.Exception.HResult System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class JsonConfigurationException : Exception, ISerializable, _Exception <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc JsonConfigurationException(JsonToken, JsonReader) Constructs a new instance of the JsonConfigurationException class which reports that the token at the current location of the file was not expected. Declaration public JsonConfigurationException(JsonToken expectedTokenType, JsonReader reader) Parameters Name Type Description expectedTokenType JsonToken reader JsonReader <!-- .classchild --> | Improve this Doc JsonConfigurationException(String, JsonReader) Constructs a new instance of the JsonConfigurationException class. Note, if you supply a JsonReader, then the current line and column will be reported automatically at the end of the exception message. Declaration public JsonConfigurationException(string message, JsonReader reader) Parameters Name Type Description message System.String reader JsonReader <!-- .classchild --> | Improve this Doc JsonConfigurationException(String, JToken) Constructs a new instance of the JsonConfigurationException class. Note, if you supply a JObject, then the starting line and column of that object from the original source text will be reported automatically at the end of the exception message. Declaration public JsonConfigurationException(string message, JToken jToken) Parameters Name Type Description message System.String jToken JToken <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Message Declaration public override string Message { get; } Property Value Type Description System.String Overrides System.Exception.Message <!-- .classchild --> | Improve this Doc Reader If not null, then this is a reader whose position should be at the place where the error occurs. Declaration public JsonReader Reader { get; } Property Value Type Description JsonReader <!-- .classchild -->"
  },
  "rezolver-api/System.html": {
    "href": "rezolver-api/System.html",
    "title": "Namespace System",
    "keywords": "Improve this Doc Namespace System Classes DelegateExtensions"
  },
  "rezolver-api/Rezolver.Configuration.Json.AdvancedConfigurationAdapterContextFactory.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.AdvancedConfigurationAdapterContextFactory.html",
    "title": "Class AdvancedConfigurationAdapterContextFactory",
    "keywords": "Improve this Doc Class AdvancedConfigurationAdapterContextFactory An advanced factory which automatically loads and references all assemblies that are deployed in the application's base directory and any subfolders determined by the System.AppDomain 's SetupInformation's PrivateBinBath. This is a singleton - accessed through the Instance property. Inheritance System.Object ConfigurationAdapterContextFactory AdvancedConfigurationAdapterContextFactory Inherited Members CreateContext(ConfigurationAdapter, IConfiguration) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class AdvancedConfigurationAdapterContextFactory : ConfigurationAdapterContextFactory, IConfigurationAdapterContextFactory Remarks The ConfigurationAdapterContextFactory has a very limited set of default assembly references, because it's a portable class, the AppDomain introspection APIs are not available. As a result, to simplify type references in a configuration file loaded in a portable environment, you need to add assembly references manually. This class, on the other hand, is targeted at environments where these APIs are available, and should effectively remove the need to add any references at all, meaning a configuration file can use shorter type names. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc AdvancedConfigurationAdapterContextFactory() Initializes a new instance of the AdvancedConfigurationAdapterContextFactory class. Class is creatable only through inheritance. Declaration protected AdvancedConfigurationAdapterContextFactory() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Instance Gets the one and only instance of the AdvancedConfigurationAdapterContextFactory . Declaration public static IConfigurationAdapterContextFactory Instance { get; } Property Value Type Description IConfigurationAdapterContextFactory The instance. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc GetDefaultAssemblyReferences() Gets the assemblies that are to be used for new contexts as the default set of references. This override gets all the assemblies that are deployed with the application. Note that this has the effect of pre-loading all those assemblies. Declaration protected override IEnumerable<Assembly> GetDefaultAssemblyReferences() Returns Type Description System.Collections.Generic.IEnumerable < System.Reflection.Assembly > IEnumerable . Overrides GetDefaultAssemblyReferences() <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ITypeRegistrationEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.ITypeRegistrationEntry.html",
    "title": "Interface ITypeRegistrationEntry",
    "keywords": "Improve this Doc Interface ITypeRegistrationEntry Represents an instruction to register one or more targets in an ITargetContainer against one or more types. Think of it as wrapping a single call to one of the builder's Register methods. Inherited Members Type StartLineNo StartLinePos EndLineNo EndLinePos Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface ITypeRegistrationEntry : IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc IsMultipleRegistration Gets a value indicating whether this instance represents a multiple registration - i.e. that when one of the Types are resolved, it's expected that an enumerable of that type will be requested, returning one or more items rather than just one. Maps to the method call. Declaration bool IsMultipleRegistration { get; } Property Value Type Description System.Boolean true if this instance is multiple registration; otherwise, false . <!-- .classchild --> | Improve this Doc TargetMetadata Metadata for the target(s) that is/are to be registered. Declaration IRezolveTargetMetadata TargetMetadata { get; } Property Value Type Description IRezolveTargetMetadata <!-- .classchild --> | Improve this Doc Types The types for which the registration is to be made in the ITargetContainer that the entry is applied to. Declaration ITypeReference[] Types { get; } Property Value Type Description ITypeReference [] <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ITypeReference.html": {
    "href": "rezolver-api/Rezolver.Configuration.ITypeReference.html",
    "title": "Interface ITypeReference",
    "keywords": "Improve this Doc Interface ITypeReference Captures a reference to a type made in a configuration file. It does not guarantee that the type can be located, it simply provides a common interface for storing the type information written in a configuration file. An IConfigurationAdapter instance will need to resolve the actual runtime type from this when registering targets from a configuration file. Inherited Members StartLineNo StartLinePos EndLineNo EndLinePos Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface ITypeReference : IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc GenericArguments Any explicitly provided generic arguments are stored here. Note that it might turn out that the TypeName refers to a whole closed generic type, in which case the referenced type could still be generic even if this array is empty. It's also the case that arguments could be passed here when the root type name resolves to a non-generic type definition, in which case type resolution will likely fail. Declaration ITypeReference[] GenericArguments { get; } Property Value Type Description ITypeReference [] <!-- .classchild --> | Improve this Doc IsArray Gets a value indicating whether the type ultimately represented by this instance is an array of the type described by the rest of this instance's properties. Declaration bool IsArray { get; } Property Value Type Description System.Boolean true if this instance represents an array type; otherwise, false . <!-- .classchild --> | Improve this Doc IsOpenGenericTypeArgument True if this type represents an open generic argument - this is how to explicitly reference an open generic type in a type reference: you specify a base type, then have one or more open generic arguments specified in the GenericArguments array. If all are open generic arguments, then you have created a reference to the fully open generic type. You only need to provide all-open arguments if the base TypeName could be ambiguous between a non generic and generic type, or there are multiple generic types with the same base name. Equally, you can do this to create references to partially open generics, which may or may not be supported by the adapter or the target that is built. Declaration bool IsOpenGenericTypeArgument { get; } Property Value Type Description System.Boolean <!-- .classchild --> | Improve this Doc IsUnbound Gets a value indicating whether this instance represents a type that is to be late-bound for a specific target type. Declaration bool IsUnbound { get; } Property Value Type Description System.Boolean true if this instance is unbound; otherwise, false . <!-- .classchild --> | Improve this Doc TypeName The root type name. Declaration string TypeName { get; } Property Value Type Description System.String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.ISingletonTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.ISingletonTargetMetadata.html",
    "title": "Interface ISingletonTargetMetadata",
    "keywords": "Improve this Doc Interface ISingletonTargetMetadata Interface for Singleton metadata. Inherited Members Type DeclaredType Bind(ITypeReference[]) CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface ISingletonTargetMetadata : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Inner Metadata representing the inner target for the singleton Declaration IRezolveTargetMetadata Inner { get; } Property Value Type Description IRezolveTargetMetadata <!-- .classchild --> | Improve this Doc Scoped If true, then the created singleton target should be a scoped singleton; i.e. with a lifetime tied to the lifetime of a parent ILifetimeScopeRezolver, not the whole application. Declaration bool Scoped { get; } Property Value Type Description System.Boolean <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadataList.html": {
    "href": "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadataList.html",
    "title": "Interface IRezolveTargetMetadataList",
    "keywords": "Improve this Doc Interface IRezolveTargetMetadataList Represents a list of IRezolveTargetMetadata instances - for when you want to register multiple targets against a single type. Note - although the interface IRezolveTargetMetadata is included by this interface, instances are not expected to be able to create a single target through the CreateRezolveTarget method - because by definition, multiple targets are produced by this. Use the CreateRezolveTargets method instead. The Bind method, however, will be expected to produce a new instance of the implementing type if any underlying targets are not bound to a specific type. Inherited Members Type DeclaredType Bind(ITypeReference[]) CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IRezolveTargetMetadataList : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Targets Gets the list of targets that will be used to construct the array. Note - a list is used to allow for modification of the targets after initial creation. Declaration IList<IRezolveTargetMetadata> Targets { get; } Property Value Type Description System.Collections.Generic.IList < IRezolveTargetMetadata > The targets. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateRezolveTargets(Type[], ConfigurationAdapterContext, IConfigurationEntry) Replacement for IRezolveTargetMetadata for this interface. Creates the rezolve target, potentially customised for the given target type(s), based on the given context. If the entry is passed, then it indicates the configuration entry for which the targets are being built. Declaration IEnumerable<ITarget> CreateRezolveTargets(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes System.Type [] The target types for each of the returned target, generally, this will be the ultimate target types for the configuration entry that is passed in entry . An implementation is not bound to use these types at all, but it helps provide additional context that might be of use when generating the rezolve target. context ConfigurationAdapterContext The context. entry IConfigurationEntry If provided, this is a reference to the configuration entry for which this target is being built. Returns Type Description System.Collections.Generic.IEnumerable < ITarget > <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadataExtension.html": {
    "href": "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadataExtension.html",
    "title": "Interface IRezolveTargetMetadataExtension",
    "keywords": "Improve this Doc Interface IRezolveTargetMetadataExtension Inherited Members Type DeclaredType Bind(ITypeReference[]) CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IRezolveTargetMetadataExtension : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc ExtensionType Declaration string ExtensionType { get; } Property Value Type Description System.String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadata.html",
    "title": "Interface IRezolveTargetMetadata",
    "keywords": "Improve this Doc Interface IRezolveTargetMetadata Represents an instruction to create an IRezolveTarget from parsed configuration. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Gets the declared type of the object that will be created by an IRezolveTarget created by this metadata. Note - this isn't always known, or always fixed, since configuration systems will allow developers to avoid being specific about the types that are to be built. Declaration ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference The type of the declared. <!-- .classchild --> | Improve this Doc Type The type of rezolve target that is expected to be produced from this metadata Declaration RezolveTargetMetadataType Type { get; } Property Value Type Description RezolveTargetMetadataType <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Bind(ITypeReference[]) Creates a new instance of this metadata (i.e. a clone) that is bound to the specified target types. This is invoked if DeclaredType represents the Unbound type reference. Declaration IRezolveTargetMetadata Bind(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] The target types. Ideally there'd only be one of these, but since type registrations can target multiple types - we need to be able to pass all of them. An implementation should seek the best possible type from the array, although in practise - given that there's no ConfigurationAdapterContext to aid in the parsing of the type names, the first type in the array is typically fine to use. Returns Type Description IRezolveTargetMetadata IRezolveTargetMetadata. <!-- .classchild --> | Improve this Doc CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Creates the rezolve target, optionally customised for the given target type(s), based on the given context. If the entry is passed, then it indicates the configuration entry for which the targets are being built. Declaration ITarget CreateRezolveTarget(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry = null) Parameters Name Type Description targetTypes System.Type [] Required. One or more target types that the returned target is expected to be compatible with (i.e. able to build an instance of). Generally, this will be the target types for the configuration entry that is passed in entry . context ConfigurationAdapterContext The current context - provides access to the builder currently being constructed, as well as methods for resolving type names from ITypeReference instances or strings (and more). entry IConfigurationEntry If provided, this is a reference to the configuration entry (typically an ITypeRegistrationEntry ) against which this target will be registered. Please note - this doesn't mean that the target that is returned will become the target of the registration. It might be that the target is one that is used by a parent target that will become the target of the registration. Returns Type Description ITarget <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IObjectTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.IObjectTargetMetadata.html",
    "title": "Interface IObjectTargetMetadata",
    "keywords": "Improve this Doc Interface IObjectTargetMetadata Interface for metadata for constructing an ObjectTarget IRezolveTarget. Inherited Members Type DeclaredType Bind(ITypeReference[]) CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IObjectTargetMetadata : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc GetObject(Type) Called to get the object that will be registered in the IRezolveTargetContainer to be returned when a caller requests one of its registered types. The method can construct an object anew everytime it is called, or it can always return the same instance; this behaviour is implementation-dependant. Declaration object GetObject(Type type) Parameters Name Type Description type System.Type The type of object that is desired. The implementation determines whether this parameter is required. If it is, and you pass null, then an ArgumentNullException will be thrown. If you pass an argument, the implementation is not bound to check or honour the type. Its purpose is to provide a hint only, not a guarantee that the object returned is compatible with the type. Returns Type Description System.Object An object. Note - if the operation returns null this is not an error. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IListTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.IListTargetMetadata.html",
    "title": "Interface IListTargetMetadata",
    "keywords": "Improve this Doc Interface IListTargetMetadata Configuration metadata for building a ListTarget in a RezolverBuilder. Inherited Members Type DeclaredType Bind(ITypeReference[]) CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IListTargetMetadata : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc ElementType Gets the declared element type of the array or list that will be created from this metadata. Declaration ITypeReference ElementType { get; } Property Value Type Description ITypeReference The type of the element. <!-- .classchild --> | Improve this Doc IsArray Maps to the AsArray property. If true, then an array of ElementType will be created, otherwise a List< ElementType > will be created by the ListTarget created from this metadata. Declaration bool IsArray { get; } Property Value Type Description System.Boolean true if this instance represents a ListTarget that will create an array; otherwise, false . <!-- .classchild --> | Improve this Doc Items Gets the metadata for the targets that will be used for the items that'll be returned in the Array or List that will be created by the ListTarget created from this metadata. Declaration IRezolveTargetMetadataList Items { get; } Property Value Type Description IRezolveTargetMetadataList The elements. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConstructorTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConstructorTargetMetadata.html",
    "title": "Interface IConstructorTargetMetadata",
    "keywords": "Improve this Doc Interface IConstructorTargetMetadata Inherited Members Type DeclaredType Bind(ITypeReference[]) CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConstructorTargetMetadata : IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Arguments Gets a dictionary of arguments that are to be supplied to the object's constructor Declaration IDictionary<string, IRezolveTargetMetadata> Arguments { get; } Property Value Type Description System.Collections.Generic.IDictionary < System.String , IRezolveTargetMetadata > The arguments. <!-- .classchild --> | Improve this Doc SignatureTypes Gets the types of the parameters for the specific constructor that is to be bound. Not required, and is mostly used when a suitable constructor cannot be found purely by matching parameter names and types to the Arguments . A common issue here being that some metadata types can build any type, therefore two constructors with identically named parameters that have different types could be matched by the same target metadata. If null, then no signature is specified. Declaration ITypeReference[] SignatureTypes { get; } Property Value Type Description ITypeReference [] The signature types. <!-- .classchild --> | Improve this Doc TypesToBuild One of these types will be selected to have its constructor bound. The rule is that multiple types passed here must represent types that all appear in an inheritance chain or interface list, and there must be one unambiguous most-derived type which will be the one whose constructor will be executed when an object is later dished out from the IRezolveTarget instance that is built from this metadata. Declaration ITypeReference[] TypesToBuild { get; } Property Value Type Description ITypeReference [] <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationLineInfo.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationLineInfo.html",
    "title": "Interface IConfigurationLineInfo",
    "keywords": "Improve this Doc Interface IConfigurationLineInfo Encapsulates information about where a particular object, parsed from a configuration file, can be found. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc EndLineNo Gets the line number within the configuration source that sees the end of the text from which this object was parsed. Used in conjunction with EndLinePos , it allows you to zero-in on the exact ending of this parsed object. Declaration int ? EndLineNo { get; } Property Value Type Description System.Nullable < System.Int32 > The end line number. <!-- .classchild --> | Improve this Doc EndLinePos Gets the position from the start of the line, indicated by EndLineNo , where the configuration text ends for this parsed object. Declaration int ? EndLinePos { get; } Property Value Type Description System.Nullable < System.Int32 > <!-- .classchild --> | Improve this Doc StartLineNo Gets the line number within the configuration source that contains the start of the text from which this object was parsed. Used in conjunction with StartLinePos , it allows you to zero-in on the exact starting point of this parsed object. Declaration int ? StartLineNo { get; } Property Value Type Description System.Nullable < System.Int32 > The start line number. <!-- .classchild --> | Improve this Doc StartLinePos Gets the position from the start of the line, indicated by StartLineNo , where the configuration text begins for this parsed object. Declaration int ? StartLinePos { get; } Property Value Type Description System.Nullable < System.Int32 > The start line position. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationExtensionEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationExtensionEntry.html",
    "title": "Interface IConfigurationExtensionEntry",
    "keywords": "Improve this Doc Interface IConfigurationExtensionEntry Inherited Members Type StartLineNo StartLinePos EndLineNo EndLinePos Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationExtensionEntry : IConfigurationEntry, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc ExtensionType Declaration string ExtensionType { get; } Property Value Type Description System.String <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationError.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationError.html",
    "title": "Interface IConfigurationError",
    "keywords": "Improve this Doc Interface IConfigurationError Interface for an error that originates from a configuration file. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationError <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc ErrorMessage The message Declaration string ErrorMessage { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc ErrorMessageWithLineInfo The message formatted with the start/end line and position for more accurate error reporting. Declaration string ErrorMessageWithLineInfo { get; } Property Value Type Description System.String <!-- .classchild --> | Improve this Doc LineInfo Start and (potentially) end position within the configuration file where this error originates. Declaration IConfigurationLineInfo LineInfo { get; } Property Value Type Description IConfigurationLineInfo <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationEntry.html",
    "title": "Interface IConfigurationEntry",
    "keywords": "Improve this Doc Interface IConfigurationEntry Inherited Members StartLineNo StartLinePos EndLineNo EndLinePos Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationEntry : IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Type Declaration ConfigurationEntryType Type { get; } Property Value Type Description ConfigurationEntryType <!-- .classchild -->"
  },
  "rezolver-api/System.Collections.Generic.html": {
    "href": "rezolver-api/System.Collections.Generic.html",
    "title": "Namespace System.Collections.Generic",
    "keywords": "Improve this Doc Namespace System.Collections.Generic Classes ReadOnlyEnumerableExtensions"
  },
  "rezolver-api/System.Collections.Generic.ReadOnlyEnumerableExtensions.html": {
    "href": "rezolver-api/System.Collections.Generic.ReadOnlyEnumerableExtensions.html",
    "title": "Class ReadOnlyEnumerableExtensions",
    "keywords": "Improve this Doc Class ReadOnlyEnumerableExtensions Inheritance System.Object ReadOnlyEnumerableExtensions Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :System.Collections.Generic Assembly :cs.temp.dll.dll Syntax public class ReadOnlyEnumerableExtensions <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc AsReadOnly<T>(IEnumerable<T>) Declaration public static IList<T> AsReadOnly<T>(this IEnumerable<T> range) Parameters Name Type Description range System.Collections.Generic.IEnumerable <T> Returns Type Description System.Collections.Generic.IList <T> Type Parameters Name Description T <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.html": {
    "href": "rezolver-api/Rezolver.html",
    "title": "Namespace Rezolver",
    "keywords": "Improve this Doc Namespace Rezolver Classes CachingContainerBase Builds on the ContainerBase base class to introduce thread-safe caching of compiled targets so they are only compiled once per requested type. Only creatable through inheritance. ChangeTypeTarget This target is specifically used for explicitly typing another target. It's effectively the same as inserting a ConvertExpression around another Expression tree Its use is rare. ChildTargetContainer A version of TargetContainer which overrides the registrations of another (the Parent ). CompileContext Provides support and compile-time state for the compilation of an ITarget by an ITargetCompiler . THIS CLASS IS NOT THREAD-SAFE CompileContext.SharedExpressionKey Key for a shared expression used during expression tree generation CompiledTargetBase Standard starting point for an implementation of ICompiledTarget where the target is built directly from an ITarget . ConditionalRewriter Reorders an expression tree where duplicate conditional expressions are found in multiple places throughout that expression tree. Those duplicated conditionals are moved further up the expression tree into one conditional. ConstructorTarget The most common target used for building new objects. Represents binding to a type's constructor with zero or more arguments supplied by other ITarget s. In addition to using the Rezolver.ConstructorTarget. constructor you can also use the factory methods - such as Auto (IPropertyBindingBehaviour) . Container ContainerBase Starting point for implementations of IContainer - only creatable through inheritance. ContainerBase.MissingCompiledTarget DecoratorTarget Implements service decoration in an ITargetContainer . The best way to add a decorator to your target container is to use the extension method RegisterDecorator (ITargetContainerOwner) or its non-generic equivalent. DefaultPropertyBindingBehaviour DefaultTarget A target that simply creates a default instance of a given type. I.e. the same as doing default(type) in C#. DelegateTarget <T> Implements IRezolveTarget using factory function delegates. DelegateTargetExtensions EnumerableTargetBuilderExtensions ExceptionResources A strongly-typed resource class, for looking up localized strings, etc. ExpressionHelper This static class contains methods and properties to aid in building expressions in the CreateExpression(CompileContext) method. ExpressionTarget A generic target for all expressions not explicitly supported by a particular target. GenericConstructorTarget GenericTargetContainer IContainerRezolveExtensions IRezolveTargetScopingExtensions Extension method(s) to convert targets into scoped targets. IRezolveTargetSingletonExtensions Extension method(s) to convert targets into singleton targets. ITargetContainerExtensions Extension methods for implementations of ITargetContainer . LifetimeScopeRezolverExtensions ListTarget This exists primarily for the configuration system. This target produces arrays or lists whose individual items are built by IRezolveTarget instances. If you are setting up your container environment from code - e.g. using expressions, then you shouldn't need to use this unless you have some pretty extreme requirements for the different targets that will contribute each element of your list/array. MethodCallExtractor ObjectTarget Implements IRezolveTarget by wrapping a single instance that's already been constructed. By default, scope tracking is disabled (since the caller owns the object, not the Rezolver framework)). If it's enabled, then scope tracking behaves exactly the same as SingletonTarget . ObjectTargetExtensions Extension method(s) OptionalParameterTarget Used specifically when binding arguments to method parameters when a parameter is optional and its default value is to be used when binding to it. OverridingContainer An IContainer which can override the resolve operations of another. This is useful when you have a core application-wide container, with some objects being customised based on some ambient information, e.g. configuration, MVC Area/Controller, Brand (in a multi-tenant application for example) or more. The scoping version of this is called OverridingScopedContainer . OverridingScopedContainer ParameterBinding PropertyOrFieldBinding RezolveContext Context of a call to an IRezolver's Resolve method. The container is included in the context to allow code generated from CreateExpression(CompileContext) to refer back to the container. This also allows us to retarget compiled targets at other containers (e.g. OverridingContainer s that override existing registrations or define new ones). RezolveContextExpressionHelper Wraps a rezolve context for expression building - used principally in the ConstruuctorTarget class, but others are free to use it also. RezolveContextPlaceholderExpression wraps an expression that represents reading or otherwise manipulating the RezolveContext that's passed into a Resolve call. RezolvedTarget Represents a target that is rezolved statically at compile time via the CompileContext , or dynamically (at 'resolve time') from the IContainer that is attached to the current RezolveContext when Resolve(RezolveContext) is called. This is the most common way that we bind constructor parameters, for example - i.e. 'I want an IService instance - go get it'. RezolveTargetAdapterExtensions RezolveTargetExpression Makes it possible to mix expressions and targets. ScopedContainer Extends the Container to implement lifetime scoping. If you want your root container to act as a lifetime scope, then you should use this class instead of using Container ScopedTarget A target that produces a single instance of an object within a lifetime scope. SingletonTarget Decorates any IRezolveTarget instance inside a lazily-initialised instance which will only ever create the target object once. TargetAdapter Default implementation of the ITargetAdapter interface. Also an ExpressionVisitor. Also, its Default property serves as the reference to the default adapter used by the system to convert expressions into IRezolveTarget instances. This class cannot be created directly - it is a singleton accessed through the Instance property. You can inherit from this class, however, to serve as the basis for your own implementation of ITargetAdapter . TargetAssemblyCompiler Implementation of the ITargetCompiler which compiles dynamic code to an assembly (which can, potentially, be saved to disk). Suitable for environments that support the full .Net profile. Generally, the performance of a container built using this compiler will be better than one that uses the TargetDelegateCompiler . TargetBase Abstract base class, suggested as a starting point for implementations of ITarget . TargetCompiler Holds a reference to the default compiler for this application. By default this is set to the TargetDelegateCompiler - which is a general purpose compiler that should work on any platform which supports linq expression trees. TargetCompilerBase TargetCompilerHelper TargetCompilerHelper.RedundantConvertRemover TargetContainer Root container for ITarget s that can be used as the backing for the standard IContainer classes - Container , ScopedContainer , and the Stores and retrieves registrations of ITarget s, is also Generic type aware, unlike its base class - TargetDictionaryContainer . Should be used as the root target container for implementations of IContainer . TargetDelegateCompiler The default compiler for ITarget instances - takes the expression tree(s) produced by an ITarget and simply compiles it to an anonymous delegate. TargetDelegateCompiler.DelegatingCompiledRezolveTarget TargetDictionaryContainer An ITargetContainerOwner implementation that stores and retrieves ITarget and ITargetContainer by type. TargetListContainer An ITargetContainer that stores multiple targets in a list. This is not a type that you would typically use directly in your code, unless you are writing custom logic/behaviour for ITarget registration. Interfaces IChildTargetContainer An IRezolveTargetContainer that is a logical child of another. A child container, if it cannot resolve a particular type, will defer to its parent for fallback. ICompiledTarget Provides an abstraction for creating objects based on a given RezolveContext . As the name suggests, it typically represents a compiled ITarget , which, in the standard IContainer implementation ( Container ) is the final stage before its ready to be used to start producing objects. An ITargetCompiler is responsible for creating these from one or more ITarget s. IContainer Represents the primary IOC container in the Rezolver framework. IPropertyBindingBehaviour Describes a type which discovers property/field bindings IScopedContainer A container that's also a lifetime scope - that is, it's disposable, and will dispose of any disposable instances that it creates when it's disposed. Also, any subsequent lifetime scopes that it, or any child, creates will be disposed of when this scope is disposed. Note that while a lifetime scope can track objects of any types, it only automatically tracks disposable objects. To force a scope to track an instance, regardless of whether it's dispoable or not, you can call AddToScope(Object, RezolveContext) . This is how the default ScopedSingletonTarget works - if an object with this lifetime isn't a disposable, it is explicitly added to the scope passed to it at runtime, and then when an instance is subsequently requested, the code compiled by the scoped singleton will search the current scope, for an existing instance, before creating one. ITarget As the name suggests, the underlying target of a Rezolver call. The output of a target is an expression. This allows a target that depends on another target to chain expressions together, creating specialised expression trees (and therefore specialised delegates). The expression produced from this interface is later compiled, by an IRezolveTargetCompiler, into an ICompiledRezolveTarget - whose job it is specifically to produce object instances. ITargetAdapter Interface for an object that is responsible for converting Expressions into ITarget s. ITargetCompiler An object that produces ICompiledTarget s from ITarget s given a particular CompileContext . ITargetContainer Stores and retrieves ITarget instances, keyed by the type of service that the targets are registered against. ITargetContainerOwner Interface for an ITargetContainer which also contains other target containers."
  },
  "rezolver-api/Rezolver.TargetListContainer.html": {
    "href": "rezolver-api/Rezolver.TargetListContainer.html",
    "title": "Class TargetListContainer",
    "keywords": "Improve this Doc Class TargetListContainer An ITargetContainer that stores multiple targets in a list. This is not a type that you would typically use directly in your code, unless you are writing custom logic/behaviour for ITarget registration. Inheritance System.Object TargetListContainer Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetListContainer : ITargetContainer Remarks This type is not thread-safe, nor does it perform any type checking on the targets that are added to it. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc TargetListContainer(Type, ITarget[]) Declaration public TargetListContainer(Type registeredType, params ITarget[] targets) Parameters Name Type Description registeredType System.Type targets ITarget [] <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Count Declaration public int Count { get; } Property Value Type Description System.Int32 <!-- .classchild --> | Improve this Doc DefaultTarget Declaration public ITarget DefaultTarget { get; } Property Value Type Description ITarget <!-- .classchild --> | Improve this Doc Item[Int32] Declaration public ITarget this[int index] { get; } Parameters Name Type Description index System.Int32 Property Value Type Description ITarget <!-- .classchild --> | Improve this Doc RegisteredType Declaration public Type RegisteredType { get; } Property Value Type Description System.Type <!-- .classchild --> | Improve this Doc Targets Declaration public IEnumerable<ITarget> Targets { get; } Property Value Type Description System.Collections.Generic.IEnumerable < ITarget > <!-- .classchild --> | Improve this Doc TargetsList Provides deriving classes a means to manipulate the underlying list. Declaration protected List<ITarget> TargetsList { get; } Property Value Type Description System.Collections.Generic.List < ITarget > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CombineWith(ITargetContainer, Type) Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer type System.Type Returns Type Description ITargetContainer Implements CombineWith(ITargetContainer, Type) <!-- .classchild --> | Improve this Doc Fetch(Type) Declaration public virtual ITarget Fetch(Type type) Parameters Name Type Description type System.Type Returns Type Description ITarget Implements Fetch(Type) <!-- .classchild --> | Improve this Doc FetchAll(Type) Declaration public virtual IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type System.Type Returns Type Description System.Collections.Generic.IEnumerable < ITarget > Implements FetchAll(Type) <!-- .classchild --> | Improve this Doc Register(ITarget, Type) Declaration public virtual void Register(ITarget target, Type registeredType = null) Parameters Name Type Description target ITarget registeredType System.Type Implements Register(ITarget, Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetDictionaryContainer.html": {
    "href": "rezolver-api/Rezolver.TargetDictionaryContainer.html",
    "title": "Class TargetDictionaryContainer",
    "keywords": "Improve this Doc Class TargetDictionaryContainer An ITargetContainerOwner implementation that stores and retrieves ITarget and ITargetContainer by type. Inheritance System.Object TargetDictionaryContainer Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetDictionaryContainer : ITargetContainerOwner, ITargetContainer Remarks This type is not thread-safe Note that for generic type, a special container is registered first against the open generic version of the type, with concrete (closed) generics being registered within that. <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CombineWith(ITargetContainer, Type) Always adds this container into the existing container as a child. Declaration public virtual ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Name Type Description existing ITargetContainer type System.Type Returns Type Description ITargetContainer Implements CombineWith(ITargetContainer, Type) <!-- .classchild --> | Improve this Doc CreateContainer(Type, ITarget) Called by Register(ITarget, Type) to create and register the container instance most suited for the passed target. The base implementation always creates a TargetListContainer , capable of storing multiple targets against a single type. Declaration protected virtual ITargetContainer CreateContainer(Type serviceType, ITarget target) Parameters Name Type Description serviceType System.Type target ITarget The initial target for which the container is being created. Can be null. Note - the function is not expected to add this target to the new container. Returns Type Description ITargetContainer <!-- .classchild --> | Improve this Doc Fetch(Type) Implementation of Fetch(Type) . Declaration public virtual ITarget Fetch(Type type) Parameters Name Type Description type System.Type The type whose default target is to be retrieved. Returns Type Description ITarget A single target representing the last target registered against the type , or, null if no target is found. Implements Fetch(Type) Remarks Note - in scenarios where you are chaining multiple containers, then you should consult the return value's UseFallback property if the method returns non-null because, if true, then it's an instruction to use a parent container's result for the same type. <!-- .classchild --> | Improve this Doc FetchAll(Type) Implementation of FetchAll(Type) Declaration public virtual IEnumerable<ITarget> FetchAll(Type type) Parameters Name Type Description type System.Type The type whose targets are to be retrieved. Returns Type Description System.Collections.Generic.IEnumerable < ITarget > A non-null enumerable containing the targets that match the type, or an empty enumerable if the type is not registered. Implements FetchAll(Type) <!-- .classchild --> | Improve this Doc FetchContainer(Type) Obtains a child container that was previously registered by the passed type . Returns null if no entry is found. Declaration public virtual ITargetContainer FetchContainer(Type type) Parameters Name Type Description type System.Type Returns Type Description ITargetContainer Implements FetchContainer(Type) <!-- .classchild --> | Improve this Doc Register(ITarget, Type) Implementation of Register(ITarget, Type) . Declaration public virtual void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget The target to be registered serviceType System.Type Implements Register(ITarget, Type) Remarks This implementation creates an ITargetContainer for the serviceType with a call to the protected method CreateContainer(Type, ITarget) if one doesn't exist (it calls FetchContainer(Type) to check for existence), and then chains to its Register(ITarget, Type) method. <!-- .classchild --> | Improve this Doc RegisterContainer(Type, ITargetContainer) Implementation of RegisterContainer(Type, ITargetContainer) Declaration public virtual void RegisterContainer(Type type, ITargetContainer container) Parameters Name Type Description type System.Type container ITargetContainer Implements RegisterContainer(Type, ITargetContainer) Remarks This container implementation actually stores containers against the types that targets are registered against, rather than simply storing a dictionary of targets. This method allows you to add your own containers against type (instead of the default, which is TargetListContainer ) so you can plug in some advanced behaviour into this container. For example, decorators are not actually ITarget implementations but specialised ITargetContainer instances into which the 'standard' targets are registered. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetDelegateCompiler.html": {
    "href": "rezolver-api/Rezolver.TargetDelegateCompiler.html",
    "title": "Class TargetDelegateCompiler",
    "keywords": "Improve this Doc Class TargetDelegateCompiler The default compiler for ITarget instances - takes the expression tree(s) produced by an ITarget and simply compiles it to an anonymous delegate. Inheritance System.Object TargetCompilerBase TargetDelegateCompiler Inherited Members CompileTarget(ITarget, CompileContext) GetLambdaBody(ITarget, CompileContext) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetDelegateCompiler : TargetCompilerBase, ITargetCompiler <!-- <hr class=\"typeSectionDivider\" /> --> Fields | Improve this Doc Default Declaration public static readonly ITargetCompiler Default Field Value Type Description ITargetCompiler <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CompileTargetBase(ITarget, Expression, CompileContext) Declaration protected override ICompiledTarget CompileTargetBase(ITarget target, Expression toCompile, CompileContext context) Parameters Name Type Description target ITarget toCompile Expression context CompileContext Returns Type Description ICompiledTarget Overrides CompileTargetBase(ITarget, Expression, CompileContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetDelegateCompiler.DelegatingCompiledRezolveTarget.html": {
    "href": "rezolver-api/Rezolver.TargetDelegateCompiler.DelegatingCompiledRezolveTarget.html",
    "title": "Class TargetDelegateCompiler.DelegatingCompiledRezolveTarget",
    "keywords": "Improve this Doc Class TargetDelegateCompiler.DelegatingCompiledRezolveTarget Inheritance System.Object TargetDelegateCompiler.DelegatingCompiledRezolveTarget Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegatingCompiledRezolveTarget : ICompiledTarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc DelegatingCompiledRezolveTarget(Func<RezolveContext, Object>) Declaration public DelegatingCompiledRezolveTarget(Func<RezolveContext, object> getObjectDelegate) Parameters Name Type Description getObjectDelegate System.Func < RezolveContext , System.Object > <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc GetObject(RezolveContext) Declaration public object GetObject(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description System.Object Implements GetObject(RezolveContext) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetContainer.html": {
    "href": "rezolver-api/Rezolver.TargetContainer.html",
    "title": "Class TargetContainer",
    "keywords": "Improve this Doc Class TargetContainer Root container for ITarget s that can be used as the backing for the standard IContainer classes - Container , ScopedContainer , and the Stores and retrieves registrations of ITarget s, is also Generic type aware, unlike its base class - TargetDictionaryContainer . Should be used as the root target container for implementations of IContainer . Inheritance System.Object TargetDictionaryContainer TargetContainer Inherited Members Fetch(Type) FetchAll(Type) CombineWith(ITargetContainer, Type) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetContainer : TargetDictionaryContainer, ITargetContainerOwner, ITargetContainer Remarks This is the type used by default for the of the Container and ScopedContainer when you don't supply an instance of an ITargetContainer explicitly on construction. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc TargetContainer(Boolean) Constructs a new instance of the TargetContainer class Declaration public TargetContainer(bool autoRezolveIEnumerable = true) Parameters Name Type Description autoRezolveIEnumerable System.Boolean If true, then IEnumerable will be automatically resolved as a concatenation of all the ITarget s that are registered against a particular type. Note - this parameter might be removed in a future version - you can achieve the same thing by using the extension method EnableEnumerableResolving(TargetContainer) <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateContainer(Type, ITarget) Called to create and register a container for the given serviceType and target . This class overrides the base version ( CreateContainer(Type, ITarget) ) to create a specialised container for generic types ( GenericTargetContainer ) if serviceType if a generic type or generic type definition. Declaration protected override ITargetContainer CreateContainer(Type serviceType, ITarget target) Parameters Name Type Description serviceType System.Type The type for which a container is to be created and registered. target ITarget Optional. The target that will be added to the container that is returned. Returns Type Description ITargetContainer An ITargetContainer in which the passed target will be registered. Overrides CreateContainer(Type, ITarget) Remarks The main caller for this method will be the base Register method, which will create a new container for a target that's being registered against a new type. It is, however, also called by this class' implementation of RegisterContainer(Type, ITargetContainer) when the type is a generic type - as all generics must have a container registered against their generic type definitions as a starting point. <!-- .classchild --> | Improve this Doc CreateGenericTypeDefContainer(Type, ITarget) Called by CreateContainer(Type, ITarget) to create a container suitable for handling targets that are registered against generic types. Declaration protected virtual ITargetContainer CreateGenericTypeDefContainer(Type genericTypeDefinition, ITarget target) Parameters Name Type Description genericTypeDefinition System.Type Will be an open generic type (generic type definition) target ITarget Optional. The initial target for which the container is being constructed Returns Type Description ITargetContainer The base implementation always creates an instance of CreateGenericTypeDefContainer(Type, ITarget) <!-- .classchild --> | Improve this Doc FetchContainer(Type) Retrieves Declaration public override ITargetContainer FetchContainer(Type type) Parameters Name Type Description type System.Type Returns Type Description ITargetContainer Overrides FetchContainer(Type) <!-- .classchild --> | Improve this Doc Register(ITarget, Type) Declaration public override void Register(ITarget target, Type serviceType = null) Parameters Name Type Description target ITarget serviceType System.Type Overrides Register(ITarget, Type) <!-- .classchild --> | Improve this Doc RegisterContainer(Type, ITargetContainer) Overrides the base method so that if type is a generic type, then the container will be registered inside another which will be registered for the generic type definition first. Declaration public override void RegisterContainer(Type type, ITargetContainer container) Parameters Name Type Description type System.Type container ITargetContainer Overrides RegisterContainer(Type, ITargetContainer) <!-- .classchild --> | Improve this Doc RegisterContainerDirect(Type, ITargetContainer) Version of RegisterContainer(Type, ITargetContainer) which does not interrogate the type to see if it's generic - simply registers the passed container directly against the passed type (it just chains through directly to the RegisterContainer(Type, ITargetContainer) method non-virtually. Declaration protected virtual void RegisterContainerDirect(Type type, ITargetContainer container) Parameters Name Type Description type System.Type container ITargetContainer <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetCompilerHelper.html": {
    "href": "rezolver-api/Rezolver.TargetCompilerHelper.html",
    "title": "Class TargetCompilerHelper",
    "keywords": "Improve this Doc Class TargetCompilerHelper Inheritance System.Object TargetCompilerHelper Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetCompilerHelper <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc Optimise(Expression, IEnumerable<Func<Expression, Expression>>) Declaration public static Expression Optimise(this Expression expression, IEnumerable<Func<Expression, Expression>> additionalOptimisations = null) Parameters Name Type Description expression Expression additionalOptimisations System.Collections.Generic.IEnumerable < System.Func < Expression , Expression >> Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetCompilerHelper.RedundantConvertRemover.html": {
    "href": "rezolver-api/Rezolver.TargetCompilerHelper.RedundantConvertRemover.html",
    "title": "Class TargetCompilerHelper.RedundantConvertRemover",
    "keywords": "Improve this Doc Class TargetCompilerHelper.RedundantConvertRemover Inheritance System.Object TargetCompilerHelper.RedundantConvertRemover Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RedundantConvertRemover : ExpressionVisitor <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc RedundantConvertRemover() Declaration public RedundantConvertRemover() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc VisitUnary(UnaryExpression) Declaration protected override Expression VisitUnary(UnaryExpression node) Parameters Name Type Description node UnaryExpression Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetCompilerBase.html": {
    "href": "rezolver-api/Rezolver.TargetCompilerBase.html",
    "title": "Class TargetCompilerBase",
    "keywords": "Improve this Doc Class TargetCompilerBase Inheritance System.Object TargetCompilerBase Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public abstract class TargetCompilerBase : ITargetCompiler <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CompileTarget(ITarget, CompileContext) Declaration public virtual ICompiledTarget CompileTarget(ITarget target, CompileContext context) Parameters Name Type Description target ITarget context CompileContext Returns Type Description ICompiledTarget Implements CompileTarget(ITarget, CompileContext) <!-- .classchild --> | Improve this Doc CompileTargetBase(ITarget, Expression, CompileContext) Called to create an ICompiledTarget instance from the passed expression produced by the passed target for the passed context. The expression passed into this method is constructed by a call to GetLambdaBody(ITarget, CompileContext) Declaration protected abstract ICompiledTarget CompileTargetBase(ITarget target, Expression toCompile, CompileContext context) Parameters Name Type Description target ITarget The target from which the expression toCompile was built. Note - this expression will have been optimised and potentially rewritten ready for compilation, and will likely not be equal to the expression originally produced by its own CreateExpression(CompileContext) method. toCompile Expression The expression built from target by this instance's own GetLambdaBody(ITarget, CompileContext) methodd. context CompileContext The context for which the compilation is being performed. Returns Type Description ICompiledTarget <!-- .classchild --> | Improve this Doc GetLambdaBody(ITarget, CompileContext) Produces the lambda body for the target. The base class uses the method GetLambdaBodyForTarget(ITarget, CompileContext) . Declaration protected virtual Expression GetLambdaBody(ITarget target, CompileContext context) Parameters Name Type Description target ITarget context CompileContext Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetCompiler.html": {
    "href": "rezolver-api/Rezolver.TargetCompiler.html",
    "title": "Class TargetCompiler",
    "keywords": "Improve this Doc Class TargetCompiler Holds a reference to the default compiler for this application. By default this is set to the TargetDelegateCompiler - which is a general purpose compiler that should work on any platform which supports linq expression trees. Inheritance System.Object TargetCompiler Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetCompiler <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Default The default compiler to be used by rezolvers when they are not explicitly provided one. Declaration public static ITargetCompiler Default { get; set; } Property Value Type Description ITargetCompiler <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetBase.html": {
    "href": "rezolver-api/Rezolver.TargetBase.html",
    "title": "Class TargetBase",
    "keywords": "Improve this Doc Class TargetBase Abstract base class, suggested as a starting point for implementations of ITarget . Inheritance System.Object TargetBase Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public abstract class TargetBase : ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Gets the declared type of object that is constructed by this target. This will be the return type of any expression built by CreateExpression(CompileContext) unless otherwise instructed to build a different type. Declaration public abstract Type DeclaredType { get; } Property Value Type Description System.Type Implements DeclaredType <!-- .classchild --> | Improve this Doc SuppressScopeTracking If false (the default) then any expression produced by CreateExpressionBase(CompileContext) will be automatically wrapped in a block of boilerplate code that will push the return value into the IScopedContainer that is in scope. Override this in your target and return true to strip this automatic behaviour - either if the objects produced by the code generated by your target is not suitable for scoping in this way, or if you handle the scoping manually. Note - you can still call the CreateScopeTrackingExpression(CompileContext, Expression) method if the expression it generates is suitable for your use, just not where it would usually place it. Declaration protected virtual bool SuppressScopeTracking { get; } Property Value Type Description System.Boolean <!-- .classchild --> | Improve this Doc UseFallback Declaration public virtual bool UseFallback { get; } Property Value Type Description System.Boolean Implements UseFallback <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateExpression(CompileContext) Virtual method implementing IRezolveTarget.CreateExpression. Rather than overriding this method, your starting point is to implement the abstract method CreateExpressionBase(CompileContext) . Declaration public virtual Expression CreateExpression(CompileContext context) Parameters Name Type Description context CompileContext The current compile context Returns Type Description Expression Implements CreateExpression(CompileContext) <!-- .classchild --> | Improve this Doc CreateExpressionBase(CompileContext) Abstract method called to create the expression - this is called by CreateExpression(CompileContext) after the target type has been validated, if provided. Note - if your implementation needs to support dynamic Resolve operations from the container that is passed to an IRezolver's Resolve method, you can use the DynamicRezolverParam property, all the default implementations of this class (and others) use that by default. Declaration protected abstract Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext The current compile context Returns Type Description Expression <!-- .classchild --> | Improve this Doc CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) Called to generate the expression that represents the argument that'll be passed to the AddToScope(Object, RezolveContext) method when an object is being tracked in a lifetime scope. By default, the base implementation generates an expression that represents null - because usually there really is little point in adding a specific context along with the object being tracked, unless you're also grabbing instances back out of the scope which isn't done by the base class behaviour by default. Declaration protected virtual Expression CreateRezolveContextExpressionForScopeAddCall(CompileContext context, Expression expression) Parameters Name Type Description context CompileContext expression Expression Returns Type Description Expression <!-- .classchild --> | Improve this Doc CreateScopeSelectionExpression(CompileContext, Expression) Called by CreateScopeTrackingExpression(CompileContext, Expression) to generate the code that selects the correct scope instance that is to be used for scope tracking for the object produced by the code generated by CreateExpressionBase(CompileContext) . Declaration protected virtual Expression CreateScopeSelectionExpression(CompileContext context, Expression expression) Parameters Name Type Description context CompileContext expression Expression Returns Type Description Expression <!-- .classchild --> | Improve this Doc CreateScopeTrackingExpression(CompileContext, Expression) This is called by CreateExpression(CompileContext) after the derived class generates its expression via a call to CreateExpressionBase(CompileContext) - unless SuppressScopeTracking is true either on this object, or on the passed context . The purpose is to generate the code that will ensure that any instance produced will be tracked in a lifetime scope, if required. Declaration protected virtual Expression CreateScopeTrackingExpression(CompileContext context, Expression expression) Parameters Name Type Description context CompileContext The current compile context. expression Expression The code generated from the CreateExpressionBase(CompileContext) method, albeit possibly rewritten and optimised. Returns Type Description Expression Remarks By default, if there is a lifetime scope, then its AddToScope(Object, RezolveContext) method is called with the object that's produced by the target, before the object is returned. If there is no scope, then no tracking is performed. Note that, also, by default, an object will only be tracked in the scope if it's IDisposable . As mentioned in the summary, if you need to disable the automatic generation of this scope tracking code, then you can override the SuppressScopeTracking property, and return false. It can also be suppressed on a per-compilation basis by setting the SuppressScopeTracking property of the context to true. This is something that the ScopedTarget does on its nested target, since by definition it generates its own explicit scope tracking code. If the target simply needs to select a different scope from the current (at the time Resolve(RezolveContext) is called), then it can override the CreateScopeSelectionExpression(CompileContext, Expression) method. <!-- .classchild --> | Improve this Doc SupportsType(Type) Called to check whether a target can create an expression that builds an instance of the given type . Declaration public virtual bool SupportsType(Type type) Parameters Name Type Description type System.Type Required Returns Type Description System.Boolean true if this target supports the given type, false otherwise. Implements SupportsType(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetAssemblyCompiler.html": {
    "href": "rezolver-api/Rezolver.TargetAssemblyCompiler.html",
    "title": "Class TargetAssemblyCompiler",
    "keywords": "Improve this Doc Class TargetAssemblyCompiler Implementation of the ITargetCompiler which compiles dynamic code to an assembly (which can, potentially, be saved to disk). Suitable for environments that support the full .Net profile. Generally, the performance of a container built using this compiler will be better than one that uses the TargetDelegateCompiler . Inheritance System.Object TargetAssemblyCompiler Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetAssemblyCompiler : ITargetCompiler <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc TargetAssemblyCompiler() Initializes a new instance of the TargetAssemblyCompiler class. Declaration public TargetAssemblyCompiler() <!-- .classchild --> | Improve this Doc TargetAssemblyCompiler(AssemblyBuilder) Initializes a new instance of the TargetAssemblyCompiler class. Declaration public TargetAssemblyCompiler(AssemblyBuilder assemblyBuilder) Parameters Name Type Description assemblyBuilder AssemblyBuilder The assembly builder into which the dynamically generated code will be compiled. Exceptions Type Condition System.ArgumentNullException assemblyBuilder is null <!-- .classchild --> | Improve this Doc TargetAssemblyCompiler(ModuleBuilder) Initializes a new instance of the TargetAssemblyCompiler class. Declaration public TargetAssemblyCompiler(ModuleBuilder moduleBuilder) Parameters Name Type Description moduleBuilder ModuleBuilder The module builder - if the assembly builder is already being used for something else and you want the dynamic code for the container to be compiled into a specific module within that assembly. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc AssemblyBuilder Gets the assembly builder whose dynamic assembly is receiving the dynamically generated code. Declaration public AssemblyBuilder AssemblyBuilder { get; } Property Value Type Description AssemblyBuilder The assembly builder. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CompileTarget(ITarget, CompileContext) Creates and builds a compiled target for the passed rezolve target which can then be used to create/obtain the object(s) it produces. Declaration public ICompiledTarget CompileTarget(ITarget target, CompileContext context) Parameters Name Type Description target ITarget The target to be compiled. context CompileContext The current compilation context. Returns Type Description ICompiledTarget A compiled target that produces the object represented by target . Implements CompileTarget(ITarget, CompileContext) <!-- .classchild --> | Improve this Doc CreateAssemblyBuilder(AssemblyBuilderAccess, String) Shortcut method for creating an assembly builder that is suitable for use with an TargetAssemblyCompiler , but with the supplied access settings (e.g. if you want to be able to save the assembly). Declaration public static AssemblyBuilder CreateAssemblyBuilder(AssemblyBuilderAccess assemblyBuilderAccess = null, string dir = null) Parameters Name Type Description assemblyBuilderAccess AssemblyBuilderAccess The assembly builder access. dir System.String If supplied, then it's the base directory that will be used when saving the dynamic dll. Returns Type Description AssemblyBuilder An AssemblyBuilder instance that can be passed to the TargetAssemblyCompiler constructor. <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.TargetAdapter.html": {
    "href": "rezolver-api/Rezolver.TargetAdapter.html",
    "title": "Class TargetAdapter",
    "keywords": "Improve this Doc Class TargetAdapter Default implementation of the ITargetAdapter interface. Also an ExpressionVisitor. Also, its Default property serves as the reference to the default adapter used by the system to convert expressions into IRezolveTarget instances. This class cannot be created directly - it is a singleton accessed through the Instance property. You can inherit from this class, however, to serve as the basis for your own implementation of ITargetAdapter . Inheritance System.Object TargetAdapter Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetAdapter : ExpressionVisitor, ITargetAdapter <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc TargetAdapter() Protected constructor ensuring that new instances can only be created through inheritance. Declaration protected TargetAdapter() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc Default The default IRezolveTargetAdapter to be used in converting expressions to IRezolveTarget instances. By default, this is initialised to a single instance of the TargetAdapter class. Declaration public static ITargetAdapter Default { get; set; } Property Value Type Description ITargetAdapter <!-- .classchild --> | Improve this Doc Instance The one and only instance of the RezolveTargetAdapter class Declaration public static ITargetAdapter Instance { get; } Property Value Type Description ITargetAdapter <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateTarget(Expression) Declaration public ITarget CreateTarget(Expression expression) Parameters Name Type Description expression Expression Returns Type Description ITarget Implements CreateTarget(Expression) <!-- .classchild --> | Improve this Doc Visit(Expression) Declaration public override Expression Visit(Expression node) Parameters Name Type Description node Expression Returns Type Description Expression <!-- .classchild --> | Improve this Doc VisitConstant(ConstantExpression) Declaration protected override Expression VisitConstant(ConstantExpression node) Parameters Name Type Description node ConstantExpression Returns Type Description Expression <!-- .classchild --> | Improve this Doc VisitLambda<T>(Expression<T>) Declaration protected override Expression VisitLambda<T>(Expression<T> node) Parameters Name Type Description node Expression <T> Returns Type Description Expression Type Parameters Name Description T <!-- .classchild --> | Improve this Doc VisitMemberAssignment(MemberAssignment) Declaration protected override MemberAssignment VisitMemberAssignment(MemberAssignment node) Parameters Name Type Description node MemberAssignment Returns Type Description MemberAssignment <!-- .classchild --> | Improve this Doc VisitMemberInit(MemberInitExpression) Declaration protected override Expression VisitMemberInit(MemberInitExpression node) Parameters Name Type Description node MemberInitExpression Returns Type Description Expression <!-- .classchild --> | Improve this Doc VisitMemberListBinding(MemberListBinding) Declaration protected override MemberListBinding VisitMemberListBinding(MemberListBinding node) Parameters Name Type Description node MemberListBinding Returns Type Description MemberListBinding <!-- .classchild --> | Improve this Doc VisitMemberMemberBinding(MemberMemberBinding) Declaration protected override MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding node) Parameters Name Type Description node MemberMemberBinding Returns Type Description MemberMemberBinding <!-- .classchild --> | Improve this Doc VisitMethodCall(MethodCallExpression) Declaration protected override Expression VisitMethodCall(MethodCallExpression node) Parameters Name Type Description node MethodCallExpression Returns Type Description Expression <!-- .classchild --> | Improve this Doc VisitNew(NewExpression) Declaration protected override Expression VisitNew(NewExpression node) Parameters Name Type Description node NewExpression Returns Type Description Expression <!-- .classchild --> | Improve this Doc VisitParameter(ParameterExpression) Declaration protected override Expression VisitParameter(ParameterExpression node) Parameters Name Type Description node ParameterExpression Returns Type Description Expression <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.SingletonTarget.html": {
    "href": "rezolver-api/Rezolver.SingletonTarget.html",
    "title": "Class SingletonTarget",
    "keywords": "Improve this Doc Class SingletonTarget Decorates any IRezolveTarget instance inside a lazily-initialised instance which will only ever create the target object once. Inheritance System.Object TargetBase SingletonTarget Inherited Members UseFallback CreateScopeTrackingExpression(CompileContext, Expression) CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) CreateExpression(CompileContext) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class SingletonTarget : TargetBase, ITarget <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc SingletonTarget(ITarget) Constructs a new instance of the SingletonTarget class. Declaration public SingletonTarget(ITarget innerTarget) Parameters Name Type Description innerTarget ITarget The target whose result (when compiled) is to be used as the singleton instance. <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description System.Type Overrides DeclaredType <!-- .classchild --> | Improve this Doc SuppressScopeTracking Overrides the base class to ensure that automatic generation of the scope tracking code by RezolveTargetBase is disabled. For the singleton, it's important that the scope tracking call occurs within the lazy's callback. Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description System.Boolean Overrides SuppressScopeTracking <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateExpressionBase(CompileContext) Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides CreateExpressionBase(CompileContext) <!-- .classchild --> | Improve this Doc CreateScopeSelectionExpression(CompileContext, Expression) Declaration protected override Expression CreateScopeSelectionExpression(CompileContext context, Expression expression) Parameters Name Type Description context CompileContext expression Expression Returns Type Description Expression Overrides CreateScopeSelectionExpression(CompileContext, Expression) <!-- .classchild --> | Improve this Doc SupportsType(Type) Declaration public override bool SupportsType(Type type) Parameters Name Type Description type System.Type Returns Type Description System.Boolean Overrides SupportsType(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ScopedTarget.html": {
    "href": "rezolver-api/Rezolver.ScopedTarget.html",
    "title": "Class ScopedTarget",
    "keywords": "Improve this Doc Class ScopedTarget A target that produces a single instance of an object within a lifetime scope. Inheritance System.Object TargetBase ScopedTarget Inherited Members UseFallback CreateScopeTrackingExpression(CompileContext, Expression) CreateRezolveContextExpressionForScopeAddCall(CompileContext, Expression) CreateScopeSelectionExpression(CompileContext, Expression) CreateExpression(CompileContext) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ScopedTarget : TargetBase, ITarget Remarks On its own, this target doesn't do anything - it's designed to wrap another target such that the code generated from the expression it produces is executed only once for each lifetime scope. Outside of that, the target generates wrapper code that forcibly caches the instance that is produced (whether it's IDiposable or not) into the current scope's cache (using AddToScope(Object, RezolveContext) ) and retrieves previous instances from that scope (using GetFromScope(RezolveContext) . <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ScopedTarget(ITarget) Declaration public ScopedTarget(ITarget innerTarget) Parameters Name Type Description innerTarget ITarget <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description System.Type Overrides DeclaredType <!-- .classchild --> | Improve this Doc SuppressScopeTracking Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description System.Boolean Overrides SuppressScopeTracking <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc CreateExpressionBase(CompileContext) Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Name Type Description context CompileContext Returns Type Description Expression Overrides CreateExpressionBase(CompileContext) <!-- .classchild --> | Improve this Doc SupportsType(Type) Declaration public override bool SupportsType(Type type) Parameters Name Type Description type System.Type Returns Type Description System.Boolean Overrides SupportsType(Type) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.ScopedContainer.html": {
    "href": "rezolver-api/Rezolver.ScopedContainer.html",
    "title": "Class ScopedContainer",
    "keywords": "Improve this Doc Class ScopedContainer Extends the Container to implement lifetime scoping. If you want your root container to act as a lifetime scope, then you should use this class instead of using Container Inheritance System.Object ContainerBase CachingContainerBase Container ScopedContainer Inherited Members GetCompiledRezolveTarget(RezolveContext) GetMissingTarget(Type) IsMissingTarget(ICompiledTarget) Compiler Targets Resolve(RezolveContext) TryResolve(RezolveContext, out Object) CreateLifetimeScope() FetchCompiled(RezolveContext) CanResolve(RezolveContext) GetFallbackCompiledRezolveTarget(RezolveContext) Rezolver.ContainerBase.System.IServiceProvider.GetService(System.Type) GetService(Type) Register(ITarget, Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.Fetch(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.FetchAll(System.Type) Rezolver.ContainerBase.Rezolver.ITargetContainer.CombineWith(Rezolver.ITargetContainer, System.Type) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ScopedContainer : Container, ITargetContainer, IScopedContainer, IContainer, IServiceProvider, IDisposable Remarks The implementation of this class is very similar to the OverridingScopedContainer , The main difference being that that class can accept additional registrations independent of those in the container that it's created from, whereas with this class, it is the container. This type is therefore suited only for standalone Rezolvers for which you want lifetime scoping and disposable handling; whereas the OverridingScopedContainer is primarily suited for use as a child lifetime scope for another container. <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc ScopedContainer(ITargetContainer, ITargetCompiler) Declaration public ScopedContainer(ITargetContainer builder = null, ITargetCompiler compiler = null) Parameters Name Type Description builder ITargetContainer compiler ITargetCompiler <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc ParentScope Declaration public IScopedContainer ParentScope { get; } Property Value Type Description IScopedContainer Implements ParentScope <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc AddToScope(Object, RezolveContext) Declaration public virtual void AddToScope(object obj, RezolveContext context = null) Parameters Name Type Description obj System.Object context RezolveContext Implements AddToScope(Object, RezolveContext) <!-- .classchild --> | Improve this Doc Dispose() Declaration public void Dispose() Implements System.IDisposable.Dispose() <!-- .classchild --> | Improve this Doc Dispose(Boolean) Declaration protected virtual void Dispose(bool disposing) Parameters Name Type Description disposing System.Boolean <!-- .classchild --> | Improve this Doc GetFromScope(RezolveContext) Declaration public virtual IEnumerable<object> GetFromScope(RezolveContext context) Parameters Name Type Description context RezolveContext Returns Type Description System.Collections.Generic.IEnumerable < System.Object > Implements GetFromScope(RezolveContext) <!-- .classchild --> | Improve this Doc OnDisposed() Declaration protected void OnDisposed() <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Events | Improve this Doc Disposed Declaration public event EventHandler Disposed Event Type Type Description System.EventHandler Implements Disposed <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.SingletonTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.SingletonTargetMetadata.html",
    "title": "Class SingletonTargetMetadata",
    "keywords": "Improve this Doc Class SingletonTargetMetadata Inheritance System.Object RezolveTargetMetadataBase SingletonTargetMetadata Inherited Members Type CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Bind(ITypeReference[]) System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class SingletonTargetMetadata : RezolveTargetMetadataBase, ISingletonTargetMetadata, IRezolveTargetMetadata <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc SingletonTargetMetadata(IRezolveTargetMetadata, Boolean) Initializes a new instance of the SingletonTargetMetadata class. Declaration public SingletonTargetMetadata(IRezolveTargetMetadata inner, bool scoped = false) Parameters Name Type Description inner IRezolveTargetMetadata The inner target that will be turned into a singleton. scoped System.Boolean if set to true [scoped]. Exceptions Type Condition System.ArgumentNullException inner <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc DeclaredType Gets the declared type of the object that will be created by an IRezolveTarget created by this metadata. Note - this isn't always known, or always fixed, since configuration systems will allow developers to avoid being specific about the types that are to be built. Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference The type of the declared. Overrides DeclaredType Implements DeclaredType <!-- .classchild --> | Improve this Doc Inner Metadata for the inner target that is turned into a scoped singleton Declaration public IRezolveTargetMetadata Inner { get; } Property Value Type Description IRezolveTargetMetadata Implements Inner <!-- .classchild --> | Improve this Doc Scoped If true, then the singleton object should be scope-compatible, i.e. with a lifetime limited to the lifetime of an external scope rather than to the AppDomain's lifetime. Declaration public bool Scoped { get; } Property Value Type Description System.Boolean Implements Scoped <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Methods | Improve this Doc BindBase(ITypeReference[]) Creates a new instance (clone) of this metadata that's bound to the target types (although, typically, you'll only ever pick the first target type that is in the array). Only ever called if DeclaredType is unbound Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Name Type Description targetTypes ITypeReference [] The target types. Returns Type Description IRezolveTargetMetadata IRezolveTargetMetadata. Overrides BindBase(ITypeReference[]) <!-- .classchild --> | Improve this Doc CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Implementation of the abstract method from the base class of the same name. If Scoped is true, then this creates a new ScopedTarget ; if false, it creates a new SingletonTarget Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Name Type Description targetTypes System.Type [] The target types. context ConfigurationAdapterContext The context. entry IConfigurationEntry The entry. Returns Type Description ITarget Overrides CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RuntimeTypeReference.html": {
    "href": "rezolver-api/Rezolver.Configuration.RuntimeTypeReference.html",
    "title": "Class RuntimeTypeReference",
    "keywords": "Improve this Doc Class RuntimeTypeReference An ITypeReference that has been built directly from a runtime type. Inheritance System.Object RuntimeTypeReference Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public sealed class RuntimeTypeReference : ITypeReference, IConfigurationLineInfo <!-- <hr class=\"typeSectionDivider\" /> --> Constructors | Improve this Doc RuntimeTypeReference(Type) Declaration public RuntimeTypeReference(Type runtimeType) Parameters Name Type Description runtimeType System.Type <!-- .classchild --> <!-- <hr class=\"typeSectionDivider\" /> --> Properties | Improve this Doc EndLineNo Declaration public int ? EndLineNo { get; } Property Value Type Description System.Nullable < System.Int32 > Implements EndLineNo <!-- .classchild --> | Improve this Doc EndLinePos Declaration public int ? EndLinePos { get; } Property Value Type Description System.Nullable < System.Int32 > Implements EndLinePos <!-- .classchild --> | Improve this Doc GenericArguments Declaration public ITypeReference[] GenericArguments { get; } Property Value Type Description ITypeReference [] Implements GenericArguments <!-- .classchild --> | Improve this Doc IsArray Declaration public bool IsArray { get; } Property Value Type Description System.Boolean Implements IsArray <!-- .classchild --> | Improve this Doc IsOpenGenericTypeArgument Declaration public bool IsOpenGenericTypeArgument { get; } Property Value Type Description System.Boolean Implements IsOpenGenericTypeArgument <!-- .classchild --> | Improve this Doc IsUnbound Declaration public bool IsUnbound { get; } Property Value Type Description System.Boolean Implements IsUnbound <!-- .classchild --> | Improve this Doc RuntimeType Declaration public Type RuntimeType { get; } Property Value Type Description System.Type <!-- .classchild --> | Improve this Doc StartLineNo Declaration public int ? StartLineNo { get; } Property Value Type Description System.Nullable < System.Int32 > Implements StartLineNo <!-- .classchild --> | Improve this Doc StartLinePos Declaration public int ? StartLinePos { get; } Property Value Type Description System.Nullable < System.Int32 > Implements StartLinePos <!-- .classchild --> | Improve this Doc TypeName Declaration public string TypeName { get; } Property Value Type Description System.String Implements TypeName <!-- .classchild -->"
  },
  "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataType.html": {
    "href": "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataType.html",
    "title": "Enum RezolveTargetMetadataType",
    "keywords": "Improve this Doc Enum RezolveTargetMetadataType Types of IRezolveTargetMetadata that can be expressed in configuration Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public enum RezolveTargetMetadataType <!-- <hr class=\"typeSectionDivider\" /> --> Fields | Improve this Doc Constructor Binding to a constructor of a type to create new instances of that type when the object is resolved Declaration Constructor = 2 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> | Improve this Doc Extension A custom metadata - the instance should also have the interface IRezolveTargetMetadataExtension Declaration Extension = 2147483647 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> | Improve this Doc List A list or array whose items are individually specified as resolve targets and eventually loaded into a ListTarget. This enables configuration files to hand-crank a list directly and when multiple registration is not applicable. Declaration List = 4 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> | Improve this Doc MetadataList Describes a list of IRezolveTargetMetadata instances - to be used for metadata objects that require multiple metadata objects. Can be created to feed a multiple instance registration for a single type (e.g. registering multiple instances of IFoo to a container, so that you can resolve all of them by resolving IEnumerable ), or simply as a collection of targets that are to be used to build an array that is to be passed as a constructor argument or property. Declaration MetadataList = 5 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> | Improve this Doc Object A physical instance to be returned when a resolve operation is performed Declaration Object = 1 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> | Improve this Doc Singleton A singleton - only one object will ever be created from the target that this metadata builds. A singleton might also be scoped - i.e. that the lifetime is limited to the lifetime of an external scope. Declaration Singleton = 3 Field Value Type Description RezolveTargetMetadataType <!-- .classchild --> | Improve this Doc Unknown Declaration Unknown = 0 Field Value Type Description RezolveTargetMetadataType <!-- .classchild -->"
  }
}