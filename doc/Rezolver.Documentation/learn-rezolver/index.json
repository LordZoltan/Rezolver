{
  "rezolver-api/Rezolver.TargetAdapterGenericRegisterExpressionExtensions.html": {
    "href": "rezolver-api/Rezolver.TargetAdapterGenericRegisterExpressionExtensions.html",
    "title": "Class TargetAdapterGenericRegisterExpressionExtensions",
    "keywords": "Class TargetAdapterGenericRegisterExpressionExtensions Contains numerous generic overloads of the RegisterExpression extension method for ITargetContainer All of these extensions act as proxies for the RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) extension method. Inheritance Object TargetAdapterGenericRegisterExpressionExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class TargetAdapterGenericRegisterExpressionExtensions Methods | Improve this Doc RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<TResult>(this ITargetContainer targetContainer, Expression<Func<TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<TResult>(ITargetContainer, Expression<Func<RezolveContext, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < RezolveContext , TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) T15 The type of the 15th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) T15 The type of the 15th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T, TResult>(this ITargetContainer targetContainer, Expression<Func<T, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T The type of the 1st lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<RezolveContext, T, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < RezolveContext , T, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T The type of the 2nd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < RezolveContext , T2, T3, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < RezolveContext , T2, T3, T4, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < RezolveContext , T2, T3, T4, T5, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < RezolveContext , T2, T3, T4, T5, T6, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type, ITargetAdapter) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(this ITargetContainer targetContainer, Expression<Func<RezolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < RezolveContext , T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression The lambda expression that is to be converted into a target and registered Type type ITargetAdapter adapter Optional adapter to use to convert the expression into an ITarget . If not provided, then the Default adapter will be used. It is unlikely you will ever need to use a different adapter unless you've created a target implementation of your own. Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) , which simply asks the adapter to create a target from the passed expression and then registers it against either the passed type , or the created target's DeclaredType if not provided."
  },
  "rezolver-api/System.Collections.Generic.html": {
    "href": "rezolver-api/System.Collections.Generic.html",
    "title": "Namespace System.Collections.Generic",
    "keywords": "Namespace System.Collections.Generic Classes"
  },
  "rezolver-api/System.DelegateExtensions.html": {
    "href": "rezolver-api/System.DelegateExtensions.html",
    "title": "Class DelegateExtensions",
    "keywords": "Class DelegateExtensions Inheritance Object DelegateExtensions Inherited Members Namespace :System Assembly :cs.temp.dll.dll Syntax public static class DelegateExtensions"
  },
  "rezolver-api/System.Linq.Expressions.ExpressionExtensions.html": {
    "href": "rezolver-api/System.Linq.Expressions.ExpressionExtensions.html",
    "title": "Class ExpressionExtensions",
    "keywords": "Class ExpressionExtensions Inheritance Object ExpressionExtensions Inherited Members Namespace :System.Linq.Expressions Assembly :cs.temp.dll.dll Syntax public static class ExpressionExtensions Methods | Improve this Doc AsRezolveTarget(Expression, ITargetAdapter) Declaration public static ITarget AsRezolveTarget(this Expression expression, ITargetAdapter adapter = null) Parameters Type Name Description Expression expression ITargetAdapter adapter Returns Type Description ITarget"
  },
  "rezolver-api/System.Linq.Expressions.html": {
    "href": "rezolver-api/System.Linq.Expressions.html",
    "title": "Namespace System.Linq.Expressions",
    "keywords": "Namespace System.Linq.Expressions Classes"
  },
  "rezolver-api/System.html": {
    "href": "rezolver-api/System.html",
    "title": "Namespace System",
    "keywords": "Namespace System Classes"
  },
  "rezolver-api/Rezolver.Targets.DecoratorTarget.html": {
    "href": "rezolver-api/Rezolver.Targets.DecoratorTarget.html",
    "title": "Class DecoratorTarget",
    "keywords": "Class DecoratorTarget Represents the action of implementing a common DecoratedType by decorating one instance (produced by DecoratedTarget ) with another ( Target , which will create an instance of DecoratorType ). NOTE - You shouldn't register or otherwise create instances of this target unless you absolutely know what you're doing. Rather, decorators should be registered using the extension method RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) or its non-generic alternative because the target needs a DecoratingTargetContainer to work properly (the creation of which is automatically handled by these extension methods). Inheritance Object TargetBase DecoratorTarget Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DecoratorTarget : TargetBase, ITarget Constructors | Improve this Doc DecoratorTarget(Type, ITarget, Type) Creates a new instance of the DecoratorTarget type, initialising the Target to a just-in-time-bound ConstructorTarget for the decoratorType . Declaration public DecoratorTarget(Type decoratorType, ITarget decoratedTarget, Type decoratedType) Parameters Type Name Description Type decoratorType The type which is decorating the decoratedType ITarget decoratedTarget The target which is being decorated Type decoratedType The common type which is being decorated - e.g. IService when the decoratedTarget is bound to the type MyService : IService and the decoratorType is set to MyServiceDecorator : IService . Properties | Improve this Doc DeclaredType Always returns DecoratorType Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc DecoratedTarget Gets the target whose instance will be wrapped (decorated) by the one produced by Target . Declaration public ITarget DecoratedTarget { get; } Property Value Type Description ITarget | Improve this Doc DecoratedType Gets the underlying type (e.g. a common service interface or base) that is being implemented through decoration. Declaration public Type DecoratedType { get; } Property Value Type Description Type | Improve this Doc DecoratorType Gets the type which is decorating the instance produced by the DecoratedTarget for the common service type DecoratedType Declaration public Type DecoratorType { get; } Property Value Type Description Type | Improve this Doc Target Gets the target which will create an instance of the DecoratorType Declaration public ITarget Target { get; } Property Value Type Description ITarget Remarks The constructor currently auto-initialises this to a just-in-time-bound ConstructorTarget targetting the DecoratorType by using the Auto(Type, IMemberBindingBehaviour) method. Methods | Improve this Doc SupportsType(Type) Overrides SupportsType(Type) to forward the call to Target . Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type The type which is to be checked. Returns Type Description Boolean true if the type is compatible with the object created by Target , false if not. Overrides See Also TargetBase"
  },
  "rezolver-api/Rezolver.Targets.DefaultTarget.html": {
    "href": "rezolver-api/Rezolver.Targets.DefaultTarget.html",
    "title": "Class DefaultTarget",
    "keywords": "Class DefaultTarget A target that simply creates a default instance of a given type. I.e. the same as doing default(type) in C#. Inheritance Object TargetBase DefaultTarget Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DefaultTarget : TargetBase, ITarget, ICompiledTarget Remarks The type also implements the ICompiledTarget interface for direct resolving. Constructors | Improve this Doc DefaultTarget(Type) Initializes a new instance of the DefaultTarget class. Declaration public DefaultTarget(Type type) Parameters Type Name Description Type type The type. Properties | Improve this Doc DeclaredType Always equal to the type for which the default value will be returned Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc ScopeBehaviour Override of ScopeBehaviour - always returns None . Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides | Improve this Doc Value Gets the actual default value represented by this instance. Declaration public object Value { get; } Property Value Type Description Object Explicit Interface Implementations | Improve this Doc ICompiledTarget.GetObject(ResolveContext) Declaration object ICompiledTarget.GetObject(ResolveContext context) Parameters Type Name Description ResolveContext context Returns Type Description Object Implements"
  },
  "rezolver-api/Rezolver.Targets.DelegateTarget-1.html": {
    "href": "rezolver-api/Rezolver.Targets.DelegateTarget-1.html",
    "title": "Class DelegateTarget<TResult>",
    "keywords": "Class DelegateTarget<TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<TResult> Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<TResult> : DelegateTarget, ITarget Type Parameters Name Description TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<TResult>, Type) Initializes a new instance of the DelegateTarget<TResult> class. Declaration public DelegateTarget(Func<TResult> factory, Type declaredType = null) Parameters Type Name Description Func <TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.Targets.DelegateTarget-10.html": {
    "href": "rezolver-api/Rezolver.Targets.DelegateTarget-10.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.Targets.DelegateTarget-11.html": {
    "href": "rezolver-api/Rezolver.Targets.DelegateTarget-11.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.Targets.DelegateTarget-12.html": {
    "href": "rezolver-api/Rezolver.Targets.DelegateTarget-12.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.Targets.DelegateTarget-13.html": {
    "href": "rezolver-api/Rezolver.Targets.DelegateTarget-13.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.Compilation.Expressions.DelegateTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.DelegateTargetBuilder.html",
    "title": "Class DelegateTargetBuilder",
    "keywords": "Class DelegateTargetBuilder Specialised builder for the class and all its derivatives. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < DelegateTarget > DelegateTargetBuilder Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class DelegateTargetBuilder : ExpressionBuilderBase<DelegateTarget>, IExpressionBuilder<DelegateTarget>, IExpressionBuilder Methods | Improve this Doc Build(DelegateTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target for the given IExpressionCompileContext Declaration protected override Expression Build(DelegateTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description DelegateTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Exceptions Type Condition NotImplementedException"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ExpressionBuilderBase-1.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ExpressionBuilderBase-1.html",
    "title": "Class ExpressionBuilderBase<TTarget>",
    "keywords": "Class ExpressionBuilderBase<TTarget> Abstract base class for implementations of IExpressionBuilder<TTarget> . Provide an implementation of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) and then register an instance in an in the active container. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase<TTarget> Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public abstract class ExpressionBuilderBase<TTarget> : ExpressionBuilderBase, IExpressionBuilder<TTarget>, IExpressionBuilder where TTarget : ITarget Type Parameters Name Description TTarget The type of target for which this builder can build an expression. Remarks This is a generic extension of the ExpressionBuilderBase class, designed to simplify the process of implementating the IExpressionBuilder<TTarget> (and, by extension, IExpressionBuilder ) interface. This is the class from which most of the built-in expression builders derive, because the ExpressionCompiler , when asked to compile an expression, attempts to resolve an IExpressionBuilder<TTarget> whose TTarget is the same type as the target that needs compiling. Inheriting from ExpressionBuilderBase is more appropriate if your builder is capable of handling multiple types of ITarget - a scenario that's much less common. Note that this class' implementation of IExpressionBuilder<TTarget> is entirely explicit and non-virtual, the same as with its base class, hence the only way to build an expression via an instance of this class without exposing the behaviour to external callers yourself is via the interface. Methods | Improve this Doc Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target for the given ICompileContext OVerride this to implement the compilation for your target type. Declaration protected abstract Expression Build(TTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description TTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression | Improve this Doc Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Overrides the abstract Build(ITarget, IExpressionCompileContext, IExpressionCompiler) (and seals it from further overrides); checks that target is an instance of TTarget (throwing an ArgumentException if not) and then calls this class' Build(TTarget, IExpressionCompileContext, IExpressionCompiler) abstract function. Declaration protected override sealed Expression Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ITarget target The target for which an expression is to be built. Must be an instance of TTarget . IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Exceptions Type Condition ArgumentException target must be an instance of { typeof(TTarget) } ArgumentException If the passed target is not an instance of TTarget | Improve this Doc CanBuild(ITarget, IExpressionCompileContext) Determines whether this instance can build an expression from the specified target. This base implementation simply checks that the type of target is compatible with the type TTarget . Declaration public override bool CanBuild(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context The compilation context. Returns Type Description Boolean Overrides Implements Explicit Interface Implementations | Improve this Doc IExpressionBuilder<TTarget>.Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Builds the specified target. Declaration Expression IExpressionBuilder<TTarget>.Build(TTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description TTarget target The target. IExpressionCompileContext context The context. IExpressionCompiler compiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the implementation attempts to locate the context compiler using the GetContextCompiler(IExpressionCompileContext) method, and will throw an InvalidOperationException if it cannot do so. Returns Type Description Expression Implements Exceptions Type Condition ArgumentNullException target is null or context is null InvalidOperationException compiler is null and an IExpressionCompiler couldn't be resolved for the current context (via GetContextCompiler(IExpressionCompileContext) See Also IExpressionBuilder <TTarget> ExpressionBuilderBase"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ExpressionBuilderBase.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ExpressionBuilderBase.html",
    "title": "Class ExpressionBuilderBase",
    "keywords": "Class ExpressionBuilderBase Abstract starting point for implementing IExpressionBuilder . Note that the interface is implemented explicitly; but exposes protected abstract or virtual methods for inheritors to extend. Inheritance Object ExpressionBuilderBase Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public abstract class ExpressionBuilderBase : IExpressionBuilder Remarks This class takes care of checking the type requested in the IExpressionCompileContext is compatible with the target that's passed to the Build(ITarget, IExpressionCompileContext, IExpressionCompiler) method Properties | Improve this Doc IContainerScope_Resolve_Method Gets a MethodInfo object for the Resolve(ResolveContext, Func<ResolveContext, Object>, ScopeBehaviour) method for help in generating scope-interfacing code. Declaration protected MethodInfo IContainerScope_Resolve_Method { get; } Property Value Type Description MethodInfo | Improve this Doc ITarget_SelectScope_Method Gets a MethodInfo object for the SelectScope(ResolveContext) method for help in generating scope-interfacing code. Declaration protected MethodInfo ITarget_SelectScope_Method { get; } Property Value Type Description MethodInfo | Improve this Doc ResolveContext_CreateNew_Method_Type Gets a MethodInfo object for the CreateNew(Type) method Declaration protected MethodInfo ResolveContext_CreateNew_Method_Type { get; } Property Value Type Description MethodInfo The type of the resolve context create new method. Methods | Improve this Doc ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) Called by the BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) method. Applies the scoping behaviour to the builtExpression such that when it is executed it correctly interfaces with the active scope (from the ResolveContext ) if one is present for the given scopeBehaviour . Declaration protected virtual Expression ApplyScoping(ScopeBehaviour scopeBehaviour, Expression builtExpression, ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ScopeBehaviour scopeBehaviour The scoping behaviour for which the expression is to be adapted. If this is None , then the base class implementation will not generate any scoping code. Expression builtExpression The expression that was built for the target . ITarget target The target that is currently being compiled and from which the builtExpression was built. IExpressionCompileContext context The current active compilation context. IExpressionCompiler compiler The compiler. Returns Type Description Expression | Improve this Doc Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Abstract method used as part implementation of the Build(ITarget, IExpressionCompileContext, IExpressionCompiler) It's called by BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) . Declaration protected abstract Expression Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context The context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression | Improve this Doc BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) The core expression build function - takes care of handling mismatched types between the target and the requested type in the context - both checking compatibility and producing conversion expressions where necessary. Also performs cyclic dependency checking and rewriting expressions to take advantage of a target's ScopeBehaviour (which can be overriden with ScopeBehaviourOverride ) Declaration protected Expression BuildCore(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ITarget target The target to be compiled. IExpressionCompileContext context The context. IExpressionCompiler compiler The compiler. Returns Type Description Expression Remarks This class' implementation of Build(ITarget, IExpressionCompileContext, IExpressionCompiler) calls this, as does the derived abstract class ExpressionBuilderBase<TTarget> for its implementation of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) . It is this function that is responsible for calling the abstract Build(ITarget, IExpressionCompileContext, IExpressionCompiler) function, which deriving classes implement to actually produce their expression for the target . Exceptions Type Condition ArgumentException targetType doesn't support the context's TargetType InvalidOperationException The target is already being compiled. | Improve this Doc CanBuild(ITarget, IExpressionCompileContext) Abstract method (implementation of CanBuild(ITarget, IExpressionCompileContext) ) which determines whether this instance can build an expression for the specified target. Declaration public abstract bool CanBuild(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context The compilation context. Returns Type Description Boolean Implements | Improve this Doc GetContextCompiler(IExpressionCompileContext) Gets the IExpressionCompiler to be used to build the expression for the given target for the given context, if different from one passed to this class' implementation of Build(ITarget, IExpressionCompileContext, IExpressionCompiler) . This function is called by BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) which will throw an exception if it returns null and no compiler was provided to BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) (typically via the explicit implementation of IExpressionBuilder ). Declaration protected virtual IExpressionCompiler GetContextCompiler(IExpressionCompileContext context) Parameters Type Name Description IExpressionCompileContext context The current compile context. Returns Type Description IExpressionCompiler Remarks The base implementation simply attempts to resolve an instance of IExpressionCompiler from the Container which should, with the default configuration, resolve to the root ExpressionCompiler . In order for this to work, it is imperative that the underlying registered target implements the ICompiledTarget interface - so as to avoid needing a (or, more precisely, this) compiler needing to compile it. Explicit Interface Implementations | Improve this Doc IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Explicit implementation of Build(ITarget, IExpressionCompileContext, IExpressionCompiler) - ultimately forwards the call to the BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) function. Declaration Expression IExpressionBuilder.Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ITarget target The target for which an expression is to be built IExpressionCompileContext context The compilation context. IExpressionCompiler compiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the implementation attempts to locate the context compiler using the GetContextCompiler(IExpressionCompileContext) method, and will throw an InvalidOperationException if it cannot do so. Returns Type Description Expression Implements Exceptions Type Condition ArgumentNullException target is null or context is null InvalidOperationException compiler is null and an IExpressionCompiler couldn't be resolved for the current context (via GetContextCompiler(IExpressionCompileContext) See Also IExpressionBuilder"
  },
  "rezolver-api/Rezolver.IContainerRezolveExtensions.html": {
    "href": "rezolver-api/Rezolver.IContainerRezolveExtensions.html",
    "title": "Class IContainerRezolveExtensions",
    "keywords": "Class IContainerRezolveExtensions Extension methods for IContainer which provide shortcuts for the Resolve(ResolveContext) operation. Inheritance Object IContainerRezolveExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class IContainerRezolveExtensions Methods | Improve this Doc Resolve(IContainer, Type) Resolves an object of the given type Declaration public static object Resolve(this IContainer container, Type type) Parameters Type Name Description IContainer container The container. Type type The type to be resolved. Returns Type Description Object An instance of the type . | Improve this Doc Resolve(IContainer, Type, IScopedContainer) Resolves an object of the given type , using the given lifetime scope for lifetime management. Declaration public static object Resolve(this IContainer container, Type type, IScopedContainer scope) Parameters Type Name Description IContainer container The container. Type type Type to be resolved. IScopedContainer scope The lifetime scope - can be a different instance to container (or the object on which the method is invoked if invoked as an extension method), e.g. when a master container instance is used to create a child 'scope' which has a different lifetime to that of the master. Returns Type Description Object An instance of the requested type . | Improve this Doc Resolve<TObject>(IContainer) Resolves an object of type TObject Declaration public static TObject Resolve<TObject>(this IContainer container) Parameters Type Name Description IContainer container The container. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject The type to be resolved. | Improve this Doc Resolve<TObject>(IContainer, IScopedContainer) Resolves an object of the type TObject , using the given lifetime scope for lifetime management. Declaration public static TObject Resolve<TObject>(this IContainer container, IScopedContainer scope) Parameters Type Name Description IContainer container The container. IScopedContainer scope The lifetime scope - can be a different instance to container (or the object on which the method is invoked if invoked as an extension method), e.g. when a master container instance is used to create a child 'scope' which has a different lifetime to that of the master. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject Type to be resolved. | Improve this Doc TryResolve(IContainer, Type, IScopedContainer, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer container, Type type, IScopedContainer scope, out object result) Parameters Type Name Description IContainer container The container. Type type The type to be resolved. IScopedContainer scope The lifetime scope - can be a different instance to container (or the object on which the method is invoked if invoked as an extension method), e.g. when a master container instance is used to create a child 'scope' which has a different lifetime to that of the master. Object result Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type, IScopedContainer) overloads | Improve this Doc TryResolve(IContainer, Type, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer container, Type type, out object result) Parameters Type Name Description IContainer container The container. Type type The type to be resolved. Object result Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type) overloads | Improve this Doc TryResolve<TObject>(IContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer container, out TObject result) Parameters Type Name Description IContainer container The container. TObject result Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved. | Improve this Doc TryResolve<TObject>(IContainer, IScopedContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer container, IScopedContainer scope, out TObject result) Parameters Type Name Description IContainer container The container. IScopedContainer scope The lifetime scope - can be a different instance to container (or the object on which the method is invoked if invoked as an extension method), e.g. when a master container instance is used to create a child 'scope' which has a different lifetime to that of the master. TObject result Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved."
  },
  "rezolver-api/Rezolver.IContainerScope.html": {
    "href": "rezolver-api/Rezolver.IContainerScope.html",
    "title": "Interface IContainerScope",
    "keywords": "Interface IContainerScope This is an IContainer -like object (resolving functionality is provided through the extension methods in the ContainerScopeResolveExtensions class) which Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IContainerScope : IDisposable, IServiceProvider Properties | Improve this Doc Container The container that this scope is tied to. All standard resolve operations should be made against this container to begin with. Declaration IContainer Container { get; } Property Value Type Description IContainer | Improve this Doc Parent If this scope has a parent scope, this is it. Declaration IContainerScope Parent { get; } Property Value Type Description IContainerScope Methods | Improve this Doc ChildScopeDisposed(IContainerScope) Called by child scopes when they are disposed to notify the parent that they will no longer need to be disposed of when the parent is disposed. Declaration void ChildScopeDisposed(IContainerScope child) Parameters Type Name Description IContainerScope child Remarks This is an infrastructure method and not something you would usually need to call. It's exposed for developers who are extending the container scoping functionality only. | Improve this Doc CreateScope() Called to create a child scope from this scope. Declaration IContainerScope CreateScope() Returns Type Description IContainerScope | Improve this Doc Resolve(ResolveContext, Func<ResolveContext, Object>, ScopeBehaviour) Execute the given object factory within this scope. Depending on the scoping behaviour passed, the object will either be resolved directly from the scope (i.e. existing objects contained within it) or obtained by executing the factory and optionally tracking the object if it's IDisposable. Declaration object Resolve(ResolveContext context, Func<ResolveContext, object> factory, ScopeBehaviour behaviour) Parameters Type Name Description ResolveContext context The resolve context - please note that the container that's present on this is the actual container that should be used to resolve objects Func < ResolveContext , Object > factory The factory to be executed ScopeBehaviour behaviour Returns Type Description Object Remarks This function is the primary workhorse of all scopes. Most importantly, the object produced from the factory DOES NOT have to come from this scope's Container - the implementing type simply has to ensure that it tracks whatever object is ultimately returned; potentially returning a previously tracked object if behaviour is Explicit See Also IDisposable IServiceProvider"
  },
  "rezolver-api/Rezolver.IMemberBindingBehaviour.html": {
    "href": "rezolver-api/Rezolver.IMemberBindingBehaviour.html",
    "title": "Interface IMemberBindingBehaviour",
    "keywords": "Interface IMemberBindingBehaviour Describes a type which discovers and creates property/field bindings, typically for use when creating a new instance. Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IMemberBindingBehaviour Remarks The default implementation of this is DefaultMemberBindingBehaviour , which always binds all publicly writable instance properties and publicly accessible instance fields to auto-generated targets. Methods | Improve this Doc GetMemberBindings(ICompileContext, Type) Retrieves the property and/or field bindings for the given type based on the given context . Declaration MemberBinding[] GetMemberBindings(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The current compilation context (will be used to look up ITarget references from its implementation of ITargetContainer Type type The type whose writable members are to be probed. Returns Type Description MemberBinding [] Zero or more bindings for the members of the type ."
  },
  "rezolver-api/Rezolver.IPropertyBindingBehaviour.html": {
    "href": "rezolver-api/Rezolver.IPropertyBindingBehaviour.html",
    "title": "Interface IPropertyBindingBehaviour",
    "keywords": "Interface IPropertyBindingBehaviour Describes a type which discovers property/field bindings Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IPropertyBindingBehaviour Methods | Improve this Doc GetPropertyBindings(CompileContext, Type) Retrieves the property and/or field bindings for the given type based on the given CompileContext Declaration PropertyOrFieldBinding[] GetPropertyBindings(CompileContext context, Type type) Parameters Type Name Description CompileContext context Type type Returns Type Description PropertyOrFieldBinding []"
  },
  "rezolver-api/Rezolver.IRezolverExtensions.html": {
    "href": "rezolver-api/Rezolver.IRezolverExtensions.html",
    "title": "Class IRezolverExtensions",
    "keywords": "Class IRezolverExtensions Inheritance Object IRezolverExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class IRezolverExtensions Methods | Improve this Doc Register(IContainer, ITarget, Type) Wrapper for the Register(ITarget, Type) method of the rezolver argument's Rezolver.IContainer.Builder Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void Register(this IContainer rezolver, ITarget target, Type type = null) Parameters Type Name Description IContainer rezolver ITarget target Type type | Improve this Doc RegisterAll(IContainer, ITarget[]) Parameter array version of the RegisterAll method. Declaration public static void RegisterAll(this IContainer rezolver, params ITarget[] targets) Parameters Type Name Description IContainer rezolver The rezolver. ITarget [] targets The targets. | Improve this Doc RegisterAll(IContainer, IEnumerable<ITarget>) Batch-registers multiple targets with different contracts. Basically, this is like calling Register(IRezolveTarget) multiple times, but with an enumerable. Declaration public static void RegisterAll(this IContainer rezolver, IEnumerable<ITarget> targets) Parameters Type Name Description IContainer rezolver IEnumerable < ITarget > targets | Improve this Doc RegisterExpression<T>(IContainer, Expression<Func<RezolveContextExpressionHelper, T>>, Type, ITargetAdapter) Wrapper for the , please see that method for the reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterExpression<T>(this IContainer rezolver, Expression<Func<RezolveContextExpressionHelper, T>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description IContainer rezolver The rezolver. Expression < Func < RezolveContextExpressionHelper , T>> expression Type type ITargetAdapter adapter Type Parameters Name Description T | Improve this Doc RegisterMultiple(IContainer, IEnumerable<ITarget>, Type) Wrapper for the RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterMultiple(this IContainer rezolver, IEnumerable<ITarget> targets, Type commonServiceType = null) Parameters Type Name Description IContainer rezolver The rezolver. IEnumerable < ITarget > targets Type commonServiceType | Improve this Doc RegisterObject<T>(IContainer, T, Type, Boolean) Wrapper for the RegisterObject<T>(ITargetContainer, T, Type, Boolean) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterObject<T>(this IContainer rezolver, T obj, Type type = null, bool suppressScopeTracking = true) Parameters Type Name Description IContainer rezolver The rezolver. T obj Type type Boolean suppressScopeTracking Type Parameters Name Description T | Improve this Doc RegisterScoped(IContainer, Type, Type, IPropertyBindingBehaviour) Wrapper for the , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterScoped(this IContainer rezolver, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description IContainer rezolver Type objectType Type serviceType IPropertyBindingBehaviour propertyBindingBehaviour | Improve this Doc RegisterScoped<TObject>(IContainer, IPropertyBindingBehaviour) Wrapper for the RegisterScoped<TObject>(ITargetContainer, IPropertyBindingBehaviour) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterScoped<TObject>(this IContainer rezolver, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description IContainer rezolver IPropertyBindingBehaviour propertyBindingBehaviour Type Parameters Name Description TObject | Improve this Doc RegisterScoped<TObject, TService>(IContainer, IPropertyBindingBehaviour) Wrapper for the RegisterScoped<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterScoped<TObject, TService>(this IContainer rezolver, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description IContainer rezolver IPropertyBindingBehaviour propertyBindingBehaviour Type Parameters Name Description TObject TService | Improve this Doc RegisterType(IContainer, Type, Type, IPropertyBindingBehaviour) Wrapper for the RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterType(this IContainer rezolver, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description IContainer rezolver Type objectType Type serviceType IPropertyBindingBehaviour propertyBindingBehaviour | Improve this Doc RegisterType<TObject>(IContainer, IPropertyBindingBehaviour) Wrapper for the RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) , please see that method for reference for the parameters. Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterType<TObject>(this IContainer rezolver, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description IContainer rezolver The rezolver. IPropertyBindingBehaviour propertyBindingBehaviour The property binding behaviour. Type Parameters Name Description TObject Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via their 'Auto' static methods and then registering them. | Improve this Doc RegisterType<TObject, TService>(IContainer, IPropertyBindingBehaviour) Wrapper for the , please see that method for reference for the parameters Note - the rezolver must have a non-null Rezolver.IContainer.Builder in order for this extension method to work. Declaration public static void RegisterType<TObject, TService>(this IContainer rezolver, IPropertyBindingBehaviour propertyBindingBehaviour = null)where TObject : TService Parameters Type Name Description IContainer rezolver IPropertyBindingBehaviour propertyBindingBehaviour Type Parameters Name Description TObject TService | Improve this Doc Resolve(IContainer, Type) Resolves an object of the given type Declaration public static object Resolve(this IContainer rezolver, Type type) Parameters Type Name Description IContainer rezolver The rezolver. Type type The type to be resolved. Returns Type Description Object An instance of the type . | Improve this Doc Resolve(IContainer, Type, IScopedContainer) Resolves an object of the given type , using the given lifetime scope for lifetime management. Declaration public static object Resolve(this IContainer rezolver, Type type, IScopedContainer scope) Parameters Type Name Description IContainer rezolver The rezolver. Type type Type to be resolved. IScopedContainer scope The lifetime scope - can be a different instance to rezolver (or the object on which the method is invoked if invoked as an extension method), e.g. when a master rezolver instance is used to create a child 'scope' which has a different lifetime to that of the master. Returns Type Description Object An instance of the requested type . | Improve this Doc Resolve<TObject>(IContainer) Resolves an object of type TObject Declaration public static TObject Resolve<TObject>(this IContainer rezolver) Parameters Type Name Description IContainer rezolver The rezolver. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject The type to be resolved. | Improve this Doc Resolve<TObject>(IContainer, IScopedContainer) Resolves an object of the type TObject , using the given lifetime scope for lifetime management. Declaration public static TObject Resolve<TObject>(this IContainer rezolver, IScopedContainer scope) Parameters Type Name Description IContainer rezolver The rezolver. IScopedContainer scope The lifetime scope - can be a different instance to rezolver (or the object on which the method is invoked if invoked as an extension method), e.g. when a master rezolver instance is used to create a child 'scope' which has a different lifetime to that of the master. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject Type to be resolved. | Improve this Doc TryResolve(IContainer, Type, IScopedContainer, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer rezolver, Type type, IScopedContainer scope, out object result) Parameters Type Name Description IContainer rezolver The rezolver. Type type The type to be resolved. IScopedContainer scope The lifetime scope - can be a different instance to rezolver (or the object on which the method is invoked if invoked as an extension method), e.g. when a master rezolver instance is used to create a child 'scope' which has a different lifetime to that of the master. Object result Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type, IScopedContainer) overloads | Improve this Doc TryResolve(IContainer, Type, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer rezolver, Type type, out object result) Parameters Type Name Description IContainer rezolver The rezolver. Type type The type to be resolved. Object result Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type) overloads | Improve this Doc TryResolve<TObject>(IContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer rezolver, out TObject result) Parameters Type Name Description IContainer rezolver The rezolver. TObject result Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved. | Improve this Doc TryResolve<TObject>(IContainer, IScopedContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer rezolver, IScopedContainer scope, out TObject result) Parameters Type Name Description IContainer rezolver The rezolver. IScopedContainer scope The lifetime scope - can be a different instance to rezolver (or the object on which the method is invoked if invoked as an extension method), e.g. when a master rezolver instance is used to create a child 'scope' which has a different lifetime to that of the master. TObject result Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved."
  },
  "rezolver-api/Rezolver.IRezolveTargetScopingExtensions.html": {
    "href": "rezolver-api/Rezolver.IRezolveTargetScopingExtensions.html",
    "title": "Class IRezolveTargetScopingExtensions",
    "keywords": "Class IRezolveTargetScopingExtensions Extension method(s) to convert targets into scoped targets. Inheritance Object IRezolveTargetScopingExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class IRezolveTargetScopingExtensions Methods | Improve this Doc Scoped(ITarget) Creates a ScopedTarget from the target on which this method is invoked. Declaration public static ScopedTarget Scoped(this ITarget target) Parameters Type Name Description ITarget target Returns Type Description ScopedTarget"
  },
  "rezolver-api/Rezolver.IRezolveTargetSingletonExtensions.html": {
    "href": "rezolver-api/Rezolver.IRezolveTargetSingletonExtensions.html",
    "title": "Class IRezolveTargetSingletonExtensions",
    "keywords": "Class IRezolveTargetSingletonExtensions Extension method(s) to convert targets into singleton targets. Inheritance Object IRezolveTargetSingletonExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class IRezolveTargetSingletonExtensions Methods | Improve this Doc Singleton(ITarget) Constructs a SingletonTarget that wraps the target on which the method is invoked. Declaration public static SingletonTarget Singleton(this ITarget target) Parameters Type Name Description ITarget target Returns Type Description SingletonTarget"
  },
  "rezolver-api/Rezolver.IScopedContainer.html": {
    "href": "rezolver-api/Rezolver.IScopedContainer.html",
    "title": "Interface IScopedContainer",
    "keywords": "Interface IScopedContainer An IContainer that also has a Scope attached to it. Many applications will use such a container as the root container to use as anchors for things like scoped singletons. Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IScopedContainer : IContainer, IServiceProvider, IDisposable Properties | Improve this Doc Scope Gets the scope for this scoped container. Note that this is used automatically by the container for Resolve(ResolveContext) operations where the Scope property is not already set. Declaration IContainerScope Scope { get; } Property Value Type Description IContainerScope See Also IContainer IDisposable"
  },
  "rezolver-api/Rezolver.ITarget.html": {
    "href": "rezolver-api/Rezolver.ITarget.html",
    "title": "Interface ITarget",
    "keywords": "Interface ITarget Represents an action to be performed in order to obtain an object to satisfy a call to Resolve(ResolveContext) , when the standard implementations of IContainer are used (e.g. Container ). Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITarget Remarks As mentioned in the summary, the role of this interface is largely determined by the framework's own standard implementations of the IContainer interface - all of which use an ITargetContainer to store service registrations which, when Resolve(ResolveContext) is called, is queried to obtain one or more targets which will have been registered for the requested type. After obtaining a target, an ITargetCompiler is then used to compile the target(s) into an ICompiledTarget whose GetObject(ResolveContext) method will ultimately then be called to 'resolve' the instance. The role of the target, then, is to act as a description of the action that is to be performed by that compiled target that is built from it. The interface doesn't describe the type of target in hand - it only provides the core data required to query the static type of the target (the type of object that the target will produce) and to determine compatibility with a request for a particular type. The framework's many implementations of this interface - e.g. , , plus many others - then define the behaviour and any additional data required in order for a compiler to produce an ICompiledTarget which matches the target's intent. E.g, the , which represents creating a new instance via a constructor, provides all the necessary information to bind to the correct constructor (including parameter bindings etc) - and the compiler's job is to translate that into an ICompiledTarget which executes that constructor, returning the result. Properties | Improve this Doc DeclaredType Gets the static type of the object produced from this target. For example, if this target represents executing a constructor on a type, then this property should equal the type to which that constructor belongs. Declaration Type DeclaredType { get; } Property Value Type Description Type | Improve this Doc ScopeBehaviour Gets the scoping behaviour for instances that will ultimately be produced by this target. Declaration ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. | Improve this Doc UseFallback If true , then the consumer should consider falling back to a more suitable target if available, as the object produced from this target is most likely a default of some kind - e.g. empty enumerable, default parameter value. Declaration bool UseFallback { get; } Property Value Type Description Boolean Methods | Improve this Doc SelectScope(ResolveContext) Selects the scope in which instances produced from this target should be tracked. This should be executed only during a resolve operation when a scope is detected. Declaration IContainerScope SelectScope(ResolveContext context) Parameters Type Name Description ResolveContext context The context passed to a container's Resolve(ResolveContext) method. Returns Type Description IContainerScope | Improve this Doc SupportsType(Type) Returns a boolean indicating whether the target is able to produce an instance of, or an instance that is compatible with, the passed type . Declaration bool SupportsType(Type type) Parameters Type Name Description Type type The type. Returns Type Description Boolean true if type is supported, false otherwise. Remarks It is strongly suggested that you use this method to check whether the target can construct an instance of a given type rather than performing any type checking yourself on the DeclaredType , because an ITarget might be able to support a much wider range of types other than just those which are directly compatible with its DeclaredType . For example, the is statically bound to an open generic, so therefore traditional type checks on the DeclaredType do not work. That class' implementation of this method, however, contains the complex logic necessary to determine if the open generic can be closed into a generic type which is compatible with the given type . Implementations of ITargetCompiler should always consult this function in their implementation of CompileTarget(ITarget, ICompileContext) to determine if the target is compatible with the TargetType of the CompileContext Please note that any type that's a generic type definition will always yield a false result, because it's impossible to build an instance of an open generic type."
  },
  "rezolver-api/Rezolver.ITargetAdapter.html": {
    "href": "rezolver-api/Rezolver.ITargetAdapter.html",
    "title": "Interface ITargetAdapter",
    "keywords": "Interface ITargetAdapter Interface for an object that can convert Expressions into ITarget s suitable for registration in an ITargetContainer Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITargetAdapter Remarks If you are considering manually creating an ExpressionTarget for an expression, then you should consider instead using an implementation of this interface to produce an ITarget for that expression. For example, the TargetAdapter class supplied by the framework, has the ability to convert some common code constructs into specific types of targets so as to properly leverage the power of the Rezolver framework at runtime. That class also has the ability to translate a whole lambda expression into a target, including converting any parameters for that lambda into injected variables. Methods | Improve this Doc CreateTarget(Expression) Declaration ITarget CreateTarget(Expression expression) Parameters Type Name Description Expression expression Returns Type Description ITarget"
  },
  "rezolver-api/Rezolver.ITargetCompiler.html": {
    "href": "rezolver-api/Rezolver.ITargetCompiler.html",
    "title": "Interface ITargetCompiler",
    "keywords": "Interface ITargetCompiler An object that produces ICompiledTarget s from ITarget s given a particular CompileContext . Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITargetCompiler Methods | Improve this Doc CompileTarget(ITarget, CompileContext) Create the ICompiledTarget for the given target using the context to inform the type of object that is to be built, and for compile-time dependency resolution. Declaration ICompiledTarget CompileTarget(ITarget target, CompileContext context) Parameters Type Name Description ITarget target Required. The target to be compiled. CompileContext context Required. The current compilation context. Returns Type Description ICompiledTarget A compiled target which can then be used to get produce objects represented by the target ."
  },
  "rezolver-api/Rezolver.ITargetContainer.html": {
    "href": "rezolver-api/Rezolver.ITargetContainer.html",
    "title": "Interface ITargetContainer",
    "keywords": "Interface ITargetContainer Stores and retrieves ITarget instances, keyed by the type of service that the targets are registered against. This is where all your service registrations will ultimately go. Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITargetContainer Remarks You do not resolve objects from a target container, instead, it holds the ITarget s which will later be compiled to produce the objects. A target container is considered mutable for its entire lifetime, because it's only a glorified dictionary of targets from which multiple IContainer objects can be built (when using the types provided in the framework). As an example, the Container class uses this as the source of the registrations that it uses to resolve objects in its Resolve(ResolveContext) implementation. Note that there are multiple implementations of this interface in the framework, however the two you will use most commonly are TargetContainer and ChildTargetContainer . Methods | Improve this Doc CombineWith(ITargetContainer, Type) If supported by the implementation, this gets the container built from combining this container with an existing container as part of a registration inside another ITargetContainerOwner . Declaration ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing The existing ITargetContainer instance that this instance is to be combined with Type type The type that the combined container owner will be registered under. Returns Type Description ITargetContainer Remarks Used most frequently in implementations of RegisterContainer(Type, ITargetContainer) when a container owner is already registered against the type, and a new container owner is then registered against the same type. This behaviour is used to implement open generics and decorators, and can be used to implement more besides. Exceptions Type Condition NotSupportedException If this container doesn't support being combined with another. | Improve this Doc Fetch(Type) Retrieves a target for a particular type, or null if no target is registered against that type. Declaration ITarget Fetch(Type type) Parameters Type Name Description Type type Required. The type for which an ITarget is to be retrieved. Returns Type Description ITarget The target for the given type , or null if no target is found. Remarks The target you receive from this method depends entirely on the implementation. It could be the last target to be registered against the type or the first, or another target entirely. As mentioned in the documentation for the Register(ITarget, Type) method - the only guarantee is that if at least one target has been registered for the same type, then this method should return a valid target. | Improve this Doc FetchAll(Type) Retrieves an enumerable of all targets that have been registered for a particular type . Declaration IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type Required. The type for which the ITarget s are to be retrieved. Returns Type Description IEnumerable < ITarget > An enumerable containing all the targets that have been registered against the given type , or, an empty enumerable if no targets have been registered. Remarks As with Fetch(Type) , the only guarantee is that if a target has been registered for the type through a call to Register(ITarget, Type) , then the returned enumerable will contain at least one valid target. | Improve this Doc Register(ITarget, Type) Registers a target, either for the serviceType specified or, if null, the DeclaredType of the target . Declaration void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target Required. The target to be registered Type serviceType Optional. The type the target is to be registered against, if different from the DeclaredType of the target . If provided, then the target must be compatible with this type. Remarks The interface does not define the behaviour for when multiple targets are registered against the same type - although the default behaviour of the framework (via the TargetContainer class) is to allow this, with the last registered target being treated as the 'default' for that type. The only guarantee expected by the framework from implementations of this interface is that if a target is registered against a given type with this method, then a Fetch(Type) operation with the same type should return a valid target, and a FetchAll(Type) operation should return a non-empty enumerable of targets. Exceptions Type Condition ArgumentException If serviceType is non-null and the target 's SupportsType(Type) method returns false for that type."
  },
  "rezolver-api/Rezolver.ITargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.ITargetContainerExtensions.html",
    "title": "Class ITargetContainerExtensions",
    "keywords": "Class ITargetContainerExtensions Extension methods for implementations of ITargetContainer . Inheritance Object ITargetContainerExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ITargetContainerExtensions Methods | Improve this Doc RegisterAlias(ITargetContainer, Type, Type) Registers an alias for one type to another type. The created entry will effectively represent a second Resolve call into the container for the aliased type. Declaration public static void RegisterAlias(this ITargetContainer builder, Type aliasType, Type aliasedType) Parameters Type Name Description ITargetContainer builder The builder in which the alias is to be registered Type aliasType The type to be registered as an alias Type aliasedType The type being aliased. Remarks Use this when it's important that a given target type is always served through the same compiled target, even when the consumer expects it to be of a different type. A very common scenario is when you have a singleton instance of the aliasedType , and need to serve that same instance for aliasType . If you register the same singleton for both types, you get two separate singletons for each type. | Improve this Doc RegisterAlias<TAlias, TAliased>(ITargetContainer) Generic version of , see that method for more. Declaration public static void RegisterAlias<TAlias, TAliased>(this ITargetContainer builder) Parameters Type Name Description ITargetContainer builder RegisterAlias<TAlias, TAliased>(ITargetContainer) Type Parameters Name Description TAlias Type being registered as an alias to another type TAliased The target type of the alias. | Improve this Doc RegisterAll(ITargetContainer, ITarget[]) Batch-registers multiple targets with different contracts. This is like calling multiple times, once for each of the targets in the array. Declaration public static void RegisterAll(this ITargetContainer builder, params ITarget[] targets) Parameters Type Name Description ITargetContainer builder The builder. ITarget [] targets The targets to be registered. | Improve this Doc RegisterAll(ITargetContainer, IEnumerable<ITarget>) Batch-registers multiple targets with different contracts. This is like calling multiple times, once for each of the targets in the enumerable. Declaration public static void RegisterAll(this ITargetContainer builder, IEnumerable<ITarget> targets) Parameters Type Name Description ITargetContainer builder The builder. IEnumerable < ITarget > targets The targets to be registered | Improve this Doc RegisterDecorator(ITargetContainerOwner, Type, Type) Declaration public static void RegisterDecorator(this ITargetContainerOwner builder, Type decoratorType, Type decoratedType) Parameters Type Name Description ITargetContainerOwner builder Type decoratorType Type decoratedType | Improve this Doc RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) Declaration public static void RegisterDecorator<TDecorator, TDecorated>(this ITargetContainerOwner builder) Parameters Type Name Description ITargetContainerOwner builder Type Parameters Name Description TDecorator TDecorated | Improve this Doc RegisterExpression<T>(ITargetContainer, Expression<Func<RezolveContextExpressionHelper, T>>, Type, ITargetAdapter) Registers an expression to be used as a factory for obtaining an instance when the registration matches a resolve request. Declaration public static void RegisterExpression<T>(this ITargetContainer builder, Expression<Func<RezolveContextExpressionHelper, T>> expression, Type type = null, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer builder Expression < Func < RezolveContextExpressionHelper , T>> expression The expression to be analysed and used as a factory. The argument that is received by this expression can be used to emit explicit calls back into the resolver to indicate that a particular argument/property value or whatever should be resolved. Type type Optional. The type against which the registration is to be made, if different from T . ITargetAdapter adapter Optional. The adapter that will be used to convert the expression into an ITarget . This defaults to Default . Extending this is an advanced topic and shouldn't be required in most cases. Type Parameters Name Description T Remarks This is not the same as registering a factory delegate for creating objects - where the code you supply is already compiled and ready to go. The expression that is passed is analysed by the adapter (or the default) and rewritten according to the expressions container within. In general, there is a one to one mapping between the code you provide and the code that's produced, but it's not guaranteed. In particular, calls back to the resolver to resolve dependencies are identified and turned into a different representation internally, so that dependency resolution works inside your code in just the same way as it does when using the higher-level targets. | Improve this Doc RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) Called to register multiple rezolve targets against a shared contract, optionally replacing any existing registration(s) or extending them. It is analogous to calling Register(ITarget, Type) multiple times with the different targets. Declaration public static void RegisterMultiple(this ITargetContainer builder, IEnumerable<ITarget> targets, Type commonServiceType = null) Parameters Type Name Description ITargetContainer builder The builder in which the registration is to be performed. IEnumerable < ITarget > targets The targets to be registered - all must support a common service type (potentially passed in the commonServiceType argument. Type commonServiceType Optional - instead of determining the common service type automatically, you can provide it in advance through this parameter. Note that all targets must support this type. | Improve this Doc RegisterObject<T>(ITargetContainer, T, Type, Boolean) Registers a single instance (already created) to be used when resolving a particular service type. If using a scope, then the object will be tracked in the rootmost scope so that, if it's disposable, it will be disposed when the root scope is disposed. Declaration public static void RegisterObject<T>(this ITargetContainer builder, T obj, Type serviceType = null, bool suppressScopeTracking = true) Parameters Type Name Description ITargetContainer builder T obj The object to be returned when resolving. Type serviceType The service type against which this object is to be registered, if different from T . Boolean suppressScopeTracking Type Parameters Name Description T Type of the object - will be used as the service type for registration if serviceType is not provied. | Improve this Doc RegisterScoped(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Version of RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) that creates instances that are scoped to the active IScopedContainer at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) (or TryResolve(RezolveContext, Object) ) is called. Declaration public static void RegisterScoped(this ITargetContainer builder, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer builder Type objectType RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Type serviceType RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) IPropertyBindingBehaviour propertyBindingBehaviour RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) | Improve this Doc RegisterScoped<TObject>(ITargetContainer, IPropertyBindingBehaviour) Version of RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) that creates instances that are scoped to the active IScopedContainer at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) (or TryResolve(RezolveContext, Object) ) is called. Declaration public static void RegisterScoped<TObject>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer builder IPropertyBindingBehaviour propertyBindingBehaviour See RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) | Improve this Doc RegisterScoped<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Version of RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) that creates instances that are scoped to the active IScopedContainer at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) (or TryResolve(RezolveContext, Object) ) is called. Declaration public static void RegisterScoped<TObject, TService>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer builder IPropertyBindingBehaviour propertyBindingBehaviour See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) TService See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) | Improve this Doc RegisterSingleton(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Version of RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) that creates singleton instances that are also scoped to the root scope of the active IScopedContainer at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) (or TryResolve(RezolveContext, Object) ) is called. Declaration public static void RegisterSingleton(this ITargetContainer builder, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer builder Type objectType RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Type serviceType RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) IPropertyBindingBehaviour propertyBindingBehaviour RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) | Improve this Doc RegisterSingleton<TObject>(ITargetContainer, IPropertyBindingBehaviour) Version of RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) that creates singleton instances that are also scoped to the root scope of the active IScopedContainer at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) (or TryResolve(RezolveContext, Object) ) is called. Declaration public static void RegisterSingleton<TObject>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer builder IPropertyBindingBehaviour propertyBindingBehaviour See RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) | Improve this Doc RegisterSingleton<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Version of RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) that creates singleton instances that are also scoped to the root scope of the active IScopedContainer at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) (or TryResolve(RezolveContext, Object) ) is called. Declaration public static void RegisterSingleton<TObject, TService>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer builder IPropertyBindingBehaviour propertyBindingBehaviour See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) TService See RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) | Improve this Doc RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Non-generic version of RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) . Declaration public static void RegisterType(this ITargetContainer targets, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targets Type objectType Required. Type of object to be constructed Type serviceType See Register(ITarget, Type) IPropertyBindingBehaviour propertyBindingBehaviour RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) | Improve this Doc RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) Registers a type to be created by the Rezolver via construction. The registration will auto-bind a constructor (most greedy) on the type and optionally bind any properties/fields on the new object, depending on the IPropertyBindingBehaviour object passed. Note that this method supports open generics. Declaration public static void RegisterType<TObject>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer builder IPropertyBindingBehaviour propertyBindingBehaviour The property binding behaviour. If null, then no properties are bound. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via their 'Auto' static methods and then registering them. | Improve this Doc RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) This is the same as RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) , except the TService type parameter allows you to explicitly set the type against which the registration is to be made. Declaration public static void RegisterType<TObject, TService>(this ITargetContainer builder, IPropertyBindingBehaviour propertyBindingBehaviour = null)where TObject : TService Parameters Type Name Description ITargetContainer builder IPropertyBindingBehaviour propertyBindingBehaviour RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) Type Parameters Name Description TObject See RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) TService The type against which the registration is to be made in the builder. E.g. 'IFoo' when TObject is 'Foo'. Remarks Please note the generic parameter constraints on this method: TService must have TObject as a base or interface in order for your code to compile. Note that if you use the RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) overload, then this is not the case."
  },
  "rezolver-api/Rezolver.ITargetContainerMSDIExtensions.html": {
    "href": "rezolver-api/Rezolver.ITargetContainerMSDIExtensions.html",
    "title": "Class ITargetContainerMSDIExtensions",
    "keywords": "Class ITargetContainerMSDIExtensions Inheritance Object ITargetContainerMSDIExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ITargetContainerMSDIExtensions Methods | Improve this Doc Populate(ITargetContainer, IServiceCollection) Declaration public static void Populate(this ITargetContainer targets, IServiceCollection services) Parameters Type Name Description ITargetContainer targets IServiceCollection services"
  },
  "rezolver-api/Rezolver.ITargetContainerOwner.html": {
    "href": "rezolver-api/Rezolver.ITargetContainerOwner.html",
    "title": "Interface ITargetContainerOwner",
    "keywords": "Interface ITargetContainerOwner Interface for an ITargetContainer which also contains other target containers. It is not typically used by your application code since it's primarily an infrastructure interface - if you are extending the API, however, then you might need to work with it. Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ITargetContainerOwner : ITargetContainer Remarks This interface, its implementations and everything else associated with it, is at the heart of functionality such as open generics, automatic enumerables and decorators. Methods | Improve this Doc FetchContainer(Type) Retrieves an existing container registered against the given type , or null if not found. Declaration ITargetContainer FetchContainer(Type type) Parameters Type Name Description Type type Returns Type Description ITargetContainer | Improve this Doc RegisterContainer(Type, ITargetContainer) Registers a container against a given type . If a container already exists against this type, then the existing container's CombineWith(ITargetContainer, Type) method is called with the container as the argument, and the resulting container will replace the existing one. Declaration void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container"
  },
  "rezolver-api/Rezolver.LifetimeScopeRezolverExtensions.html": {
    "href": "rezolver-api/Rezolver.LifetimeScopeRezolverExtensions.html",
    "title": "Class LifetimeScopeRezolverExtensions",
    "keywords": "Class LifetimeScopeRezolverExtensions Inheritance Object LifetimeScopeRezolverExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class LifetimeScopeRezolverExtensions Methods | Improve this Doc GetOrAdd<T>(IScopedContainer, RezolveContext, Func<RezolveContext, T>, Boolean) Declaration public static T GetOrAdd<T>(this IScopedContainer scope, RezolveContext context, Func<RezolveContext, T> factory, bool disposableOnly = true) Parameters Type Name Description IScopedContainer scope RezolveContext context Func < RezolveContext , T> factory Boolean disposableOnly Returns Type Description T Type Parameters Name Description T | Improve this Doc GetScopeRoot(IScopedContainer) As the name suggests - this grabs the root scope for the scope on which this method is invoked. Declaration public static IScopedContainer GetScopeRoot(this IScopedContainer scope) Parameters Type Name Description IScopedContainer scope The scope whose root scope is sought. If null, then the method also returns null. Returns Type Description IScopedContainer An IScopedContainer reference representing the top-level (root) scope for the passed scope. | Improve this Doc GetSingleFromScope(IScopedContainer, RezolveContext) Retrieves a single instance that was previously added to the scope (or, optionally parent scopes) through a call to AddToScope(Object, RezolveContext) with a RezolveContext matching the one passed. Note - if multiple matches are found in a single scope, an InvalidOperationException will be thrown. Declaration public static object GetSingleFromScope(this IScopedContainer scope, RezolveContext context) Parameters Type Name Description IScopedContainer scope Required. The scope to be searched and optionally whose parent scopes are to be searched. RezolveContext context Required. The context whose properties will be used to find the matching disposable. Returns Type Description Object | Improve this Doc TrackIfScopedAndDisposableAndReturn<T>(IScopedContainer, T) This is primarily used by the dynamic code generated by RezolveTargetBase - if the scope is non-null and the instance is an IDiposable, then the object will be added to the scope. The instance , either way, is returned to simplify the function's use in dynamic code produced from expression trees. Declaration public static T TrackIfScopedAndDisposableAndReturn<T>(this IScopedContainer scope, T instance) Parameters Type Name Description IScopedContainer scope T instance Returns Type Description T Type Parameters Name Description T"
  },
  "rezolver-api/Rezolver.ListTarget.html": {
    "href": "rezolver-api/Rezolver.ListTarget.html",
    "title": "Class ListTarget",
    "keywords": "Class ListTarget This target produces arrays ( AsArray = true ) or lists ( AsArray = false ) whose individual items are built by ITarget instances. Primarily used by the Rezolver.EnumerableTargetContainer and the configuration framework, but can also be used by your code. Inheritance Object TargetBase ListTarget Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ListTarget : TargetBase, ITarget Remarks The element type you feed on construction determines the type of array or the generic argument to List<T>. Each of the rezolve targets that you then pass must support that type. Constructors | Improve this Doc ListTarget(Type, IEnumerable<ITarget>, Boolean) Initializes a new instance of the ListTarget class. Declaration public ListTarget(Type elementType, IEnumerable<ITarget> items, bool asArray = false) Parameters Type Name Description Type elementType Required. Type of the elements in the array or list. IEnumerable < ITarget > items Required. The targets that will create each the individual items. Boolean asArray A boolean indicating whether the target will build an array ( true ) or a list ( false ). Exceptions Type Condition ArgumentNullException elementType or items ArgumentException All targets in the items enumerable must be non-null;items or All targets in the items enumerable must support the element type elementType Properties | Improve this Doc AsArray Gets a value indicating whether the target will build an array ( true ) or a list ( false ). Declaration public bool AsArray { get; } Property Value Type Description Boolean | Improve this Doc DeclaredType Implementation of the abstract property from the base. This will always return either a type equal to an array of ElementType , or List<T> with ElementType as the generic parameter. This is controlled by the AsArray property. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc ElementType Gets the declared type of each element in the array or list that will be constructed. The DeclaredType returned by this instance will either be ElementType[] or List<ElementType> depending on the value of AsArray . Declaration public Type ElementType { get; } Property Value Type Description Type The declared type of each element. | Improve this Doc Items Gets the rezolve targets that will build each individual item in the resulting list or array. Declaration public IEnumerable<ITarget> Items { get; } Property Value Type Description IEnumerable < ITarget > The items. | Improve this Doc ListConstructor Gets the list constructor to be invoked when AsArray is false. Declaration public ConstructorInfo ListConstructor { get; } Property Value Type Description ConstructorInfo The list constructor. Exceptions Type Condition InvalidOperationException Since this target is configured to build an array, getting the ListConstructor is not a valid operation. | Improve this Doc UseFallback Returns true if the Items enumerable is empty. Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides"
  },
  "rezolver-api/Rezolver.MemberBinding.html": {
    "href": "rezolver-api/Rezolver.MemberBinding.html",
    "title": "Class MemberBinding",
    "keywords": "Class MemberBinding Represents the binding of an ITarget to a property or field of a given type. Not to be confused with the type of the same name from the System.Linq.Expressions namespace, although they are technically equivalent. Inheritance Object MemberBinding Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class MemberBinding Remarks You typically don't create this type directly - instead, other targets such as will create it as needed through the use of an IMemberBindingBehaviour object. Constructors | Improve this Doc MemberBinding(MemberInfo, ITarget) Initializes a new instance of the MemberBinding class. Declaration public MemberBinding(MemberInfo member, ITarget target) Parameters Type Name Description MemberInfo member The member to be bound. ITarget target The target whose value will be written to the member. Fields | Improve this Doc None Empty bindings. Declaration public static readonly MemberBinding[] None Field Value Type Description MemberBinding [] Properties | Improve this Doc Member Gets the member against which this binding is to be applied. Declaration public MemberInfo Member { get; } Property Value Type Description MemberInfo The member. | Improve this Doc MemberType Gets the type of the Member . E.g. if the member represents a String property on the declaring type, then this will return the String type. If the member represents an integer field, this it will return the Int32 type. Declaration public Type MemberType { get; } Property Value Type Description Type The type of the member. | Improve this Doc Target Gets the target whose value when resolved will be written to the Member Declaration public ITarget Target { get; } Property Value Type Description ITarget The target."
  },
  "rezolver-api/Rezolver.MethodBinding.html": {
    "href": "rezolver-api/Rezolver.MethodBinding.html",
    "title": "Class MethodBinding",
    "keywords": "Class MethodBinding Represents a binding to a method whose arguments will be supplied by ITarget instances. Inheritance Object MethodBinding Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class MethodBinding Constructors | Improve this Doc MethodBinding(MethodBase, ParameterBinding[]) Initializes a new instance of the MethodBinding class. Declaration public MethodBinding(MethodBase method, ParameterBinding[] boundArgs = null) Parameters Type Name Description MethodBase method The method. ParameterBinding [] boundArgs Optional. The bound arguments. Can be null or empty. Properties | Improve this Doc BoundArguments Gets the argument bindings for the method call. Never null but can be empty. Declaration public ParameterBinding[] BoundArguments { get; } Property Value Type Description ParameterBinding [] The bound arguments. | Improve this Doc Method Gets the method to be invoked. Declaration public MethodBase Method { get; } Property Value Type Description MethodBase The method."
  },
  "rezolver-api/Rezolver.MethodCallExtractor.html": {
    "href": "rezolver-api/Rezolver.MethodCallExtractor.html",
    "title": "Class MethodCallExtractor",
    "keywords": "Class MethodCallExtractor Used to help grab method and constructor info from expressions (which is easier than writing long strings of reflection code). For example: MethodCallExtractor.ExtractCalledMethod(() => Console.WriteLine(\"foo\")) Will return the MethodInfo for the WriteLine method of the Console class. Inheritance Object MethodCallExtractor Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public sealed class MethodCallExtractor : ExpressionVisitor Methods | Improve this Doc ExtractCalledMethod(Expression<Action>) Extracts the MethodInfo of the first method call found in the expression. Declaration public static MethodInfo ExtractCalledMethod(Expression<Action> expr) Parameters Type Name Description Expression < System.Action > expr The expression to be read Returns Type Description MethodInfo A MethodInfo representing the method - if the expression contains a method call; otherwise null | Improve this Doc ExtractCalledMethod<T>(Expression<Action<T>>) Extracts the MethodInfo of the first method call found in the expression. Declaration public static MethodInfo ExtractCalledMethod<T>(Expression<Action<T>> expr) Parameters Type Name Description Expression < System.Action <T>> expr The expression to be read Returns Type Description MethodInfo A MethodInfo representing the method - if the expression contains a method call; otherwise null Type Parameters Name Description T Allows the expression to declare a parameter to aid overload resolution, but doesn't actually have any material influence on the expression analysis. | Improve this Doc ExtractCalledMethod<TResult>(Expression<Func<TResult>>) Extracts the MethodInfo of the first method call found in the expression. Declaration public static MethodInfo ExtractCalledMethod<TResult>(Expression<Func<TResult>> expr) Parameters Type Name Description Expression < Func <TResult>> expr The expression to be read Returns Type Description MethodInfo A MethodInfo representing the method - if the expression contains a method call; otherwise null Type Parameters Name Description TResult Return type of the expression. Not actually used in any way, it's just here to allow overload resolution when an expression represents a non-void function call | Improve this Doc ExtractCalledMethod<TInstance, TResult>(Expression<Func<TInstance, TResult>>) Extracts the MethodInfo of the first method call found in the expression. Declaration public static MethodInfo ExtractCalledMethod<TInstance, TResult>(Expression<Func<TInstance, TResult>> expr) Parameters Type Name Description Expression < Func <TInstance, TResult>> expr The expression to be read Returns Type Description MethodInfo A MethodInfo representing the method - if the expression contains a method call; otherwise null Type Parameters Name Description TInstance Allows the expression to declare a parameter to aid overload resolution, but doesn't actually have any material influence on the expression analysis. TResult Return type of the expression. Not actually used in any way, it's just here to allow overload resolution when an expression represents a non-void function call | Improve this Doc ExtractConstructorCall(Expression<Action>) Extracts the ConstructorInfo of the first 'new' statement found in the expression Declaration public static ConstructorInfo ExtractConstructorCall(Expression<Action> expr) Parameters Type Name Description Expression < System.Action > expr The expression to be analysed. Returns Type Description ConstructorInfo A ConstructorInfo representing the constructor being called in the expression; otherwise null if not found. | Improve this Doc ExtractConstructorCall<T>(Expression<Action<T>>) Extracts the ConstructorInfo of the first 'new' statement found in the expression Declaration public static ConstructorInfo ExtractConstructorCall<T>(Expression<Action<T>> expr) Parameters Type Name Description Expression < System.Action <T>> expr The expression to be analysed. Returns Type Description ConstructorInfo A ConstructorInfo representing the constructor being called in the expression; otherwise null if not found. Type Parameters Name Description T Allows the expression to declare a parameter to aid overload resolution, but doesn't actually have any material influence on the expression analysis. | Improve this Doc ExtractConstructorCall<TResult>(Expression<Func<TResult>>) Extracts the ConstructorInfo of the first 'new' statement found in the expression Declaration public static ConstructorInfo ExtractConstructorCall<TResult>(Expression<Func<TResult>> expr) Parameters Type Name Description Expression < Func <TResult>> expr The expression to be analysed. Returns Type Description ConstructorInfo A ConstructorInfo representing the constructor being called in the expression; otherwise null if not found. Type Parameters Name Description TResult Return type of the expression. Not actually used in any way, it's just here to allow overload resolution when an expression represents a non-void function call | Improve this Doc ExtractConstructorCall<TInstance, TResult>(Expression<Func<TInstance, TResult>>) Extracts the ConstructorInfo of the first 'new' statement found in the expression Declaration public static ConstructorInfo ExtractConstructorCall<TInstance, TResult>(Expression<Func<TInstance, TResult>> expr) Parameters Type Name Description Expression < Func <TInstance, TResult>> expr The expression to be analysed. Returns Type Description ConstructorInfo A ConstructorInfo representing the constructor being called in the expression; otherwise null if not found. Type Parameters Name Description TInstance Allows the expression to declare a parameter to aid overload resolution, but doesn't actually have any material influence on the expression analysis. TResult Return type of the expression. Not actually used in any way, it's just here to allow overload resolution when an expression represents a non-void function call | Improve this Doc VisitMethodCall(MethodCallExpression) Visits the children of the MethodCallExpression . Declaration protected override Expression VisitMethodCall(MethodCallExpression node) Parameters Type Name Description MethodCallExpression node The expression to visit. Returns Type Description Expression | Improve this Doc VisitNew(NewExpression) Visits the children of the NewExpression . Declaration protected override Expression VisitNew(NewExpression node) Parameters Type Name Description NewExpression node The expression to visit. Returns Type Description Expression"
  },
  "rezolver-api/Rezolver.Microsoft.Extensions.DependencyInjection.RezolverRegistration.html": {
    "href": "rezolver-api/Rezolver.Microsoft.Extensions.DependencyInjection.RezolverRegistration.html",
    "title": "Class RezolverRegistration",
    "keywords": "Class RezolverRegistration Inheritance Object RezolverRegistration Inherited Members Namespace :Rezolver.Microsoft.Extensions.DependencyInjection Assembly :cs.temp.dll.dll Syntax public static class RezolverRegistration Methods | Improve this Doc CreateDefaultContainer(ITargetContainer) Declaration public static IContainer CreateDefaultContainer(ITargetContainer targetContainer) Parameters Type Name Description ITargetContainer targetContainer Returns Type Description IContainer | Improve this Doc Populate(ContainerBase, IServiceCollection) Declaration public static IServiceProvider Populate(this ContainerBase rezolver, IServiceCollection services) Parameters Type Name Description ContainerBase rezolver IServiceCollection services Returns Type Description IServiceProvider"
  },
  "rezolver-api/Rezolver.Microsoft.Extensions.DependencyInjection.html": {
    "href": "rezolver-api/Rezolver.Microsoft.Extensions.DependencyInjection.html",
    "title": "Namespace Rezolver.Microsoft.Extensions.DependencyInjection",
    "keywords": "Namespace Rezolver.Microsoft.Extensions.DependencyInjection Classes"
  },
  "rezolver-api/Rezolver.MSDIITargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.MSDIITargetContainerExtensions.html",
    "title": "Class MSDIITargetContainerExtensions",
    "keywords": "Class MSDIITargetContainerExtensions Inheritance Object MSDIITargetContainerExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class MSDIITargetContainerExtensions Methods | Improve this Doc Populate(ITargetContainer, IServiceCollection) Declaration public static void Populate(this ITargetContainer targets, IServiceCollection services) Parameters Type Name Description ITargetContainer targets IServiceCollection services"
  },
  "rezolver-api/Rezolver.MultipleTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.MultipleTargetContainerExtensions.html",
    "title": "Class MultipleTargetContainerExtensions",
    "keywords": "Class MultipleTargetContainerExtensions Extensions for registering multiple targets individually and against the same type Inheritance Object MultipleTargetContainerExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class MultipleTargetContainerExtensions Methods | Improve this Doc RegisterAll(ITargetContainer, ITarget[]) Performs the same operations as RegisterAll(ITargetContainer, IEnumerable<ITarget>) except via a variable number of ITarget arguments. Declaration public static void RegisterAll(this ITargetContainer targetContainer, params ITarget[] targets) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registrations are to be performed. ITarget [] targets The targets to be registered. | Improve this Doc RegisterAll(ITargetContainer, IEnumerable<ITarget>) Batch-registers multiple targets against their DeclaredType . This is the same as calling Register(ITarget, Type) for each of the targets , except the type cannot be overriden from the target's DeclaredType. Declaration public static void RegisterAll(this ITargetContainer targetContainer, IEnumerable<ITarget> targets) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registrations are to be performed. IEnumerable < ITarget > targets The targets to be registered | Improve this Doc RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) Called to register multiple targets against the same type. It is the same as calling Register(ITarget, Type) multiple times with the different targets. Declaration public static void RegisterMultiple(this ITargetContainer targetContainer, IEnumerable<ITarget> targets, Type commonServiceType = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registration is to be performed. IEnumerable < ITarget > targets The targets to be registered - all must support a common service type (potentially passed in the commonServiceType argument. Type commonServiceType Optional - if provided, then this will be used as the common service type for registration. If not provided, then the DeclaredType of the first target will be used. Remarks If the container has the capability to handle enumerables, then each target will be returned when an IEnumerable of the common service type is requested. This is an opt-in behaviour in Rezolver - implemented by the Rezolver.EnumerableTargetContainer and can be added to a target container with the extension method EnableEnumerableResolving(ITargetContainerOwner) . Note that default behaviour of TargetContainer is for this to be enabled."
  },
  "rezolver-api/Rezolver.ObjectTarget.html": {
    "href": "rezolver-api/Rezolver.ObjectTarget.html",
    "title": "Class ObjectTarget",
    "keywords": "Class ObjectTarget Implements ITarget by wrapping a single instance that's already been constructed by application code. Inheritance Object TargetBase ObjectTarget Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ObjectTarget : TargetBase, ITarget, ICompiledTarget Constructors | Improve this Doc ObjectTarget(Object, Type, Boolean) Creates a new instance of the ObjectTarget class. Declaration public ObjectTarget(object obj, Type declaredType = null, bool suppressScopeTracking = true) Parameters Type Name Description Object obj The object to be returned by this target when resolved. Type declaredType Optional. The declared type of this target, if different from the absolute type of the obj Boolean suppressScopeTracking Optional. Controls whether the instance will be added to a scope when resolved. If true (the default) then no scope tracking is performed, and you will have to dispose of the object, if disposable. If false, then the object will be tracked by the ROOT scope of the first scope the object is resolved from. Remarks Please note - if you enable scope tracking, but the object is never resolved, then the object will not be disposed and you will need to ensure you dispose of it. Properties | Improve this Doc DeclaredType Gets the declared type of object that is returned by this target. Might be different from the type of Value if explicitly defined when this target was constructed. Declaration public override Type DeclaredType { get; } Property Value Type Description Type The type of the declared. Overrides | Improve this Doc SuppressScopeTracking Overrides SuppressScopeTracking Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides | Improve this Doc Value Gets the value that will be exposed by expressions built by this instance. Declaration public object Value { get; } Property Value Type Description Object The value. Explicit Interface Implementations | Improve this Doc ICompiledTarget.GetObject(ResolveContext) Declaration object ICompiledTarget.GetObject(ResolveContext context) Parameters Type Name Description ResolveContext context Returns Type Description Object Implements"
  },
  "rezolver-api/Rezolver.ObjectTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.ObjectTargetContainerExtensions.html",
    "title": "Class ObjectTargetContainerExtensions",
    "keywords": "Class ObjectTargetContainerExtensions Extensions for ITargetContainer relating to registering concrete instances via the target. Inheritance Object ObjectTargetContainerExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ObjectTargetContainerExtensions Methods | Improve this Doc RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) Registers an instance to be used when resolving a particular service type via the target. Declaration public static void RegisterObject<T>(this ITargetContainer targetContainer, T obj, Type serviceType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description ITargetContainer targetContainer The target container which will receive the registration. T obj The instance that will be resolved when the service type is requested. Type serviceType The service type against which this object is to be registered, if different from T . ScopeBehaviour scopeBehaviour Sets the ScopeBehaviour for the that's created Type Parameters Name Description T Type of the object - will be used as the service type for registration if serviceType is not provied."
  },
  "rezolver-api/Rezolver.ObjectTargetExtensions.html": {
    "href": "rezolver-api/Rezolver.ObjectTargetExtensions.html",
    "title": "Class ObjectTargetExtensions",
    "keywords": "Class ObjectTargetExtensions Extension method(s) to help create the ObjectTarget target. Inheritance Object ObjectTargetExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ObjectTargetExtensions Methods | Improve this Doc AsObjectTarget<T>(T, Type, Boolean) Wraps the instance on which this is invoked as an ObjectTarget that can be registered into an ITargetContainer . The parameters are direct analogues of the parameters on the type's constructor (see ObjectTarget(Object, Type, Boolean) ). Declaration public static ObjectTarget AsObjectTarget<T>(this T obj, Type declaredType = null, bool suppressScopeTracking = true) Parameters Type Name Description T obj the object being wrapped Type declaredType Optional. The type which is to be set as the DeclaredType of the created target. Boolean suppressScopeTracking Probably going to be removed or changed. Returns Type Description ObjectTarget A new object target that wraps the object obj . Type Parameters Name Description T The type of object being wrapped"
  },
  "rezolver-api/Rezolver.OptionalParameterTarget.html": {
    "href": "rezolver-api/Rezolver.OptionalParameterTarget.html",
    "title": "Class OptionalParameterTarget",
    "keywords": "Class OptionalParameterTarget Used specifically when binding arguments to method parameters when a parameter is optional and its default value is to be used when binding to it. Inheritance Object TargetBase OptionalParameterTarget Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class OptionalParameterTarget : TargetBase, ITarget Constructors | Improve this Doc OptionalParameterTarget(ParameterInfo) Constructs a new instance of the OptionalParameterTarget class. Declaration public OptionalParameterTarget(ParameterInfo methodParameter) Parameters Type Name Description ParameterInfo methodParameter Required - parameter to which this target will be bound. Its property must be true otherwise an ArgumentException is thrown. Properties | Improve this Doc DeclaredType Always returns the of the MethodParameter Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc MethodParameter The parameter to which this target is bound. Declaration public ParameterInfo MethodParameter { get; } Property Value Type Description ParameterInfo | Improve this Doc SuppressScopeTracking Possibly going to be removed or at least changed. Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides | Improve this Doc UseFallback Always returns true, since using a default argument of a parameter is always considered to be a last-resort. Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides"
  },
  "rezolver-api/Rezolver.OverridingContainer.html": {
    "href": "rezolver-api/Rezolver.OverridingContainer.html",
    "title": "Class OverridingContainer",
    "keywords": "Class OverridingContainer An IContainer which can override the resolve operations of another. This is useful when you have a core application-wide container, with some objects being customised based on some ambient information, e.g. configuration, MVC Area/Controller, Brand (in a multi-tenant application for example) or more. Inheritance Object ContainerBase CachingContainerBase Container OverridingContainer Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class OverridingContainer : Container, IContainer, IServiceProvider, ITargetContainer Remarks When overriding another IContainer , you are overriding the ICompiledTarget objects that will be returned when FetchCompiled(ResolveContext) is called on that container and, therefore, the compiled target which is executed when the Resolve(ResolveContext) method is called. This has the side effect of overriding automatically resolved arguments (bound to a ) compiled in the overridden container by virtue of the fact that the overriding container is a different reference, because the is typically compiled with a check, at resolve-time, that the Container is the same container as the one that was active when it was originally compiled. In essence, when resolving an instance as a dependency the does something like this: resolveContext.Container == compileContext.Container ? (execute compile-time target) : resolveContext.Container.Resolve(type) Constructors | Improve this Doc OverridingContainer(IContainer, ITargetContainer, ICompilerConfigurationProvider) Creates a new instance of the OverridingContainer Declaration public OverridingContainer(IContainer inner, ITargetContainer targets = null, ICompilerConfigurationProvider compilerConfig = null) Parameters Type Name Description IContainer inner Required. The inner container that this one combines with. Any dependencies not served by the new combined container's own targets will be sought from this container. Equally, any targets in the base which are resolved when the overriding container is the root container for a resolve operation, will resolve their dependencies from this container. ITargetContainer targets Optional. A specific target container to be used for this container's own registrations. ICompilerConfigurationProvider compilerConfig Optional. An object which will be used to configure this container and its targets to use a specific compilation strategy. If null (recommended), then the inner container's configuration will be inherited. Methods | Improve this Doc CanResolve(ResolveContext) Called to determine if this container is able to resolve the type specified in the passed context . Declaration public override bool CanResolve(ResolveContext context) Parameters Type Name Description ResolveContext context Required. The ResolveContext . Returns Type Description Boolean Overrides | Improve this Doc GetFallbackCompiledRezolveTarget(ResolveContext) Overrides the base implementation to pass the lookup for an ITarget to the inner container - this is how dependency chaining from this container to the inner container is achieved. Declaration protected override ICompiledTarget GetFallbackCompiledRezolveTarget(ResolveContext context) Parameters Type Name Description ResolveContext context Required. The ResolveContext . Returns Type Description ICompiledTarget Overrides"
  },
  "rezolver-api/Rezolver.OverridingScopedContainer.html": {
    "href": "rezolver-api/Rezolver.OverridingScopedContainer.html",
    "title": "Class OverridingScopedContainer",
    "keywords": "Class OverridingScopedContainer Not sure if this is sticking around anyway. Think the scoping stuff needs a bit of a rethink. Inheritance Object ContainerBase CachingContainerBase Container OverridingContainer OverridingScopedContainer Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class OverridingScopedContainer : OverridingContainer, ITargetContainer, IScopedContainer, IContainer, IServiceProvider, IDisposable Constructors | Improve this Doc OverridingScopedContainer(IScopedContainer, IContainer, ITargetContainer, ITargetCompiler) Constructs a new instance of the CombinedLifetimeScopeRezolver class. Declaration public OverridingScopedContainer(IScopedContainer parentScope, IContainer inner = null, ITargetContainer builder = null, ITargetCompiler compiler = null) Parameters Type Name Description IScopedContainer parentScope Can be null, but if it is, then inner must be supplied IContainer inner Can be null, but if it is, then parentScope must be supplied ITargetContainer builder ITargetCompiler compiler Properties | Improve this Doc ParentScope Declaration public IScopedContainer ParentScope { get; } Property Value Type Description IScopedContainer Implements | Improve this Doc TrackedObjects Declaration protected IEnumerable<object> TrackedObjects { get; } Property Value Type Description IEnumerable < Object > Methods | Improve this Doc AddToScope(Object, ResolveContext) Declaration public virtual void AddToScope(object obj, ResolveContext context = null) Parameters Type Name Description Object obj ResolveContext context Implements | Improve this Doc Dispose() Declaration public void Dispose() Implements | Improve this Doc Dispose(Boolean) Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description Boolean disposing | Improve this Doc GetFromScope(ResolveContext) Declaration public virtual IEnumerable<object> GetFromScope(ResolveContext context) Parameters Type Name Description ResolveContext context Returns Type Description IEnumerable < Object > Implements | Improve this Doc OnDisposed() Declaration protected void OnDisposed() Events | Improve this Doc Disposed Declaration public event EventHandler Disposed Event Type Type Description EventHandler Implements"
  },
  "rezolver-api/Rezolver.ParameterBinding.html": {
    "href": "rezolver-api/Rezolver.ParameterBinding.html",
    "title": "Class ParameterBinding",
    "keywords": "Class ParameterBinding Represents a binding between a method parameter and an ITarget Inheritance Object ParameterBinding Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ParameterBinding Constructors | Improve this Doc ParameterBinding(ParameterInfo, ITarget) Constructs a new instance of the ParameterBinding class. Declaration public ParameterBinding(ParameterInfo parameter, ITarget target = null) Parameters Type Name Description ParameterInfo parameter Required - the parameter being bound ITarget target Optional - the argument supplied for the parameter. Fields | Improve this Doc None Represents an empty parameter bindings array. Declaration public static readonly ParameterBinding[] None Field Value Type Description ParameterBinding [] Properties | Improve this Doc IsValid Gets a boolean indicating whether the parameter binding is valid Ultimately, this returns true if Target is non-null. Declaration public bool IsValid { get; } Property Value Type Description Boolean | Improve this Doc Parameter The parameter to be bound Declaration public ParameterInfo Parameter { get; } Property Value Type Description ParameterInfo | Improve this Doc Target The initial target that was bound to this parameter. Declaration public ITarget Target { get; } Property Value Type Description ITarget Methods | Improve this Doc BindMethod(MethodBase, ParameterBinding[]) Binds the method using explicit bindings for each parameter supplied in the suppliedBindings array, or defaults (which will be resolved from the compile or run-time container) if not present. Declaration public static ParameterBinding[] BindMethod(MethodBase method, ParameterBinding[] suppliedBindings) Parameters Type Name Description MethodBase method The method to be bound ParameterBinding [] suppliedBindings Optional. The supplied bindings for the parameters of the method. Any parameters not matched from this array will be automatically bound with default (resolved from the container). Returns Type Description ParameterBinding [] | Improve this Doc BindMethod(MethodBase, IDictionary<String, ITarget>) Matches named targets in args to parameters on the passed method , creating default ParameterBinding s (which will be resolved from the compile or run-time container), for any parameters for which named targets cannot be found. Declaration public static ParameterBinding[] BindMethod(MethodBase method, IDictionary<string, ITarget> args) Parameters Type Name Description MethodBase method IDictionary < String , ITarget > args Returns Type Description ParameterBinding [] | Improve this Doc BindOverload(MethodBase[], IDictionary<String, ITarget>, out MethodBase) Searches for a method in the methods collection whose parameters can be filled by the targets provided in the args dictionary, returning the parameter bindings, and passing out the resolved target method in resolvedMethod if found. Note - if no match can be found, or if more than one method could be bound, then an InvalidOperationException will occur. Declaration public static ParameterBinding[] BindOverload(MethodBase[] methods, IDictionary<string, ITarget> args, out MethodBase resolvedMethod) Parameters Type Name Description MethodBase [] methods The methods. IDictionary < String , ITarget > args The arguments. MethodBase resolvedMethod The resolved method. Returns Type Description ParameterBinding [] ParameterBinding[]. | Improve this Doc BindWithRezolvedArguments(MethodBase) Creates parameter bindings for each parameter in the passed method where each value will be resolved. For any optional parameters - their default values will be used as a fallback if the cannot either resolve a target at compile time or from the IContainer at resolve-time. Declaration public static ParameterBinding[] BindWithRezolvedArguments(MethodBase method) Parameters Type Name Description MethodBase method Returns Type Description ParameterBinding [] | Improve this Doc Resolve(ICompileContext) Fetch the target that would be bound to this parameter given the passed ICompileContext Declaration public virtual ITarget Resolve(ICompileContext context) Parameters Type Name Description ICompileContext context The current compile context - a new one is created for the Parameter type Returns Type Description ITarget The target that should be used for the parameter, or null if no target could be found. Note that if the returned target's UseFallback property is set to true , then it means either the parameter's default value is being used, or that the target fetched from the target container in the context is a stub (e.g. empty enumerable) Remarks During compilation - you should not use the target returned by this function as a direct part of your expression tree - you should"
  },
  "rezolver-api/Rezolver.PropertyOrFieldBinding.html": {
    "href": "rezolver-api/Rezolver.PropertyOrFieldBinding.html",
    "title": "Class PropertyOrFieldBinding",
    "keywords": "Class PropertyOrFieldBinding Inheritance Object PropertyOrFieldBinding Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class PropertyOrFieldBinding Constructors | Improve this Doc PropertyOrFieldBinding(MemberInfo, ITarget) Declaration public PropertyOrFieldBinding(MemberInfo member, ITarget target) Parameters Type Name Description MemberInfo member ITarget target Fields | Improve this Doc None Declaration public static readonly PropertyOrFieldBinding[] None Field Value Type Description PropertyOrFieldBinding [] Properties | Improve this Doc Member Declaration public MemberInfo Member { get; } Property Value Type Description MemberInfo | Improve this Doc MemberType Declaration public Type MemberType { get; } Property Value Type Description Type | Improve this Doc Target Declaration public ITarget Target { get; } Property Value Type Description ITarget Methods | Improve this Doc CreateMemberBinding(CompileContext) Method for creating a Linq Expression MemberBinding object for the Member , to the expression produced by the Target object's Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) method. Declaration public MemberBinding CreateMemberBinding(CompileContext context) Parameters Type Name Description CompileContext context The CompileContext under which the generated expression will be compiled. Returns Type Description MemberBinding | Improve this Doc DeriveAutoPropertyBinding(Type, Boolean) Static factory method that creates bindings for all publicly writable instance properties (and, optionally, fields) of the given type. Each property/field is bound to a RezolvedTarget instance - meaning that, at runtime, values for those properties or fields will be resolved from the container by type. Declaration public static PropertyOrFieldBinding[] DeriveAutoPropertyBinding(Type type, bool includeFields = false) Parameters Type Name Description Type type The type whose properties (and, optionally, publicly writable fields) are to be bound. Boolean includeFields If true, then publicly writable fields will be bound. Returns Type Description PropertyOrFieldBinding []"
  },
  "rezolver-api/Rezolver.RegisterTypeDictionaryExtensions.html": {
    "href": "rezolver-api/Rezolver.RegisterTypeDictionaryExtensions.html",
    "title": "Class RegisterTypeDictionaryExtensions",
    "keywords": "Class RegisterTypeDictionaryExtensions Extensions for ITargetContainer to provide shortcuts for the simplest cases of registering ConstructorTarget and GenericConstructorTarget targets. Inheritance Object RegisterTypeDictionaryExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class RegisterTypeDictionaryExtensions Methods | Improve this Doc RegisterType(ITargetContainer, Type, Type, IPropertyBindingBehaviour) Registers an instance of objectType (optionally for the service type serviceType ) to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IPropertyBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. Type objectType The type of the object that is to be constructed when resolved. Type serviceType Optional. The type against which the registration will be performed, if different from objectType . objectType must be compatible with this type, if it's provided. IPropertyBindingBehaviour propertyBindingBehaviour Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Rezolver.ConstructorTarget.Auto(System.Type,Rezolver.IPropertyBindingBehaviour) or Rezolver.GenericConstructorTarget.Auto(System.Type,Rezolver.IPropertyBindingBehaviour) static methods and then registering it against the type serviceType or objectType . | Improve this Doc RegisterType<TObject>(ITargetContainer, IPropertyBindingBehaviour) Registers an instance of TObject to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IPropertyBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType<TObject>(this ITargetContainer targetContainer, IPropertyBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IPropertyBindingBehaviour propertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Rezolver.ConstructorTarget.Auto``1(Rezolver.IPropertyBindingBehaviour) or Rezolver.GenericConstructorTarget.Auto``1(Rezolver.IPropertyBindingBehaviour) static methods and then registering it. | Improve this Doc RegisterType<TObject, TService>(ITargetContainer, IPropertyBindingBehaviour) Registers an instance of TObject for the service type TService to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Rezolver.IContainer.Resolve(Rezolver.RezolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IPropertyBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType<TObject, TService>(this ITargetContainer targetContainer, IPropertyBindingBehaviour propertyBindingBehaviour = null)where TObject : TService Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IPropertyBindingBehaviour propertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. TService The type against which the registration will be performed. TObject must be compatible with this type. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Rezolver.ConstructorTarget.Auto``1(Rezolver.IPropertyBindingBehaviour) or Rezolver.GenericConstructorTarget.Auto``1(Rezolver.IPropertyBindingBehaviour) static methods and then registering it against the type TService ."
  },
  "rezolver-api/Rezolver.RegisterTypeTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.RegisterTypeTargetContainerExtensions.html",
    "title": "Class RegisterTypeTargetContainerExtensions",
    "keywords": "Class RegisterTypeTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for the simplest cases of registering and targets. Inheritance Object RegisterTypeTargetContainerExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class RegisterTypeTargetContainerExtensions Methods | Improve this Doc RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) Registers an instance of objectType (optionally for the service type serviceType ) to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. Type objectType The type of the object that is to be constructed when resolved. Type serviceType Optional. The type against which the registration will be performed, if different from objectType . objectType must be compatible with this type, if it's provided. IMemberBindingBehaviour propertyBindingBehaviour Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. Remarks This is equivalent to creating either a or via the or static methods and then registering it against the type serviceType or objectType . | Improve this Doc RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) Registers an instance of TObject to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType<TObject>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IMemberBindingBehaviour propertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a or via the or static methods and then registering it. | Improve this Doc RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) Registers an instance of TObject for the service type TService to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType<TObject, TService>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null)where TObject : TService Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IMemberBindingBehaviour propertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. TService The type against which the registration will be performed. TObject must be compatible with this type. Remarks This is equivalent to creating either a or via the or static methods and then registering it against the type TService ."
  },
  "rezolver-api/Rezolver.ResolveContext.html": {
    "href": "rezolver-api/Rezolver.ResolveContext.html",
    "title": "Class ResolveContext",
    "keywords": "Class ResolveContext Captures the state for a call to Resolve(ResolveContext) (or TryResolve(ResolveContext, out Object) ), including the container on which the operation is invoked, any IScopedContainer that might be active for the call (if different), and the type which is being resolved from the IContainer . Inheritance Object ResolveContext Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ResolveContext : IEquatable<ResolveContext> Constructors | Improve this Doc ResolveContext(IContainer, Type) Initializes a new instance of the ResolveContext class. Declaration public ResolveContext(IContainer container, Type requestedType) Parameters Type Name Description IContainer container The container. Type requestedType The type of object to be resolved from the container. | Improve this Doc ResolveContext(IContainer, Type, IContainerScope) Initializes a new instance of the ResolveContext class. Declaration public ResolveContext(IContainer container, Type requestedType, IContainerScope scope) Parameters Type Name Description IContainer container The container. Type requestedType The type of object to be resolved from the container. IContainerScope scope The scope for this context. | Improve this Doc ResolveContext(IContainerScope, Type) Initializes a new instance of the ResolveContext class from the given scope. The Container is inherited from the scope's Container . Declaration public ResolveContext(IContainerScope scope, Type requestedType) Parameters Type Name Description IContainerScope scope The scope. Type requestedType The of object to be resolved from the container. Properties | Improve this Doc Container The container for this context. Declaration public IContainer Container { get; } Property Value Type Description IContainer Remarks This is the container which received the original call to Resolve(ResolveContext) , but is not necessarily the same container that will eventually end up resolving the object. | Improve this Doc RequestedType Gets the type being requested from the container Declaration public Type RequestedType { get; } Property Value Type Description Type The type of the requested. | Improve this Doc Scope Gets the scope that's active for all calls for this context. Declaration public IContainerScope Scope { get; } Property Value Type Description IContainerScope The scope. Methods | Improve this Doc CreateNew(IContainer) Returns a clone of this context, but replaces the Container . Declaration public ResolveContext CreateNew(IContainer container) Parameters Type Name Description IContainer container The container for the new context. Returns Type Description ResolveContext | Improve this Doc CreateNew(IContainer, IContainerScope) Returns a clone of this context, but replaces the Container and the Scope . Declaration public ResolveContext CreateNew(IContainer container, IContainerScope scope) Parameters Type Name Description IContainer container The container for the new context - regardless of what the Container of the scope is. IContainerScope scope The scope for the new context. Returns Type Description ResolveContext | Improve this Doc CreateNew(IContainer, Type) Returns a clone of this context, but replaces the RequestedType and Container . Declaration public ResolveContext CreateNew(IContainer container, Type requestedType) Parameters Type Name Description IContainer container The container for the new context. Type requestedType The type of object to be resolved from the container. Returns Type Description ResolveContext | Improve this Doc CreateNew(IContainerScope) Returns a clone of this context, but replaces the Scope . Declaration public ResolveContext CreateNew(IContainerScope scope) Parameters Type Name Description IContainerScope scope The scope for the new context. Returns Type Description ResolveContext | Improve this Doc CreateNew(Type) Returns a clone of this context, but replaces the type. Declaration public ResolveContext CreateNew(Type requestedType) Parameters Type Name Description Type requestedType The type of object to be resolved from the container. Returns Type Description ResolveContext | Improve this Doc CreateNew(Type, IContainerScope) Returns a clone of this context, but replaces the RequestedType and the Scope . Declaration public ResolveContext CreateNew(Type requestedType, IContainerScope scope) Parameters Type Name Description Type requestedType The type of object to be resolved from the container. IContainerScope scope The scope for the new context. Returns Type Description ResolveContext | Improve this Doc Equals(ResolveContext) Indicates whether the current object is equal to another object of the same type. Declaration public virtual bool Equals(ResolveContext other) Parameters Type Name Description ResolveContext other An object to compare with this object. Returns Type Description Boolean Implements | Improve this Doc Equals(Object) Determines whether the specified Object is equal to this instance. Declaration public override bool Equals(object obj) Parameters Type Name Description Object obj The object to compare with the current object. Returns Type Description Boolean Overrides | Improve this Doc GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description Int32 Overrides | Improve this Doc ToString() Returns a String that represents this instance. Declaration public override string ToString() Returns Type Description String Overrides Operators | Improve this Doc Equality(ResolveContext, ResolveContext) Implements the equality operator. Contexts are checked for reference equality, and then their RequestedType properties are checked for equality also. Declaration public static bool operator ==(ResolveContext left, ResolveContext right) Parameters Type Name Description ResolveContext left The left. ResolveContext right The right. Returns Type Description Boolean | Improve this Doc Inequality(ResolveContext, ResolveContext) Implements the inequality operator. Declaration public static bool operator !=(ResolveContext left, ResolveContext right) Parameters Type Name Description ResolveContext left The left. ResolveContext right The right. Returns Type Description Boolean"
  },
  "rezolver-api/Rezolver.RezolveContext.html": {
    "href": "rezolver-api/Rezolver.RezolveContext.html",
    "title": "Class RezolveContext",
    "keywords": "Class RezolveContext Context of a call to an IRezolver's Resolve method. The container is included in the context to allow code generated from Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) to refer back to the container. This also allows us to retarget compiled targets at other containers (e.g. OverridingContainer s that override existing registrations or define new ones). Inheritance Object RezolveContext Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolveContext : IEquatable<RezolveContext> Constructors | Improve this Doc RezolveContext(IContainer, Type) Declaration public RezolveContext(IContainer container, Type requestedType) Parameters Type Name Description IContainer container Type requestedType | Improve this Doc RezolveContext(IContainer, Type, IScopedContainer) Declaration public RezolveContext(IContainer container, Type requestedType, IScopedContainer scope) Parameters Type Name Description IContainer container Type requestedType IScopedContainer scope Fields | Improve this Doc EmptyContext Declaration public static readonly RezolveContext EmptyContext Field Value Type Description RezolveContext Properties | Improve this Doc Container The container for this context. Declaration public IContainer Container { get; } Property Value Type Description IContainer | Improve this Doc RequestedType Declaration public Type RequestedType { get; } Property Value Type Description Type | Improve this Doc Scope Declaration public IScopedContainer Scope { get; } Property Value Type Description IScopedContainer Methods | Improve this Doc CreateNew(IContainer) Declaration public RezolveContext CreateNew(IContainer container) Parameters Type Name Description IContainer container Returns Type Description RezolveContext | Improve this Doc CreateNew(IContainer, IScopedContainer) Declaration public RezolveContext CreateNew(IContainer container, IScopedContainer scope) Parameters Type Name Description IContainer container IScopedContainer scope Returns Type Description RezolveContext | Improve this Doc CreateNew(IContainer, Type) Declaration public RezolveContext CreateNew(IContainer container, Type requestedType) Parameters Type Name Description IContainer container Type requestedType Returns Type Description RezolveContext | Improve this Doc CreateNew(IContainer, Type, IScopedContainer) Declaration public RezolveContext CreateNew(IContainer container, Type requestedType, IScopedContainer scope) Parameters Type Name Description IContainer container Type requestedType IScopedContainer scope Returns Type Description RezolveContext | Improve this Doc CreateNew(IScopedContainer) Declaration public RezolveContext CreateNew(IScopedContainer scope) Parameters Type Name Description IScopedContainer scope Returns Type Description RezolveContext | Improve this Doc CreateNew(Type) Returns a clone of this context, but replaces the type, establishing the root context relationship also, either by inheriting this one's root context, or setting this as the root context. Declaration public RezolveContext CreateNew(Type requestedType) Parameters Type Name Description Type requestedType Returns Type Description RezolveContext | Improve this Doc CreateNew(Type, IScopedContainer) Declaration public RezolveContext CreateNew(Type requestedType, IScopedContainer scope) Parameters Type Name Description Type requestedType IScopedContainer scope Returns Type Description RezolveContext | Improve this Doc Equals(RezolveContext) Declaration public virtual bool Equals(RezolveContext other) Parameters Type Name Description RezolveContext other Returns Type Description Boolean Implements | Improve this Doc Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description Object obj Returns Type Description Boolean Overrides | Improve this Doc GetHashCode() Declaration public override int GetHashCode() Returns Type Description Int32 Overrides | Improve this Doc ToString() Declaration public override string ToString() Returns Type Description String Overrides Operators | Improve this Doc Equality(RezolveContext, RezolveContext) Declaration public static bool operator ==(RezolveContext left, RezolveContext right) Parameters Type Name Description RezolveContext left RezolveContext right Returns Type Description Boolean | Improve this Doc Inequality(RezolveContext, RezolveContext) Declaration public static bool operator !=(RezolveContext left, RezolveContext right) Parameters Type Name Description RezolveContext left RezolveContext right Returns Type Description Boolean"
  },
  "rezolver-api/Rezolver.RezolveContextExpressionHelper.html": {
    "href": "rezolver-api/Rezolver.RezolveContextExpressionHelper.html",
    "title": "Class RezolveContextExpressionHelper",
    "keywords": "Class RezolveContextExpressionHelper Wraps a rezolve context for expression building - used principally in the ConstruuctorTarget class, but others are free to use it also. Inheritance Object RezolveContext RezolveContextExpressionHelper Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolveContextExpressionHelper : RezolveContext, IEquatable<RezolveContext> Methods | Improve this Doc Resolve<T>() Declaration public T Resolve<T>() Returns Type Description T Type Parameters Name Description T"
  },
  "rezolver-api/Rezolver.RezolveContextPlaceholderExpression.html": {
    "href": "rezolver-api/Rezolver.RezolveContextPlaceholderExpression.html",
    "title": "Class RezolveContextPlaceholderExpression",
    "keywords": "Class RezolveContextPlaceholderExpression wraps an expression that represents reading or otherwise manipulating the RezolveContext that's passed into a Resolve call. Inheritance Object RezolveContextPlaceholderExpression Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolveContextPlaceholderExpression : Expression Constructors | Improve this Doc RezolveContextPlaceholderExpression(Expression) Declaration public RezolveContextPlaceholderExpression(Expression rezolveContextExpression) Parameters Type Name Description Expression rezolveContextExpression Properties | Improve this Doc CanReduce Declaration public override bool CanReduce { get; } Property Value Type Description Boolean | Improve this Doc NodeType Declaration public override ExpressionType NodeType { get; } Property Value Type Description ExpressionType | Improve this Doc RezolveContextExpression Declaration public Expression RezolveContextExpression { get; } Property Value Type Description Expression | Improve this Doc Type Declaration public override Type Type { get; } Property Value Type Description Type"
  },
  "rezolver-api/Rezolver.RezolvedTarget.html": {
    "href": "rezolver-api/Rezolver.RezolvedTarget.html",
    "title": "Class RezolvedTarget",
    "keywords": "Class RezolvedTarget Represents a target that is rezolved statically at compile time via the ICompileContext , or dynamically (at 'resolve time') from the IContainer that is attached to the current ResolveContext when Resolve(ResolveContext) is called. This is the most common way that we bind constructor parameters, for example - i.e. 'I want an IService instance - go get it'. Inheritance Object TargetBase RezolvedTarget Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolvedTarget : TargetBase, ITarget Remarks The concept of compile-time resolving is what is typically implemented by most other IOC containers - at compile time, a target is resolved for a given type and, if found, its expression is used. If it's not found, then an error occurs. Rezolver does this, but goes further when the target can't be resolved at compile-time - in this case, it will emit a call back into the current ResolveContext 's IContainer to try and dynamically resolve the value that is required. Furthermore, the code it produces in either case also checks that the IContainer that is active at resolve-time is the same one (if applicable) that was active during compile-time. If it isn't, then it'll automatically defer resolving of the value to that container Constructors | Improve this Doc RezolvedTarget(Type, ITarget) Creates a new RezolvedTarget for the given type which will attempt to resolve a value at compile time and/or resolve-time and, if it can't, will either use the fallbackTarget or will throw an exception. Declaration public RezolvedTarget(Type type, ITarget fallbackTarget = null) Parameters Type Name Description Type type Required. The type to be resolved ITarget fallbackTarget Optional. The target to be used if the value cannot be resolved at either compile time or resolve-time. Properties | Improve this Doc DeclaredType The type that will be resolved Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc FallbackTarget Gets the target that this RezolvedTarget will fallback to if a satisfactory target cannot be found at compile time. Declaration public ITarget FallbackTarget { get; } Property Value Type Description ITarget Remarks The UseFallback property is also used to determine whether this will be used. If the target resolved from the ICompileContext has its UseFallback property set to true, and this property is non-null for this target, then this target will be used. Note also that extension containers such as OverridingContainer also have the ability to override the use of this fallback if they successfully resolve the type. | Improve this Doc SuppressScopeTracking Always returns true - we never wrap calls to a container inside a scope tracking expression. Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides Methods | Improve this Doc Resolve(ICompileContext) Attempts to obtain the target that this RezolvedTarget resolves to for the given ICompileContext . Used in the implementation of but also available to consumers to enable checking of RezolvedTargets to see if they'll succeed at compile time (useful when late-binding overloaded constructors, for example). Declaration public virtual ITarget Resolve(ICompileContext context) Parameters Type Name Description ICompileContext context The context from which a target is to be resolved. Returns Type Description ITarget The target resolved by this target - could be the FallbackTarget , could be null. Remarks The target that is returned depends both on the context passed and also whether a FallbackTarget has been provided to this target."
  },
  "rezolver-api/Rezolver.RezolveTargetAdapterExtensions.html": {
    "href": "rezolver-api/Rezolver.RezolveTargetAdapterExtensions.html",
    "title": "Class RezolveTargetAdapterExtensions",
    "keywords": "Class RezolveTargetAdapterExtensions Inheritance Object RezolveTargetAdapterExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class RezolveTargetAdapterExtensions Methods | Improve this Doc CreateTarget<T>(ITargetAdapter, Expression<Func<T>>) Declaration public static ITarget CreateTarget<T>(this ITargetAdapter adapter, Expression<Func<T>> expression) Parameters Type Name Description ITargetAdapter adapter Expression < Func <T>> expression Returns Type Description ITarget Type Parameters Name Description T | Improve this Doc CreateTarget<T>(ITargetAdapter, Expression<Func<RezolveContextExpressionHelper, T>>) Declaration public static ITarget CreateTarget<T>(this ITargetAdapter adapter, Expression<Func<RezolveContextExpressionHelper, T>> expression) Parameters Type Name Description ITargetAdapter adapter Expression < Func < RezolveContextExpressionHelper , T>> expression Returns Type Description ITarget Type Parameters Name Description T"
  },
  "rezolver-api/Rezolver.RezolveTargetExpression.html": {
    "href": "rezolver-api/Rezolver.RezolveTargetExpression.html",
    "title": "Class RezolveTargetExpression",
    "keywords": "Class RezolveTargetExpression Makes it possible to mix expressions and targets. Inheritance Object RezolveTargetExpression Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RezolveTargetExpression : Expression Constructors | Improve this Doc RezolveTargetExpression(ITarget) Declaration public RezolveTargetExpression(ITarget target) Parameters Type Name Description ITarget target Properties | Improve this Doc CanReduce Declaration public override bool CanReduce { get; } Property Value Type Description Boolean | Improve this Doc NodeType Declaration public override ExpressionType NodeType { get; } Property Value Type Description ExpressionType | Improve this Doc Target Declaration public ITarget Target { get; } Property Value Type Description ITarget | Improve this Doc Type Declaration public override Type Type { get; } Property Value Type Description Type Methods | Improve this Doc Reduce() Declaration public override Expression Reduce() Returns Type Description Expression"
  },
  "rezolver-api/Rezolver.ScopeBehaviour.html": {
    "href": "rezolver-api/Rezolver.ScopeBehaviour.html",
    "title": "Enum ScopeBehaviour",
    "keywords": "Enum ScopeBehaviour Describes different ways in which objeects interact with scopes. Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public enum ScopeBehaviour Remarks Note: this enum might be replaced with an abstraction in the future. If so, it will not alter how regatrations are performed, but it will affect any low-level code which uses this enum directly. Fields Name Description Explicit Explicitly scoped objects act like singletons in the current scope, regardless of whether they are disposable or not. Implicit Implicitly scoped objects are only added to the scope for the purposes of disposing when the scope is disposed None The object will not be tracked in any scope, regardless of whether there is one active, or whether the object is disposable."
  },
  "rezolver-api/Rezolver.ScopedContainer.html": {
    "href": "rezolver-api/Rezolver.ScopedContainer.html",
    "title": "Class ScopedContainer",
    "keywords": "Class ScopedContainer Extends the Container to implement lifetime implicit scoping through the Scope that's created along with it. Implementation of the IScopedContainer interface. Inheritance Object ContainerBase CachingContainerBase Container ScopedContainer Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ScopedContainer : Container, ITargetContainer, IScopedContainer, IContainer, IServiceProvider, IDisposable Remarks Both the Resolve(ResolveContext) and TryResolve(ResolveContext, out Object) methods will inject the Scope into ResolveContext that's passed if the context doesn't already have a scope. If you want your root container to act as a lifetime scope, then you should use this class instead of using Container . Note that this class does NOT implement the IContainerScope interface because the two interfaces are not actually compatible with each other, thanks to identical sets of extension methods. Constructors | Improve this Doc ScopedContainer(ITargetContainer, ICompilerConfigurationProvider) Initializes a new instance of the ScopedContainer class. Declaration public ScopedContainer(ITargetContainer targets = null, ICompilerConfigurationProvider compilerConfig = null) Parameters Type Name Description ITargetContainer targets Optional. The underlying target container to be used to resolve objects. ICompilerConfigurationProvider compilerConfig Optional. The compiler configuration. Properties | Improve this Doc Scope Gets the scope for this scoped container. Note that this is used automatically by the container for Resolve(ResolveContext) operations where the Scope property is not already set. Declaration public IContainerScope Scope { get; } Property Value Type Description IContainerScope Implements Methods | Improve this Doc CanResolve(ResolveContext) Overrides the base implementation to ensure that the context has the Scope assigned. Declaration public override bool CanResolve(ResolveContext context) Parameters Type Name Description ResolveContext context The resolve context containing the requested type. Returns Type Description Boolean Overrides Implements | Improve this Doc CreateScope() Overrides the base method to pass the Scope as the new scope's parent. Declaration public override IContainerScope CreateScope() Returns Type Description IContainerScope Overrides Implements | Improve this Doc Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() Implements | Improve this Doc Dispose(Boolean) Releases unmanaged and - optionally - managed resources. Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description Boolean disposing true to release both managed and unmanaged resources; false to release only unmanaged resources. | Improve this Doc Resolve(ResolveContext) Overrides the base implementation to ensure that the context has the Scope assigned. Declaration public override object Resolve(ResolveContext context) Parameters Type Name Description ResolveContext context The context containing the type that's requested, any active scope and so on. Returns Type Description Object Overrides Implements | Improve this Doc TryResolve(ResolveContext, out Object) Overrides the base implementation to ensure that the context has the Scope assigned. Declaration public override bool TryResolve(ResolveContext context, out object result) Parameters Type Name Description ResolveContext context The context containing the type that's requested, any active scope and so on. Object result Receives a reference to the object that was resolved, if successful, or null if not. Returns Type Description Boolean Overrides Implements"
  },
  "rezolver-api/Rezolver.ScopedContainerScopeExtensions.html": {
    "href": "rezolver-api/Rezolver.ScopedContainerScopeExtensions.html",
    "title": "Class ScopedContainerScopeExtensions",
    "keywords": "Class ScopedContainerScopeExtensions Contains extension methods for the IScopedContainer interface which provide some additional shortucts for getting or adding objects from/to scopes. Inheritance Object ScopedContainerScopeExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ScopedContainerScopeExtensions Methods | Improve this Doc GetOrAdd(IScopedContainer, ResolveContext, Func<ResolveContext, Object>, Boolean) Retrieves an object from scope or adds it (by calling the factory before returning it. Declaration public static object GetOrAdd(this IScopedContainer scope, ResolveContext context, Func<ResolveContext, object> factory, bool disposableOnly = true) Parameters Type Name Description IScopedContainer scope The scope. ResolveContext context The context. Func < ResolveContext , Object > factory The factory. Boolean disposableOnly if set to true then object only gets added to the scope if it's has the IDisposable interface.. Returns Type Description Object | Improve this Doc GetOrAdd<T>(IScopedContainer, ResolveContext, Func<ResolveContext, T>, Boolean) Retrieves an object from scope or adds it (by calling the factory before returning it. Declaration public static T GetOrAdd<T>(this IScopedContainer scope, ResolveContext context, Func<ResolveContext, T> factory, bool disposableOnly = true) Parameters Type Name Description IScopedContainer scope The scope. ResolveContext context The context. Func < ResolveContext , T> factory The factory. Boolean disposableOnly if set to true then object only gets added to the scope if it's has the IDisposable interface.. Returns Type Description T Type Parameters Name Description T Type of object being created and/or retrieved from the scope. | Improve this Doc GetScopeRoot(IScopedContainer) As the name suggests - this grabs the root scope for the scope on which this method is invoked. Declaration public static IScopedContainer GetScopeRoot(this IScopedContainer scope) Parameters Type Name Description IScopedContainer scope The scope whose root scope is sought. If null, then the method also returns null. Returns Type Description IScopedContainer An IScopedContainer reference representing the top-level (root) scope for the passed scope. | Improve this Doc GetSingleFromScope(IScopedContainer, ResolveContext) Retrieves a single instance that was previously added to the scope (or, optionally parent scopes) through a call to AddToScope(Object, ResolveContext) with a ResolveContext matching the one passed. Note - if multiple matches are found in a single scope, an InvalidOperationException will be thrown. Declaration public static object GetSingleFromScope(this IScopedContainer scope, ResolveContext context) Parameters Type Name Description IScopedContainer scope Required. The scope to be searched and optionally whose parent scopes are to be searched. ResolveContext context Required. The context whose properties will be used to find the matching disposable. Returns Type Description Object | Improve this Doc TrackIfScopedAndDisposableAndReturn<T>(IScopedContainer, T) This is primarily used by the dynamic code generated by RezolveTargetBase - if the scope is non-null and the instance is an IDiposable, then the object will be added to the scope. The instance , either way, is returned to simplify the function's use in dynamic code produced from expression trees. Declaration public static T TrackIfScopedAndDisposableAndReturn<T>(this IScopedContainer scope, T instance) Parameters Type Name Description IScopedContainer scope T instance Returns Type Description T Type Parameters Name Description T"
  },
  "rezolver-api/Rezolver.ScopedTarget.html": {
    "href": "rezolver-api/Rezolver.ScopedTarget.html",
    "title": "Class ScopedTarget",
    "keywords": "Class ScopedTarget A target that produces a single instance of an object within a lifetime scope. Inheritance Object TargetBase ScopedTarget Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ScopedTarget : TargetBase, ITarget Remarks On its own, this target doesn't do anything - it's designed to wrap another target such that the code generated from the expression it produces is executed only once for each lifetime scope. Outside of that, the target generates wrapper code that forcibly caches the instance that is produced (whether it's IDiposable or not) into the current scope's cache (using AddToScope(Object, ResolveContext) ) and retrieves previous instances from that scope (using Rezolver.IScopedContainer.GetFromScope(Rezolver.ResolveContext) . Constructors | Improve this Doc ScopedTarget(ITarget) Declaration public ScopedTarget(ITarget innerTarget) Parameters Type Name Description ITarget innerTarget Properties | Improve this Doc DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc InnerTarget Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget | Improve this Doc SuppressScopeTracking Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides Methods | Improve this Doc SupportsType(Type) Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type Returns Type Description Boolean Overrides"
  },
  "rezolver-api/Rezolver.ScopedTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.ScopedTargetContainerExtensions.html",
    "title": "Class ScopedTargetContainerExtensions",
    "keywords": "Class ScopedTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for registering constructor-injected types whose lifetimes are slaved to that of a parent IScopedContainer . All of the extension methods ultimately create a Inheritance Object ScopedTargetContainerExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ScopedTargetContainerExtensions Methods | Improve this Doc RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) Registers an explicitly instance of objectType (optionally for the service type serviceType ) to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterScoped(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. Type objectType The type of the object that is to be constructed when resolved. Type serviceType Optional. The type against which the registration will be performed, if different from objectType . objectType must be compatible with this type, if it's provided. IMemberBindingBehaviour propertyBindingBehaviour Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. Remarks This is equivalent to creating either a or via the or static methods, wrapping it with a and then registering it against the type serviceType or objectType . | Improve this Doc RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) Registers an explicitly scoped instance of TObject to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterScoped<TObject>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IMemberBindingBehaviour propertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a or via the or static methods, wrapping it with a and registering it. | Improve this Doc RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) Registers an explicitly scoped instance of TObject for the service type TService to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterScoped<TObject, TService>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IMemberBindingBehaviour propertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. TService The type against which the registration will be performed. TObject must be compatible with this type. Remarks This is equivalent to creating either a or via the or static methods, wrapping it with a and then registering it against the type TService ."
  },
  "rezolver-api/Rezolver.SingletonTarget.html": {
    "href": "rezolver-api/Rezolver.SingletonTarget.html",
    "title": "Class SingletonTarget",
    "keywords": "Class SingletonTarget A target which applies the singleton pattern to any ITarget . The inner target is available from the InnerTarget property. Inheritance Object TargetBase SingletonTarget Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class SingletonTarget : TargetBase, ITarget Constructors | Improve this Doc SingletonTarget(ITarget) Constructs a new instance of the SingletonTarget class. Declaration public SingletonTarget(ITarget innerTarget) Parameters Type Name Description ITarget innerTarget The target whose result (when compiled) is to be used as the singleton instance. Properties | Improve this Doc DeclaredType Override of DeclaredType - always returns the DeclaredType of the InnerTarget Declaration public override Type DeclaredType { get; } Property Value Type Description Type The type of the declared. Overrides | Improve this Doc InnerTarget Gets the inner target for this singleton. Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget | Improve this Doc SuppressScopeTracking Overrides the base class to ensure that automatic generation of the scope tracking code by TargetBase is disabled. For the singleton, it's important that the scope tracking call occurs within the lazy's callback. Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides Methods | Improve this Doc GetOrAddInitialiser(Type, Func<Type, ICompiledTarget>) Used to support compiled versions of this singleton - note this concept is something that probably needs to move out of this type, into a more generic TargetState object or something like that. Declaration public ICompiledTarget GetOrAddInitialiser(Type declaredType, Func<Type, ICompiledTarget> initialiserFactory) Parameters Type Name Description Type declaredType Type of object. Func < Type , ICompiledTarget > initialiserFactory The initialiser factory. Returns Type Description ICompiledTarget | Improve this Doc SupportsType(Type) Called to check whether a target can create an expression that builds an instance of the given type . The base implementation always passes the call on to the InnerTarget Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type Required Returns Type Description Boolean Overrides"
  },
  "rezolver-api/Rezolver.SingletonTargetDictionaryExtensions.html": {
    "href": "rezolver-api/Rezolver.SingletonTargetDictionaryExtensions.html",
    "title": "Class SingletonTargetDictionaryExtensions",
    "keywords": "Class SingletonTargetDictionaryExtensions Extension methods for the ITargetContainer interface which simplify the registration of singletons. Inheritance Object SingletonTargetDictionaryExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class SingletonTargetDictionaryExtensions Methods | Improve this Doc RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) Registers the type objectType as a singleton ( ) in the target container using either objectType as the service type, or serviceType instead - if it's provided. The instance will be built automatically with constructor injection (and, optionally, property injection if a propertyBindingBehaviour is passed) by leveraging the or targets. Declaration public static void RegisterSingleton(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registrations will be made. Type objectType Required. The type of object to be created. Type serviceType Optional. The type against which the target will be registered in the targetContainer IMemberBindingBehaviour propertyBindingBehaviour Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. | Improve this Doc RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) Registers the type TObject as a singleton ( ) in the target container. The instance will be built automatically with constructor injection (and, optionally, property injection if a propertyBindingBehaviour is passed) by leveraging the or targets. Declaration public static void RegisterSingleton<TObject>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registrations will be made. IMemberBindingBehaviour propertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type to be created, and the type against which the registration will be made | Improve this Doc RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) Registers the type TObject as a singleton ( ) in the target container for the service type TService . The instance will be built automatically with constructor injection (and, optionally, property injection if a propertyBindingBehaviour is passed) by leveraging the or targets. Declaration public static void RegisterSingleton<TObject, TService>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registrations will be made. IMemberBindingBehaviour propertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of object to be created. TService The type against which the target will be registered in the targetContainer"
  },
  "rezolver-api/Rezolver.TargetAdapter.html": {
    "href": "rezolver-api/Rezolver.TargetAdapter.html",
    "title": "Class TargetAdapter",
    "keywords": "Class TargetAdapter Default implementation of the ITargetAdapter interface. Also an ExpressionVisitor. Also, its Default property serves as the reference to the default adapter used by the system to convert expressions into IRezolveTarget instances. This class cannot be created directly - it is a singleton accessed through the Instance property. You can inherit from this class, however, to serve as the basis for your own implementation of ITargetAdapter . Inheritance Object TargetAdapter Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetAdapter : ExpressionVisitor, ITargetAdapter Constructors | Improve this Doc TargetAdapter() Protected constructor ensuring that new instances can only be created through inheritance. Declaration protected TargetAdapter() Properties | Improve this Doc Default The default IRezolveTargetAdapter to be used in converting expressions to IRezolveTarget instances. By default, this is initialised to a single instance of the TargetAdapter class. Declaration public static ITargetAdapter Default { get; set; } Property Value Type Description ITargetAdapter | Improve this Doc Instance The one and only instance of the RezolveTargetAdapter class Declaration public static ITargetAdapter Instance { get; } Property Value Type Description ITargetAdapter Methods | Improve this Doc CreateTarget(Expression) Creates the target. Declaration public ITarget CreateTarget(Expression expression) Parameters Type Name Description Expression expression The expression. Returns Type Description ITarget Implements"
  },
  "rezolver-api/Rezolver.TargetAdapterCreateExtensions.html": {
    "href": "rezolver-api/Rezolver.TargetAdapterCreateExtensions.html",
    "title": "Class TargetAdapterCreateExtensions",
    "keywords": "Class TargetAdapterCreateExtensions Inheritance Object TargetAdapterCreateExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class TargetAdapterCreateExtensions Methods | Improve this Doc CreateTarget<TResult>(ITargetAdapter, Expression<Func<TResult>>) Declaration public static ITarget CreateTarget<TResult>(this ITargetAdapter adapter, Expression<Func<TResult>> expression) Parameters Type Name Description ITargetAdapter adapter Expression < Func <TResult>> expression Returns Type Description ITarget Type Parameters Name Description TResult | Improve this Doc CreateTarget<TResult>(ITargetAdapter, Expression<Func<RezolveContext, TResult>>) Declaration public static ITarget CreateTarget<TResult>(this ITargetAdapter adapter, Expression<Func<RezolveContext, TResult>> expression) Parameters Type Name Description ITargetAdapter adapter Expression < Func < RezolveContext , TResult>> expression Returns Type Description ITarget Type Parameters Name Description TResult"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ExpressionCompileContext.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ExpressionCompileContext.html",
    "title": "Class ExpressionCompileContext",
    "keywords": "Class ExpressionCompileContext An implementation of ICompileContext which is specialised for use by an IExpressionCompiler . Inheritance Object CompileContext ExpressionCompileContext Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class ExpressionCompileContext : CompileContext, IExpressionCompileContext, ICompileContext, ITargetContainer Constructors | Improve this Doc ExpressionCompileContext(IExpressionCompileContext, Type, Boolean, Nullable<ScopeBehaviour>) Initializes a new instance of the ExpressionCompileContext class as a child of another. Note that all the expression properties ( ResolveContextExpression , ContextContainerPropertyExpression and ContextScopePropertyExpression ) are always inherited from the source context to ensure consistency across all expressions being built during a particular compilation chain. Declaration protected ExpressionCompileContext(IExpressionCompileContext sourceContext, Type targetType = null, bool useParentSharedExpressions = true, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description IExpressionCompileContext sourceContext The source context. Type targetType If not null, the type for which expressions are to be compiled. If null, then the sourceContext 's TargetType will be inherited. Boolean useParentSharedExpressions If true then the SharedExpressions of the sourceContext will be reused by this new context. If false , then this context will start with a new empty set of shared expressions. Nullable < ScopeBehaviour > scopeBehaviourOverride Override the scope behaviour to be used for the target that is compiled with this context. | Improve this Doc ExpressionCompileContext(IContainer, ITargetContainer, Type, ParameterExpression) Initializes a new instance of the ExpressionCompileContext class. Declaration protected ExpressionCompileContext(IContainer container, ITargetContainer dependencyTargetContainer, Type targetType = null, ParameterExpression resolveContextExpression = null) Parameters Type Name Description IContainer container Required. The container for which the compilation is being performed. When compiling in response to a call to Resolve(ResolveContext) , the container which first receives the call should be the one passed here. ITargetContainer dependencyTargetContainer Required - target container used for dependency lookups. As with the base class this is actually wrapped in a new ChildTargetContainer and used as this class' implementation of ITargetContainer . Type targetType Optional. Will be set into the TargetType property. If null, then any ITarget that is compiled should be compiled for its own DeclaredType . ParameterExpression resolveContextExpression Optional, mapped to ResolveContextExpression - the default for this (i.e. when you leave it as null) is to use the static DefaultResolveContextParameterExpression and generally it should always be left as that. The ExpressionCompiler , when building expressions to turn into compiled lambdas, uses this as the main parameter on the lambda itself. See Also Rezolver.Compilation.CompileContext. Properties | Improve this Doc ContainerExpression Gets an expression which gives a reference to the IContainer for this context - i.e. the same reference as given by the Container property. Declaration public Expression ContainerExpression { get; } Property Value Type Description Expression The container expression. Implements Remarks Note that this is not the same as ContextContainerPropertyExpression - but is provided to allow expressions to be compiled which compare the container supplied at compile time to the one from the Container at resolve-time. | Improve this Doc ContextContainerPropertyExpression Gets an expression for reading the Container property of the ResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration public MemberExpression ContextContainerPropertyExpression { get; } Property Value Type Description MemberExpression The context container property expression. Implements | Improve this Doc ContextScopePropertyExpression Gets an expression for reading the Scope property of the ResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration public MemberExpression ContextScopePropertyExpression { get; } Property Value Type Description MemberExpression The context scope property expression. Implements | Improve this Doc DefaultResolveContextParameterExpression The default ResolveContext parameter expression used by the expression-based code generators defined in this library, although it's not used directly for that purpose - instead, the ResolveContextExpression of new contexts is initialised to this if not explicitly provided on construction and when not being inherited from another context. Declaration public static ParameterExpression DefaultResolveContextParameterExpression { get; } Property Value Type Description ParameterExpression | Improve this Doc ParentContext Gets the parent context. Declaration public IExpressionCompileContext ParentContext { get; } Property Value Type Description IExpressionCompileContext Implements Remarks Note that this property hides the inherited ParentContext property, since an IExpressionCompileContext can only be a child of another IExpressionCompileContext . | Improve this Doc ResolveContextExpression This is the parameter expression which represents the ResolveContext that is passed to the ICompiledTarget at resolve-time. The other expressions - ContextContainerPropertyExpression and ContextScopePropertyExpression are both built from this too. Declaration public ParameterExpression ResolveContextExpression { get; } Property Value Type Description ParameterExpression The resolve context expression. Implements Remarks If the code produced by the IExpressionBuilder for a given target needs to read or use the ResolveContext that was originally passed to the Resolve(ResolveContext) method, then it does it by using this expression, which will be set as the only parameter on the lambda expression which is eventually compiled (in the case of the default expression compiler, ExpressionCompiler . | Improve this Doc SharedExpressions Gets a read-only enumerable of all the shared expressions that have been inherited from any parent context and/or added via calls to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) or GetOrAddSharedLocal(Type, String, Type) . Declaration public IEnumerable<Expression> SharedExpressions { get; } Property Value Type Description IEnumerable < Expression > Implements Methods | Improve this Doc GetOrAddSharedExpression(Type, String, Func<Expression>, Type) Gets or adds a shared expression (created by the expressionFactory if it's not already cached) with the given name, type, optionally for the given requestingType . Declaration public Expression GetOrAddSharedExpression(Type type, string name, Func<Expression> expressionFactory, Type requestingType = null) Parameters Type Name Description Type type The runtime type of the Expression. String name The runtime name of the Expression - and also the name used to retrieve it later. Func < Expression > expressionFactory The factory method to use to construct the shared expression from scratch, if it's not already cached. Type requestingType Optional - to avoid naming clashes with shared expressions created by other targets, you can pass a type here (usually the runtime type of your ITarget implementation). Returns Type Description Expression Expression. Implements | Improve this Doc GetOrAddSharedLocal(Type, String, Type) Similar to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) , except this is used when expression builders want to use local variables in block expressions to store the result of some operation in the expression tree built for a particular target. Reusing one local variable is more efficient than declaring the same local multiple times. Declaration public ParameterExpression GetOrAddSharedLocal(Type type, string name, Type requestingType = null) Parameters Type Name Description Type type The type. String name The name. Type requestingType Optional - the type of the object requesting this shared expression. If this is provided, then the search for an existing shared expression will only work if the same requesting type was passed previously. Returns Type Description ParameterExpression Implements Remarks When multiple expression trees from multiple targets are brought together into one lambda, there will often be many duplicate variables which could be shared. So, if an IExpressionBuilder needs a local variable for a block, instead of simply declaring it directly through the function, it can use this function instead, which will return a previously created one if available. Exceptions Type Condition InvalidOperationException Cannot add ParameterExpression: A shared expression of a different type has already been added with the same type and name. | Improve this Doc NewContext(Type, Nullable<ScopeBehaviour>) Used by the explicit implementation of NewContext(Type, Nullable<ScopeBehaviour>) . This is overriden to ensure that the correct type of context is created when created directly through the ICompileContext interface. Declaration protected override ICompileContext NewContext(Type targetType = null, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Nullable < ScopeBehaviour > scopeBehaviourOverride Override the ScopeBehaviourOverride to be used for the target that is compiled with the new context. This is never inherited automatically from one context to another. Returns Type Description ICompileContext Overrides Remarks Note all child contexts created through this virtual method will always inherit the parent context's shared expressions. | Improve this Doc RegisterExpressionTargets() Registers some additional targets into the compile context to support compilation. Declaration protected void RegisterExpressionTargets() Explicit Interface Implementations | Improve this Doc IExpressionCompileContext.NewContext(Type, Boolean, Nullable<ScopeBehaviour>) Creates a new IExpressionCompileContext using this one as a seed. This function is identical to NewContext(Type, Nullable<ScopeBehaviour>) but allows you to control whether the SharedExpressions are inherited (the default); and is more convenient because it returns another IExpressionCompileContext . Declaration IExpressionCompileContext IExpressionCompileContext.NewContext(Type targetType, bool useParentSharedExpressions, ScopeBehaviour? scopeBehaviourOverride) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Boolean useParentSharedExpressions If true then the shared expressions in this context will be inherited by the new context by reference. That is, when the new context goes out of scope, any new shared expressions it created will still be available. If false, then the new context will get a brand new, empty, set of shared expressions. Nullable < ScopeBehaviour > scopeBehaviourOverride Override the ScopeBehaviourOverride to be used for the target that is compiled with the new context. This is never inherited automatically from one context to another. Returns Type Description IExpressionCompileContext Implements See Also CompileContext"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ExpressionCompiler.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ExpressionCompiler.html",
    "title": "Class ExpressionCompiler",
    "keywords": "Class ExpressionCompiler Implementation of the ITargetCompiler interface which produces ICompiledTarget objects by building and compiling expression trees from the ITarget objects which are registered. Inheritance Object ExpressionCompiler Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class ExpressionCompiler : IExpressionCompiler, ITargetCompiler, ICompileContextProvider Remarks This compiler is automatically configured as the default for all containers because the ConfigProvider from this class is set as the DefaultProvider . This class works by directly resolving IExpressionBuilder instances which can build an expression for a given ITarget from the IExpressionCompileContext . Typically, this is done by searching for an IExpressionBuilder<TTarget> where 'TTarget' is equal to the runtime type of the target - e.g. ConstructorTarget . If one cannot be found, it will then search for an IExpressionBuilder whose CanBuild(ITarget, IExpressionCompileContext) function returns true for the given target. With a correctly configured target dictionary (using the ConfigProvider which, as mentioned previously, is used by default if no configuration provider is explicitly passed to the constructor of one of the ContainerBase deriving types) this should resolve to an instance of the ConstructorTargetBuilder class, which implements IExpressionBuilder<ConstructorTarget> . As such, the compiler can be extended to support extra target types and its existing expression builders can be replaced for customised behaviour because they are all resolved from the ITargetContainer underpinning a particular CompileContext . There is a caveat for this, however: you cannot use the traditional targets ( ConstructorTarget etc) to extend the compiler because they need to be compiled in order to work - which would cause an infinite recursion. Therefore, the targets which are registered as expression builders must directly implement either the IExpressionBuilder<TTarget> or IExpressionBuilder interfaces; or implement the ICompiledTarget interface and produce an instance of those interfaces when GetObject(ResolveContext) is called on them. Because of this requirement, the most common way to register an expression builder is to register an instance inside an ObjectTarget against the correct type, because that class does implement ICompiledTarget in addition to ITarget . Using this pattern, it's important that an expression builder is completely threadsafe and recursion safe (since one target's compilation might depend on the compilation of another of the same type). Under the default configuration, if you want to get hold of this compiler then you should request the type IExpressionCompiler from the current compilation context, or from your target container. Properties | Improve this Doc ConfigProvider Gets the default expression compiler configuration provider which is also set, by default, into the DefaultProvider property. Declaration public static ExpressionCompilerConfigurationProvider ConfigProvider { get; } Property Value Type Description ExpressionCompilerConfigurationProvider | Improve this Doc Default Gets the default expression compiler which is registered by the ConfigProvider by default. Declaration public static ExpressionCompiler Default { get; } Property Value Type Description ExpressionCompiler Methods | Improve this Doc Build(ITarget, IExpressionCompileContext) Called to build an expression for the specified target for the given IExpressionCompileContext - implementation of the Build(ITarget, IExpressionCompileContext) method. Declaration public Expression Build(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target for which an expression is to be built IExpressionCompileContext context The compilation context. Returns Type Description Expression Implements Remarks This implementation attempts to resolve an IExpressionBuilder<TTarget> (with TTarget\" equal to the runtime type of the target ) or IExpressionBuilder whose CanBuild(ITarget, IExpressionCompileContext) function returns true for the given target and context. If that lookup fails, then an ArgumentException is raised. If the lookup succeeds, then the builder's Build(ITarget, IExpressionCompileContext, IExpressionCompiler) function is called, and the expression it produces is returned. Exceptions Type Condition ArgumentException If the compiler is unable to resolve an IExpressionBuilder from the context for the target | Improve this Doc BuildCompiledTargetForLambda(Expression<Func<ResolveContext, Object>>) Creates an ICompiledTarget from the finalised lambda expression which was previously built for a target. Declaration protected virtual ICompiledTarget BuildCompiledTargetForLambda(Expression<Func<ResolveContext, object>> lambda) Parameters Type Name Description Expression < Func < ResolveContext , Object >> lambda The lambda expression representing the code to be executed in order to get the underlying object which will be resolved. Typically, this is fed directly from the BuildResolveLambda(Expression, IExpressionCompileContext) implementation. Returns Type Description ICompiledTarget | Improve this Doc BuildResolveLambda(Expression, IExpressionCompileContext) Takes the unoptimised expression built for a target and optimises it and turns it into a lambda expression ready to be compiled into an ICompiledTarget . Declaration public virtual Expression<Func<ResolveContext, object>> BuildResolveLambda(Expression expression, IExpressionCompileContext context) Parameters Type Name Description Expression expression The expression. IExpressionCompileContext context The context. Returns Type Description Expression < Func < ResolveContext , Object >> Implements | Improve this Doc CompileTarget(ITarget, ICompileContext) Create the ICompiledTarget for the given target using the context to inform the type of object that is to be built, and for compile-time dependency resolution. Declaration public ICompiledTarget CompileTarget(ITarget target, ICompileContext context) Parameters Type Name Description ITarget target Required. The target to be compiled. ICompileContext context Required. The current compilation context. Returns Type Description ICompiledTarget Implements Exceptions Type Condition ArgumentException context must be an instance of IExpressionCompileContext | Improve this Doc CreateContext(ResolveContext, ITargetContainer, IContainer) Implementation of CreateContext(ResolveContext, ITargetContainer, IContainer) Declaration public ICompileContext CreateContext(ResolveContext resolveContext, ITargetContainer targets, IContainer containerOverride = null) Parameters Type Name Description ResolveContext resolveContext ITargetContainer targets IContainer containerOverride Returns Type Description ICompileContext Implements | Improve this Doc ResolveBuilder(ITarget, IExpressionCompileContext) Resolves an expression builder that can build the given target for the given compile context. Or Returns null if no builder can be found. Declaration public virtual IExpressionBuilder ResolveBuilder(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context The context. Returns Type Description IExpressionBuilder Remarks The function builds a list of all the types in the hierarchy represented by the type of the target and, for each of those types which are compatible with ITarget , it looks for an IExpressionBuilder<TTarget> which is specialised for that type. If no compatible builder is found, then it attempts to find a general purpose IExpressionBuilder which can build the type. See Also IExpressionCompiler ITargetCompiler"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ExpressionCompilerBuildExtensions.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ExpressionCompilerBuildExtensions.html",
    "title": "Class ExpressionCompilerBuildExtensions",
    "keywords": "Class ExpressionCompilerBuildExtensions Extensions for IExpressionCompiler . Inheritance Object ExpressionCompilerBuildExtensions Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public static class ExpressionCompilerBuildExtensions Methods | Improve this Doc BuildResolveLambda(IExpressionCompiler, ITarget, IExpressionCompileContext) This method is a shortcut for building a lambda expression directly from an ITarget . It calls Build(ITarget, IExpressionCompileContext) and passes the result to BuildResolveLambda(Expression, IExpressionCompileContext) , which should yield an optimised lambda expression for the expression produced from the target which can then be compiled and used as the factory for that target. Declaration public static Expression<Func<ResolveContext, object>> BuildResolveLambda(this IExpressionCompiler compiler, ITarget target, IExpressionCompileContext context) Parameters Type Name Description IExpressionCompiler compiler The compiler. ITarget target The target. IExpressionCompileContext context The current compilation context. Returns Type Description Expression < Func < ResolveContext , Object >>"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ExpressionCompilerConfigurationProvider.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ExpressionCompilerConfigurationProvider.html",
    "title": "Class ExpressionCompilerConfigurationProvider",
    "keywords": "Class ExpressionCompilerConfigurationProvider Implements the ICompilerConfigurationProvider to configure expression-based compilation for targets in containers. The implementation registers all the targets necessary to use the expression tree-based compilation provided by the Rezolver.Compilation.Expressions library. This configuration provider is automatically configured as the default for all containers when the Rezolver library is referenced. Inheritance Object ExpressionCompilerConfigurationProvider Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class ExpressionCompilerConfigurationProvider : ICompilerConfigurationProvider Methods | Improve this Doc Configure(IContainer, ITargetContainer) Implements the Configure(IContainer, ITargetContainer) method, registering all the targets necessary to use expression-based compilation for all the standard targets defined in the Rezolver core library. Declaration public virtual void Configure(IContainer container, ITargetContainer targets) Parameters Type Name Description IContainer container The container - ignored. ITargetContainer targets Required - the target container into which the various targets will be registered. Implements Remarks All targets registered by this function are targets backed by concrete instances of the various components (compiler etc)."
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ExpressionTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ExpressionTargetBuilder.html",
    "title": "Class ExpressionTargetBuilder",
    "keywords": "Class ExpressionTargetBuilder An IExpressionBuilder specialised for building the expression trees for the target type. This builder takes care of all expressions, including lambdas (where additional parameters beyond the standard ResolveContext are turned into local variables with injected values), producing an expression which can be compiled by an IExpressionCompiler after a Rezolver.Compilation.Expressions.TargetExpressionRewriter has been used to expand any targets embedded in the expression. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ExpressionTarget > ExpressionTargetBuilder Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class ExpressionTargetBuilder : ExpressionBuilderBase<ExpressionTarget>, IExpressionBuilder<ExpressionTarget>, IExpressionBuilder Methods | Improve this Doc Build(ExpressionTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(ExpressionTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ExpressionTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.GenericConstructorTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.GenericConstructorTargetBuilder.html",
    "title": "Class GenericConstructorTargetBuilder",
    "keywords": "Class GenericConstructorTargetBuilder An IExpressionBuilder specialised for building expressions for targets. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < GenericConstructorTarget > GenericConstructorTargetBuilder Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class GenericConstructorTargetBuilder : ExpressionBuilderBase<GenericConstructorTarget>, IExpressionBuilder<GenericConstructorTarget>, IExpressionBuilder Methods | Improve this Doc Build(GenericConstructorTarget, IExpressionCompileContext, IExpressionCompiler) Obtains the bound target for the target passed (by calling , and passes it to the compiler to have an expression built for it. Declaration protected override Expression Build(GenericConstructorTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description GenericConstructorTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.IExpressionBuilder-1.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.IExpressionBuilder-1.html",
    "title": "Interface IExpressionBuilder<TTarget>",
    "keywords": "Interface IExpressionBuilder<TTarget> Interface for an object that produces expressions from instances of TTarget . This is a generic extension to the IExpressionBuilder interface. Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public interface IExpressionBuilder<in TTarget> : IExpressionBuilder where TTarget : ITarget Type Parameters Name Description TTarget The type of the target. Methods | Improve this Doc Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target. Declaration Expression Build(TTarget target, IExpressionCompileContext context, IExpressionCompiler compiler = null) Parameters Type Name Description TTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the builder should attempt to fetch the compiler from the context; or throw an exception if it is required but not provided and cannot be resolved fromm the context. Returns Type Description Expression Remarks When invoked by the ExpressionCompiler class, the compiler parameter will always be provided. See Also IExpressionBuilder"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.IExpressionBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.IExpressionBuilder.html",
    "title": "Interface IExpressionBuilder",
    "keywords": "Interface IExpressionBuilder The interface for an object that produces expressions (which can be compiled to delegates) from ITarget instances. Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public interface IExpressionBuilder Methods | Improve this Doc Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the specified target. Declaration Expression Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler = null) Parameters Type Name Description ITarget target The target for which an expression is to be built IExpressionCompileContext context The compilation context. IExpressionCompiler compiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the builder should attempt to fetch the compiler from the context; or throw an exception if it is required but not provided and cannot be resolved fromm the context. Returns Type Description Expression Remarks When invoked by the ExpressionCompiler class, the compiler parameter will always be provided. | Improve this Doc CanBuild(ITarget, IExpressionCompileContext) Determines whether this instance can build an expression for the specified target. Declaration bool CanBuild(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context The compilation context. Returns Type Description Boolean"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.IExpressionCompileContext.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.IExpressionCompileContext.html",
    "title": "Interface IExpressionCompileContext",
    "keywords": "Interface IExpressionCompileContext Extension to the ICompileContext interface which provides additional state and functionality for the IExpressionCompiler and the IExpressionBuilder implementations which are used by the default expression compiler, the ExpressionCompiler class. Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public interface IExpressionCompileContext : ICompileContext, ITargetContainer Properties | Improve this Doc ContainerExpression Gets an expression which gives a reference to the IContainer for this context - i.e. the same reference as given by the Container property. Declaration Expression ContainerExpression { get; } Property Value Type Description Expression Remarks Note that this is not the same as ContextContainerPropertyExpression - but is provided to allow expressions to be compiled which compare the container supplied at compile time to the one from the Container at resolve-time. | Improve this Doc ContextContainerPropertyExpression Gets an expression for reading the Container property of the ResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration MemberExpression ContextContainerPropertyExpression { get; } Property Value Type Description MemberExpression | Improve this Doc ContextScopePropertyExpression Gets an expression for reading the Scope property of the ResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration MemberExpression ContextScopePropertyExpression { get; } Property Value Type Description MemberExpression | Improve this Doc ParentContext Gets the parent context. Declaration IExpressionCompileContext ParentContext { get; } Property Value Type Description IExpressionCompileContext Remarks Note that this property hides the inherited ParentContext property, since an IExpressionCompileContext can only be a child of another IExpressionCompileContext . | Improve this Doc ResolveContextExpression This is the parameter expression which represents the ResolveContext that is passed to the ICompiledTarget at resolve-time. The other expressions - ContextContainerPropertyExpression and ContextScopePropertyExpression are both built from this too. Declaration ParameterExpression ResolveContextExpression { get; } Property Value Type Description ParameterExpression Remarks If the code produced by the IExpressionBuilder for a given target needs to read or use the ResolveContext that was originally passed to the Resolve(ResolveContext) method, then it does it by using this expression, which will be set as the only parameter on the lambda expression which is eventually compiled (in the case of the default expression compiler, ExpressionCompiler . | Improve this Doc SharedExpressions Gets a read-only enumerable of all the shared expressions that have been inherited from any parent context or added via calls to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) or GetOrAddSharedLocal(Type, String, Type) . Declaration IEnumerable<Expression> SharedExpressions { get; } Property Value Type Description IEnumerable < Expression > The shared expressions. Methods | Improve this Doc GetOrAddSharedExpression(Type, String, Func<Expression>, Type) Gets or adds an expression which is potentially shared between multiple targets' expression trees. Declaration Expression GetOrAddSharedExpression(Type type, string name, Func<Expression> expressionFactory, Type requestingType = null) Parameters Type Name Description Type type Required - the type of the expression. String name Required - the caller-defined name for this expression. Func < Expression > expressionFactory Required - Delegate to call to create the expression if it does not already exist. Type requestingType Optional - the type of the object requesting this shared expression. If this is provided, then the search for an existing shared expression will only work if the same requesting type was passed previously. Returns Type Description Expression Remarks Using shared expressions opens the door to potentially multiple optimisations, depending on the type of expression in question. For example, conditional expressions which share the same operand and comparand can all be merged into one with all the 'true' and 'false' branches being combined into one of each, thus saving multiple identical comparisons. | Improve this Doc GetOrAddSharedLocal(Type, String, Type) Similar to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) , except this is used when expression builders want to use local variables in block expressions to store the result of some operation in the expression tree built for a particular target. Reusing one local variable is more efficient than declaring the same local multiple times. Declaration ParameterExpression GetOrAddSharedLocal(Type type, string name, Type requestingType = null) Parameters Type Name Description Type type The type. String name The name. Type requestingType Optional - the type of the object requesting this shared expression. If this is provided, then the search for an existing shared expression will only work if the same requesting type was passed previously. Returns Type Description ParameterExpression Remarks When multiple expression trees from multiple targets are brought together into one lambda, there will often be many duplicate variables which could be shared. So, if an IExpressionBuilder needs a local variable for a block, instead of simply declaring it directly through the function, it can use this function instead, which will return a previously created one if available. | Improve this Doc NewContext(Type, Boolean, Nullable<ScopeBehaviour>) Creates a new IExpressionCompileContext using this one as a seed. This function is identical to NewContext(Type, Nullable<ScopeBehaviour>) but allows you to control whether the SharedExpressions are inherited (the default); and is more convenient because it returns another IExpressionCompileContext . Declaration IExpressionCompileContext NewContext(Type targetType = null, bool inheritSharedExpressions = true, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Boolean inheritSharedExpressions If true then the shared expressions in this context will be inherited by the new context by reference. That is, when the new context goes out of scope, any new shared expressions it created will still be available. If false, then the new context will get a brand new, empty, set of shared expressions. Nullable < ScopeBehaviour > scopeBehaviourOverride Override the ScopeBehaviourOverride to be used for the target that is compiled with the new context. This is never inherited automatically from one context to another. Returns Type Description IExpressionCompileContext Remarks When you have a reference to an IExpressionCompileContext the compiler will favour this method to the one defined on the ICompileContext interface because it is 'closer', even if you do not explicitly provide an argument for the inheritSharedExpressions parameter. See Also ICompileContext"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.IExpressionCompiler.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.IExpressionCompiler.html",
    "title": "Interface IExpressionCompiler",
    "keywords": "Interface IExpressionCompiler Interface for an object which is responsible for coordinating the production of expressions for targets during the compilation phase. Objects implementing this are expected to be implementations of ITargetCompiler ; this library provides the one implementation, too: ExpressionCompiler . Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public interface IExpressionCompiler : ITargetCompiler Remarks All expressions are built to be called from the GetObject(ResolveContext) function which, in turn, is typically called in response to a container's Resolve(ResolveContext) function being called. Note that the Build(ITarget, IExpressionCompileContext) method declared here is effectively an analogue to the Build(ITarget, IExpressionCompileContext, IExpressionCompiler) . Indeed, the default implementation resolves IExpressionBuilder instances to delegate the building of expressions. Methods | Improve this Doc Build(ITarget, IExpressionCompileContext) Gets an unoptimised expression containing the logic required to create or fetch an instance of the target 's DeclaredType when invoked for a particular ResolveContext . Use this method if you want the raw expression for a target (possibly when integrating it into your own expressions during custom compilation). Declaration Expression Build(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context Contains the supporting expressions (shared locals, shared expressions, ResolveContext expression etc) that have been used in the generation of the expression. Returns Type Description Expression Remarks If you want to build the optimised code for the passed target, you should use the BuildResolveLambda(IExpressionCompiler, ITarget, IExpressionCompileContext) extension method, which uses this method and then passes the result to the BuildResolveLambda(Expression, IExpressionCompileContext) function also defined on this interface. | Improve this Doc BuildResolveLambda(Expression, IExpressionCompileContext) This function optimises and prepares an expression that's (most likely) previously been produced by the Build(ITarget, IExpressionCompileContext) function into a lambda expression which can be compiled into a delegate and executed; or quoted inside another expression as a callback. The ResolveContextExpression of the context will be used to define the single parameter for the lambda that is created. Declaration Expression<Func<ResolveContext, object>> BuildResolveLambda(Expression targetExpression, IExpressionCompileContext context) Parameters Type Name Description Expression targetExpression Expression to be optimised and used as the body of the lambda. Any expression produced by the Build(ITarget, IExpressionCompileContext) method must be compatible with this. IExpressionCompileContext context Contains the supporting expressions (shared locals, shared expressions, ResolveContext expression etc) that have been used in the generation of the expression. Returns Type Description Expression < Func < ResolveContext , Object >> A lambda expression which, when compiled and executed, will produce an object consistent with the ITarget from which the code was produced."
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ListTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ListTargetBuilder.html",
    "title": "Class ListTargetBuilder",
    "keywords": "Class ListTargetBuilder An IExpressionBuilder specialised for building expressions for the target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ListTarget > ListTargetBuilder Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class ListTargetBuilder : ExpressionBuilderBase<ListTarget>, IExpressionBuilder<ListTarget>, IExpressionBuilder Methods | Improve this Doc Build(ListTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression which either represents creating an array or a list of objects using an enumerable of targets from the target 's . The target's flag is used to determine which expression to build. Declaration protected override Expression Build(ListTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ListTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ObjectTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ObjectTargetBuilder.html",
    "title": "Class ObjectTargetBuilder",
    "keywords": "Class ObjectTargetBuilder An IExpressionBuilder specialised to build expressions for the target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ObjectTarget > ObjectTargetBuilder Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class ObjectTargetBuilder : ExpressionBuilderBase<ObjectTarget>, IExpressionBuilder<ObjectTarget>, IExpressionBuilder Methods | Improve this Doc Build(ObjectTarget, IExpressionCompileContext, IExpressionCompiler) returns a ConstantExpression wrapped around the reference. Declaration protected override Expression Build(ObjectTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ObjectTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Exceptions Type Condition NotImplementedException"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.OptionalParameterTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.OptionalParameterTargetBuilder.html",
    "title": "Class OptionalParameterTargetBuilder",
    "keywords": "Class OptionalParameterTargetBuilder An IExpressionBuilder specialised for building an expression for the target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < OptionalParameterTarget > OptionalParameterTargetBuilder Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class OptionalParameterTargetBuilder : ExpressionBuilderBase<OptionalParameterTarget>, IExpressionBuilder<OptionalParameterTarget>, IExpressionBuilder Methods | Improve this Doc Build(OptionalParameterTarget, IExpressionCompileContext, IExpressionCompiler) Always returns a which contains the . Declaration protected override Expression Build(OptionalParameterTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description OptionalParameterTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.RedundantConvertRewriter.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.RedundantConvertRewriter.html",
    "title": "Class RedundantConvertRewriter",
    "keywords": "Class RedundantConvertRewriter Removes unnecessary convert expressions from an expression. An unnecessary conversion is one where the target type is equal to, or a base of, the source type. Only boxing/unboxing conversions or upcasts are left intact. Inheritance Object RedundantConvertRewriter Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class RedundantConvertRewriter : ExpressionVisitor Methods | Improve this Doc VisitUnary(UnaryExpression) Visits the children of the UnaryExpression . Declaration protected override Expression VisitUnary(UnaryExpression node) Parameters Type Name Description UnaryExpression node The expression to visit. Returns Type Description Expression"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.RezolvedTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.RezolvedTargetBuilder.html",
    "title": "Class RezolvedTargetBuilder",
    "keywords": "Class RezolvedTargetBuilder An IExpressionBuilder specialised for building the expression for the target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ResolvedTarget > RezolvedTargetBuilder Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class RezolvedTargetBuilder : ExpressionBuilderBase<ResolvedTarget>, IExpressionBuilder<ResolvedTarget>, IExpressionBuilder Methods | Improve this Doc Build(ResolvedTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(ResolvedTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ResolvedTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Exceptions Type Condition InvalidOperationException"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ScopedTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ScopedTargetBuilder.html",
    "title": "Class ScopedTargetBuilder",
    "keywords": "Class ScopedTargetBuilder An IExpressionBuilder specialised for building expressions for targets. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ScopedTarget > ScopedTargetBuilder Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class ScopedTargetBuilder : ExpressionBuilderBase<ScopedTarget>, IExpressionBuilder<ScopedTarget>, IExpressionBuilder Methods | Improve this Doc Build(ScopedTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(ScopedTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ScopedTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.SharedExpressionKey.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.SharedExpressionKey.html",
    "title": "Class SharedExpressionKey",
    "keywords": "Class SharedExpressionKey Key for a shared expression used during expression tree generation. As a consumer of this library, you are unlikely ever to need to use it. Inheritance Object SharedExpressionKey Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class SharedExpressionKey : IEquatable<SharedExpressionKey> Constructors | Improve this Doc SharedExpressionKey(Type, String, Type) Initializes a new instance of the SharedExpressionKey class. Declaration public SharedExpressionKey(Type targetType, string name, Type requestingType = null) Parameters Type Name Description Type targetType Required. Eventual runtime type of the object produced by the expression that will be cached using this key. String name Required. The name used for storing and retrieving expressions cached with this key. Type requestingType The type (e.g. the runtime type of an ITarget implementation) whose compilation requires the cached expression. Properties | Improve this Doc Name Gets the name used for expressions that are cached using this key. Declaration public string Name { get; } Property Value Type Description String The name. | Improve this Doc RequestingType Gets the type that registered the shared expression Declaration public Type RequestingType { get; } Property Value Type Description Type | Improve this Doc TargetType The intended type of the expression that is cached by this key. Declaration public Type TargetType { get; } Property Value Type Description Type Methods | Improve this Doc Equals(SharedExpressionKey) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(SharedExpressionKey other) Parameters Type Name Description SharedExpressionKey other An object to compare with this object. Returns Type Description Boolean true if the current object is equal to the other parameter; otherwise, false. Implements | Improve this Doc Equals(Object) Determines whether the specified Object is equal to this instance. Declaration public override bool Equals(object obj) Parameters Type Name Description Object obj The object to compare with the current object. Returns Type Description Boolean true if the specified Object is equal to this instance; otherwise, false . Overrides | Improve this Doc GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description Int32 A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. Overrides"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.SingletonTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.SingletonTargetBuilder.html",
    "title": "Class SingletonTargetBuilder",
    "keywords": "Class SingletonTargetBuilder An IExpressionBuilder specialised for the building the expression for a target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < SingletonTarget > SingletonTargetBuilder Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class SingletonTargetBuilder : ExpressionBuilderBase<SingletonTarget>, IExpressionBuilder<SingletonTarget>, IExpressionBuilder Methods | Improve this Doc Build(SingletonTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(SingletonTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description SingletonTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.TargetExpression.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.TargetExpression.html",
    "title": "Class TargetExpression",
    "keywords": "Class TargetExpression An expression which represents an ITarget . Inheritance Object TargetExpression Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class TargetExpression : Expression Remarks The ExpressionTargetBuilder uses this class extensively when translating expressions into targets and back again. It's highly unlikely you'll need to use it in your code. It acts as a placeholder for targets until the point at which the expression compiler wants to build a complete expression tree for a target. Constructors | Improve this Doc TargetExpression(ITarget) Initializes a new instance of the TargetExpression class. Declaration public TargetExpression(ITarget target) Parameters Type Name Description ITarget target The target. Properties | Improve this Doc CanReduce Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form. Declaration public override bool CanReduce { get; } Property Value Type Description Boolean true if this instance can reduce; otherwise, false . Remarks The implementation always returns true ; although the Reduce() methodd is not implemented. | Improve this Doc NodeType Gets the node type of this . Declaration public override ExpressionType NodeType { get; } Property Value Type Description ExpressionType Always returns . | Improve this Doc Target Gets the target whose expression will be subsituted for this TargetExpression in the final expression tree. Declaration public ITarget Target { get; } Property Value Type Description ITarget | Improve this Doc Type Gets the static type of the expression that this represents. Declaration public override Type Type { get; } Property Value Type Description Type Remarks Always returns the type referenced by the DeclaredType property of Target . Methods | Improve this Doc Reduce() Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced. Declaration public override Expression Reduce() Returns Type Description Expression Exceptions Type Condition NotSupportedException RezolveTargetExpression must be rewritten as a bona-fide expression before walking the expression tree for any other purpose"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.UnscopedTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.UnscopedTargetBuilder.html",
    "title": "Class UnscopedTargetBuilder",
    "keywords": "Class UnscopedTargetBuilder Builder for the . Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < UnscopedTarget > UnscopedTargetBuilder Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class UnscopedTargetBuilder : ExpressionBuilderBase<UnscopedTarget>, IExpressionBuilder<UnscopedTarget>, IExpressionBuilder Methods | Improve this Doc ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) overrides the base method to block all automatic scoping code from the expression being built. Declaration protected override Expression ApplyScoping(ScopeBehaviour scopeBehaviour, Expression builtExpression, ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ScopeBehaviour scopeBehaviour Expression builtExpression ITarget target IExpressionCompileContext context IExpressionCompiler compiler Returns Type Description Expression Overrides | Improve this Doc Build(UnscopedTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(UnscopedTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description UnscopedTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.html",
    "title": "Namespace Rezolver.Compilation.Expressions",
    "keywords": "Namespace Rezolver.Compilation.Expressions Classes Implementation of IExpressionBuilder specialised to build expressions for the This always produces a conversion expression (i.e. cast or box/unbox) An IExpressionBuilder specialised for building the target Specialised builder for targets. An IExpressionBuilder specialised for building the expression for the target. Essentially, it just calls for the . Specialised builder for the class and all its derivatives. Abstract starting point for implementing IExpressionBuilder . Note that the interface is implemented explicitly; but exposes protected abstract or virtual methods for inheritors to extend. Abstract base class for implementations of IExpressionBuilder<TTarget> . Provide an implementation of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) and then register an instance in an in the active container. An implementation of ICompileContext which is specialised for use by an IExpressionCompiler . Implementation of the ITargetCompiler interface which produces ICompiledTarget objects by building and compiling expression trees from the ITarget objects which are registered. Extensions for IExpressionCompiler . Implements the ICompilerConfigurationProvider to configure expression-based compilation for targets in containers. The implementation registers all the targets necessary to use the expression tree-based compilation provided by the Rezolver.Compilation.Expressions library. This configuration provider is automatically configured as the default for all containers when the Rezolver library is referenced. An IExpressionBuilder specialised for building the expression trees for the target type. This builder takes care of all expressions, including lambdas (where additional parameters beyond the standard ResolveContext are turned into local variables with injected values), producing an expression which can be compiled by an IExpressionCompiler after a Rezolver.Compilation.Expressions.TargetExpressionRewriter has been used to expand any targets embedded in the expression. An IExpressionBuilder specialised for building expressions for targets. An IExpressionBuilder specialised for building expressions for the target. An IExpressionBuilder specialised to build expressions for the target. An IExpressionBuilder specialised for building an expression for the target. Removes unnecessary convert expressions from an expression. An unnecessary conversion is one where the target type is equal to, or a base of, the source type. Only boxing/unboxing conversions or upcasts are left intact. An IExpressionBuilder specialised for building the expression for the target. An IExpressionBuilder specialised for building expressions for targets. Key for a shared expression used during expression tree generation. As a consumer of this library, you are unlikely ever to need to use it. An IExpressionBuilder specialised for the building the expression for a target. An expression which represents an ITarget . Builder for the . Interfaces The interface for an object that produces expressions (which can be compiled to delegates) from ITarget instances. Interface for an object that produces expressions from instances of TTarget . This is a generic extension to the IExpressionBuilder interface. Extension to the ICompileContext interface which provides additional state and functionality for the IExpressionCompiler and the IExpressionBuilder implementations which are used by the default expression compiler, the ExpressionCompiler class. Interface for an object which is responsible for coordinating the production of expressions for targets during the compilation phase. Objects implementing this are expected to be implementations of ITargetCompiler ; this library provides the one implementation, too: ExpressionCompiler ."
  },
  "rezolver-api/Rezolver.Compilation.ICompileContext.html": {
    "href": "rezolver-api/Rezolver.Compilation.ICompileContext.html",
    "title": "Interface ICompileContext",
    "keywords": "Interface ICompileContext Tracks state and provides services during the compilation phase in which ITarget targets are compiled into ICompiledTarget targets, which produce actual instances of objects. Inherited Members Namespace :Rezolver.Compilation Assembly :cs.temp.dll.dll Syntax public interface ICompileContext : ITargetContainer Remarks Implementations must also implement the ITargetContainer so the compile context can be used for dependency lookups during compilation time. Indeed, if you are developing your own compilation component (possibly for a custom ITarget implementation) and need to resolve any dependencies from an ITargetContainer during compilation, it should be done through the context's implementation of ITargetContainer. Properties | Improve this Doc CompileStack Gets the stack entries for all the targets that are being compiled. Declaration IEnumerable<CompileStackEntry> CompileStack { get; } Property Value Type Description IEnumerable < CompileStackEntry > The compile stack. | Improve this Doc Container The container that is considered the current compilation 'scope' - i.e. the container for which the compilation is being performed and, usually, the one on which the Resolve(ResolveContext) method was originally called which triggered the compilation call. Declaration IContainer Container { get; } Property Value Type Description IContainer | Improve this Doc ParentContext Gets the parent context from which this context was created, if applicable. Declaration ICompileContext ParentContext { get; } Property Value Type Description ICompileContext The parent context. | Improve this Doc ScopeBehaviourOverride If not null then this overrides the ScopeBehaviour of the ITarget that's currently being compiled. Declaration ScopeBehaviour? ScopeBehaviourOverride { get; } Property Value Type Description Nullable < ScopeBehaviour > | Improve this Doc TargetType Any ICompiledTarget built for a ITarget with this context should target this type. If null, then the DeclaredType of the target being compiled should be used. Declaration Type TargetType { get; } Property Value Type Description Type Methods | Improve this Doc NewContext(Type, Nullable<ScopeBehaviour>) Creates a new child context from this one, except the TargetType and ScopeBehaviourOverride properties can be overriden if required. Implementations must make sure that the ScopeBehaviourOverride is never inherited. Declaration ICompileContext NewContext(Type targetType = null, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Nullable < ScopeBehaviour > scopeBehaviourOverride Override the ScopeBehaviourOverride to be used for the target that is compiled with the new context. This is never inherited automatically from one context to another. Returns Type Description ICompileContext A new ICompileContext . | Improve this Doc PopCompileStack() Pops the compile stack, returning the entry that was popped. Declaration CompileStackEntry PopCompileStack() Returns Type Description CompileStackEntry | Improve this Doc PushCompileStack(ITarget, Type) Pushes the passed target on to the compile stack if it's not already on it for the same TargetType Compilers should consult the return value and abort compilation if it's true - since that implies a cyclic dependency graph. Declaration bool PushCompileStack(ITarget toCompile, Type targetType = null) Parameters Type Name Description ITarget toCompile To compile. Type targetType The type for which the target is being compiled, if different from DeclaredType Returns Type Description Boolean Remarks Targets can appear on the compilation stack more than once for different types, since the ICompiledTarget produced for a target for one type can be different than it is for another. Ultimately, if a target does in fact have a cyclic dependency graph, then this method will detect that. See Also ITargetContainer"
  },
  "rezolver-api/Rezolver.Compilation.ICompileContextProvider.html": {
    "href": "rezolver-api/Rezolver.Compilation.ICompileContextProvider.html",
    "title": "Interface ICompileContextProvider",
    "keywords": "Interface ICompileContextProvider Interface for an object which creates ICompileContext instances for when the system needs to compile an ITarget into an ICompiledTarget . Namespace :Rezolver.Compilation Assembly :cs.temp.dll.dll Syntax public interface ICompileContextProvider Remarks In normal operation, this interface is closely related to the ITargetCompiler interface because the core ContainerBase class (which provides most of the default implementation for IContainer ) obtains a new ICompileContext by resolving an instance of this interface, and calling the CreateContext(ResolveContext, ITargetContainer, IContainer) method, passing the result to the CompileTarget(ITarget, ICompileContext) method, along with the target to be compiled. Frequently, implementations of ITargetCompiler will also implement this interface to ensure that the compilation context contains everything the compiler needs to do its work. Methods | Improve this Doc CreateContext(ResolveContext, ITargetContainer, IContainer) Creates a compilation context for the given resolveContext - which is used to determine the RequestedType that the eventual ICompiledTarget should return. Declaration ICompileContext CreateContext(ResolveContext resolveContext, ITargetContainer targets, IContainer containerOverride = null) Parameters Type Name Description ResolveContext resolveContext The resolve context - used to get the RequestedType and the Container (if containerOverride is not provided). ITargetContainer targets The target container that should be used to lookup other non-compiled targets. IContainer containerOverride The container requesting the new compilation context, if different from the Container on the resolveContext Returns Type Description ICompileContext"
  },
  "rezolver-api/Rezolver.Compilation.ICompilerConfigurationProvider.html": {
    "href": "rezolver-api/Rezolver.Compilation.ICompilerConfigurationProvider.html",
    "title": "Interface ICompilerConfigurationProvider",
    "keywords": "Interface ICompilerConfigurationProvider Interface for an object which configures the compiler for the given container and/or targets object to use a specific ITargetCompiler and ICompileContextProvider . Used by all the standard container types in the Rezolver framework. You can provide a specific provider to most containers on creation, and you can configure the default system-wide provider via the DefaultProvider static property. Namespace :Rezolver.Compilation Assembly :cs.temp.dll.dll Syntax public interface ICompilerConfigurationProvider Methods | Improve this Doc Configure(IContainer, ITargetContainer) Called to configure the compiler and context provider for the given container and/or targets. When using the standard container types (based on ContainerBase ), the method should register directly-resolvable targets in the targets target container for the types ITargetCompiler and ICompileContextProvider so that the container can resolve the compiler and context provider. Declaration void Configure(IContainer container, ITargetContainer targets) Parameters Type Name Description IContainer container The container. ITargetContainer targets The targets. Remarks The built-in container classes (all those which inherit from ContainerBase ) rely on their ITargetContainer to directly resolve the compiler and context provider that is used to compile ITarget objects into ICompiledTarget instances. Therefore, in order to use a specific compilation strategy, the framework needs some way of knowing how the underlying ITargetContainer should be configured to use that strategy. Since this requires adding registrations to the container, the most flexible way to do that is via a callback, which is what this method technically represents. Note that the registered targets must NOT require compilation - i.e. - the target must either directly implement ITargetCompiler / ICompileContextProvider or also implement ICompiledTarget such that when GetObject(ResolveContext) is called, the actual compiler or context provider are returned. The simplest way to achieve this is to build the compiler/context provider conventionally, and then use the target to store them directly in the target container against the types for which they should be used. This is how the default expression compiler does it - in addition to registering additional targets to support the different compilation strategies required for the different target types."
  },
  "rezolver-api/Rezolver.Compilation.ITargetCompiler.html": {
    "href": "rezolver-api/Rezolver.Compilation.ITargetCompiler.html",
    "title": "Interface ITargetCompiler",
    "keywords": "Interface ITargetCompiler An object that produces ICompiledTarget s from ITarget s given a particular ICompileContext . Namespace :Rezolver.Compilation Assembly :cs.temp.dll.dll Syntax public interface ITargetCompiler Methods | Improve this Doc CompileTarget(ITarget, ICompileContext) Create the ICompiledTarget for the given target using the context to inform the type of object that is to be built, and for compile-time dependency resolution. Declaration ICompiledTarget CompileTarget(ITarget target, ICompileContext context) Parameters Type Name Description ITarget target Required. The target to be compiled. ICompileContext context Required. The current compilation context. Returns Type Description ICompiledTarget A compiled target which can then be used to get produce objects represented by the target ."
  },
  "rezolver-api/Rezolver.Compilation.SharedExpressionKey.html": {
    "href": "rezolver-api/Rezolver.Compilation.SharedExpressionKey.html",
    "title": "Class SharedExpressionKey",
    "keywords": "Class SharedExpressionKey Key for a shared expression used during expression tree generation. As a consumer of this library, you are unlikely ever to need to use it. Inheritance Object SharedExpressionKey Inherited Members Namespace :Rezolver.Compilation Assembly :cs.temp.dll.dll Syntax public class SharedExpressionKey : IEquatable<SharedExpressionKey> Constructors | Improve this Doc SharedExpressionKey(Type, String, Type) Initializes a new instance of the SharedExpressionKey class. Declaration public SharedExpressionKey(Type targetType, string name, Type requestingType = null) Parameters Type Name Description Type targetType Required. Eventual runtime type of the object produced by the expression that will be cached using this key. String name Required. The name used for storing and retrieving expressions cached with this key. Type requestingType The type (e.g. the runtime type of an ITarget implementation) whose compilation requires the cached expression. Properties | Improve this Doc Name Gets the name used for expressions that are cached using this key. Declaration public string Name { get; } Property Value Type Description String The name. | Improve this Doc RequestingType Gets the type that registered the shared expression Declaration public Type RequestingType { get; } Property Value Type Description Type | Improve this Doc TargetType The intended type of the expression that is cached by this key. Declaration public Type TargetType { get; } Property Value Type Description Type Methods | Improve this Doc Equals(SharedExpressionKey) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(SharedExpressionKey other) Parameters Type Name Description SharedExpressionKey other An object to compare with this object. Returns Type Description Boolean true if the current object is equal to the other parameter; otherwise, false. Implements | Improve this Doc Equals(Object) Determines whether the specified Object is equal to this instance. Declaration public override bool Equals(object obj) Parameters Type Name Description Object obj The object to compare with the current object. Returns Type Description Boolean true if the specified Object is equal to this instance; otherwise, false . Overrides | Improve this Doc GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description Int32 A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. Overrides"
  },
  "rezolver-api/Rezolver.Compilation.TargetCompiler.html": {
    "href": "rezolver-api/Rezolver.Compilation.TargetCompiler.html",
    "title": "Class TargetCompiler",
    "keywords": "Class TargetCompiler Holds a reference to the default compiler for this application. Inheritance Object TargetCompiler Inherited Members Namespace :Rezolver.Compilation Assembly :cs.temp.dll.dll Syntax public static class TargetCompiler Properties | Improve this Doc Default The default compiler to be used by rezolvers when they are not explicitly provided one. Declaration public static ITargetCompiler Default { get; set; } Property Value Type Description ITargetCompiler"
  },
  "rezolver-api/Rezolver.Compilation.html": {
    "href": "rezolver-api/Rezolver.Compilation.html",
    "title": "Namespace Rezolver.Compilation",
    "keywords": "Namespace Rezolver.Compilation Classes Core implementation of ICompileContext . A root context (i.e. where ParentContext is null ; created via the CompileContext(IContainer, ITargetContainer, Type) constructor) is the starting point for all shared state, such as the Container and the compilation stack. The ITargetContainer implementation is done by decorating a new ChildTargetContainer , so that new registrations can be added without interfering with upstream containers. Note that many of the interface members are implemented explicitly - therefore most of your interaction with this type is through its implementation of ICompileContext and ITargetContainer . Controls the system-wide compiler configuration used by default by all standard Rezolver containers. Represents an entry in the compilation stack of a ICompileContext , recording both a target that is being compiled, and the type for which it is being compiled. Holds a reference to the default compiler for this application. Interfaces Tracks state and provides services during the compilation phase in which ITarget targets are compiled into ICompiledTarget targets, which produce actual instances of objects. Interface for an object which creates ICompileContext instances for when the system needs to compile an ITarget into an ICompiledTarget . Interface for an object which configures the compiler for the given container and/or targets object to use a specific ITargetCompiler and ICompileContextProvider . Used by all the standard container types in the Rezolver framework. You can provide a specific provider to most containers on creation, and you can configure the default system-wide provider via the DefaultProvider static property. An object that produces ICompiledTarget s from ITarget s given a particular ICompileContext ."
  },
  "rezolver-api/Rezolver.CompileContext.CompileStackEntry.html": {
    "href": "rezolver-api/Rezolver.CompileContext.CompileStackEntry.html",
    "title": "Class CompileContext.CompileStackEntry",
    "keywords": "Class CompileContext.CompileStackEntry Represents an Inheritance Object CompileContext.CompileStackEntry Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class CompileStackEntry : IEquatable<CompileContext.CompileStackEntry> Constructors | Improve this Doc CompileStackEntry(ITarget, Type) Declaration public CompileStackEntry(ITarget target, Type compilingType) Parameters Type Name Description ITarget target Type compilingType Properties | Improve this Doc CompilingType Declaration public Type CompilingType { get; } Property Value Type Description Type | Improve this Doc Target Declaration public ITarget Target { get; } Property Value Type Description ITarget Methods | Improve this Doc Equals(CompileContext.CompileStackEntry) Declaration public bool Equals(CompileContext.CompileStackEntry other) Parameters Type Name Description CompileContext.CompileStackEntry other Returns Type Description Boolean Implements"
  },
  "rezolver-api/Rezolver.CompileContext.SharedExpressionKey.html": {
    "href": "rezolver-api/Rezolver.CompileContext.SharedExpressionKey.html",
    "title": "Class CompileContext.SharedExpressionKey",
    "keywords": "Class CompileContext.SharedExpressionKey Key for a shared expression used during expression tree generation. As a consumer of this library, you are unlikely ever to need to use it. Inheritance Object CompileContext.SharedExpressionKey Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class SharedExpressionKey : IEquatable<CompileContext.SharedExpressionKey> Constructors | Improve this Doc SharedExpressionKey(Type, String, Type) Initializes a new instance of the CompileContext.SharedExpressionKey class. Declaration public SharedExpressionKey(Type targetType, string name, Type requestingType = null) Parameters Type Name Description Type targetType Required. Eventual runtime type of the object produced by the expression that will be cached using this key. String name Required. The name used for storing and retrieving expressions cached with this key. Type requestingType The type (e.g. the runtime type of an ITarget implementation) whose compilation requires the cached expression. Properties | Improve this Doc Name Gets the name used for expressions that are cached using this key. Declaration public string Name { get; } Property Value Type Description String The name. | Improve this Doc RequestingType Gets the type that registered the shared expression Declaration public Type RequestingType { get; } Property Value Type Description Type | Improve this Doc TargetType The intended type of the expression that is cached by this key. Declaration public Type TargetType { get; } Property Value Type Description Type Methods | Improve this Doc Equals(CompileContext.SharedExpressionKey) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(CompileContext.SharedExpressionKey other) Parameters Type Name Description CompileContext.SharedExpressionKey other An object to compare with this object. Returns Type Description Boolean true if the current object is equal to the other parameter; otherwise, false. Implements | Improve this Doc Equals(Object) Determines whether the specified Object is equal to this instance. Declaration public override bool Equals(object obj) Parameters Type Name Description Object obj The object to compare with the current object. Returns Type Description Boolean true if the specified Object is equal to this instance; otherwise, false . Overrides | Improve this Doc GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description Int32 A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. Overrides"
  },
  "rezolver-api/Rezolver.CompileContext.html": {
    "href": "rezolver-api/Rezolver.CompileContext.html",
    "title": "Class CompileContext",
    "keywords": "Class CompileContext Provides support and compile-time state for the compilation of an ITarget by an ITargetCompiler . THIS CLASS IS NOT THREAD-SAFE Inheritance Object CompileContext Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class CompileContext : ITargetContainer Remarks The purpose of this class is to help an ITarget generate an expression tree that will ultimately be compiled using CompileTarget(ITarget, CompileContext) method. The goal being to produce an ICompiledTarget whose Rezolver.ICompiledTarget.GetObject(Rezolver.RezolveContext) method will be called to get instances when a container's Rezolver.IContainer.Resolve(Rezolver.RezolveContext) method is invoked. Therefore, the context of the expression tree being generated is a method which takes a single RezolveContext parameter - hence the expressions exposed by this type (e.g. RezolveContextExpression ) are there to help generate code that will work in that context. Working directly with this, or any other code connected with the expression tree/compilation process, is an advanced topic! The class implements the ITargetContainer interface also to extend dependency lookups during compilation time. Indeed, if you are developing your own ITarget implementation and need to resolve any dependencies from an ITargetContainer during compilation, it should be done through the context's implementation of ITargetContainer. Constructors | Improve this Doc CompileContext(CompileContext, Type, Boolean, Boolean) Creates a new CompileContext using an existing one as a template. Declaration public CompileContext(CompileContext parentContext, Type targetType = null, bool inheritSharedExpressions = true, bool suppressScopeTracking = false) Parameters Type Name Description CompileContext parentContext Used to seed the compilation stack, container, rezolve context parameter and optionally the target type (if you pass null for targetType . Type targetType The target type that is expected to be compiled, or null to inherit the parentContext 's TargetType property. Boolean inheritSharedExpressions If true (the default), then the SharedExpressions for this context will be shared from the parent context - meaning that any new additions will be added back to the parent context again. This is the most common behaviour when chaining multiple targets' expressions together. Passing false for this parameter is only required in rare situations. Boolean suppressScopeTracking If true, then any expressions constructed from ITarget objects should not contain automatically generated code to track objects in an enclosing scope. The default is false. This is typically only enabled when one target is explicitly using expressions created from other targets, and has its own scope tracking code, or expects to be surrounded by automatically generated scope tracking code itself. | Improve this Doc CompileContext(IContainer, ITargetContainer, Type, ParameterExpression, IEnumerable<CompileContext.CompileStackEntry>) Creates a new CompileContext Declaration public CompileContext(IContainer container, ITargetContainer dependencyTargetContainer, Type targetType = null, ParameterExpression rezolveContextExpression = null, IEnumerable<CompileContext.CompileStackEntry> compilingTargets = null) Parameters Type Name Description IContainer container Required. The container for which compilation is being performed. Will be set into the Container property. ITargetContainer dependencyTargetContainer Required - An ITargetContainer that contains the ITarget s that will be required to complete compilation. Note - this argument is passed to a new ChildTargetContainer that is created and proxied by this class' implementation of ITargetContainer . As a result, it's possible to register new targets directly into the context via the Register(ITarget, Type) method, without modifying the underlying targets in the container you pass. Some of the core ITarget s exposed by this library take advantage of that functionality (notably, the DecoratorTarget ). Type targetType Optional. Will be set into the TargetType property. If not provided, then any code generated within this context should compile for the DeclaredType . ParameterExpression rezolveContextExpression Optional. Will be set into the RezolveContextExpression property. If not provided, then the RezolveContextParameterExpression global reference will be used. IEnumerable < CompileContext.CompileStackEntry > compilingTargets Optional. Allows you to seed the stack of compiling targets from creation. Properties | Improve this Doc CompilingTargets An enumerable representing the current stack of targets that are being compiled on this context. The underlying stack is not exposed through this enumerable. Declaration public IEnumerable<CompileContext.CompileStackEntry> CompilingTargets { get; } Property Value Type Description IEnumerable < CompileContext.CompileStackEntry > | Improve this Doc Container The container that is considered the current compilation 'scope' - i.e. the container for which the compilation is being performed and, usually, the one on which the Rezolver.IContainer.Resolve(Rezolver.RezolveContext) method was originally called which triggered the compilation call. Declaration public IContainer Container { get; } Property Value Type Description IContainer Remarks NOTE - For compile-time dependency resolution (i.e. other ITarget s) you should use this class' implementation of ITargetContainer . | Improve this Doc ContainerExpression A ConstantExpression that equals the Container that is active for this context - you can use this during code generation to alter your expression's behaviour if the Container during a future call to Rezolver.IContainer.Resolve(Rezolver.RezolveContext) is different from the one for which the expression was first compiled. For this kind of behaviour you will also need to use the RezolveContextExpression Declaration public Expression ContainerExpression { get; } Property Value Type Description Expression | Improve this Doc ContextContainerPropertyExpression Returns an expression that represents reading the Container property of the RezolveContextExpression during the execution of an ICompiledTarget 's Rezolver.ICompiledTarget.GetObject(Rezolver.RezolveContext) method. Declaration public MemberExpression ContextContainerPropertyExpression { get; } Property Value Type Description MemberExpression Remarks This IS NOT the same as the ContainerExpression property, which always returns a constant reference to the original IContainer for which this compilation context was created. Always non-null. | Improve this Doc ContextScopePropertyExpression Returns an expression that represents reading the Scope property of the RezolveContext referenced by the RezolveContextExpression at resolve-time. Declaration public MemberExpression ContextScopePropertyExpression { get; } Property Value Type Description MemberExpression | Improve this Doc RezolveContextExpression An expression to be used to bind to the RezolveContext parameter be passed to the generated code at runtime (the context parameter for Rezolver.IContainer.Resolve(Rezolver.RezolveContext) and, eventually, Rezolver.ICompiledTarget.GetObject(Rezolver.RezolveContext) ). Declaration public ParameterExpression RezolveContextExpression { get; } Property Value Type Description ParameterExpression Remarks If this is never explicitly set, the framework uses RezolveContextParameterExpression by default. In theory, you should never need to set this to anything else, unless you're doing something very interesting with the generated expressions. | Improve this Doc SharedExpressions The expressions that have been registered by targets whilst creating expressions for compiled targets. Declaration public IEnumerable<Expression> SharedExpressions { get; } Property Value Type Description IEnumerable < Expression > Remarks Shared expressions are expressions which targets add to the compile context as they are compiled, enabling them to generate code which is both more efficient at runtime (e.g. avoiding the creation of redundant locals for blocks which can reuse a pre-existing local) and which can be more efficiently rewritten due to the reuse of identical expression references for things like conditional checks and so on. A compiler MUST handle the case where this enumerable contains ParameterExpressions, as they will need to be added as local variables to an all-encompassing BlockExpression around the root of an expression tree that is to be compiled. | Improve this Doc SuppressScopeTracking If true, then any target that is compiling within this context should not generate any runtime code to fetch the object from, or track the object in, the current IScopedContainer (identified by the ContextScopePropertyExpression ). Declaration public bool SuppressScopeTracking { get; } Property Value Type Description Boolean Remarks This is currently used, for example, by wrapper targets that generate their own scope tracking code (specifically, the SingletonTarget and ScopedTarget . It's therefore very important that any custom ITarget implementations which intend to do their own scoping honour this flag in their implementation of Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) . The TargetBase class does honour this flag. | Improve this Doc TargetType The type that is to be returned by the generated code. Declaration public Type TargetType { get; } Property Value Type Description Type Methods | Improve this Doc CombineWith(ITargetContainer, Type) Always throws a NotSupportedException Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Ignored Type type Ignored Returns Type Description ITargetContainer Implements Exceptions Type Condition NotSupportedException Always thrown | Improve this Doc Fetch(Type) Implements Fetch(Type) by wrapping around the child target container created by this context on construction. Declaration public ITarget Fetch(Type type) Parameters Type Name Description Type type See Fetch(Type) for more. Returns Type Description ITarget Implements | Improve this Doc FetchAll(Type) Implements FetchAll(Type) by wrapping around the child target container created by this context on construction. Declaration public IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type See FetchAll(Type) for more Returns Type Description IEnumerable < ITarget > Implements | Improve this Doc GetOrAddSharedExpression(Type, String, Func<Expression>, Type) Gets or adds a shared expression (created by the expressionFactory if it's not already cached) with the given name, type, optionally for the given requestingType . Declaration public Expression GetOrAddSharedExpression(Type type, string name, Func<Expression> expressionFactory, Type requestingType = null) Parameters Type Name Description Type type The runtime type of the Expression. String name The runtime name of the Expression - and also the name used to retrieve it later. Func < Expression > expressionFactory The factory method to use to construct the shared expression from scratch, if it's not already cached. Type requestingType Optional - to avoid naming clashes with shared expressions created by other targets, you can pass a type here (usually the runtime type of your ITarget implementation). Returns Type Description Expression Expression. | Improve this Doc GetOrAddSharedLocal(Type, String, Type) Creates or retrieves a shared with the given name and type, optionally registered for the given requestingType . Declaration public ParameterExpression GetOrAddSharedLocal(Type type, string name, Type requestingType = null) Parameters Type Name Description Type type The runtime type of the ParameterExpression. String name The runtime name of the ParameterExpression - and also the name used to retrieve it later. Type requestingType Optional - to avoid naming clashes with shared parameter expressions created by other targets, you can pass a type here (usually the runtime type of your ITarget implementation). Returns Type Description ParameterExpression Remarks If you use a shared for a local in your expression trees, you are signifying that all of your targets which use that local, regardless of whether they represent different results at runtime, can safely store and retrieve whatever state they are tracking within without interfering with each other. | Improve this Doc New(Type, Boolean, Boolean) Spawns a new context for the passed targetType , with everything else being inherited from this context by default. Declaration public CompileContext New(Type targetType, bool inheritSharedExpressions = true, bool suppressScopeTracking = false) Parameters Type Name Description Type targetType Required. The type to be compiled. Boolean inheritSharedExpressions if set to true [inherit shared expressions]. Boolean suppressScopeTracking if set to true [suppress scope tracking]. Returns Type Description CompileContext A new CompileContext Remarks This is a convenience method which simply wraps the CompileContext(CompileContext, Type, Boolean, Boolean) constructor, except in this method the targetType is required. | Improve this Doc PopCompileStack() Pops a target from the stack and returns it. Note that if there are no targets on the stack, an InvalidOperationException will occur. Declaration public CompileContext.CompileStackEntry PopCompileStack() Returns Type Description CompileContext.CompileStackEntry | Improve this Doc PushCompileStack(ITarget) Adds the target to the compilation stack if it doesn't already exist. Declaration public bool PushCompileStack(ITarget toCompile) Parameters Type Name Description ITarget toCompile The target to be pushed Returns Type Description Boolean A boolean indicating whether the target was added. Will be false if the target is already on the stack. | Improve this Doc Register(ITarget, Type) Implements Register(ITarget, Type) by wrapping around the child target container created by this context on construction. Declaration public void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target See Register(ITarget, Type) for more Type serviceType See Register(ITarget, Type) for more Implements"
  },
  "rezolver-api/Rezolver.CompiledTargetBase.html": {
    "href": "rezolver-api/Rezolver.CompiledTargetBase.html",
    "title": "Class CompiledTargetBase",
    "keywords": "Class CompiledTargetBase Standard starting point for an implementation of ICompiledTarget where the target is built directly from an ITarget . Inheritance Object CompiledTargetBase Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public abstract class CompiledTargetBase : ICompiledTarget Constructors | Improve this Doc CompiledTargetBase(ITarget) Initialises the CompiledTargetBase abstract class. Declaration protected CompiledTargetBase(ITarget originalTarget) Parameters Type Name Description ITarget originalTarget Required - the target that was compiled into this instance. Properties | Improve this Doc OriginalTarget The target whose expression (obtained from Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) ) was compiled into this instance. Will not be null. Declaration protected ITarget OriginalTarget { get; } Property Value Type Description ITarget Methods | Improve this Doc GetObject(RezolveContext) Abstract implementation of Rezolver.ICompiledTarget.GetObject(Rezolver.RezolveContext) Declaration public abstract object GetObject(RezolveContext context) Parameters Type Name Description RezolveContext context Returns Type Description Object Implements"
  },
  "rezolver-api/Rezolver.ConditionalRewriter.html": {
    "href": "rezolver-api/Rezolver.ConditionalRewriter.html",
    "title": "Class ConditionalRewriter",
    "keywords": "Class ConditionalRewriter Reorders an expression tree where duplicate conditional expressions are found in multiple places throughout that expression tree. Those duplicated conditionals are moved further up the expression tree into one conditional. Inheritance Object ConditionalRewriter Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ConditionalRewriter : ExpressionVisitor Constructors | Improve this Doc ConditionalRewriter(Expression, IEnumerable<Expression>) Declaration public ConditionalRewriter(Expression expression, IEnumerable<Expression> candidateTests) Parameters Type Name Description Expression expression IEnumerable < Expression > candidateTests Methods | Improve this Doc Rewrite() Declaration public Expression Rewrite() Returns Type Description Expression | Improve this Doc Visit(Expression) Declaration public override Expression Visit(Expression node) Parameters Type Name Description Expression node Returns Type Description Expression | Improve this Doc VisitConditional(ConditionalExpression) Declaration protected override Expression VisitConditional(ConditionalExpression node) Parameters Type Name Description ConditionalExpression node Returns Type Description Expression"
  },
  "rezolver-api/Rezolver.Configuration.AssemblyReferenceEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.AssemblyReferenceEntry.html",
    "title": "Class AssemblyReferenceEntry",
    "keywords": "Class AssemblyReferenceEntry Inheritance Object ConfigurationEntryBase AssemblyReferenceEntry Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class AssemblyReferenceEntry : ConfigurationEntryBase, IAssemblyReferenceEntry, IConfigurationEntry, IConfigurationLineInfo Constructors | Improve this Doc AssemblyReferenceEntry(String, IConfigurationLineInfo) Declaration public AssemblyReferenceEntry(string assemblyName, IConfigurationLineInfo lineInfo = null) Parameters Type Name Description String assemblyName IConfigurationLineInfo lineInfo Properties | Improve this Doc AssemblyName Declaration public string AssemblyName { get; } Property Value Type Description String Implements"
  },
  "rezolver-api/Rezolver.Configuration.Json.JsonConfigurationException.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.JsonConfigurationException.html",
    "title": "Class JsonConfigurationException",
    "keywords": "Class JsonConfigurationException Thrown when a Json container configuration file is invalid. Inheritance Object Exception JsonConfigurationException Inherited Members Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class JsonConfigurationException : Exception, ISerializable, _Exception Constructors | Improve this Doc JsonConfigurationException(JsonToken, JsonReader) Constructs a new instance of the JsonConfigurationException class which reports that the token at the current location of the file was not expected. Declaration public JsonConfigurationException(JsonToken expectedTokenType, JsonReader reader) Parameters Type Name Description JsonToken expectedTokenType JsonReader reader | Improve this Doc JsonConfigurationException(String, JsonReader) Constructs a new instance of the JsonConfigurationException class. Note, if you supply a JsonReader, then the current line and column will be reported automatically at the end of the exception message. Declaration public JsonConfigurationException(string message, JsonReader reader) Parameters Type Name Description String message JsonReader reader | Improve this Doc JsonConfigurationException(String, JToken) Constructs a new instance of the JsonConfigurationException class. Note, if you supply a JObject, then the starting line and column of that object from the original source text will be reported automatically at the end of the exception message. Declaration public JsonConfigurationException(string message, JToken jToken) Parameters Type Name Description String message JToken jToken Properties | Improve this Doc Message Declaration public override string Message { get; } Property Value Type Description String Overrides | Improve this Doc Reader If not null, then this is a reader whose position should be at the place where the error occurs. Declaration public JsonReader Reader { get; } Property Value Type Description JsonReader"
  },
  "rezolver-api/Rezolver.Configuration.Json.JsonConfigurationParser.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.JsonConfigurationParser.html",
    "title": "Class JsonConfigurationParser",
    "keywords": "Class JsonConfigurationParser Inheritance Object JsonConfigurationParser Inherited Members Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class JsonConfigurationParser Methods | Improve this Doc CreateJsonSerializerSettings() Declaration public virtual JsonSerializerSettings CreateJsonSerializerSettings() Returns Type Description JsonSerializerSettings | Improve this Doc CreateSerializer(JsonSerializerSettings) Declaration public virtual JsonSerializer CreateSerializer(JsonSerializerSettings settings) Parameters Type Name Description JsonSerializerSettings settings Returns Type Description JsonSerializer | Improve this Doc Parse(String) Declaration public IConfiguration Parse(string json) Parameters Type Name Description String json Returns Type Description IConfiguration | Improve this Doc Parse(String, JsonSerializer) Declaration public virtual IConfiguration Parse(string json, JsonSerializer jsonSerializer) Parameters Type Name Description String json JsonSerializer jsonSerializer Returns Type Description IConfiguration"
  },
  "rezolver-api/Rezolver.Configuration.Json.LazyJsonObjectTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.LazyJsonObjectTargetMetadata.html",
    "title": "Class LazyJsonObjectTargetMetadata",
    "keywords": "Class LazyJsonObjectTargetMetadata Special version of IObjectTargetMetadata which creates an instance of the requested type from a JToken. Some more work might be required here to Inheritance Object RezolveTargetMetadataBase ObjectTargetMetadataBase LazyJsonObjectTargetMetadata Inherited Members Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class LazyJsonObjectTargetMetadata : ObjectTargetMetadataBase, IObjectTargetMetadata, IRezolveTargetMetadata Properties | Improve this Doc DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides Methods | Improve this Doc BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Type Name Description ITypeReference [] targetTypes Returns Type Description IRezolveTargetMetadata Overrides | Improve this Doc GetObject(Type) Declaration public override object GetObject(Type type) Parameters Type Name Description Type type Returns Type Description Object Overrides"
  },
  "rezolver-api/Rezolver.TargetAdapterRegisterExpressionExtensions.html": {
    "href": "rezolver-api/Rezolver.TargetAdapterRegisterExpressionExtensions.html",
    "title": "Class TargetAdapterRegisterExpressionExtensions",
    "keywords": "Class TargetAdapterRegisterExpressionExtensions Extensions for to simplify registering expressions in an ITargetContainer . Inheritance Object TargetAdapterRegisterExpressionExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class TargetAdapterRegisterExpressionExtensions Methods | Improve this Doc RegisterExpression(ITargetContainer, Expression, Type, ITargetAdapter) Registers the expression. Declaration public static void RegisterExpression(this ITargetContainer targetContainer, Expression expression, Type type, ITargetAdapter adapter = null) Parameters Type Name Description ITargetContainer targetContainer The target container. Expression expression The expression. Type type The type. ITargetAdapter adapter The adapter."
  },
  "rezolver-api/Rezolver.TargetAssemblyCompiler.html": {
    "href": "rezolver-api/Rezolver.TargetAssemblyCompiler.html",
    "title": "Class TargetAssemblyCompiler",
    "keywords": "Class TargetAssemblyCompiler Implementation of the ITargetCompiler which compiles dynamic code to an assembly (which can, potentially, be saved to disk). Suitable for environments that support the full .Net profile. Generally, the performance of a container built using this compiler will be better than one that uses the TargetDelegateCompiler . Inheritance Object TargetAssemblyCompiler Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetAssemblyCompiler : ITargetCompiler Constructors | Improve this Doc TargetAssemblyCompiler() Initializes a new instance of the TargetAssemblyCompiler class. Declaration public TargetAssemblyCompiler() | Improve this Doc TargetAssemblyCompiler(AssemblyBuilder) Initializes a new instance of the TargetAssemblyCompiler class. Declaration public TargetAssemblyCompiler(AssemblyBuilder assemblyBuilder) Parameters Type Name Description AssemblyBuilder assemblyBuilder The assembly builder into which the dynamically generated code will be compiled. Exceptions Type Condition ArgumentNullException assemblyBuilder is null | Improve this Doc TargetAssemblyCompiler(ModuleBuilder) Initializes a new instance of the TargetAssemblyCompiler class. Declaration public TargetAssemblyCompiler(ModuleBuilder moduleBuilder) Parameters Type Name Description ModuleBuilder moduleBuilder The module builder - if the assembly builder is already being used for something else and you want the dynamic code for the container to be compiled into a specific module within that assembly. Properties | Improve this Doc AssemblyBuilder Gets the assembly builder whose dynamic assembly is receiving the dynamically generated code. Declaration public AssemblyBuilder AssemblyBuilder { get; } Property Value Type Description AssemblyBuilder The assembly builder. Methods | Improve this Doc CompileTarget(ITarget, CompileContext) Creates and builds a compiled target for the passed rezolve target which can then be used to create/obtain the object(s) it produces. Declaration public ICompiledTarget CompileTarget(ITarget target, CompileContext context) Parameters Type Name Description ITarget target The target to be compiled. CompileContext context The current compilation context. Returns Type Description ICompiledTarget A compiled target that produces the object represented by target . Implements | Improve this Doc CreateAssemblyBuilder(AssemblyBuilderAccess, String) Shortcut method for creating an assembly builder that is suitable for use with an TargetAssemblyCompiler , but with the supplied access settings (e.g. if you want to be able to save the assembly). Declaration public static AssemblyBuilder CreateAssemblyBuilder(AssemblyBuilderAccess assemblyBuilderAccess = null, string dir = null) Parameters Type Name Description AssemblyBuilderAccess assemblyBuilderAccess The assembly builder access. String dir If supplied, then it's the base directory that will be used when saving the dynamic dll. Returns Type Description AssemblyBuilder An AssemblyBuilder instance that can be passed to the TargetAssemblyCompiler constructor."
  },
  "rezolver-api/Rezolver.TargetBase.html": {
    "href": "rezolver-api/Rezolver.TargetBase.html",
    "title": "Class TargetBase",
    "keywords": "Class TargetBase Abstract base class, suggested as a starting point for implementations of ITarget . Inheritance Object TargetBase Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public abstract class TargetBase : ITarget Properties | Improve this Doc DeclaredType Gets the declared type of object that is constructed by this target. Declaration public abstract Type DeclaredType { get; } Property Value Type Description Type Implements | Improve this Doc SuppressScopeTracking this is probably going to be removed or at least changed. Declaration protected virtual bool SuppressScopeTracking { get; } Property Value Type Description Boolean | Improve this Doc UseFallback Implementation of UseFallback Base version always returns false . Declaration public virtual bool UseFallback { get; } Property Value Type Description Boolean Implements Methods | Improve this Doc SupportsType(Type) Called to check whether a target can create an expression that builds an instance of the given type . Declaration public virtual bool SupportsType(Type type) Parameters Type Name Description Type type Required Returns Type Description Boolean true if this target supports the given type, false otherwise. Implements"
  },
  "rezolver-api/Rezolver.TargetCompiler.html": {
    "href": "rezolver-api/Rezolver.TargetCompiler.html",
    "title": "Class TargetCompiler",
    "keywords": "Class TargetCompiler Holds a reference to the default compiler for this application. By default this is set to the TargetDelegateCompiler - which is a general purpose compiler that should work on any platform which supports linq expression trees. Inheritance Object TargetCompiler Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class TargetCompiler Properties | Improve this Doc Default The default compiler to be used by rezolvers when they are not explicitly provided one. Declaration public static ITargetCompiler Default { get; set; } Property Value Type Description ITargetCompiler"
  },
  "rezolver-api/Rezolver.TargetCompilerBase.html": {
    "href": "rezolver-api/Rezolver.TargetCompilerBase.html",
    "title": "Class TargetCompilerBase",
    "keywords": "Class TargetCompilerBase Inheritance Object TargetCompilerBase Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public abstract class TargetCompilerBase : ITargetCompiler Methods | Improve this Doc CompileTarget(ITarget, CompileContext) Declaration public virtual ICompiledTarget CompileTarget(ITarget target, CompileContext context) Parameters Type Name Description ITarget target CompileContext context Returns Type Description ICompiledTarget Implements | Improve this Doc CompileTargetBase(ITarget, Expression, CompileContext) Called to create an ICompiledTarget instance from the passed expression produced by the passed target for the passed context. The expression passed into this method is constructed by a call to GetLambdaBody(ITarget, CompileContext) Declaration protected abstract ICompiledTarget CompileTargetBase(ITarget target, Expression toCompile, CompileContext context) Parameters Type Name Description ITarget target The target from which the expression toCompile was built. Note - this expression will have been optimised and potentially rewritten ready for compilation, and will likely not be equal to the expression originally produced by its own Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) method. Expression toCompile The expression built from target by this instance's own GetLambdaBody(ITarget, CompileContext) methodd. CompileContext context The context for which the compilation is being performed. Returns Type Description ICompiledTarget | Improve this Doc GetLambdaBody(ITarget, CompileContext) Produces the lambda body for the target. The base class uses the method GetLambdaBodyForTarget(ITarget, CompileContext) to get the expression tree that will be compiled. Declaration protected virtual Expression GetLambdaBody(ITarget target, CompileContext context) Parameters Type Name Description ITarget target CompileContext context Returns Type Description Expression"
  },
  "rezolver-api/Rezolver.TargetCompilerHelper.RedundantConvertRemover.html": {
    "href": "rezolver-api/Rezolver.TargetCompilerHelper.RedundantConvertRemover.html",
    "title": "Class TargetCompilerHelper.RedundantConvertRemover",
    "keywords": "Class TargetCompilerHelper.RedundantConvertRemover Inheritance Object TargetCompilerHelper.RedundantConvertRemover Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class RedundantConvertRemover : ExpressionVisitor Constructors | Improve this Doc RedundantConvertRemover() Declaration public RedundantConvertRemover() Methods | Improve this Doc VisitUnary(UnaryExpression) Declaration protected override Expression VisitUnary(UnaryExpression node) Parameters Type Name Description UnaryExpression node Returns Type Description Expression"
  },
  "rezolver-api/Rezolver.TargetCompilerHelper.html": {
    "href": "rezolver-api/Rezolver.TargetCompilerHelper.html",
    "title": "Class TargetCompilerHelper",
    "keywords": "Class TargetCompilerHelper Inheritance Object TargetCompilerHelper Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class TargetCompilerHelper Methods | Improve this Doc Optimise(Expression, IEnumerable<Func<Expression, Expression>>) Declaration public static Expression Optimise(this Expression expression, IEnumerable<Func<Expression, Expression>> additionalOptimisations = null) Parameters Type Name Description Expression expression IEnumerable < Func < Expression , Expression >> additionalOptimisations Returns Type Description Expression"
  },
  "rezolver-api/Rezolver.TargetContainer.html": {
    "href": "rezolver-api/Rezolver.TargetContainer.html",
    "title": "Class TargetContainer",
    "keywords": "Class TargetContainer Root container for ITarget s that can be used as the backing for the standard IContainer classes - Container and ScopedContainer . Stores and retrieves registrations of ITarget s, is also Generic type aware, unlike its base class - TargetDictionaryContainer . Inheritance Object TargetDictionaryContainer TargetContainer Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetContainer : TargetDictionaryContainer, ITargetContainerOwner, ITargetContainer Remarks This is the type used by default for the Targets of all the standard containers in the core framework, e.g. Container , ScopedContainer etc, when you don't supply an instance of an ITargetContainer explicitly on construction. Constructors | Improve this Doc TargetContainer(Boolean) Constructs a new instance of the TargetContainer class Declaration public TargetContainer(bool autoRezolveIEnumerable = true) Parameters Type Name Description Boolean autoRezolveIEnumerable If true, then IEnumerable<T> will be automatically resolved as a concatenation of all the ITarget s that are registered against a particular type. Note - this parameter might be removed in a future version - you can achieve the same thing by using the extension method EnableEnumerableResolving(ITargetContainerOwner) Methods | Improve this Doc CreateContainer(Type, ITarget) Called to create and register a container for the given serviceType and target . This class overrides the base version ( CreateContainer(Type, ITarget) ) to create a specialised container for generic types ( GenericTargetContainer ) if serviceType if a generic type or generic type definition. Declaration protected override ITargetContainer CreateContainer(Type serviceType, ITarget target) Parameters Type Name Description Type serviceType The type for which a container is to be created and registered. ITarget target Optional. The target that will be added to the container that is returned. Returns Type Description ITargetContainer An ITargetContainer in which the passed target will be registered. Overrides Remarks The main caller for this method will be the base Register method, which will create a new container for a target that's being registered against a new type. It is, however, also called by this class' implementation of RegisterContainer(Type, ITargetContainer) when the type is a generic type - as all generics must have a container registered against their generic type definitions as a starting point. | Improve this Doc CreateGenericTypeDefContainer(Type, ITarget) Called by CreateContainer(Type, ITarget) to create a container suitable for handling targets that are registered against generic types. Declaration protected virtual ITargetContainer CreateGenericTypeDefContainer(Type genericTypeDefinition, ITarget target) Parameters Type Name Description Type genericTypeDefinition Will be an open generic type (generic type definition) ITarget target Optional. The initial target for which the container is being constructed Returns Type Description ITargetContainer The base implementation always creates an instance of CreateGenericTypeDefContainer(Type, ITarget) | Improve this Doc FetchContainer(Type) Retrieves Declaration public override ITargetContainer FetchContainer(Type type) Parameters Type Name Description Type type Returns Type Description ITargetContainer Overrides | Improve this Doc Register(ITarget, Type) Overrides the base method to block registration if the target does not support the serviceType (checked by calling the target's SupportsType(Type) method). Declaration public override void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target The target to be registered. Type serviceType Optional - the type against which the target is to be registered, if different from the target's DeclaredType . Overrides | Improve this Doc RegisterContainer(Type, ITargetContainer) Overrides the base method so that if type is a generic type, then the container will be registered inside another which will be registered for the generic type definition first. Declaration public override void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container Overrides | Improve this Doc RegisterContainerDirect(Type, ITargetContainer) Version of RegisterContainer(Type, ITargetContainer) which does not interrogate the type to see if it's generic - simply registers the passed container directly against the passed type (it just chains through directly to the RegisterContainer(Type, ITargetContainer) method non-virtually. Declaration protected virtual void RegisterContainerDirect(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container"
  },
  "rezolver-api/Rezolver.TargetCreationExtensions.html": {
    "href": "rezolver-api/Rezolver.TargetCreationExtensions.html",
    "title": "Class TargetCreationExtensions",
    "keywords": "Class TargetCreationExtensions Extensions which provide shortcuts for creating some of the extensions in the Rezolver.Targets namespace. Inheritance Object TargetCreationExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class TargetCreationExtensions Methods | Improve this Doc AsDelegateTarget(Delegate, Type) Creates a from the factory which can be registered in an ITargetContainer to resolve an instance of a type compatible with the delegate's return type and, optionally, with the declaredType Declaration public static DelegateTarget AsDelegateTarget(this Delegate factory, Type declaredType = null) Parameters Type Name Description Delegate factory The delegate to be used as a factory. Type declaredType Optional type to set as the of the target, if not passed, then the return type of the delegate will be used. Returns Type Description DelegateTarget | Improve this Doc AsObjectTarget<T>(T, Type, ScopeBehaviour) Wraps the instance on which this is invoked as an that can be registered into an ITargetContainer . The parameters are direct analogues of the parameters on the type's constructor (see ). Declaration public static ObjectTarget AsObjectTarget<T>(this T obj, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description T obj the object being wrapped Type declaredType Optional. The type which is to be set as the of the created target. ScopeBehaviour scopeBehaviour Controls how the object will interact the the scope. By default, object targets must be disposed by you. Returns Type Description ObjectTarget A new object target that wraps the object obj . Type Parameters Name Description T The type of object being wrapped | Improve this Doc Scoped(ITarget) Creates a from the target on which this method is invoked. Declaration public static ScopedTarget Scoped(this ITarget target) Parameters Type Name Description ITarget target Returns Type Description ScopedTarget | Improve this Doc Singleton(ITarget) Constructs a that wraps the target on which the method is invoked. Declaration public static SingletonTarget Singleton(this ITarget target) Parameters Type Name Description ITarget target Returns Type Description SingletonTarget | Improve this Doc Unscoped(ITarget) Creates an from the target on which this method is invoked. Declaration public static UnscopedTarget Unscoped(this ITarget target) Parameters Type Name Description ITarget target The target. Returns Type Description UnscopedTarget"
  },
  "rezolver-api/Rezolver.TargetDelegateCompiler.DelegatingCompiledRezolveTarget.html": {
    "href": "rezolver-api/Rezolver.TargetDelegateCompiler.DelegatingCompiledRezolveTarget.html",
    "title": "Class TargetDelegateCompiler.DelegatingCompiledRezolveTarget",
    "keywords": "Class TargetDelegateCompiler.DelegatingCompiledRezolveTarget Inheritance Object TargetDelegateCompiler.DelegatingCompiledRezolveTarget Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegatingCompiledRezolveTarget : ICompiledTarget Constructors | Improve this Doc DelegatingCompiledRezolveTarget(Func<RezolveContext, Object>) Declaration public DelegatingCompiledRezolveTarget(Func<RezolveContext, object> getObjectDelegate) Parameters Type Name Description Func < RezolveContext , Object > getObjectDelegate Methods | Improve this Doc GetObject(RezolveContext) Declaration public object GetObject(RezolveContext context) Parameters Type Name Description RezolveContext context Returns Type Description Object Implements"
  },
  "rezolver-api/Rezolver.TargetDelegateCompiler.html": {
    "href": "rezolver-api/Rezolver.TargetDelegateCompiler.html",
    "title": "Class TargetDelegateCompiler",
    "keywords": "Class TargetDelegateCompiler The default compiler for ITarget instances - takes the expression tree(s) produced by an ITarget and simply compiles it to an anonymous delegate. Inheritance Object TargetCompilerBase TargetDelegateCompiler Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetDelegateCompiler : TargetCompilerBase, ITargetCompiler Fields | Improve this Doc Default Declaration public static readonly ITargetCompiler Default Field Value Type Description ITargetCompiler Methods | Improve this Doc CompileTargetBase(ITarget, Expression, CompileContext) Declaration protected override ICompiledTarget CompileTargetBase(ITarget target, Expression toCompile, CompileContext context) Parameters Type Name Description ITarget target Expression toCompile CompileContext context Returns Type Description ICompiledTarget Overrides"
  },
  "rezolver-api/Rezolver.TargetDictionaryContainer.html": {
    "href": "rezolver-api/Rezolver.TargetDictionaryContainer.html",
    "title": "Class TargetDictionaryContainer",
    "keywords": "Class TargetDictionaryContainer An ITargetContainerOwner implementation that stores and retrieves ITarget and ITargetContainer by type. Inheritance Object TargetDictionaryContainer Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetDictionaryContainer : ITargetContainerOwner, ITargetContainer Remarks This type is not thread-safe Note that for generic type, a special container is registered first against the open generic version of the type, with concrete (closed) generics being registered within that. Methods | Improve this Doc CombineWith(ITargetContainer, Type) Always adds this container into the existing container as a child. Declaration public virtual ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Type type Returns Type Description ITargetContainer Implements | Improve this Doc CreateContainer(Type, ITarget) Called by Register(ITarget, Type) to create and register the container instance most suited for the passed target. The base implementation always creates a TargetListContainer , capable of storing multiple targets against a single type. Declaration protected virtual ITargetContainer CreateContainer(Type serviceType, ITarget target) Parameters Type Name Description Type serviceType ITarget target The initial target for which the container is being created. Can be null. Note - the function is not expected to add this target to the new container. Returns Type Description ITargetContainer | Improve this Doc Fetch(Type) Implementation of Fetch(Type) . Declaration public virtual ITarget Fetch(Type type) Parameters Type Name Description Type type The type whose default target is to be retrieved. Returns Type Description ITarget A single target representing the last target registered against the type , or, null if no target is found. Implements Remarks Note - in scenarios where you are chaining multiple containers, then you should consult the return value's UseFallback property if the method returns non-null because, if true, then it's an instruction to use a parent container's result for the same type. | Improve this Doc FetchAll(Type) Implementation of FetchAll(Type) Declaration public virtual IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type The type whose targets are to be retrieved. Returns Type Description IEnumerable < ITarget > A non-null enumerable containing the targets that match the type, or an empty enumerable if the type is not registered. Implements | Improve this Doc FetchContainer(Type) Obtains a child container that was previously registered by the passed type . Returns null if no entry is found. Declaration public virtual ITargetContainer FetchContainer(Type type) Parameters Type Name Description Type type Returns Type Description ITargetContainer Implements | Improve this Doc Register(ITarget, Type) Implementation of Register(ITarget, Type) . Declaration public virtual void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target The target to be registered Type serviceType Implements Remarks This implementation creates an ITargetContainer for the serviceType with a call to the protected method CreateContainer(Type, ITarget) if one doesn't exist (it calls FetchContainer(Type) to check for existence), and then chains to its Register(ITarget, Type) method. | Improve this Doc RegisterContainer(Type, ITargetContainer) Implementation of RegisterContainer(Type, ITargetContainer) Declaration public virtual void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container Implements Remarks This container implementation actually stores containers against the types that targets are registered against, rather than simply storing a dictionary of targets. This method allows you to add your own containers against type (instead of the default, which is TargetListContainer ) so you can plug in some advanced behaviour into this container. For example, decorators are not actually ITarget implementations but specialised ITargetContainer instances into which the 'standard' targets are registered."
  },
  "rezolver-api/Rezolver.TargetExpression.html": {
    "href": "rezolver-api/Rezolver.TargetExpression.html",
    "title": "Class TargetExpression",
    "keywords": "Class TargetExpression An expression which represents an ITarget that can be baked into any type of expression during code generation. Used by the TargetAdapter extensively. Inheritance Object TargetExpression Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetExpression : Expression Constructors | Improve this Doc TargetExpression(ITarget) Initializes a new instance of the TargetExpression class. Declaration public TargetExpression(ITarget target) Parameters Type Name Description ITarget target The target. Properties | Improve this Doc CanReduce Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form. Declaration public override bool CanReduce { get; } Property Value Type Description Boolean true if this instance can reduce; otherwise, false . Remarks The implementation always returns true ; although the Reduce() methodd is not implemented. | Improve this Doc NodeType Gets the node type of this . Declaration public override ExpressionType NodeType { get; } Property Value Type Description ExpressionType Always returns . | Improve this Doc Target Gets the target whose expression (obtained from Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) ) will be subsituted for this TargetExpression in the final expression tree. Declaration public ITarget Target { get; } Property Value Type Description ITarget | Improve this Doc Type Gets the static type of the expression that this represents. Declaration public override Type Type { get; } Property Value Type Description Type Remarks Always returns the type referenced by the DeclaredType property of Target . Methods | Improve this Doc Reduce() Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced. Declaration public override Expression Reduce() Returns Type Description Expression Exceptions Type Condition NotSupportedException RezolveTargetExpression must be rewritten as a bona-fide expression before walking the expression tree for any other purpose"
  },
  "rezolver-api/Rezolver.TargetExpressionRewriter.html": {
    "href": "rezolver-api/Rezolver.TargetExpressionRewriter.html",
    "title": "Class TargetExpressionRewriter",
    "keywords": "Class TargetExpressionRewriter Used by TargetBase (and potentially your own targets) to convert TargetExpression instances which have been baked into expression trees (most likely by a TargetAdapter ) into expressions for a given CompileContext . Inheritance Object TargetExpressionRewriter Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetExpressionRewriter : ExpressionVisitor Remarks The TargetBase class always pushes expressions it receives from its Rezolver.TargetBase.CreateExpressionBase(Rezolver.CompileContext) abstract method through a rewrite - because if there are any non-standard expressions left, then compilation will not be possible. Constructors | Improve this Doc TargetExpressionRewriter(CompileContext) Initializes a new instance of the TargetExpressionRewriter class for the given context Declaration public TargetExpressionRewriter(CompileContext context) Parameters Type Name Description CompileContext context The compilation context. Methods | Improve this Doc Visit(Expression) Dispatches the expression to one of the more specialized visit methods in this class. Declaration public override Expression Visit(Expression node) Parameters Type Name Description Expression node The expression to visit. Returns Type Description Expression"
  },
  "rezolver-api/Rezolver.TargetListContainer.html": {
    "href": "rezolver-api/Rezolver.TargetListContainer.html",
    "title": "Class TargetListContainer",
    "keywords": "Class TargetListContainer An ITargetContainer that stores multiple targets in a list. This is not a type that you would typically use directly in your code, unless you are writing custom logic/behaviour for ITarget registration. Inheritance Object TargetListContainer Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class TargetListContainer : ITargetContainer Remarks This type is not thread-safe, nor does it perform any type checking on the targets that are added to it. Constructors | Improve this Doc TargetListContainer(Type, ITarget[]) Initializes a new instance of the TargetListContainer class. Declaration public TargetListContainer(Type registeredType, params ITarget[] targets) Parameters Type Name Description Type registeredType Required - the type against which this list will be registered. ITarget [] targets Optional array of targets with which to initialise the list. Properties | Improve this Doc Count Gets the number of targets which have been added to the list. Declaration public int Count { get; } Property Value Type Description Int32 The count. | Improve this Doc DefaultTarget Gets the default target for this list - which will always be the last target added to the list, or null if no targets have been added yet. Declaration public ITarget DefaultTarget { get; } Property Value Type Description ITarget | Improve this Doc Item[Int32] Gets the ITarget at the specified index. Declaration public ITarget this[int index] { get; } Parameters Type Name Description Int32 index The index. Property Value Type Description ITarget ITarget. Exceptions Type Condition IndexOutOfRangeException If index is less than zero, or if Count is zero, or if index represents an index greater than last item's index | Improve this Doc RegisteredType Gets the type against which this list container is registered in its ITargetContainerOwner . Declaration public Type RegisteredType { get; } Property Value Type Description Type | Improve this Doc Targets Gets the targets stored in this list container. Declaration public IEnumerable<ITarget> Targets { get; } Property Value Type Description IEnumerable < ITarget > | Improve this Doc TargetsList Provides deriving classes a means to manipulate the underlying list. Declaration protected List<ITarget> TargetsList { get; } Property Value Type Description List < ITarget > Methods | Improve this Doc CombineWith(ITargetContainer, Type) Not supported. Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Ignored Type type Ignored. Returns Type Description ITargetContainer Implements Exceptions Type Condition NotSupportedException Always | Improve this Doc Fetch(Type) Always returns the DefaultTarget Declaration public virtual ITarget Fetch(Type type) Parameters Type Name Description Type type Ignored. Returns Type Description ITarget Implements | Improve this Doc FetchAll(Type) Retrieves an enumerable of all targets that have been registered to this list. Declaration public virtual IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type Ignored. Returns Type Description IEnumerable < ITarget > Implements | Improve this Doc Register(ITarget, Type) Registers the specified target into the list. Note - the target is not checked to see if it supports this list's RegisteredType . Declaration public virtual void Register(ITarget target, Type registeredType = null) Parameters Type Name Description ITarget target The target. Type registeredType Ignored. Implements"
  },
  "rezolver-api/Rezolver.Targets.ChangeTypeTarget.html": {
    "href": "rezolver-api/Rezolver.Targets.ChangeTypeTarget.html",
    "title": "Class ChangeTypeTarget",
    "keywords": "Class ChangeTypeTarget This target is specifically used for explicitly casting the result of one target to another type. Its use is rare, since the framework already caters for downcasting the result of targets to base types. Inheritance Object TargetBase ChangeTypeTarget Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class ChangeTypeTarget : TargetBase, ITarget Remarks A valid use of this target is when you have a SingletonTarget registered against one type, and you want the same singleton (backed by the same instance) to server another type. In this case, instead of registering the same singleton target multiple times, you can register it once for its primary type, then register one of these for the other type, with a ResolvedTarget as its inner target. When creating this target, the DeclaredType of the InnerTarget must be able to cast up or down to the DeclaredType of this target. Constructors | Improve this Doc ChangeTypeTarget(ITarget, Type) Creates a new instance of the ChangeTypeTarget class. Declaration public ChangeTypeTarget(ITarget innerTarget, Type targetType) Parameters Type Name Description ITarget innerTarget Required. See InnerTarget Type targetType Required. See DeclaredType Properties | Improve this Doc DeclaredType Always returns the target type that was passed in the ChangeTypeTarget(ITarget, Type) constructor. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc InnerTarget The target whose type will be changed to DeclaredType . Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget | Improve this Doc ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides"
  },
  "rezolver-api/Rezolver.DefaultTarget.html": {
    "href": "rezolver-api/Rezolver.DefaultTarget.html",
    "title": "Class DefaultTarget",
    "keywords": "Class DefaultTarget A target that simply creates a default instance of a given type. I.e. the same as doing default(type) in C#. Inheritance Object TargetBase DefaultTarget Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DefaultTarget : TargetBase, ITarget, ICompiledTarget Remarks The type also implements the ICompiledTarget interface for direct resolving. Constructors | Improve this Doc DefaultTarget(Type) Initializes a new instance of the DefaultTarget class. Declaration public DefaultTarget(Type type) Parameters Type Name Description Type type The type. Properties | Improve this Doc DeclaredType Always equal to the type for which the default value will be returned Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides Explicit Interface Implementations | Improve this Doc ICompiledTarget.GetObject(ResolveContext) Declaration object ICompiledTarget.GetObject(ResolveContext context) Parameters Type Name Description ResolveContext context Returns Type Description Object Implements"
  },
  "rezolver-api/Rezolver.DelegateTarget-1.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-1.html",
    "title": "Class DelegateTarget<TResult>",
    "keywords": "Class DelegateTarget<TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<TResult> Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<TResult> : DelegateTarget, ITarget Type Parameters Name Description TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<TResult>, Type) Initializes a new instance of the DelegateTarget<TResult> class. Declaration public DelegateTarget(Func<TResult> factory, Type declaredType = null) Parameters Type Name Description Func <TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.DelegateTarget-10.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-10.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.DelegateTarget-11.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-11.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.DelegateTarget-12.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-12.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.DelegateTarget-13.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-13.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.DelegateTarget-14.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-14.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.DelegateTarget-15.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-15.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.DelegateTarget-16.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-16.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) T15 The type of the 15th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.DelegateTarget-2.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-2.html",
    "title": "Class DelegateTarget<T, TResult>",
    "keywords": "Class DelegateTarget<T, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T, TResult> Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T, TResult> : DelegateTarget, ITarget Type Parameters Name Description T The type of the 1st delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T, TResult>, Type) Initializes a new instance of the DelegateTarget<T, TResult> class. Declaration public DelegateTarget(Func<T, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.DelegateTarget-3.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-3.html",
    "title": "Class DelegateTarget<T1, T2, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, TResult> Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, TResult> class. Declaration public DelegateTarget(Func<T1, T2, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.DelegateTarget-4.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-4.html",
    "title": "Class DelegateTarget<T1, T2, T3, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, TResult> Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.DelegateTarget-5.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-5.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, TResult> Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.DelegateTarget-6.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-6.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, TResult> Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.DelegateTarget-7.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-7.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.DelegateTarget-8.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-8.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.DelegateTarget-9.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget-9.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.DelegateTarget.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget.html",
    "title": "Class DelegateTarget",
    "keywords": "Class DelegateTarget An ITarget which resolve objects by executing a delegate with argument injection. Inheritance Object TargetBase DelegateTarget Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget : TargetBase, ITarget Remarks The delegate must be non-void and can have any number of parameters. A compiler must ensure that any parameters for the Factory are automatically resolved from the container, and that a parameter of the type ResolveContext will receive the context passed to the Resolve(ResolveContext) method call for which this target is being compiled and/or executed. Constructors | Improve this Doc DelegateTarget(Delegate, Type) Initializes a new instance of the DelegateTarget class. Declaration public DelegateTarget(Delegate factory, Type declaredType = null) Parameters Type Name Description Delegate factory Required - the factory delegate. Must have a return type and can take 0 or more parameters. Type declaredType Optional - type that will be set into the DeclaredType for the target; if not provided, then it will be derived from the factory 's return type Exceptions Type Condition ArgumentNullException If factory is null ArgumentException If the factory represents a void delegate or if declaredType is passed but the type is not compatible with the return type of factory . Properties | Improve this Doc DeclaredType Gets the declared type of object that is constructed by this target, either set on construction or derived from the return type of the Factory Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc Factory Gets the factory method that will be invoked when this target is compiled and executed Declaration public Delegate Factory { get; } Property Value Type Description Delegate The factory."
  },
  "rezolver-api/Rezolver.DelegateTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.DelegateTargetContainerExtensions.html",
    "title": "Class DelegateTargetContainerExtensions",
    "keywords": "Class DelegateTargetContainerExtensions Extension methods for ITargetContainer designed to simplify the registration of and its numerous generic variants. Inheritance Object DelegateTargetContainerExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class DelegateTargetContainerExtensions Methods | Improve this Doc RegisterDelegate(ITargetContainer, Delegate, Type) Constructs a from the passed factory delegate (optionally with the given declaredType ) and registers it in the target container. Declaration public static void RegisterDelegate(this ITargetContainer targetContainer, Delegate factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Delegate factory Type declaredType | Improve this Doc RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) Creates a DelegateTarget<TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<TResult>(this ITargetContainer targetContainer, Func<TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <TResult> factory Type declaredType Type Parameters Name Description TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) T15 The type of the 15th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) Creates a DelegateTarget<T, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T, TResult>(this ITargetContainer targetContainer, Func<T, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T, TResult> factory Type declaredType Type Parameters Name Description T The type of the 1st delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) Creates a DelegateTarget<T1, T2, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, TResult>(this ITargetContainer targetContainer, Func<T1, T2, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, T8, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method."
  },
  "rezolver-api/Rezolver.DelegateTargetDelegateExtensions.html": {
    "href": "rezolver-api/Rezolver.DelegateTargetDelegateExtensions.html",
    "title": "Class DelegateTargetDelegateExtensions",
    "keywords": "Class DelegateTargetDelegateExtensions Extension methods for the Delegate type to aid in the construction of DelegateTarget . Inheritance Object DelegateTargetDelegateExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class DelegateTargetDelegateExtensions Methods | Improve this Doc AsDelegateTarget(Delegate, Type) Creates a DelegateTarget from the factory which can be registered in an ITargetContainer to resolve an instance of a type compatible with the delegate's return type and, optionally, with the declaredType Declaration public static DelegateTarget AsDelegateTarget(this Delegate factory, Type declaredType = null) Parameters Type Name Description Delegate factory The delegate to be used as a factory. Type declaredType Optional type to set as the DeclaredType of the target, if not passed, then the return type of the delegate will be used. Returns Type Description DelegateTarget"
  },
  "rezolver-api/Rezolver.DelegateTargetExtensions.html": {
    "href": "rezolver-api/Rezolver.DelegateTargetExtensions.html",
    "title": "Class DelegateTargetExtensions",
    "keywords": "Class DelegateTargetExtensions Extension methods for creating DelegateTarget<TResult> instances. Inheritance Object DelegateTargetExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class DelegateTargetExtensions Methods | Improve this Doc AsDelegateTarget<T>(Func<T>, Type) Creates a DelegateTarget<TResult> using the delegate as the factory method to be executed. Declaration public static DelegateTarget<T> AsDelegateTarget<T>(this Func<T> factory, Type declaredType = null) Parameters Type Name Description Func <T> factory The factory. Type declaredType Optional override for the type exposed by the DelegateTarget<TResult> . See the DelegateTarget(Func<TResult>, Type) constructor for more. Returns Type Description DelegateTarget <T> Type Parameters Name Description T The type returned by the factory when executed. | Improve this Doc AsDelegateTarget<T>(Func<RezolveContext, T>, Type) Creates a DelegateTarget<TResult> using the delegate as the factory method to be executed. Declaration public static DelegateTarget<T> AsDelegateTarget<T>(this Func<RezolveContext, T> factory, Type declaredType = null) Parameters Type Name Description Func < RezolveContext , T> factory The factory. Type declaredType Optional override for the type exposed by the DelegateTarget<TResult> . See the Rezolver.DelegateTarget`1.#ctor(System.Func{Rezolver.RezolveContext,`0},System.Type) constructor for more. Returns Type Description DelegateTarget <T> Type Parameters Name Description T The type returned by the factory when executed."
  },
  "rezolver-api/Rezolver.DelegateTarget`1.html": {
    "href": "rezolver-api/Rezolver.DelegateTarget`1.html",
    "title": "Class DelegateTarget<T>",
    "keywords": "Class DelegateTarget<T> Implements IRezolveTarget using factory function delegates. Inheritance Object TargetBase DelegateTarget<T> Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T> : TargetBase, ITarget Type Parameters Name Description T Constructors | Improve this Doc DelegateTarget(Func<T>, Type) Declaration public DelegateTarget(Func<T> factory, Type declaredType = null) Parameters Type Name Description Func <T> factory Type declaredType Properties | Improve this Doc DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides Methods | Improve this Doc CreateExpressionBase(CompileContext) Declaration protected override Expression CreateExpressionBase(CompileContext context) Parameters Type Name Description CompileContext context Returns Type Description Expression Overrides"
  },
  "rezolver-api/Rezolver.EnumerableTargetBuilderExtensions.html": {
    "href": "rezolver-api/Rezolver.EnumerableTargetBuilderExtensions.html",
    "title": "Class EnumerableTargetBuilderExtensions",
    "keywords": "Class EnumerableTargetBuilderExtensions Houses an extension method which enables native resolving of IEnumerables of services on ITargetContainer containers which, in turn, enables it for any ContainerBase containers which use that target container. Inheritance Object EnumerableTargetBuilderExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class EnumerableTargetBuilderExtensions Methods | Improve this Doc EnableEnumerableResolving(ITargetContainerOwner) Enables resolving of enumerables of services on the target container. Declaration public static void EnableEnumerableResolving(this ITargetContainerOwner targetContainer) Parameters Type Name Description ITargetContainerOwner targetContainer The target container. Remarks After calling this, you can immediately request a target for IEnumerable<T> of any type and you will receive a (with set to true) which contains all the targets which have previously been registered for the type T , in the order they were registered. If a service has not been registered, then the returned will be empty and its property will be true ."
  },
  "rezolver-api/Rezolver.ExceptionResources.html": {
    "href": "rezolver-api/Rezolver.ExceptionResources.html",
    "title": "Class ExceptionResources",
    "keywords": "Class ExceptionResources A strongly-typed resource class, for looking up localized strings, etc. Inheritance Object ExceptionResources Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ExceptionResources Properties | Improve this Doc _MOVETOSHAREDPROJECT Looks up a localized string similar to REMINDER TO MOVE THIS TO THE SHARED PROJECT AND MARK AS INTERNAL WHEN YOU FINALY CAN. Declaration public static string _MOVETOSHAREDPROJECT { get; } Property Value Type Description String | Improve this Doc Culture Overrides the current thread's CurrentUICulture property for all resource lookups using this strongly typed resource class. Declaration public static CultureInfo Culture { get; set; } Property Value Type Description CultureInfo | Improve this Doc CyclicDependencyDetectedInTargetFormat Looks up a localized string similar to Cyclic dependency detected in targets - current target of type {0} with DeclaredType of {1} has tried to include itself in its expression.. Declaration public static string CyclicDependencyDetectedInTargetFormat { get; } Property Value Type Description String | Improve this Doc DeclaredTypeIsNotCompatible_Format Looks up a localized string similar to The declared type {0} is not compatible with the type {1}. Declaration public static string DeclaredTypeIsNotCompatible_Format { get; } Property Value Type Description String | Improve this Doc LambdaBodyIsNotNewExpressionFormat Looks up a localized string similar to The body of the lambda \"{0}\" is not a NewExpression. Declaration public static string LambdaBodyIsNotNewExpressionFormat { get; } Property Value Type Description String | Improve this Doc LambdaBodyNewExpressionIsWrongTypeFormat Looks up a localized string similar to The expression {0} does not represent calling a constructor of the type {1}. Declaration public static string LambdaBodyNewExpressionIsWrongTypeFormat { get; } Property Value Type Description String | Improve this Doc MoreThanOneBestConstructorFormat Looks up a localized string similar to More than one constructor for {0} found that could be bound from the current context. Possible candidates: {1}. Declaration public static string MoreThanOneBestConstructorFormat { get; } Property Value Type Description String | Improve this Doc MoreThanOneConstructorFormat Looks up a localized string similar to More than one constructor for {0} qualifies as a target for Auto construction. Declaration public static string MoreThanOneConstructorFormat { get; } Property Value Type Description String | Improve this Doc MoreThanOneObjectFoundInScope Looks up a localized string similar to More than one matching object was found in the scope. Declaration public static string MoreThanOneObjectFoundInScope { get; } Property Value Type Description String | Improve this Doc NoApplicableConstructorForContextFormat Looks up a localized string similar to No constructor found on the type {0} which can be satisfied by the CompileContext. Declaration public static string NoApplicableConstructorForContextFormat { get; } Property Value Type Description String | Improve this Doc NoConstructorSetOnNewExpression Looks up a localized string similar to No constructor has been set on the NewExpression - this is not allowed.. Declaration public static string NoConstructorSetOnNewExpression { get; } Property Value Type Description String | Improve this Doc NoDefaultOrAllOptionalConstructorFormat Looks up a localized string similar to The type {0} has no default constructor, nor any constructors where all the parameters are optional.. Declaration public static string NoDefaultOrAllOptionalConstructorFormat { get; } Property Value Type Description String | Improve this Doc NoPublicConstructorsDefinedFormat Looks up a localized string similar to No public constructors declared on the type {0}. Declaration public static string NoPublicConstructorsDefinedFormat { get; } Property Value Type Description String | Improve this Doc NotRuntimeMethod Looks up a localized string similar to This method is not to be called at run-time - it is only used for static expression analysis in creating IRezolveTargets for an IRezolveBuilder. Declaration public static string NotRuntimeMethod { get; } Property Value Type Description String | Improve this Doc PathIsAtEnd Looks up a localized string similar to path's Next must not be null - pass path as null once it's reached the last item. Declaration public static string PathIsAtEnd { get; } Property Value Type Description String | Improve this Doc PathIsInvalid Looks up a localized string similar to The path {0} is invalid. All path steps must contain non-whitespace characters and be at least one character in length. Declaration public static string PathIsInvalid { get; } Property Value Type Description String | Improve this Doc ResourceManager Returns the cached ResourceManager instance used by this class. Declaration public static ResourceManager ResourceManager { get; } Property Value Type Description ResourceManager | Improve this Doc RezolverTargetEntryHasBeenRealised Looks up a localized string similar to No more targets can be added to this entry. Declaration public static string RezolverTargetEntryHasBeenRealised { get; } Property Value Type Description String | Improve this Doc ScopedSingletonRequiresAScope Looks up a localized string similar to A lifetime scope is required for a scoped singleton. Declaration public static string ScopedSingletonRequiresAScope { get; } Property Value Type Description String | Improve this Doc TargetDoesntSupportType_Format Looks up a localized string similar to The target does not support the type {0}. Declaration public static string TargetDoesntSupportType_Format { get; } Property Value Type Description String | Improve this Doc TargetIsNullButTypeIsNotNullable_Format Looks up a localized string similar to The type {0} is not a nullable type. Declaration public static string TargetIsNullButTypeIsNotNullable_Format { get; } Property Value Type Description String | Improve this Doc TargetReturnedNullExpressionFormat Looks up a localized string similar to Target of type {0} returned a null expression for context {1} - implementation is invalid, targets must never return a null expression.. Declaration public static string TargetReturnedNullExpressionFormat { get; } Property Value Type Description String | Improve this Doc TypeIsAlreadyRegistered Looks up a localized string similar to The type {0} has already been registered. Declaration public static string TypeIsAlreadyRegistered { get; } Property Value Type Description String | Improve this Doc UnableToResolveTypeFromBuilderFormat Looks up a localized string similar to Unable to resolve type {0} from builder. Declaration public static string UnableToResolveTypeFromBuilderFormat { get; } Property Value Type Description String"
  },
  "rezolver-api/Rezolver.ExpressionCompilerTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.ExpressionCompilerTargetContainerExtensions.html",
    "title": "Class ExpressionCompilerTargetContainerExtensions",
    "keywords": "Class ExpressionCompilerTargetContainerExtensions Inheritance Object ExpressionCompilerTargetContainerExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ExpressionCompilerTargetContainerExtensions Methods | Improve this Doc UseExpressionCompiler(ITargetContainer, ExpressionCompiler) Declaration public static ITargetContainer UseExpressionCompiler(this ITargetContainer targets, ExpressionCompiler compiler = null) Parameters Type Name Description ITargetContainer targets ExpressionCompiler compiler Returns Type Description ITargetContainer"
  },
  "rezolver-api/Rezolver.ExpressionHelper.html": {
    "href": "rezolver-api/Rezolver.ExpressionHelper.html",
    "title": "Class ExpressionHelper",
    "keywords": "Class ExpressionHelper This static class contains methods and properties to aid in building expressions in an implementation of the Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) method. Inheritance Object ExpressionHelper Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ExpressionHelper Fields | Improve this Doc DynamicRezolverParam This parameter expression is to be used by all targets and rezolvers in this library by default to perform late binding to a container provided at run time when a caller is trying to resolve something through code built from a target. Declaration public static readonly ParameterExpression DynamicRezolverParam Field Value Type Description ParameterExpression | Improve this Doc RezolveContextParameterExpression The default RezolveContext parameter expression to be used during code generation in an implementation of Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) Declaration public static readonly ParameterExpression RezolveContextParameterExpression Field Value Type Description ParameterExpression | Improve this Doc Scope_GetOrAddGenericMethod A MethodInfo object representing the generic definition Declaration public static readonly MethodInfo Scope_GetOrAddGenericMethod Field Value Type Description MethodInfo | Improve this Doc Scope_GetScopeRootMethod A MethodInfo object representing the GetScopeRoot(IScopedContainer) method - to aid in code generation where the target scope for tracking an object is the root scope, not the current scope. Declaration public static readonly MethodInfo Scope_GetScopeRootMethod Field Value Type Description MethodInfo Methods | Improve this Doc GetLambdaBodyForTarget(ITarget, CompileContext) Provides a standard way to create the method body for a lambda that, when compiled (with the correct signature) will execute code that will produce the object represented by the target. Some rewriting optimisations are applied to the expression tree, the resulting expression tree will be able to be compiled straight to a method if passed into a LambdaExpression. Declaration public static Expression GetLambdaBodyForTarget(ITarget target, CompileContext context) Parameters Type Name Description ITarget target CompileContext context Returns Type Description Expression Remarks Note that the TargetCompilerBase abstract class uses this method to get the expression tree for a target that is to be compiled, and the TargetDelegateCompiler uses that expression tree as-is. Note, however, that some compilers might override this behaviour, or rewrite the generated expression more - in which case this code wouldn't be suitable for those compilers. This method, therefore, is exposed to provide a surefire way to generate a whole lambda that can be compiled into an in-memory delegate for re-use in other targets and scenarios. The SingletonTarget, for example, uses this method during its own Rezolver.ITarget.CreateExpression(Rezolver.CompileContext) implementation to get a nested lambda for the wrapped target, so that it can dynamically construct a Lazy whose factory method is the code we'd normally produce for a target. | Improve this Doc GetResolveLambdaForTarget(ITarget, CompileContext) First gets the lambda body using GetLambdaBodyForTarget(ITarget, CompileContext) , then passes that as the body for the returned expression, using also the RezolveContextExpression from the context parameter as the expression for the RezolveContext that's passed to the compiled method when invoked. Declaration public static Expression<Func<RezolveContext, object>> GetResolveLambdaForTarget(ITarget target, CompileContext context) Parameters Type Name Description ITarget target CompileContext context Returns Type Description Expression < Func < RezolveContext , Object >> | Improve this Doc Make_Scope_GetOrAddCallExpression(CompileContext, Type, LambdaExpression, Expression) Makes an expression which represents calling the GetOrAdd<T>(IScopedContainer, RezolveContext, Func<RezolveContext, T>, Boolean) function for the passed objectType . Used automatically by the built-in scope tracking behaviour, but can also be used by your own custom target if you want to take control of its scope tracking behaviour. Declaration public static Expression Make_Scope_GetOrAddCallExpression(CompileContext context, Type objectType, LambdaExpression factoryExpression, Expression iDisposableOnly = null) Parameters Type Name Description CompileContext context The compile context. Type objectType Type of the object to be stored or retrieved. LambdaExpression factoryExpression Lambda which should be executed to obtain a new instance if a matching object is not already in scope. Expression iDisposableOnly Expected to be a boolean expression indicating whether only IDisposables should be tracked in the scope. The default (if not provided) then will be set to 'true'. Returns Type Description Expression | Improve this Doc Make_Scope_GetScopeRootCallExpression(CompileContext) Returns an expression that represents a call to the Scope_GetScopeRootMethod extension method on the scope of the RezolveContext passed to a compiled object target. Declaration public static Expression Make_Scope_GetScopeRootCallExpression(CompileContext context) Parameters Type Name Description CompileContext context Returns Type Description Expression"
  },
  "rezolver-api/Rezolver.ExpressionTarget.html": {
    "href": "rezolver-api/Rezolver.ExpressionTarget.html",
    "title": "Class ExpressionTarget",
    "keywords": "Class ExpressionTarget A generic target for all expressions not explicitly supported by a particular target. Enables more complex behaviours to be registered and used with the more formal ITarget implementations. Inheritance Object TargetBase ExpressionTarget Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ExpressionTarget : TargetBase, ITarget Remarks Note to compiler implementers: This class can be used to represent simple expressions such as constants, constructor calls and so on; but can also contain whole lambda expressions with parameters. In the latter case, expression parameters are expected to receive injected arguments and, therefore, some rewriting of the expression is likely to be required. Constructors | Improve this Doc ExpressionTarget(Expression, Type) Initializes a new instance of the ExpressionTarget class. Declaration public ExpressionTarget(Expression expression, Type declaredType = null) Parameters Type Name Description Expression expression Required. The static expression which should be used by compilers. Type declaredType Declared type of the target to be created (used when registering without an explicit type or when this target is used as a value inside another target). Remarks declaredType will automatically be determined if not provided by examining the type of the expression . For lambdas, the type will be derived from the Type of the lambda's body. For all other expressions, the type is taken directly from the Type property of the expression itself. | Improve this Doc ExpressionTarget(Func<ICompileContext, Expression>, Type) Initializes a new instance of the ExpressionTarget class. Declaration public ExpressionTarget(Func<ICompileContext, Expression> expressionFactory, Type declaredType) Parameters Type Name Description Func < ICompileContext , Expression > expressionFactory Required. The factory delegate that a compiler should call to get the expression to use when compiling this target. Type declaredType Required. Static type of all expressions that will be returned by expressionFactory . Properties | Improve this Doc DeclaredType Gets the type of Expression or the type that all expressions returned by the ExpressionFactory are expected to be equal to. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc Expression Gets the static expression represented by this target - if null , then a factory is being used to produce the expression, which is available from the ExpressionFactory property. Declaration public Expression Expression { get; } Property Value Type Description Expression | Improve this Doc ExpressionFactory Gets a factory which will be executed to obtain an expression given a particular ICompileContext . If null , then a static expression will be used instead and is available from the Expression property. Declaration public Func<ICompileContext, Expression> ExpressionFactory { get; } Property Value Type Description Func < ICompileContext , Expression >"
  },
  "rezolver-api/Rezolver.ExpressionTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.ExpressionTargetContainerExtensions.html",
    "title": "Class ExpressionTargetContainerExtensions",
    "keywords": "Class ExpressionTargetContainerExtensions Extensions for to simplify registering expressions in an ITargetContainer . Inheritance Object ExpressionTargetContainerExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ExpressionTargetContainerExtensions Methods | Improve this Doc RegisterExpression(ITargetContainer, Expression, Type) Registers the expression. Declaration public static void RegisterExpression(this ITargetContainer targetContainer, Expression expression, Type type) Parameters Type Name Description ITargetContainer targetContainer The target container. Expression expression The expression. Type type The type. | Improve this Doc RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<TResult>(this ITargetContainer targetContainer, Expression<Func<TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) T15 The type of the 15th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) T15 The type of the 15th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T, TResult>(this ITargetContainer targetContainer, Expression<Func<T, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T The type of the 1st lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T The type of the 2nd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an and then registers it against either the passed type , or the created target's DeclaredType if not provided."
  },
  "rezolver-api/Rezolver.Functions.html": {
    "href": "rezolver-api/Rezolver.Functions.html",
    "title": "Class Functions",
    "keywords": "Class Functions This type is only used when using expressions as targets (via the type) - it's functions server no actual purpose other than to act as hooks to create specific ITarget objects in place of static code. For example, the Resolve<T>() function is used to trigger the creation of a in its place - thus allowing expressions to leverage the full power of the Rezolver API all through a simple method call. Inheritance Object Functions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class Functions Methods | Improve this Doc Resolve<T>() Translated to a with T being the type that will be resolved in this function's place. Declaration public static T Resolve<T>() Returns Type Description T Type Parameters Name Description T The type to be resolved. Exceptions Type Condition NotImplementedException Always. The method is not intended to be used outside of an expression."
  },
  "rezolver-api/Rezolver.GenericConstructorTarget.html": {
    "href": "rezolver-api/Rezolver.GenericConstructorTarget.html",
    "title": "Class GenericConstructorTarget",
    "keywords": "Class GenericConstructorTarget Equivalent of ConstructorTarget but for open generic types. So, this will handle the open generic MyType<,>, for example, whereas ConstructorTarget would handle the closed type MyType<int, string>. Inheritance Object TargetBase GenericConstructorTarget Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class GenericConstructorTarget : TargetBase, ITarget Constructors | Improve this Doc GenericConstructorTarget(Type, IMemberBindingBehaviour) Constructs a new instance of the GenericConstructorTarget for the given open generic type, which will utilise the optional memberBindingBehaviour when it constructs its ConstructorTarget when Bind(ICompileContext) is called. Declaration public GenericConstructorTarget(Type genericType, IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description Type genericType The type of the object that is to be built (open generic of course) IMemberBindingBehaviour memberBindingBehaviour Optional. The IMemberBindingBehaviour to be used for binding properties and/or fields on the ConstructorTarget that is generated. If null, then no property or fields will be bound on construction. Properties | Improve this Doc DeclaredType Implementation of the abstract base property. Will retrn the unbound generic type passed to this object on construction. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc GenericType Gets the generic type definition from which generic types are to be built and instances of which will be constructed. Declaration public Type GenericType { get; } Property Value Type Description Type | Improve this Doc MemberBindingBehaviour Gets the member binding behaviour to be used when creating an instance. Declaration public IMemberBindingBehaviour MemberBindingBehaviour { get; } Property Value Type Description IMemberBindingBehaviour The member binding behaviour. Methods | Improve this Doc Auto(Type, IMemberBindingBehaviour) Equivalent of Auto(Type, IMemberBindingBehaviour) but for open generic types. Declaration public static ITarget Auto(Type type, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description Type type The type. IMemberBindingBehaviour propertyBindingBehaviour The property binding behaviour. Returns Type Description ITarget Exceptions Type Condition ArgumentException The passed type must be an open generic type or The passed type must a non-abstract class | Improve this Doc Auto<TGeneric>(IMemberBindingBehaviour) Equivalent of Auto<T>(IMemberBindingBehaviour) but for open generic types. Declaration public static ITarget Auto<TGeneric>(IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description IMemberBindingBehaviour propertyBindingBehaviour Optional behaviour controlling which properties and fields, if any, receive injected values. Returns Type Description ITarget Type Parameters Name Description TGeneric The open generic type from which a closed generic will be created when this target is called upon to create an instance. | Improve this Doc Bind(ICompileContext) Obtains an ITarget (usually a ConstructorTarget ) which will create an instance of a generic type (whose definition is equal to GenericType ) with generic arguments set correctly according to the TargetType of the context . Declaration public ITarget Bind(ICompileContext context) Parameters Type Name Description ICompileContext context The context. Returns Type Description ITarget Remarks The process of binding a requested type to the concrete type can be a very complex process, when inheritance chains and interface implementation maps are taken into account. At the simplest end of the spectrum, if GenericType is MyGeneric<> and the context 's TargetType is MyGeneric<int> , then this function merely has to insert the int type as the generic parameter to the MyGeneric<> type definition, bake a new type and create an auto-bound ConstructorTarget . Consider what happens, however, when the inheritance chain is more complex: interface IMyInterfaceCore<T, U> { } class MyBaseClass<T, U> : IMyInterfaceCore<U, T> { } class MyDerivedClass<T, U> : MyBaseClass<U, T> { } A GenericConstructorTarget bound to the generic type definition MyDerivedClass<,> can create instances not only of any generic type based on that definition, but also any generic type based on the definitions of either it's immediate base, or that base's interface. In order to do so, however, the parameters must be mapped between the generic type definitions so that if an instance of MyBaseClass<string, int> is requested, then an instance of MyDerivedClass<int, string> (note the arguments are reversed) is actually created. Similarly, if an instance of IMyInterface<string, int> is requested, we actually need to create an instance of MyDerivedClass<string, int> - because the generic arguments are reversed first through the base class inheritance, and then again by the base class' implementation of the interface. Note that a GenericConstructorTarget can only bind to the context's target type if there is enough information in order to deduce the generic type arguments for GenericType . This means, in general, that the requested type will almost always need to be a generic type with at least as many type arguments as the GenericType . | Improve this Doc SupportsType(Type) Override - introduces additional logic to cope with generic types not generally supported by the majority of other targets. Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type Returns Type Description Boolean Overrides See Also TargetBase"
  },
  "rezolver-api/Rezolver.GenericTargetContainer.html": {
    "href": "rezolver-api/Rezolver.GenericTargetContainer.html",
    "title": "Class GenericTargetContainer",
    "keywords": "Class GenericTargetContainer A special type of ITargetContainerOwner which stores targets (and potentially other containers) which are specifically keyed either to a particular open generic type or a closed generic built from it. Inheritance Object TargetDictionaryContainer GenericTargetContainer Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class GenericTargetContainer : TargetDictionaryContainer, ITargetContainerOwner, ITargetContainer Remarks You don't typically use this container directly - it is implicitly added to an ITargetContainer when generic types are registered. Indeed the TargetContainer and DecoratingTargetContainer booth create instances of this; and the Rezolver.EnumerableTargetContainer (understandably) inherits from it. Constructors | Improve this Doc GenericTargetContainer(Type) Initializes a new instance of the GenericTargetContainer class. Declaration public GenericTargetContainer(Type genericType) Parameters Type Name Description Type genericType Required. The generic type definition that all targets and subcontainers will be grouped under. Properties | Improve this Doc GenericType Gets the open generic type definition which is common to all targets and containers within this container. Declaration public Type GenericType { get; } Property Value Type Description Type Methods | Improve this Doc Fetch(Type) Gets the target which can be used to build an instance of type . Declaration public override ITarget Fetch(Type type) Parameters Type Name Description Type type Required. The type for which a target is to be obtained. Because of the restrictions placed on the DeclaredType of the targets that can actually be registered into this container, the function will only ever return anything if type is a closed generic type whose definition equals GenericType . Returns Type Description ITarget Overrides Remarks Targets which have been registered specifically against the exact closed generic type represented by type take precedence over any targets which have been registered against the open generic type GenericType . | Improve this Doc FetchAll(Type) Implementation of FetchAll(Type) Declaration public override IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type The type whose targets are to be retrieved. Returns Type Description IEnumerable < ITarget > Overrides | Improve this Doc Register(ITarget, Type) Overrides the Register(ITarget, Type) method to support registering both targets against the open generic type GenericType and against specific closed versions of that open generic type. Declaration public override void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target The target to be registered Type serviceType Service type against which the registration will be made. If null, then it will be assumed to be equal to GenericType . Only types equal to GenericType or generic types whose generic type definition is equal to GenericType are supported. Overrides Remarks Notes to overriders: When serviceType is a closed generic type, this function creates an ITargetContainer for that serviceType by calling the protected method CreateContainer(Type, ITarget) if one doesn't exist (it calls FetchContainer(Type) to check for existence), and then chains to its Register(ITarget, Type) method. Exceptions Type Condition ArgumentException If serviceType is not equal to GenericType or is not a closed generic type whose generic type definition is GenericType . See Also TargetDictionaryContainer"
  },
  "rezolver-api/Rezolver.IChildTargetContainer.html": {
    "href": "rezolver-api/Rezolver.IChildTargetContainer.html",
    "title": "Interface IChildTargetContainer",
    "keywords": "Interface IChildTargetContainer An ITargetContainer that inherits all registrations from a ( Parent ) target container. If it cannot resolve a target for a particular type, will defer to its parent for fallback. Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IChildTargetContainer : ITargetContainer Remarks Note that the framework does not require that enumerables of targets (retrieved by calling FetchAll(Type) are merged between a child and parent container. Typically, as soon as one registration exists in a child container for the same type as in the parent, it overrides all registrations in the parent for that same type. Properties | Improve this Doc Parent Gets the parent target container. Declaration ITargetContainer Parent { get; } Property Value Type Description ITargetContainer The parent. See Also ITargetContainer"
  },
  "rezolver-api/Rezolver.ICompiledTarget.html": {
    "href": "rezolver-api/Rezolver.ICompiledTarget.html",
    "title": "Interface ICompiledTarget",
    "keywords": "Interface ICompiledTarget Provides an abstraction for creating objects based on a given ResolveContext - this is the ultimate target of all Resolve(ResolveContext) calls in the standard container implementations within the Rezolver framework. Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface ICompiledTarget Remarks In the standard implementations of IContainer (e.g. Container ), a ITargetCompiler creates instances of this from ITarget s which are registered in an ITargetContainer . When the container is then called upon to resolve an instance of a particular type, the ICompiledTarget is first obtained, and then the responsibility for creating the object is delegated to its GetObject(ResolveContext) method. Methods | Improve this Doc GetObject(ResolveContext) Called to get/create an object, potentially using the passed context to resolve additional dependencies (via its Container ), or interact with any lifetime scope which is 'active' for that request (through Scope ). Declaration object GetObject(ResolveContext context) Parameters Type Name Description ResolveContext context The current rezolve context. Returns Type Description Object The object that is constructed. The return value can legitimately be null. Exceptions Type Condition InvalidOperationException If the target fails to create the object Exception Any other application-level exception could be raised by this operation"
  },
  "rezolver-api/Rezolver.IContainer.html": {
    "href": "rezolver-api/Rezolver.IContainer.html",
    "title": "Interface IContainer",
    "keywords": "Interface IContainer The primary IOC container interface in the Rezolver framework. Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public interface IContainer : IServiceProvider Remarks Instances of objects (typically known as 'services' in IOC-speak) are resolved via the Resolve(ResolveContext) or TryResolve(ResolveContext, out Object) methods. You can introspect the container to check in advance whether a given type can be resolved through the CanResolve(ResolveContext) method. Lifetime scoping (where IDisposable objects are created within a scope and destroyed when that scope is destroyed) can be achieved by obtaining a new scope through the CreateScope() method; although a container might also implement the IScopedContainer interface, in which case the container itself is a lifetime scope. Many of the functions which accept a ResolveContext also have alternatives (in the form of extension methods) in the ContainerRezolveExtensions class. If you're looking for the 'traditional' IOC container methods (e.g. Resolve<TObject>(IContainer) , that's where you'll find them. Note that while the standard implementation of this interface supplied by the framework ( ContainerBase and its derivatives) all utilitise the ITargetContainer to actually locate registrations for types which are ultimately requested from the container; the interface doesn't actually mandate that pattern. Methods | Improve this Doc CanResolve(ResolveContext) Returns true if a resolve operation for the given context will succeed. If you're going to be calling Resolve(ResolveContext) immediately afterwards, consider using the TryResolve(ResolveContext, out Object) method instead, which allows you to check and obtain the result at the same time. Declaration bool CanResolve(ResolveContext context) Parameters Type Name Description ResolveContext context The resolve context. Returns Type Description Boolean true if this instance can resolve a type for the specified context; otherwise, false . | Improve this Doc CreateScope() Called to create an IContainerScope which can resolve the same objects as this container, but which will track, and dispose of, any disposable objects that it creates. Declaration IContainerScope CreateScope() Returns Type Description IContainerScope | Improve this Doc FetchCompiled(ResolveContext) Fetches the ICompiledTarget for the given context, whose GetObject(ResolveContext) method would ultimately be called if the same context was passed to Resolve(ResolveContext) or TryResolve(ResolveContext, out Object) . Declaration ICompiledTarget FetchCompiled(ResolveContext context) Parameters Type Name Description ResolveContext context The context. Returns Type Description ICompiledTarget Remarks This is not typically a method that you're likely to use as the consumer of an IContainer . It's more typically used by implementations of ITargetCompiler or implementations of IContainer when communicating with other containers. As such, its use at an application level is limited. | Improve this Doc Resolve(ResolveContext) Called to resolve a reference to an object for the given context (which provides the RequestedType of the object that is required, among other things). Declaration object Resolve(ResolveContext context) Parameters Type Name Description ResolveContext context The context. Returns Type Description Object The resolved object, if successful. Exceptions Type Condition InvalidOperationException If the requested type cannot be resolved. | Improve this Doc TryResolve(ResolveContext, out Object) Merges the CanResolve(ResolveContext) and Resolve(ResolveContext) operations into one operation. Declaration bool TryResolve(ResolveContext context, out object result) Parameters Type Name Description ResolveContext context The context. Object result Receives the resultant resolved object if the operation succeeds. Returns Type Description Boolean true if the operation succeeded (the resolved object will be set into the result parameter); false otherwise."
  },
  "rezolver-api/Rezolver.Targets.ConstructorTarget.html": {
    "href": "rezolver-api/Rezolver.Targets.ConstructorTarget.html",
    "title": "Class ConstructorTarget",
    "keywords": "Class ConstructorTarget A target that binds to a type's constructor with zero or more arguments supplied by other ITarget s and, optionally binding to the new instance's writeable properties. The target supports en explicitly supplied constructor, as well as just-in-time lookups for the best available constructor based on the available services and/or any named arguments which might been provided up front. Inheritance Object TargetBase ConstructorTarget Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class ConstructorTarget : TargetBase, ITarget Remarks Although you can create this target directly through the Rezolver.Targets.ConstructorTarget.#ctor(System.Type,ConstructorInfo,Rezolver.IMemberBindingBehaviour,Rezolver.ParameterBinding[],System.Collections.Generic.IDictionary{System.String,Rezolver.ITarget}) constructor, you're more likely to create it through factory methods such as Auto<T>(IMemberBindingBehaviour) or, more likely still, extension methods such as RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) during your application's container setup phase. To compile this target, an ITargetCompiler must call the Bind(ICompileContext) method Constructors | Improve this Doc ConstructorTarget(ConstructorInfo, IMemberBindingBehaviour, ParameterBinding[]) Initializes a new instance of the ConstructorTarget class bound in advance to a specific constructor. Declaration public ConstructorTarget(ConstructorInfo ctor, IMemberBindingBehaviour memberBindingBehaviour = null, ParameterBinding[] parameterBindings = null) Parameters Type Name Description ConstructorInfo ctor Required - the constructor that is to be bound. The DeclaredType of the new instance will be set to the of this object. IMemberBindingBehaviour memberBindingBehaviour Optional. If provided, can be used to select properties which are to be initialised before the new instance is returned. ParameterBinding [] parameterBindings Optional. Specific bindings for the parameters of the given ctor which should be used during code generation. Note that this array can contain fewer or more entries than there are parameters on the ctor . Any missing bindings will be automatically generated when Bind(ICompileContext) is called. | Improve this Doc ConstructorTarget(Type, IMemberBindingBehaviour, IDictionary<String, ITarget>) Initializes a just-in-time-bound instance of the ConstructorTarget class which must be bound to the best constructor at compile-time by calling the Bind(ICompileContext) method. Declaration public ConstructorTarget(Type type, IMemberBindingBehaviour memberBindingBehaviour = null, IDictionary<string, ITarget> namedArgs = null) Parameters Type Name Description Type type Required. The type whose constructor is to bound. IMemberBindingBehaviour memberBindingBehaviour Optional. If provided, can be used to select properties which are to be initialised before the new instance is returned. IDictionary < String , ITarget > namedArgs Optional. The named arguments which will be passed to, and used to find, the best-matched constructor. These are taken into account when the constructor is sought - with the constructor containing the most matched parameters matched being selected. Remarks To compile this target, a ITargetCompiler first calls the Bind(ICompileContext) method to discover the constructor to be executed, along with the final set of arguments to be provided to it (see ConstructorBinding ). The best available constructor is defined as the constructor with the most parameters for which arguments can be resolved from the ICompileContext at compile-time to the fewest number of ITarget objects whose UseFallback is false. Properties | Improve this Doc Ctor Can be null. Gets the constructor that this target is bound to, if it was known when the target was created. Declaration public ConstructorInfo Ctor { get; } Property Value Type Description ConstructorInfo Remarks ConstructorTargets can be bound to a particular constructor in advance, or they can search for a best-match constructor at the point where Bind(ICompileContext) is called. This property will only be set ultimately if it was passed to the ConstructorTarget(ConstructorInfo, IMemberBindingBehaviour, ParameterBinding[]) constructor, possibly by a factory method like WithArgs(ConstructorInfo, IDictionary<String, ITarget>) , or FromNewExpression(Type, NewExpression) , where the constructor is captured within the expression. | Improve this Doc DeclaredType Implementation of DeclaredType . Always equal to the type whose constructor will be bound by this target. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc MemberBindingBehaviour Gets the member binding behaviour to be used when Bind(ICompileContext) is called. Declaration public IMemberBindingBehaviour MemberBindingBehaviour { get; } Property Value Type Description IMemberBindingBehaviour | Improve this Doc NamedArgs Named arguments (as ITarget objects) to be supplied to the object on construction, also aiding the search for a constructor. This equivalent to the way that languages such as C# can bind to overloaded functions based solely on named arguments. Declaration public IReadOnlyDictionary<string, ITarget> NamedArgs { get; } Property Value Type Description IReadOnlyDictionary < String , ITarget > Remarks Note the difference between this and ParameterBindings - this property might be used when the constructor is not known in advance, whereas ParameterBindings is used when it is. | Improve this Doc ParameterBindings If this target was created with a specific constructor then this might contain argument bindings for that constructor's parameters. Declaration public IReadOnlyList<ParameterBinding> ParameterBindings { get; } Property Value Type Description IReadOnlyList < ParameterBinding > Remarks This is not the same as NamedArgs - as is noted by the documentation on that property. This property is for when the constructor is known in advance and when certain parameters are to be bound with specific arguments; whereas NamedArgs is for when the constructor is not known. Methods | Improve this Doc Auto(Type, IMemberBindingBehaviour) Creates a late bound ConstructorTarget or GenericConstructorTarget for the given type . Declaration public static ITarget Auto(Type type, IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description Type type The type that is to be constructed when this target is compiled and executed. IMemberBindingBehaviour memberBindingBehaviour Optional. An object which selects properties on the new instance which are to be bound from the container. Returns Type Description ITarget Either a ConstructorTarget or GenericConstructorTarget , depending on whether the type is a generic type definition. Remarks This factory is merely a shortcut for calling the ConstructorTarget(Type, IMemberBindingBehaviour, IDictionary<String, ITarget>) with only the type and memberBindingBehaviour arguments supplied. When creating a GenericConstructorTarget , the function uses the GenericConstructorTarget(Type, IMemberBindingBehaviour) constructor. | Improve this Doc Auto<T>(IMemberBindingBehaviour) Generic version of the Auto(Type, IMemberBindingBehaviour) method. Declaration public static ITarget Auto<T>(IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description IMemberBindingBehaviour memberBindingBehaviour See the documentation for the memberBindingBehaviour parameter on the non-generic version of this method. Returns Type Description ITarget Either a ConstructorTarget or GenericConstructorTarget , depending on whether T is a generic type definition. Type Parameters Name Description T The type that is to be constructed when the new target is compiled and executed. | Improve this Doc Bind(ICompileContext) Gets the ConstructorBinding for the DeclaredType using the targets available in the context for dependency lookup. The constructor is either resolved by checking available targets for the best match, or is pre-selected on construction ( Ctor will be non-null in this case). Declaration public ConstructorBinding Bind(ICompileContext context) Parameters Type Name Description ICompileContext context The current compilation context. Returns Type Description ConstructorBinding Exceptions Type Condition InvalidOperationException If no sutiable constructors can be found. | Improve this Doc FromNewExpression(Type, NewExpression) Non-generic version of FromNewExpression<T>(Expression<Func<T>>) . See the documentation on that method for more. Declaration public static ITarget FromNewExpression(Type declaredType, NewExpression newExpr) Parameters Type Name Description Type declaredType The of the object to be created by the new ConstructorTarget NewExpression newExpr An expression from which the target can be built - parameter bindings and the specific constructor called in the expression will be used to seed the new target. Returns Type Description ITarget | Improve this Doc FromNewExpression<T>(Expression<Func<T>>) Creates a new ConstructorTarget from the passed lambda expression (whose must be a ) Declaration public static ITarget FromNewExpression<T>(Expression<Func<T>> newExpr) Parameters Type Name Description Expression < Func <T>> newExpr Required. The expression from which to create the target. Returns Type Description ITarget An ITarget which, when compiled, will perform that same construction as provided in the given expression. Type Parameters Name Description T The type of the object to be created by the new ConstructorTarget Remarks This method does not support member binding expressions - e.g. c => new MyObject() { A = \"hello\" } - these can be converted into targets - for these you should construct an ExpressionTarget and let the compiler do the rest. When providing custom expressions to be used as targets in an ITargetContainer , it is possible to explicitly define properties/arguments as being resolved from the container itself, in exactly the same way as generated by the other factory methods such as Auto<T>(IMemberBindingBehaviour) and RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) . To do this, simply call the Resolve<T>() function on the object passed into your expression (see the signature of the lambda newExpr ), and Rezolver will convert that call into a ResolvedTarget . Exceptions Type Condition ArgumentNullException If newExpr is null. ArgumentException If the newExpr does not have a NewExpression as its root (Body) node, or if the type of that expression does not equal T | Improve this Doc WithArgs(ConstructorInfo, IDictionary<String, ITarget>) Similar to WithArgs(Type, IDictionary<String, ITarget>) except this one creates a ConstructorTarget that is specifically bound to a particular constructor on a given type, using any matched argument bindings from the provided namedArgs dictionary, and using ResolvedTarget targets for any that are not matched. Declaration public static ITarget WithArgs(ConstructorInfo ctor, IDictionary<string, ITarget> namedArgs) Parameters Type Name Description ConstructorInfo ctor Required. The constructor to be bound. IDictionary < String , ITarget > namedArgs Optional. Any arguments to be supplied to parameters on the ctor by name. Any parameters for which matches are not found in this dictionary will be automatically bound either from compile-time defaults or by resolving those types dynamically. Returns Type Description ITarget Remarks Although this overload accepts a dictionary of arguments, note that it will not result in the NamedArgs property being set on the target that is created - it's just an alternative for deriving the ParameterBindings with which the target will be created. Also, this function will not fail if the args dictionary contains named arguments that cannot be matched to parameters on the ctor . | Improve this Doc WithArgs(ConstructorInfo, Object) Performs the same operation as WithArgs(ConstructorInfo, IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration public static ITarget WithArgs(ConstructorInfo ctor, object namedArgs) Parameters Type Name Description ConstructorInfo ctor Required. The constructor to be bound. Object namedArgs An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Remarks Although this overload accepts a dictionary of arguments, note that it will not result in the NamedArgs property being set on the target that is created - it's just an alternative for deriving the ParameterBindings with which the target will be created. Also, this function will not fail if the args dictionary contains named arguments that cannot be matched to parameters on the ctor . | Improve this Doc WithArgs(Type, IDictionary<String, ITarget>) Non-generic version of WithArgs<T>(IDictionary<String, ITarget>) . Creates a ConstructorTarget with a set of named targets which will be used like named arguments to late-bind the constructor when code-generation occurs. Declaration public static ITarget WithArgs(Type declaredType, IDictionary<string, ITarget> namedArgs) Parameters Type Name Description Type declaredType The type whose constructor is to be bound. IDictionary < String , ITarget > namedArgs The named arguments to be used when building the expression. Returns Type Description ITarget Remarks Both versions of this method will create a target which will try to find the best-matching constructor where all of the named arguments match, and with the fewest number of auto-resolved arguments. So, a class with a constructor such as Foo(IService1 s1, IService2 s2) Can happily be bound if you only provide a named argument for 's1'; the target will simply attempt to auto-resolve the argument for the IService2 s2 parameter when constructing the object - and will fail only if it can't be resolved at that point. | Improve this Doc WithArgs(Type, Object) Performs the same operation as WithArgs(Type, IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration public static ITarget WithArgs(Type declaredType, object namedArgs) Parameters Type Name Description Type declaredType The type whose constructor is to be bound. Object namedArgs An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Remarks This overload exists to simplify the process of creating a ConstructorTarget with argument bindings by removing the need to create an argument dictionary in advance. An anonymous type can instead be used to supply the arguments. Examples This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a ConstructorTarget for the type 'MyType': ConstructorTarget.WithArgs(typeof(MyType), new { param1 = new ObjectTarget(\"Hello World\") }); | Improve this Doc WithArgs<T>(IDictionary<String, ITarget>) Creates a ConstructorTarget with a set of named targets which will be used like named arguments to late-bind the constructor when code-generation occurs. Declaration public static ITarget WithArgs<T>(IDictionary<string, ITarget> namedArgs) Parameters Type Name Description IDictionary < String , ITarget > namedArgs The named arguments to be used when building the expression. Returns Type Description ITarget Type Parameters Name Description T The type whose constructor is to be bound Remarks Both versions of this method will create a target which will try to find the best-matching constructor where all of the named arguments match, and with the fewest number of auto-resolved arguments. So, a class with a constructor such as Foo(IService1 s1, IService2 s2) Can happily be bound if you only provide a named argument for 's1'; the target will simply attempt to auto-resolve the argument for the IService2 s2 parameter when constructing the object - and will fail only if it can't be resolved at that point. | Improve this Doc WithArgs<T>(Object) Performs the same operation as WithArgs<T>(IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration public static ITarget WithArgs<T>(object namedArgs) Parameters Type Name Description Object namedArgs An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Type Parameters Name Description T Remarks This overload exists to simplify the process of creating a ConstructorTarget with argument bindings by removing the need to create an argument dictionary in advance. An anonymous type can instead be used to supply the arguments. Examples This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a ConstructorTarget for the type 'MyType': ConstructorTarget.WithArgs<MyType>(new { param1 = new ObjectTarget(\"Hello World\") });"
  },
  "rezolver-api/Rezolver.Targets.ObjectTarget.html": {
    "href": "rezolver-api/Rezolver.Targets.ObjectTarget.html",
    "title": "Class ObjectTarget",
    "keywords": "Class ObjectTarget Implements ITarget by wrapping a single instance that's already been constructed by application code. Inheritance Object TargetBase ObjectTarget Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class ObjectTarget : TargetBase, ITarget, ICompiledTarget Constructors | Improve this Doc ObjectTarget(Object, Type, ScopeBehaviour) Creates a new instance of the ObjectTarget class. Declaration public ObjectTarget(object obj, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description Object obj The object to be returned by this target when resolved. Type declaredType Optional. The declared type of this target, if different from the absolute type of the obj ScopeBehaviour scopeBehaviour Optional. If you want the object to be disposed by Rezolver when the root scope is disposed, then specify a behaviour other than the default. Note - the only real behaviour that makes sense for this is Explicit , since the Implicit behaviour will typically fool a scope that multiple instances are being created and, therefore, the object will be tracked multiple times by that scope. Remarks Please note - if you enable scope tracking, but the object is never resolved, then the object will not be disposed and you will need to ensure you dispose of it. Properties | Improve this Doc DeclaredType Gets the declared type of object that is returned by this target. Might be different from the type of Value if explicitly defined when this target was constructed. Declaration public override Type DeclaredType { get; } Property Value Type Description Type The type of the declared. Overrides | Improve this Doc ScopeBehaviour Gets the scope behaviour. Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides | Improve this Doc Value Gets the value that will be exposed by expressions built by this instance. Declaration public object Value { get; } Property Value Type Description Object The value. Methods | Improve this Doc SelectScope(ResolveContext) Selects the scopem in which instance should be tracked for disposal. Declaration public override IContainerScope SelectScope(ResolveContext context) Parameters Type Name Description ResolveContext context The context. Returns Type Description IContainerScope Overrides Explicit Interface Implementations | Improve this Doc ICompiledTarget.GetObject(ResolveContext) Declaration object ICompiledTarget.GetObject(ResolveContext context) Parameters Type Name Description ResolveContext context Returns Type Description Object Implements"
  },
  "rezolver-api/Rezolver.Targets.OptionalParameterTarget.html": {
    "href": "rezolver-api/Rezolver.Targets.OptionalParameterTarget.html",
    "title": "Class OptionalParameterTarget",
    "keywords": "Class OptionalParameterTarget Used specifically when binding arguments to method parameters when a parameter is optional and its default value is to be used when binding to it. It is highly unlikely you'll ever create one of these directly. Inheritance Object TargetBase OptionalParameterTarget Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class OptionalParameterTarget : TargetBase, ITarget Constructors | Improve this Doc OptionalParameterTarget(ParameterInfo) Constructs a new instance of the OptionalParameterTarget class. Declaration public OptionalParameterTarget(ParameterInfo methodParameter) Parameters Type Name Description ParameterInfo methodParameter Required - parameter to which this target will be bound. Its property must be true otherwise an ArgumentException is thrown. Properties | Improve this Doc DeclaredType Always returns the of the MethodParameter Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc MethodParameter The parameter to which this target is bound. Declaration public ParameterInfo MethodParameter { get; } Property Value Type Description ParameterInfo | Improve this Doc ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides | Improve this Doc UseFallback Always returns true, since using a default argument of a parameter is always considered to be a last-resort. Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides | Improve this Doc Value Gets the value represented by this target. This is either the default value of the MethodParameter , if applicable, or the default for the parameter type. Declaration public object Value { get; } Property Value Type Description Object The value."
  },
  "rezolver-api/Rezolver.Targets.ResolvedTarget.html": {
    "href": "rezolver-api/Rezolver.Targets.ResolvedTarget.html",
    "title": "Class ResolvedTarget",
    "keywords": "Class ResolvedTarget Represents a target that is rezolved statically at compile time via the ICompileContext , or dynamically (at 'resolve time') from the IContainer that is attached to the current ResolveContext when Resolve(ResolveContext) is called. This is the most common way that we bind constructor parameters, for example - i.e. 'I want an IService instance - go get it'. Inheritance Object TargetBase ResolvedTarget Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class ResolvedTarget : TargetBase, ITarget Remarks Represents an object that will be resolved from the container when its ICompiledTarget is executed, or when the target is used perhaps by another ITarget (e.g. - a ConstructorTarget with a constructor parameter bound to one of these). So, in essence, a ResolvedTarget represents an automatic call to a container's Resolve(ResolveContext) method, for the DeclaredType . In practise - an ITargetCompiler might take advantage of the fact that, during compilation, targets can be discovered directly from the ICompileContext that is passed to CompileTarget(ITarget, ICompileContext) by leveraging its ITargetContainer implementation. Indeed - the expressions compiler uses this to avoid repeated recursion into the Resolve method of the container, instead choosing to compile all the expressions for all targets required for an operation into one dynamically built method - which results in very fast execution times for all resolve operations. Not only this, but the behaviour can be extended still further by realising that a Container on which a resolve operation is invoked might not be the same container for which this ResolvedTarget was first compiled. In this case - it's possible that the other container has alternative registrations for a given service type which the application expects to take precedence over those which were originally resolved when compilation took place. The expressions compiler, again, detects this - allowing compiled code from a root container to detect an 'overriding' container and to dynamically resolve a different dependency in this situation. It's this behaviour which is almost unique to the Rezolver framework out of the box. Constructors | Improve this Doc ResolvedTarget(Type, ITarget) Creates a new ResolvedTarget for the given type which will attempt to resolve a value at compile time and/or resolve-time and, if it can't, will either use the fallbackTarget or will throw an exception. Declaration public ResolvedTarget(Type type, ITarget fallbackTarget = null) Parameters Type Name Description Type type Required. The type to be resolved ITarget fallbackTarget Optional. The target to be used if the value cannot be resolved at either compile time or resolve-time. An ArgumentException is thrown if this target's SupportsType(Type) function returns false when called with the type . Properties | Improve this Doc DeclaredType The type that is to be resolved from the container at resolve-time. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc FallbackTarget Gets the target that this ResolvedTarget will fallback to if a satisfactory target cannot be found at compile time or resolve-time. Declaration public ITarget FallbackTarget { get; } Property Value Type Description ITarget Remarks The UseFallback property is also used to determine whether this will be used. If the target resolved from the ICompileContext has its UseFallback property set to true, and this property is non-null for this target, then this target will be used. Note also that extension containers such as OverridingContainer also have the ability to override the use of this fallback if they successfully resolve the type. | Improve this Doc ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides Methods | Improve this Doc Bind(ICompileContext) Attempts to obtain the target that this ResolvedTarget resolves to for the given ICompileContext . This function should be used by ITargetCompiler implementations when producing the ICompiledTarget for this instance, who wish to perform some form of up-front optimisations. Declaration public virtual ITarget Bind(ICompileContext context) Parameters Type Name Description ICompileContext context The context from which a target is to be resolved. Returns Type Description ITarget The target resolved by this target - could be the FallbackTarget , could be null. Remarks The target that is returned depends both on the context passed and also whether a FallbackTarget has been provided to this target."
  },
  "rezolver-api/Rezolver.Targets.RezolvedTarget.html": {
    "href": "rezolver-api/Rezolver.Targets.RezolvedTarget.html",
    "title": "Class RezolvedTarget",
    "keywords": "Class RezolvedTarget Represents a target that is rezolved statically at compile time via the ICompileContext , or dynamically (at 'resolve time') from the IContainer that is attached to the current ResolveContext when Resolve(ResolveContext) is called. This is the most common way that we bind constructor parameters, for example - i.e. 'I want an IService instance - go get it'. Inheritance Object TargetBase RezolvedTarget Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class RezolvedTarget : TargetBase, ITarget Remarks Represents an object that will be resolved from the container when its ICompiledTarget is executed, or when the target is used perhaps by another ITarget (e.g. - a ConstructorTarget with a constructor parameter bound to one of these). So, in essence, a RezolvedTarget represents an automatic call to a container's Resolve(ResolveContext) method, for the DeclaredType . In practise - an ITargetCompiler might take advantage of the fact that, during compilation, targets can be discovered directly from the ICompileContext that is passed to CompileTarget(ITarget, ICompileContext) by leveraging its ITargetContainer implementation. Indeed - the expressions compiler uses this to avoid repeated recursion into the Resolve method of the container, instead choosing to compile all the expressions for all targets required for an operation into one dynamically built method - which results in very fast execution times for all resolve operations. Not only this, but the behaviour can be extended still further by realising that a Container on which a resolve operation is invoked might not be the same container for which this RezolvedTarget was first compiled. In this case - it's possible that the other container has alternative registrations for a given service type which the application expects to take precedence over those which were originally resolved when compilation took place. The expressions compiler, again, detects this - allowing compiled code from a root container to detect an 'overriding' container and to dynamically resolve a different dependency in this situation. It's this behaviour which is almost unique to the Rezolver framework out of the box. Constructors | Improve this Doc RezolvedTarget(Type, ITarget) Creates a new RezolvedTarget for the given type which will attempt to resolve a value at compile time and/or resolve-time and, if it can't, will either use the fallbackTarget or will throw an exception. Declaration public RezolvedTarget(Type type, ITarget fallbackTarget = null) Parameters Type Name Description Type type Required. The type to be resolved ITarget fallbackTarget Optional. The target to be used if the value cannot be resolved at either compile time or resolve-time. Properties | Improve this Doc DeclaredType The type that is to be resolved from the container at resolve-time. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc FallbackTarget Gets the target that this RezolvedTarget will fallback to if a satisfactory target cannot be found at compile time or resolve-time. Declaration public ITarget FallbackTarget { get; } Property Value Type Description ITarget Remarks The UseFallback property is also used to determine whether this will be used. If the target resolved from the ICompileContext has its UseFallback property set to true, and this property is non-null for this target, then this target will be used. Note also that extension containers such as OverridingContainer also have the ability to override the use of this fallback if they successfully resolve the type. | Improve this Doc SuppressScopeTracking Always returns true - we never wrap calls to a container inside a scope tracking expression. Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides Methods | Improve this Doc Bind(ICompileContext) Attempts to obtain the target that this RezolvedTarget resolves to for the given ICompileContext . This function should be used by ITargetCompiler implementations when producing the ICompiledTarget for this instance, who wish to perform some form of up-front optimisations. Declaration public virtual ITarget Bind(ICompileContext context) Parameters Type Name Description ICompileContext context The context from which a target is to be resolved. Returns Type Description ITarget The target resolved by this target - could be the FallbackTarget , could be null. Remarks The target that is returned depends both on the context passed and also whether a FallbackTarget has been provided to this target."
  },
  "rezolver-api/Rezolver.Targets.ScopedTarget.html": {
    "href": "rezolver-api/Rezolver.Targets.ScopedTarget.html",
    "title": "Class ScopedTarget",
    "keywords": "Class ScopedTarget A target that produces or fetches a single instance of an object within a lifetime scope. Inheritance Object TargetBase ScopedTarget Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class ScopedTarget : TargetBase, ITarget Remarks Scopes in Rezolver operate much the same as they do in any IOC framework, but use of them is always entirely optional. When a scope is active for a given Resolve(ResolveContext) operation, most objects which are returned from those operations will implicitly be scoped to whichever scope is active when the objects are resolved. Implicitly scoped objects are only disposed of when their containing scope is disposed, and you can have an unlimited number of instances of implicitly scoped objects per scope. This target is used to scope the object produced by a target explicitly to a scope, and to ensure that only one instance of that object is produced per scope. Such objects are also not inherited between parent scopes and child scopes. Constructors | Improve this Doc ScopedTarget(ITarget) Initializes a new instance of the ScopedTarget class. Declaration public ScopedTarget(ITarget innerTarget) Parameters Type Name Description ITarget innerTarget Required. The inner target. Properties | Improve this Doc DeclaredType Gets the declared type of object that is constructed by this target. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides Remarks Always forwards the call on to InnerTarget | Improve this Doc InnerTarget Gets the inner target whose result (when compiled) will be scoped to the active scope. Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget The inner target. | Improve this Doc ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides Methods | Improve this Doc SupportsType(Type) Called to check whether a target can create an expression that builds an instance of the given type . Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type Required Returns Type Description Boolean Overrides Remarks Always forwards the call on the InnerTarget"
  },
  "rezolver-api/Rezolver.Targets.SingletonTarget.html": {
    "href": "rezolver-api/Rezolver.Targets.SingletonTarget.html",
    "title": "Class SingletonTarget",
    "keywords": "Class SingletonTarget A target which applies the singleton pattern to any ITarget . The inner target is available from the InnerTarget property. Inheritance Object TargetBase SingletonTarget Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class SingletonTarget : TargetBase, ITarget Constructors | Improve this Doc SingletonTarget(ITarget) Constructs a new instance of the SingletonTarget class. Declaration public SingletonTarget(ITarget innerTarget) Parameters Type Name Description ITarget innerTarget The target whose result (when compiled) is to be used as the singleton instance. Properties | Improve this Doc DeclaredType Override of DeclaredType - always returns the DeclaredType of the InnerTarget Declaration public override Type DeclaredType { get; } Property Value Type Description Type The type of the declared. Overrides | Improve this Doc InnerTarget Gets the inner target for this singleton. Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget | Improve this Doc ScopeBehaviour Always returns Explicit . Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour Overrides Methods | Improve this Doc GetOrAddInitialiser(Type, Func<Type, ICompiledTarget>) Used to support compiled versions of this singleton Declaration public ICompiledTarget GetOrAddInitialiser(Type declaredType, Func<Type, ICompiledTarget> initialiserFactory) Parameters Type Name Description Type declaredType Type of object. Func < Type , ICompiledTarget > initialiserFactory The initialiser factory. Returns Type Description ICompiledTarget Remarks This concept is something that probably needs to move out of this type, into a more generic TargetState object or something like that. | Improve this Doc SelectScope(ResolveContext) Always selects the root scope from the context ( GetRootScope(IContainerScope) , if the context has a non-null scope. Declaration public override IContainerScope SelectScope(ResolveContext context) Parameters Type Name Description ResolveContext context The context. Returns Type Description IContainerScope Overrides | Improve this Doc SupportsType(Type) Called to check whether a target can create an expression that builds an instance of the given type . The base implementation always passes the call on to the InnerTarget Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type Required Returns Type Description Boolean Overrides"
  },
  "rezolver-api/Rezolver.Targets.TargetBase.html": {
    "href": "rezolver-api/Rezolver.Targets.TargetBase.html",
    "title": "Class TargetBase",
    "keywords": "Class TargetBase Abstract base class, suggested as a starting point for implementations of ITarget . Inheritance Object TargetBase Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public abstract class TargetBase : ITarget Properties | Improve this Doc DeclaredType Gets the declared type of object that is constructed by this target. Declaration public abstract Type DeclaredType { get; } Property Value Type Description Type Implements | Improve this Doc ScopeBehaviour Gets the scoping behaviour for instances that will ultimately be produced by this target. Declaration public virtual ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Implements Remarks Base implementation always returns Implicit . | Improve this Doc UseFallback Implementation of UseFallback Base version always returns false . Declaration public virtual bool UseFallback { get; } Property Value Type Description Boolean Implements Methods | Improve this Doc SelectScope(ResolveContext) Selects the scope. Declaration public virtual IContainerScope SelectScope(ResolveContext context) Parameters Type Name Description ResolveContext context The context. Returns Type Description IContainerScope Implements | Improve this Doc SupportsType(Type) Implementation of SupportsType(Type) . Returns a boolean indicating whether the target is able to produce an instance of, or an instance that is compatible with, the passed type . Declaration public virtual bool SupportsType(Type type) Parameters Type Name Description Type type The type. Returns Type Description Boolean Implements Remarks It is strongly suggested that you use this method to check whether the target can construct an instance of a given type rather than performing any type checking yourself on the DeclaredType , because an ITarget might be able to support a much wider range of types other than just those which are directly compatible with its DeclaredType . For example, the GenericConstructorTarget is statically bound to an open generic, so therefore traditional type checks on the DeclaredType do not work. That class' implementation of this method, however, contains the complex logic necessary to determine if the open generic can be closed into a generic type which is compatible with the given type . Implementations of ITargetCompiler should always consult this function in their implementation of CompileTarget(ITarget, ICompileContext) to determine if the target is compatible with the TargetType of the CompileContext"
  },
  "rezolver-api/Rezolver.Targets.UnscopedTarget.html": {
    "href": "rezolver-api/Rezolver.Targets.UnscopedTarget.html",
    "title": "Class UnscopedTarget",
    "keywords": "Class UnscopedTarget Wraps another target to force scoping to be ignored for the object that it produces, regardless of whether that object is IDisposable or otherwise has its own scoping behaviour. Inheritance Object TargetBase UnscopedTarget Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class UnscopedTarget : TargetBase, ITarget Constructors | Improve this Doc UnscopedTarget(ITarget) Initializes a new instance of the UnscopedTarget class. Declaration public UnscopedTarget(ITarget inner) Parameters Type Name Description ITarget inner Required - the inner target. Properties | Improve this Doc DeclaredType Gets the declared type of object that is constructed by this target - always forwards the call to the Inner target. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc Inner Gets the inner target whose scoping rules are to be stripped by this target. Declaration public ITarget Inner { get; } Property Value Type Description ITarget | Improve this Doc ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour Overrides | Improve this Doc UseFallback Implementation of UseFallback Always forwards the call to Inner target. Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides Methods | Improve this Doc SupportsType(Type) Always forward the call to the Inner target's implementation. Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type The type. Returns Type Description Boolean Overrides"
  },
  "rezolver-api/Rezolver.Targets.html": {
    "href": "rezolver-api/Rezolver.Targets.html",
    "title": "Namespace Rezolver.Targets",
    "keywords": "Namespace Rezolver.Targets Classes This target is specifically used for explicitly casting the result of one target to another type. Its use is rare, since the framework already caters for downcasting the result of targets to base types. A target that binds to a type's constructor with zero or more arguments supplied by other ITarget s and, optionally binding to the new instance's writeable properties. The target supports en explicitly supplied constructor, as well as just-in-time lookups for the best available constructor based on the available services and/or any named arguments which might been provided up front. Represents the action of implementing a common DecoratedType by decorating one instance (produced by DecoratedTarget ) with another ( Target , which will create an instance of DecoratorType ). NOTE - You shouldn't register or otherwise create instances of this target unless you absolutely know what you're doing. Rather, decorators should be registered using the extension method RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) or its non-generic alternative because the target needs a DecoratingTargetContainer to work properly (the creation of which is automatically handled by these extension methods). A target that simply creates a default instance of a given type. I.e. the same as doing default(type) in C#. An ITarget which resolve objects by executing a delegate with argument injection. Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. A generic target for all expressions not explicitly supported by a particular target. Enables more complex behaviours to be registered and used with the more formal ITarget implementations. Equivalent of ConstructorTarget but for open generic types. So, this will handle the open generic MyType<,>, for example, whereas ConstructorTarget would handle the closed type MyType<int, string>. Result returned from the MapType(Type) function. Represents various levels of success - from a completely incompatible mapping ( Success = false ), or a successful mapping from an open generic type to a closed generic type which can then be constructed ( Success = true and IsFullyBound = true ) or, a successful mapping from an open generic type to another open generic type ( Success = true but IsFullyBound = false ). This mapping is then used by both the SupportsType(Type) and Bind(ICompileContext) functions. Only fully bound mappings are supported by Bind(ICompileContext) , whereas SupportsType(Type) will return true so long as the Success is true. The caller, therefore, must ensure it is aware of the difference between open and closed generics. This target produces arrays ( AsArray = true ) or lists ( AsArray = false ) whose individual items are built by ITarget instances. Primarily used by the Rezolver.EnumerableTargetContainer and the configuration framework, but can also be used by your code. Implements ITarget by wrapping a single instance that's already been constructed by application code. Used specifically when binding arguments to method parameters when a parameter is optional and its default value is to be used when binding to it. It is highly unlikely you'll ever create one of these directly. Represents a target that is rezolved statically at compile time via the ICompileContext , or dynamically (at 'resolve time') from the IContainer that is attached to the current ResolveContext when Resolve(ResolveContext) is called. This is the most common way that we bind constructor parameters, for example - i.e. 'I want an IService instance - go get it'. A target that produces or fetches a single instance of an object within a lifetime scope. A target which applies the singleton pattern to any ITarget . The inner target is available from the InnerTarget property. Abstract base class, suggested as a starting point for implementations of ITarget . Wraps another target to force scoping to be ignored for the object that it produces, regardless of whether that object is IDisposable or otherwise has its own scoping behaviour."
  },
  "rezolver-api/Rezolver.html": {
    "href": "rezolver-api/Rezolver.html",
    "title": "Namespace Rezolver",
    "keywords": "Namespace Rezolver Classes Contains extension methods for ITargetContainer to create targets which alias others by different types. Builds on the ContainerBase base class to introduce thread-safe caching of compiled targets so they are only compiled once per requested type. Only creatable through inheritance. A version of TargetContainer which overrides the registrations of another (the Parent ). Represents a binding specifically to a class constructor, optionally with an additional set of MemberBindings to be used to initialise a new instance's properties or fields directly. The standard IOC container class in Rezolver. Starting point for implementations of IContainer - only creatable through inheritance. Used when an ITarget is also of the same type as the one for which it is returned by the Fetch(Type) method of the Targets container. In this case, the target is not compiled, but instead is simply returned as the desired object. Used as a sentinel type when a type cannot be resolved by a ContainerBase instance. Instead of returning a null ICompiledTarget instance, the container will construct an instance of this type (typically through GetMissingTarget(Type) , which caches singleton instances of this class on a per-type basis) which can then be used just as if the lookup succeeded. Extension methods for IContainer which provide shortcuts for the Resolve(ResolveContext) operation. Standard implementation of the IContainerScope interface. Standard extensions for the IContainerScope Extensions for IContainerScope so that instances of that interface present a similar set of functionality to IContainer . Implements service decoration in an ITargetContainer , producing instances of the when Fetch(Type) or FetchAll(Type) are called. The best way to add a decorator to your target container is to use the extension method RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) or its non-generic equivalent. Extensions for ITargetContainerOwner which simplify the registration of decorators (via the DecoratingTargetContainer pseudo-target) The default implementation of IMemberBindingBehaviour when you are creating a or and you want publicly writable properties and public fields to be assigned values obtained from the container. If you do not require properties or fields to be bound from the container, then use a null IMemberBindingBehaviour . Extension methods for ITargetContainer designed to simplify the registration of and its numerous generic variants. Houses an extension method which enables native resolving of IEnumerables of services on ITargetContainer containers which, in turn, enables it for any ContainerBase containers which use that target container. A strongly-typed resource class, for looking up localized strings, etc. Extensions for to simplify registering expressions in an ITargetContainer . This type is only used when using expressions as targets (via the type) - it's functions server no actual purpose other than to act as hooks to create specific ITarget objects in place of static code. For example, the Resolve<T>() function is used to trigger the creation of a in its place - thus allowing expressions to leverage the full power of the Rezolver API all through a simple method call. A special type of ITargetContainerOwner which stores targets (and potentially other containers) which are specifically keyed either to a particular open generic type or a closed generic built from it. Represents the binding of an ITarget to a property or field of a given type. Not to be confused with the type of the same name from the System.Linq.Expressions namespace, although they are technically equivalent. Represents a binding to a method whose arguments will be supplied by ITarget instances. Used to help grab method and constructor info from expressions (which is easier than writing long strings of reflection code). For example: MethodCallExtractor.ExtractCalledMethod(() => Console.WriteLine(\"foo\")) Will return the MethodInfo for the WriteLine method of the Console class. Extensions for registering multiple targets individually and against the same type Extensions for ITargetContainer relating to registering concrete instances via the target. An IContainer which can override the resolve operations of another. This is useful when you have a core application-wide container, with some objects being customised based on some ambient information, e.g. configuration, MVC Area/Controller, Brand (in a multi-tenant application for example) or more. Represents a binding between a method parameter and an ITarget Extensions for ITargetContainer to provide shortcuts for the simplest cases of registering and targets. Captures the state for a call to Resolve(ResolveContext) (or TryResolve(ResolveContext, out Object) ), including the container on which the operation is invoked, any IScopedContainer that might be active for the call (if different), and the type which is being resolved from the IContainer . Extends the Container to implement lifetime implicit scoping through the Scope that's created along with it. Implementation of the IScopedContainer interface. Extensions for ITargetContainer to provide shortcuts for registering constructor-injected types whose lifetimes are slaved to that of a parent IScopedContainer . All of the extension methods ultimately create a Extension methods for the ITargetContainer interface which simplify the registration of singletons. Root container for ITarget s that can be used as the backing for the standard IContainer classes - Container and ScopedContainer . Stores and retrieves registrations of ITarget s, is also Generic type aware, unlike its base class - TargetDictionaryContainer . Extensions which provide shortcuts for creating some of the extensions in the Rezolver.Targets namespace. An ITargetContainerOwner implementation that stores and retrieves ITarget and ITargetContainer by type. An ITargetContainer that stores multiple targets in a list. This is not a type that you would typically use directly in your code, unless you are writing custom logic/behaviour for ITarget registration. Interfaces An ITargetContainer that inherits all registrations from a ( Parent ) target container. If it cannot resolve a target for a particular type, will defer to its parent for fallback. Provides an abstraction for creating objects based on a given ResolveContext - this is the ultimate target of all Resolve(ResolveContext) calls in the standard container implementations within the Rezolver framework. The primary IOC container interface in the Rezolver framework. This is an IContainer -like object (resolving functionality is provided through the extension methods in the ContainerScopeResolveExtensions class) which Describes a type which discovers and creates property/field bindings, typically for use when creating a new instance. An IContainer that also has a Scope attached to it. Many applications will use such a container as the root container to use as anchors for things like scoped singletons. Represents an action to be performed in order to obtain an object to satisfy a call to Resolve(ResolveContext) , when the standard implementations of IContainer are used (e.g. Container ). Stores and retrieves ITarget instances, keyed by the type of service that the targets are registered against. This is where all your service registrations will ultimately go. Interface for an ITargetContainer which also contains other target containers. It is not typically used by your application code since it's primarily an infrastructure interface - if you are extending the API, however, then you might need to work with it. Enums Describes different ways in which objeects interact with scopes."
  },
  "rezolver-api/System.Collections.Generic.ReadOnlyEnumerableExtensions.html": {
    "href": "rezolver-api/System.Collections.Generic.ReadOnlyEnumerableExtensions.html",
    "title": "Class ReadOnlyEnumerableExtensions",
    "keywords": "Class ReadOnlyEnumerableExtensions Inheritance Object ReadOnlyEnumerableExtensions Inherited Members Namespace :System.Collections.Generic Assembly :cs.temp.dll.dll Syntax public static class ReadOnlyEnumerableExtensions Methods | Improve this Doc AsReadOnly<T>(IEnumerable<T>) Declaration public static IList<T> AsReadOnly<T>(this IEnumerable<T> range) Parameters Type Name Description IEnumerable <T> range Returns Type Description IList <T> Type Parameters Name Description T"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapter.ConfigurationEntryProcessOrderer.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapter.ConfigurationEntryProcessOrderer.html",
    "title": "Class ConfigurationAdapter.ConfigurationEntryProcessOrderer",
    "keywords": "Class ConfigurationAdapter.ConfigurationEntryProcessOrderer Used by the ConfigurationAdapter class to sort configuration entries for processing. It ensures that Assembly Reference entries are given priority, followed by Namespace Imports, and then finally all the rest. Inheritance Object ConfigurationAdapter.ConfigurationEntryProcessOrderer Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax protected class ConfigurationEntryProcessOrderer : IComparer<IConfigurationEntry> Methods | Improve this Doc Compare(IConfigurationEntry, IConfigurationEntry) Declaration public int Compare(IConfigurationEntry x, IConfigurationEntry y) Parameters Type Name Description IConfigurationEntry x IConfigurationEntry y Returns Type Description Int32 Implements"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapter.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapter.html",
    "title": "Class ConfigurationAdapter",
    "keywords": "Class ConfigurationAdapter Standard implementation of the IConfigurationAdapter interface. Inheritance Object ConfigurationAdapter Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationAdapter : IConfigurationAdapter Constructors | Improve this Doc ConfigurationAdapter(IConfigurationAdapterContextFactory) Creates a new instance of the ConfigurationAdapter class. Declaration public ConfigurationAdapter(IConfigurationAdapterContextFactory contextFactory = null) Parameters Type Name Description IConfigurationAdapterContextFactory contextFactory The factory that is, by default, used to create a new context to be used while transforming an IConfiguration instance. If you pass null, then the DefaultContextFactory will be used. Properties | Improve this Doc ContextFactory Declaration protected IConfigurationAdapterContextFactory ContextFactory { get; } Property Value Type Description IConfigurationAdapterContextFactory | Improve this Doc DefaultContextFactory Gets or sets the default context factory. The uninitialised default is Instance . Note - this can never be a null reference. Declaration public static IConfigurationAdapterContextFactory DefaultContextFactory { get; set; } Property Value Type Description IConfigurationAdapterContextFactory The default context factory. Exceptions Type Condition ArgumentNullException If you try to set the property to null. Methods | Improve this Doc AppendInstructions(ConfigurationAdapterContext) Called to add instructions into the context from the configuration entries in the configuration within the passed context. Declaration protected virtual void AppendInstructions(ConfigurationAdapterContext context) Parameters Type Name Description ConfigurationAdapterContext context The context for this operation - provides access to the configuration whose entries are to be processed, and acts as the target for the processing instructions. | Improve this Doc CreateBuilderInstance(IConfiguration) Called to construct the instance of the ITargetContainer into which registrations are to be loaded. Declaration protected virtual ITargetContainer CreateBuilderInstance(IConfiguration configuration) Parameters Type Name Description IConfiguration configuration The configuration instance for which a builder is to be created. Returns Type Description ITargetContainer Remarks No parsing of the configuration is to be done here (except, perhaps, if the actual implementation of ITargetContainer that is used is dependant upon, say, the type of configuration object. The base behaviour is simply to create an instance of TargetContainer . | Improve this Doc CreateContext(IConfiguration) Creates the context that will be used while the passed configuration is processed. The default implementation forwards this call onto the context factory that was supplied on construction. Declaration protected virtual ConfigurationAdapterContext CreateContext(IConfiguration configuration) Parameters Type Name Description IConfiguration configuration Returns Type Description ConfigurationAdapterContext | Improve this Doc CreateTargetContainer(IConfiguration) Attempts to create an IRezolveTargetContainer instance from the passed configuration object. If the operation succeeds, then a builder will be returned, which you can then use to construct a new Rezolver. If the operation fails, then a ConfigurationException will be thrown. Declaration public virtual ITargetContainer CreateTargetContainer(IConfiguration configuration) Parameters Type Name Description IConfiguration configuration The parsed configuration to be loaded. Returns Type Description ITargetContainer An IRezolveTargetContainer instance ready to be used to construct a new IRezolver. Implements Exceptions Type Condition ConfigurationException If any part of the passed configuration is invalid (e.g. bad type references) or cannot be handled by this adapter (e.g. custom IConfigurationEntry instances or custom IRezolveTargetMetadata instances). | Improve this Doc TransformAssemblyReferenceEntry(IConfigurationEntry, ConfigurationAdapterContext) Transforms an IConfigurationEntry with a Type of AssemblyReference by attempting to convert the entry to an IAssemblyReferenceEntry , and then passing that to the current context as an assembly reference to be added. Declaration protected virtual RezolverBuilderInstruction TransformAssemblyReferenceEntry(IConfigurationEntry entry, ConfigurationAdapterContext context) Parameters Type Name Description IConfigurationEntry entry The entry to be processed. ConfigurationAdapterContext context The context for the operation Returns Type Description RezolverBuilderInstruction The default implementation returns null Remarks The default behaviour of this method is not to return anything - instead the entry is passed to the context to be treated as an Assembly Reference. The function signature still allows the returning of an instruction, however, in case derived classes want to tie this operation to an action being performed on the ITargetContainer later on. | Improve this Doc TransformEntry(IConfigurationEntry, ConfigurationAdapterContext) Called to transform a configuration entry into an instruction that will later be performed on the builder that is constructed by the configuration adapter. Declaration protected virtual RezolverBuilderInstruction TransformEntry(IConfigurationEntry entry, ConfigurationAdapterContext context) Parameters Type Name Description IConfigurationEntry entry The entry to be transformed into an instruction. ConfigurationAdapterContext context The context for the operation. Returns Type Description RezolverBuilderInstruction An instance of RezolverBuilderInstruction if successful, otherwise null. If errors occur, they are added to the context. | Improve this Doc TransformTypeRegistrationEntry(IConfigurationEntry, ConfigurationAdapterContext) Transforms an IConfigurationEntry with a Type of TypeRegistration into a RezolverBuilderInstruction . Declaration protected virtual RezolverBuilderInstruction TransformTypeRegistrationEntry(IConfigurationEntry entry, ConfigurationAdapterContext context) Parameters Type Name Description IConfigurationEntry entry The entry to be transformed. ConfigurationAdapterContext context The context for the operation. Returns Type Description RezolverBuilderInstruction If the entry can be converted into a RezolverBuilderInstruction , then an instance of that type, otherwise null. Remarks The default behaviour is to: Attempt to convert the entry to an ITypeRegistrationEntry Parsing its type references in Types Constructing an ITarget from the entry's TargetMetadata through a call to its CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) method. If that returns a non-null target, then a RegisterInstruction is created and returned."
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContext.UnresolvedType.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContext.UnresolvedType.html",
    "title": "Class ConfigurationAdapterContext.UnresolvedType",
    "keywords": "Class ConfigurationAdapterContext.UnresolvedType Used as a sentinel type by the ResolveType(String, Nullable<Int32>) method when the type search fails. Inheritance Object ConfigurationAdapterContext.UnresolvedType Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax protected class UnresolvedType"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContext.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContext.html",
    "title": "Class ConfigurationAdapterContext",
    "keywords": "Class ConfigurationAdapterContext This class is used to store the intermediate state for the default IConfigurationAdapter implementation's ( ConfigurationAdapter ) parsing operation on an IConfiguration instance. If you are extending the default adapter you might need also to extend this class to ensure any additional state you require is maintained. Inheritance Object ConfigurationAdapterContext Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationAdapterContext Constructors | Improve this Doc ConfigurationAdapterContext(IConfigurationAdapter, IConfiguration, IEnumerable<Assembly>) Constructs a new instance of the ConfigurationAdapterContext class. Declaration public ConfigurationAdapterContext(IConfigurationAdapter adapter, IConfiguration configuration, IEnumerable<Assembly> defaultAssemblyReferences = null) Parameters Type Name Description IConfigurationAdapter adapter The adapter that will create the ITargetContainer from the configuration. IConfiguration configuration Required. The configuration that is being processed by the adapter for which this context is being constructed IEnumerable < Assembly > defaultAssemblyReferences Optional. Default set of assemblies that are to be searched for types when type references are processed. Properties | Improve this Doc Adapter Declaration public IConfigurationAdapter Adapter { get; } Property Value Type Description IConfigurationAdapter | Improve this Doc Configuration Gets the configuration that is being processed by the adapter that is working within this context. Declaration public IConfiguration Configuration { get; } Property Value Type Description IConfiguration The configuration. | Improve this Doc ErrorCount Retrieves the number of errors currently in the Errors enumerable. Declaration public int ErrorCount { get; } Property Value Type Description Int32 | Improve this Doc Errors Retrieves a snapshot of the current errors list. If further errors are added while you are enumerating the enumerable returned by this property, no exception will occur, and the newly added items will not be included. Declaration public IEnumerable<IConfigurationError> Errors { get; } Property Value Type Description IEnumerable < IConfigurationError > | Improve this Doc Instructions Retrieves a snapshot of the instructions currently present in the context. Declaration public IEnumerable<RezolverBuilderInstruction> Instructions { get; } Property Value Type Description IEnumerable < RezolverBuilderInstruction > Methods | Improve this Doc AddAssemblyReference(Assembly) Called to add an assembly reference to this context - the assembly will then be included in the search for types that are not fully qualified. Declaration public void AddAssemblyReference(Assembly assembly) Parameters Type Name Description Assembly assembly Required - the assembly to be added as a reference. | Improve this Doc AddAssemblyReference(IAssemblyReferenceEntry) Adds an assembly reference from an IAssemblyReferenceEntry obtained directly from an IConfiguration instance. The default behaviour is to attempt to load an assembly with the given name and, if found, add that using the overload that accepts an Assembly reference. Declaration public virtual void AddAssemblyReference(IAssemblyReferenceEntry entry) Parameters Type Name Description IAssemblyReferenceEntry entry | Improve this Doc AddAssemblyReferenceBase(Assembly) The core method for adding an assembly reference. The method will never be called (by the base at least) with a null argument. Declaration protected virtual void AddAssemblyReferenceBase(Assembly assembly) Parameters Type Name Description Assembly assembly | Improve this Doc AddAssemblyReferences(IEnumerable<Assembly>) Declaration public virtual void AddAssemblyReferences(IEnumerable<Assembly> assemblies) Parameters Type Name Description IEnumerable < Assembly > assemblies | Improve this Doc AddError(IConfigurationError) Declaration public void AddError(IConfigurationError error) Parameters Type Name Description IConfigurationError error | Improve this Doc AddErrors(IEnumerable<IConfigurationError>) Declaration public void AddErrors(IEnumerable<IConfigurationError> errors) Parameters Type Name Description IEnumerable < IConfigurationError > errors | Improve this Doc AppendInstruction(RezolverBuilderInstruction) Declaration public void AppendInstruction(RezolverBuilderInstruction instruction) Parameters Type Name Description RezolverBuilderInstruction instruction | Improve this Doc GetNamespacePrefixedTypeNames(String) Declaration protected IEnumerable<string> GetNamespacePrefixedTypeNames(string typeName) Parameters Type Name Description String typeName Returns Type Description IEnumerable < String > | Improve this Doc GetReferencedAssemblies() Gets an enumerable of all the assemblies that are referenced by this configuration file. This is used when resolving types. Declaration protected virtual IEnumerable<Assembly> GetReferencedAssemblies() Returns Type Description IEnumerable < Assembly > | Improve this Doc GetUsingNamespaces() Gets an enumerable of strings of all the namespaces (using dotted separators) that are imported for the configuration. This is used, by default, to project a list of type names to search for during type resolution. Declaration protected virtual IEnumerable<string> GetUsingNamespaces() Returns Type Description IEnumerable < String > | Improve this Doc InsertAfter(RezolverBuilderInstruction, RezolverBuilderInstruction) Allows for explicit ordering of instructions Declaration public void InsertAfter(RezolverBuilderInstruction instruction, RezolverBuilderInstruction after) Parameters Type Name Description RezolverBuilderInstruction instruction RezolverBuilderInstruction after | Improve this Doc InsertBefore(RezolverBuilderInstruction, RezolverBuilderInstruction) Allows for explicit ordering of instructions Declaration public void InsertBefore(RezolverBuilderInstruction instruction, RezolverBuilderInstruction before) Parameters Type Name Description RezolverBuilderInstruction instruction RezolverBuilderInstruction before | Improve this Doc InsertRangeAfter(IEnumerable<RezolverBuilderInstruction>, RezolverBuilderInstruction) Declaration public void InsertRangeAfter(IEnumerable<RezolverBuilderInstruction> instructions, RezolverBuilderInstruction after) Parameters Type Name Description IEnumerable < RezolverBuilderInstruction > instructions RezolverBuilderInstruction after | Improve this Doc InsertRangeBefore(IEnumerable<RezolverBuilderInstruction>, RezolverBuilderInstruction) Declaration public void InsertRangeBefore(IEnumerable<RezolverBuilderInstruction> instructions, RezolverBuilderInstruction before) Parameters Type Name Description IEnumerable < RezolverBuilderInstruction > instructions RezolverBuilderInstruction before | Improve this Doc ResolveType(String, Nullable<Int32>) Resolves a particular type name given this context's assembly references and, potentially, any namespace imports. This is designed to be used by a configuration adapter during the process of creating a container builder from a set of configuration entries. Declaration public virtual Type ResolveType(string typeName, int ? genericParameterCount = null) Parameters Type Name Description String typeName The typename Nullable < Int32 > genericParameterCount Used as a hint when multiple versions of the same type exist with open generic parameters and potentially with no generic parameters. Null means that either a generic or non-generic type can match. Zero means that only a non-generic type (or a closed generic type) can match. Any other positive value means that only an open generic type with that exact number of parameters can match. Returns Type Description Type A Type reference if the type is located, otherwise null. Exceptions Type Condition AmbiguousMatchException If more than one type could be matched with the given name, typically due to namespace imports being used and more than type being available which has the same | Improve this Doc TryParseTypeReference(ITypeReference, out Type) Attempts to convert the passed typeReference into a Type . Errors are added to this context's Errors if the method returns false. Declaration public virtual bool TryParseTypeReference(ITypeReference typeReference, out Type type) Parameters Type Name Description ITypeReference typeReference The type reference. Type type The type that is identified, if successful. Returns Type Description Boolean true if the type reference is successfully parsed, false otherwise (with errors being added to the Errors collection). | Improve this Doc TryParseTypeReferences(IEnumerable<ITypeReference>, out Type[]) Tries to parse all type references, returning an overall success flag, with successfully parsed types being added to a list that is returned in the types output parameter. Declaration public bool TryParseTypeReferences(IEnumerable<ITypeReference> typeReferences, out Type[] types) Parameters Type Name Description IEnumerable < ITypeReference > typeReferences The type references. Type [] types Receives the types that are parsed. Note that if the method returns true, then this list will contain the same number of types as there are references in typeReferences , in the same order. If the method returns false, however, then the number of results in this list is undefined and you will not be able to marry up the input type reference to its output type. Returns Type Description Boolean true if all type references could be parsed, otherwise false ."
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContextFactory.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationAdapterContextFactory.html",
    "title": "Class ConfigurationAdapterContextFactory",
    "keywords": "Class ConfigurationAdapterContextFactory The standard Singleton implementation of the IConfigurationAdapterContextFactory interface, and one which you can use as the starting point of your own factory. By default, it creates a new instance of the ConfigurationAdapterContext class (using the virtual method CreateContext(ConfigurationAdapter, IConfiguration) , and then instructs it to add its default assembly references. Inheritance Object ConfigurationAdapterContextFactory Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationAdapterContextFactory : IConfigurationAdapterContextFactory Constructors | Improve this Doc ConfigurationAdapterContextFactory() Creation of new instances of this class, outside of the Instance instance, is only through inheritance. Declaration protected ConfigurationAdapterContextFactory() Properties | Improve this Doc Instance The one and only instance of this context factory. Note that this is also the default application-wide context factory that is used by the standard ConfigurationAdapter class when converting configuration data into rezolvers (by virtue of the DefaultContextFactory property, which you can change). Declaration public static ConfigurationAdapterContextFactory Instance { get; } Property Value Type Description ConfigurationAdapterContextFactory Methods | Improve this Doc CreateContext(ConfigurationAdapter, IConfiguration) Implements the IConfigurationAdapterContextFactory method of the same name. The base behaviour is to create an instance of the ConfigurationAdapterContext class, passing the configuration and the default set of assembly references returned by GetDefaultAssemblyReferences() . Declaration public virtual ConfigurationAdapterContext CreateContext(ConfigurationAdapter adapter, IConfiguration configuration) Parameters Type Name Description ConfigurationAdapter adapter The adapter. IConfiguration configuration The configuration. Returns Type Description ConfigurationAdapterContext Implements | Improve this Doc GetDefaultAssemblyReferences() Gets the assemblies that are to be used for new contexts as the default set of references. The base behaviour is to add mscorlib, System and System.Core although, depending on the target platform, the list might be less. Declaration protected virtual IEnumerable<Assembly> GetDefaultAssemblyReferences() Returns Type Description IEnumerable < Assembly >"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationEntryBase.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationEntryBase.html",
    "title": "Class ConfigurationEntryBase",
    "keywords": "Class ConfigurationEntryBase suggested starting point for implementing your own configuration entries. Inheritance Object ConfigurationEntryBase Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationEntryBase : IConfigurationEntry, IConfigurationLineInfo Constructors | Improve this Doc ConfigurationEntryBase(ConfigurationEntryType, IConfigurationLineInfo) Declaration protected ConfigurationEntryBase(ConfigurationEntryType type, IConfigurationLineInfo lineInfo) Parameters Type Name Description ConfigurationEntryType type IConfigurationLineInfo lineInfo Properties | Improve this Doc EndLineNo Declaration public int ? EndLineNo { get; } Property Value Type Description Nullable < Int32 > Implements | Improve this Doc EndLinePos Declaration public int ? EndLinePos { get; } Property Value Type Description Nullable < Int32 > Implements | Improve this Doc StartLineNo Declaration public int ? StartLineNo { get; } Property Value Type Description Nullable < Int32 > Implements | Improve this Doc StartLinePos Declaration public int ? StartLinePos { get; } Property Value Type Description Nullable < Int32 > Implements | Improve this Doc Type Declaration public ConfigurationEntryType Type { get; } Property Value Type Description ConfigurationEntryType Implements"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationEntryType.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationEntryType.html",
    "title": "Enum ConfigurationEntryType",
    "keywords": "Enum ConfigurationEntryType Types of configuration entry that can be parsed from a configuration file Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public enum ConfigurationEntryType Fields Name Description AssemblyReference An instruction to load one or more assemblies before any type registrations are processed Depending on the runtime environment, to be sure of the type binder finding namespace-qualified types mentioned in a configuration file, then any assemblies you might be referencing should be included in your configuration file. Equally, you can use this to load assemblies that wouldn't normally be found (e.g. a la unity) Note that types which would usually be found with a simple call to Type.GetType do not need their parent assemblies explicitly referenced. Extension A custom entry - the instance should also have the interface IConfigurationExtensionEntry NamedBuilder An instruction to create a named builder in the target builder, within which further named builders or type registrations might be performed. NamespaceImport Just like 'using' or 'import' in C# or VB, this allows you to specify namespaces that you will be using in your type names elsewhere in a configuration file. TypeRegistration The most common type - an instruction to generate one or more type registrations in the target builder Unknown"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationError.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationError.html",
    "title": "Class ConfigurationError",
    "keywords": "Class ConfigurationError Inheritance Object ConfigurationError Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationError : IConfigurationError Constructors | Improve this Doc ConfigurationError(Exception, IConfigurationLineInfo) Declaration public ConfigurationError(Exception exception, IConfigurationLineInfo lineInfo) Parameters Type Name Description Exception exception IConfigurationLineInfo lineInfo | Improve this Doc ConfigurationError(String, IConfigurationLineInfo) Declaration public ConfigurationError(string errorMessage, IConfigurationLineInfo lineInfo) Parameters Type Name Description String errorMessage IConfigurationLineInfo lineInfo Properties | Improve this Doc ErrorMessage Declaration public string ErrorMessage { get; } Property Value Type Description String Implements | Improve this Doc ErrorMessageWithLineInfo Declaration public string ErrorMessageWithLineInfo { get; } Property Value Type Description String Implements | Improve this Doc Exception Declaration public Exception Exception { get; } Property Value Type Description Exception | Improve this Doc IsException Declaration public bool IsException { get; } Property Value Type Description Boolean | Improve this Doc LineInfo Declaration public IConfigurationLineInfo LineInfo { get; } Property Value Type Description IConfigurationLineInfo Implements Methods | Improve this Doc UnexpectedMetadataType(RezolveTargetMetadataType, Type, Type, IConfigurationLineInfo) Declaration public static ConfigurationError UnexpectedMetadataType(RezolveTargetMetadataType type, Type expected, Type actual, IConfigurationLineInfo lineInfo) Parameters Type Name Description RezolveTargetMetadataType type Type expected Type actual IConfigurationLineInfo lineInfo Returns Type Description ConfigurationError | Improve this Doc UnresolvedType(ITypeReference) Declaration public static ConfigurationError UnresolvedType(ITypeReference typeReference) Parameters Type Name Description ITypeReference typeReference Returns Type Description ConfigurationError | Improve this Doc UnresolvedType(String, IConfigurationLineInfo) Declaration public static ConfigurationError UnresolvedType(string typeName, IConfigurationLineInfo lineInfo) Parameters Type Name Description String typeName IConfigurationLineInfo lineInfo Returns Type Description ConfigurationError"
  },
  "rezolver-api/Rezolver.Configuration.ConfigurationException.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConfigurationException.html",
    "title": "Class ConfigurationException",
    "keywords": "Class ConfigurationException Inheritance Object Exception ConfigurationException Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConfigurationException : Exception, ISerializable, _Exception Constructors | Improve this Doc ConfigurationException(ConfigurationAdapterContext) Declaration public ConfigurationException(ConfigurationAdapterContext context) Parameters Type Name Description ConfigurationAdapterContext context | Improve this Doc ConfigurationException(IConfiguration, IEnumerable<IConfigurationError>) Declaration public ConfigurationException(IConfiguration configuration, IEnumerable<IConfigurationError> errors) Parameters Type Name Description IConfiguration configuration IEnumerable < IConfigurationError > errors Properties | Improve this Doc Message Declaration public override string Message { get; } Property Value Type Description String Overrides"
  },
  "rezolver-api/Rezolver.Configuration.ConstructorTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.ConstructorTargetMetadata.html",
    "title": "Class ConstructorTargetMetadata",
    "keywords": "Class ConstructorTargetMetadata Inheritance Object RezolveTargetMetadataBase ConstructorTargetMetadata Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ConstructorTargetMetadata : RezolveTargetMetadataBase, IConstructorTargetMetadata, IRezolveTargetMetadata Constructors | Improve this Doc ConstructorTargetMetadata(ITypeReference[], ITypeReference[], IDictionary<String, IRezolveTargetMetadata>) Constructs a new instance of the ConstructorTargetMetadata class. Declaration public ConstructorTargetMetadata(ITypeReference[] typesToBuild, ITypeReference[] signatureTypes = null, IDictionary<string, IRezolveTargetMetadata> args = null) Parameters Type Name Description ITypeReference [] typesToBuild The types to build. ITypeReference [] signatureTypes The types of the parameters for the constructor that is to be bound. If null, then the constructor is to be sought by finding the best match based on the arguments (if provided). This is typically required if you have an ambiguity when matching purely by name. IDictionary < String , IRezolveTargetMetadata > args The arguments. Remarks Please note that although the typesToBuild parameter is an array, in practise only one type can ever be built. Multiple types are accepted to cover scenarios where a class, its bases and zero or more interfaces are all referenced as target registration types, and these types are passed directly to the constructor target. In building such a target from the metadata an adapter will typically find the most derived type of the group and bind to that only. Note that if one or more types are not related to the rest of the group, then an adapter is free to throw a runtime error. Exceptions Type Condition ArgumentNullException typesToBuild ArgumentException The array cannot be empty;typesToBuild or All entries in the array must be non-null;typesToBuild Properties | Improve this Doc Arguments Declaration public IDictionary<string, IRezolveTargetMetadata> Arguments { get; } Property Value Type Description IDictionary < String , IRezolveTargetMetadata > Implements | Improve this Doc DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides Implements | Improve this Doc SignatureTypes Declaration public ITypeReference[] SignatureTypes { get; } Property Value Type Description ITypeReference [] Implements | Improve this Doc TypesToBuild Remember - the intention is that only one of these types will actually be bound on constructing the constructor target. Declaration public ITypeReference[] TypesToBuild { get; } Property Value Type Description ITypeReference [] Implements Methods | Improve this Doc BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Type Name Description ITypeReference [] targetTypes Returns Type Description IRezolveTargetMetadata Overrides | Improve this Doc CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Type Name Description Type [] targetTypes ConfigurationAdapterContext context IConfigurationEntry entry Returns Type Description ITarget Overrides"
  },
  "rezolver-api/Rezolver.Configuration.IAssemblyReferenceEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.IAssemblyReferenceEntry.html",
    "title": "Interface IAssemblyReferenceEntry",
    "keywords": "Interface IAssemblyReferenceEntry A configuration entry instructing the configuration adapter to load an assembly before resolving types. Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IAssemblyReferenceEntry : IConfigurationEntry, IConfigurationLineInfo Properties | Improve this Doc AssemblyName Declaration string AssemblyName { get; } Property Value Type Description String"
  },
  "rezolver-api/Rezolver.Configuration.IConfiguration.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfiguration.html",
    "title": "Interface IConfiguration",
    "keywords": "Interface IConfiguration Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfiguration Properties | Improve this Doc Entries Declaration IEnumerable<IConfigurationEntry> Entries { get; } Property Value Type Description IEnumerable < IConfigurationEntry > | Improve this Doc FileName Declaration string FileName { get; } Property Value Type Description String"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationAdapter.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationAdapter.html",
    "title": "Interface IConfigurationAdapter",
    "keywords": "Interface IConfigurationAdapter Represents an object that is responsible for transforming configuration data into target containers. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationAdapter Methods | Improve this Doc CreateTargetContainer(IConfiguration) Creates an ITargetContainer instance from an IConfiguration instance. Declaration ITargetContainer CreateTargetContainer(IConfiguration configuration) Parameters Type Name Description IConfiguration configuration Required - the configuration object that is to be used to build a container. Returns Type Description ITargetContainer"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationAdapterContextFactory.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationAdapterContextFactory.html",
    "title": "Interface IConfigurationAdapterContextFactory",
    "keywords": "Interface IConfigurationAdapterContextFactory Used by this library's default implementation of IConfigurationAdapter, the ConfigurationAdapter class, to create an instance of the ConfigurationAdapterContext class for a given adapter that's processing a given configuration. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationAdapterContextFactory Methods | Improve this Doc CreateContext(ConfigurationAdapter, IConfiguration) Declaration ConfigurationAdapterContext CreateContext(ConfigurationAdapter adapter, IConfiguration configuration) Parameters Type Name Description ConfigurationAdapter adapter IConfiguration configuration Returns Type Description ConfigurationAdapterContext"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationEntry.html",
    "title": "Interface IConfigurationEntry",
    "keywords": "Interface IConfigurationEntry Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationEntry : IConfigurationLineInfo Properties | Improve this Doc Type Declaration ConfigurationEntryType Type { get; } Property Value Type Description ConfigurationEntryType"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationError.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationError.html",
    "title": "Interface IConfigurationError",
    "keywords": "Interface IConfigurationError Interface for an error that originates from a configuration file. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationError Properties | Improve this Doc ErrorMessage The message Declaration string ErrorMessage { get; } Property Value Type Description String | Improve this Doc ErrorMessageWithLineInfo The message formatted with the start/end line and position for more accurate error reporting. Declaration string ErrorMessageWithLineInfo { get; } Property Value Type Description String | Improve this Doc LineInfo Start and (potentially) end position within the configuration file where this error originates. Declaration IConfigurationLineInfo LineInfo { get; } Property Value Type Description IConfigurationLineInfo"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationExtensionEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationExtensionEntry.html",
    "title": "Interface IConfigurationExtensionEntry",
    "keywords": "Interface IConfigurationExtensionEntry Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationExtensionEntry : IConfigurationEntry, IConfigurationLineInfo Properties | Improve this Doc ExtensionType Declaration string ExtensionType { get; } Property Value Type Description String"
  },
  "rezolver-api/Rezolver.Configuration.IConfigurationLineInfo.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConfigurationLineInfo.html",
    "title": "Interface IConfigurationLineInfo",
    "keywords": "Interface IConfigurationLineInfo Encapsulates information about where a particular object, parsed from a configuration file, can be found. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConfigurationLineInfo Properties | Improve this Doc EndLineNo Gets the line number within the configuration source that sees the end of the text from which this object was parsed. Used in conjunction with EndLinePos , it allows you to zero-in on the exact ending of this parsed object. Declaration int ? EndLineNo { get; } Property Value Type Description Nullable < Int32 > The end line number. | Improve this Doc EndLinePos Gets the position from the start of the line, indicated by EndLineNo , where the configuration text ends for this parsed object. Declaration int ? EndLinePos { get; } Property Value Type Description Nullable < Int32 > | Improve this Doc StartLineNo Gets the line number within the configuration source that contains the start of the text from which this object was parsed. Used in conjunction with StartLinePos , it allows you to zero-in on the exact starting point of this parsed object. Declaration int ? StartLineNo { get; } Property Value Type Description Nullable < Int32 > The start line number. | Improve this Doc StartLinePos Gets the position from the start of the line, indicated by StartLineNo , where the configuration text begins for this parsed object. Declaration int ? StartLinePos { get; } Property Value Type Description Nullable < Int32 > The start line position."
  },
  "rezolver-api/Rezolver.Configuration.IConstructorTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.IConstructorTargetMetadata.html",
    "title": "Interface IConstructorTargetMetadata",
    "keywords": "Interface IConstructorTargetMetadata Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IConstructorTargetMetadata : IRezolveTargetMetadata Properties | Improve this Doc Arguments Gets a dictionary of arguments that are to be supplied to the object's constructor Declaration IDictionary<string, IRezolveTargetMetadata> Arguments { get; } Property Value Type Description IDictionary < String , IRezolveTargetMetadata > The arguments. | Improve this Doc SignatureTypes Gets the types of the parameters for the specific constructor that is to be bound. Not required, and is mostly used when a suitable constructor cannot be found purely by matching parameter names and types to the Arguments . A common issue here being that some metadata types can build any type, therefore two constructors with identically named parameters that have different types could be matched by the same target metadata. If null, then no signature is specified. Declaration ITypeReference[] SignatureTypes { get; } Property Value Type Description ITypeReference [] The signature types. | Improve this Doc TypesToBuild One of these types will be selected to have its constructor bound. The rule is that multiple types passed here must represent types that all appear in an inheritance chain or interface list, and there must be one unambiguous most-derived type which will be the one whose constructor will be executed when an object is later dished out from the IRezolveTarget instance that is built from this metadata. Declaration ITypeReference[] TypesToBuild { get; } Property Value Type Description ITypeReference []"
  },
  "rezolver-api/Rezolver.Configuration.IListTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.IListTargetMetadata.html",
    "title": "Interface IListTargetMetadata",
    "keywords": "Interface IListTargetMetadata Configuration metadata for building a ListTarget in a RezolverBuilder. Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IListTargetMetadata : IRezolveTargetMetadata Properties | Improve this Doc ElementType Gets the declared element type of the array or list that will be created from this metadata. Declaration ITypeReference ElementType { get; } Property Value Type Description ITypeReference The type of the element. | Improve this Doc IsArray Maps to the AsArray property. If true, then an array of ElementType will be created, otherwise a List< ElementType > will be created by the ListTarget created from this metadata. Declaration bool IsArray { get; } Property Value Type Description Boolean true if this instance represents a ListTarget that will create an array; otherwise, false . | Improve this Doc Items Gets the metadata for the targets that will be used for the items that'll be returned in the Array or List that will be created by the ListTarget created from this metadata. Declaration IRezolveTargetMetadataList Items { get; } Property Value Type Description IRezolveTargetMetadataList The elements."
  },
  "rezolver-api/Rezolver.Configuration.IObjectTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.IObjectTargetMetadata.html",
    "title": "Interface IObjectTargetMetadata",
    "keywords": "Interface IObjectTargetMetadata Interface for metadata for constructing an ObjectTarget IRezolveTarget. Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IObjectTargetMetadata : IRezolveTargetMetadata Methods | Improve this Doc GetObject(Type) Called to get the object that will be registered in the IRezolveTargetContainer to be returned when a caller requests one of its registered types. The method can construct an object anew everytime it is called, or it can always return the same instance; this behaviour is implementation-dependant. Declaration object GetObject(Type type) Parameters Type Name Description Type type The type of object that is desired. The implementation determines whether this parameter is required. If it is, and you pass null, then an ArgumentNullException will be thrown. If you pass an argument, the implementation is not bound to check or honour the type. Its purpose is to provide a hint only, not a guarantee that the object returned is compatible with the type. Returns Type Description Object An object. Note - if the operation returns null this is not an error."
  },
  "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadata.html",
    "title": "Interface IRezolveTargetMetadata",
    "keywords": "Interface IRezolveTargetMetadata Represents an instruction to create an IRezolveTarget from parsed configuration. Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IRezolveTargetMetadata Properties | Improve this Doc DeclaredType Gets the declared type of the object that will be created by an IRezolveTarget created by this metadata. Note - this isn't always known, or always fixed, since configuration systems will allow developers to avoid being specific about the types that are to be built. Declaration ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference The type of the declared. | Improve this Doc Type The type of rezolve target that is expected to be produced from this metadata Declaration RezolveTargetMetadataType Type { get; } Property Value Type Description RezolveTargetMetadataType Methods | Improve this Doc Bind(ITypeReference[]) Creates a new instance of this metadata (i.e. a clone) that is bound to the specified target types. This is invoked if DeclaredType represents the Unbound type reference. Declaration IRezolveTargetMetadata Bind(params ITypeReference[] targetTypes) Parameters Type Name Description ITypeReference [] targetTypes The target types. Ideally there'd only be one of these, but since type registrations can target multiple types - we need to be able to pass all of them. An implementation should seek the best possible type from the array, although in practise - given that there's no ConfigurationAdapterContext to aid in the parsing of the type names, the first type in the array is typically fine to use. Returns Type Description IRezolveTargetMetadata IRezolveTargetMetadata. | Improve this Doc CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Creates the rezolve target, optionally customised for the given target type(s), based on the given context. If the entry is passed, then it indicates the configuration entry for which the targets are being built. Declaration ITarget CreateRezolveTarget(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry = null) Parameters Type Name Description Type [] targetTypes Required. One or more target types that the returned target is expected to be compatible with (i.e. able to build an instance of). Generally, this will be the target types for the configuration entry that is passed in entry . ConfigurationAdapterContext context The current context - provides access to the builder currently being constructed, as well as methods for resolving type names from ITypeReference instances or strings (and more). IConfigurationEntry entry If provided, this is a reference to the configuration entry (typically an ITypeRegistrationEntry ) against which this target will be registered. Please note - this doesn't mean that the target that is returned will become the target of the registration. It might be that the target is one that is used by a parent target that will become the target of the registration. Returns Type Description ITarget"
  },
  "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadataExtension.html": {
    "href": "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadataExtension.html",
    "title": "Interface IRezolveTargetMetadataExtension",
    "keywords": "Interface IRezolveTargetMetadataExtension Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IRezolveTargetMetadataExtension : IRezolveTargetMetadata Properties | Improve this Doc ExtensionType Declaration string ExtensionType { get; } Property Value Type Description String"
  },
  "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadataList.html": {
    "href": "rezolver-api/Rezolver.Configuration.IRezolveTargetMetadataList.html",
    "title": "Interface IRezolveTargetMetadataList",
    "keywords": "Interface IRezolveTargetMetadataList Represents a list of IRezolveTargetMetadata instances - for when you want to register multiple targets against a single type. Note - although the interface IRezolveTargetMetadata is included by this interface, instances are not expected to be able to create a single target through the CreateRezolveTarget method - because by definition, multiple targets are produced by this. Use the CreateRezolveTargets method instead. The Bind method, however, will be expected to produce a new instance of the implementing type if any underlying targets are not bound to a specific type. Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface IRezolveTargetMetadataList : IRezolveTargetMetadata Properties | Improve this Doc Targets Gets the list of targets that will be used to construct the array. Note - a list is used to allow for modification of the targets after initial creation. Declaration IList<IRezolveTargetMetadata> Targets { get; } Property Value Type Description IList < IRezolveTargetMetadata > The targets. Methods | Improve this Doc CreateRezolveTargets(Type[], ConfigurationAdapterContext, IConfigurationEntry) Replacement for IRezolveTargetMetadata for this interface. Creates the rezolve target, potentially customised for the given target type(s), based on the given context. If the entry is passed, then it indicates the configuration entry for which the targets are being built. Declaration IEnumerable<ITarget> CreateRezolveTargets(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Type Name Description Type [] targetTypes The target types for each of the returned target, generally, this will be the ultimate target types for the configuration entry that is passed in entry . An implementation is not bound to use these types at all, but it helps provide additional context that might be of use when generating the rezolve target. ConfigurationAdapterContext context The context. IConfigurationEntry entry If provided, this is a reference to the configuration entry for which this target is being built. Returns Type Description IEnumerable < ITarget >"
  },
  "rezolver-api/Rezolver.Configuration.ISingletonTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.ISingletonTargetMetadata.html",
    "title": "Interface ISingletonTargetMetadata",
    "keywords": "Interface ISingletonTargetMetadata Interface for Singleton metadata. Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface ISingletonTargetMetadata : IRezolveTargetMetadata Properties | Improve this Doc Inner Metadata representing the inner target for the singleton Declaration IRezolveTargetMetadata Inner { get; } Property Value Type Description IRezolveTargetMetadata | Improve this Doc Scoped If true, then the created singleton target should be a scoped singleton; i.e. with a lifetime tied to the lifetime of a parent ILifetimeScopeRezolver, not the whole application. Declaration bool Scoped { get; } Property Value Type Description Boolean"
  },
  "rezolver-api/Rezolver.Configuration.ITypeReference.html": {
    "href": "rezolver-api/Rezolver.Configuration.ITypeReference.html",
    "title": "Interface ITypeReference",
    "keywords": "Interface ITypeReference Captures a reference to a type made in a configuration file. It does not guarantee that the type can be located, it simply provides a common interface for storing the type information written in a configuration file. An IConfigurationAdapter instance will need to resolve the actual runtime type from this when registering targets from a configuration file. Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface ITypeReference : IConfigurationLineInfo Properties | Improve this Doc GenericArguments Any explicitly provided generic arguments are stored here. Note that it might turn out that the TypeName refers to a whole closed generic type, in which case the referenced type could still be generic even if this array is empty. It's also the case that arguments could be passed here when the root type name resolves to a non-generic type definition, in which case type resolution will likely fail. Declaration ITypeReference[] GenericArguments { get; } Property Value Type Description ITypeReference [] | Improve this Doc IsArray Gets a value indicating whether the type ultimately represented by this instance is an array of the type described by the rest of this instance's properties. Declaration bool IsArray { get; } Property Value Type Description Boolean true if this instance represents an array type; otherwise, false . | Improve this Doc IsOpenGenericTypeArgument True if this type represents an open generic argument - this is how to explicitly reference an open generic type in a type reference: you specify a base type, then have one or more open generic arguments specified in the GenericArguments array. If all are open generic arguments, then you have created a reference to the fully open generic type. You only need to provide all-open arguments if the base TypeName could be ambiguous between a non generic and generic type, or there are multiple generic types with the same base name. Equally, you can do this to create references to partially open generics, which may or may not be supported by the adapter or the target that is built. Declaration bool IsOpenGenericTypeArgument { get; } Property Value Type Description Boolean | Improve this Doc IsUnbound Gets a value indicating whether this instance represents a type that is to be late-bound for a specific target type. Declaration bool IsUnbound { get; } Property Value Type Description Boolean true if this instance is unbound; otherwise, false . | Improve this Doc TypeName The root type name. Declaration string TypeName { get; } Property Value Type Description String"
  },
  "rezolver-api/Rezolver.Configuration.ITypeRegistrationEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.ITypeRegistrationEntry.html",
    "title": "Interface ITypeRegistrationEntry",
    "keywords": "Interface ITypeRegistrationEntry Represents an instruction to register one or more targets in an ITargetContainer against one or more types. Think of it as wrapping a single call to one of the builder's Register methods. Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public interface ITypeRegistrationEntry : IConfigurationEntry, IConfigurationLineInfo Properties | Improve this Doc IsMultipleRegistration Gets a value indicating whether this instance represents a multiple registration - i.e. that when one of the Types are resolved, it's expected that an enumerable of that type will be requested, returning one or more items rather than just one. Maps to the method call. Declaration bool IsMultipleRegistration { get; } Property Value Type Description Boolean true if this instance is multiple registration; otherwise, false . | Improve this Doc TargetMetadata Metadata for the target(s) that is/are to be registered. Declaration IRezolveTargetMetadata TargetMetadata { get; } Property Value Type Description IRezolveTargetMetadata | Improve this Doc Types The types for which the registration is to be made in the ITargetContainer that the entry is applied to. Declaration ITypeReference[] Types { get; } Property Value Type Description ITypeReference []"
  },
  "rezolver-api/Rezolver.Configuration.Json.AdvancedConfigurationAdapterContextFactory.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.AdvancedConfigurationAdapterContextFactory.html",
    "title": "Class AdvancedConfigurationAdapterContextFactory",
    "keywords": "Class AdvancedConfigurationAdapterContextFactory An advanced factory which automatically loads and references all assemblies that are deployed in the application's base directory and any subfolders determined by the AppDomain 's SetupInformation's PrivateBinBath. This is a singleton - accessed through the Instance property. Inheritance Object ConfigurationAdapterContextFactory AdvancedConfigurationAdapterContextFactory Inherited Members Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class AdvancedConfigurationAdapterContextFactory : ConfigurationAdapterContextFactory, IConfigurationAdapterContextFactory Remarks The ConfigurationAdapterContextFactory has a very limited set of default assembly references, because it's a portable class, the AppDomain introspection APIs are not available. As a result, to simplify type references in a configuration file loaded in a portable environment, you need to add assembly references manually. This class, on the other hand, is targeted at environments where these APIs are available, and should effectively remove the need to add any references at all, meaning a configuration file can use shorter type names. Constructors | Improve this Doc AdvancedConfigurationAdapterContextFactory() Initializes a new instance of the AdvancedConfigurationAdapterContextFactory class. Class is creatable only through inheritance. Declaration protected AdvancedConfigurationAdapterContextFactory() Properties | Improve this Doc Instance Gets the one and only instance of the AdvancedConfigurationAdapterContextFactory . Declaration public static IConfigurationAdapterContextFactory Instance { get; } Property Value Type Description IConfigurationAdapterContextFactory The instance. Methods | Improve this Doc GetDefaultAssemblyReferences() Gets the assemblies that are to be used for new contexts as the default set of references. This override gets all the assemblies that are deployed with the application. Note that this has the effect of pre-loading all those assemblies. Declaration protected override IEnumerable<Assembly> GetDefaultAssemblyReferences() Returns Type Description IEnumerable < System.Reflection.Assembly > IEnumerable<System.Reflection.Assembly>. Overrides"
  },
  "rezolver-api/Rezolver.Configuration.Json.ConfigurationEntryConverter.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.ConfigurationEntryConverter.html",
    "title": "Class ConfigurationEntryConverter",
    "keywords": "Class ConfigurationEntryConverter JSON converter for IConfigurationEntry The converter defaults to looking for type registrations; to enable it to look for a different entry type, you must instruct Json.Net to create an instance of it using the constructor that accepts a ConfigurationEntryType Inheritance Object ConfigurationEntryConverter Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class ConfigurationEntryConverter : JsonConverter Constructors | Improve this Doc ConfigurationEntryConverter() Declaration public ConfigurationEntryConverter() | Improve this Doc ConfigurationEntryConverter(ConfigurationEntryType) Declaration public ConfigurationEntryConverter(ConfigurationEntryType expectedType) Parameters Type Name Description ConfigurationEntryType expectedType Properties | Improve this Doc CanWrite Declaration public override bool CanWrite { get; } Property Value Type Description Boolean Methods | Improve this Doc CanConvert(Type) Declaration public override bool CanConvert(Type objectType) Parameters Type Name Description Type objectType Returns Type Description Boolean | Improve this Doc ReadJson(JsonReader, Type, Object, JsonSerializer) Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Type Name Description JsonReader reader Type objectType Object existingValue JsonSerializer serializer Returns Type Description Object | Improve this Doc WriteJson(JsonWriter, Object, JsonSerializer) Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Type Name Description JsonWriter writer Object value JsonSerializer serializer"
  },
  "rezolver-api/Rezolver.Configuration.Json.JsonConfiguration.JsonConfigurationConverter.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.JsonConfiguration.JsonConfigurationConverter.html",
    "title": "Class JsonConfiguration.JsonConfigurationConverter",
    "keywords": "Class JsonConfiguration.JsonConfigurationConverter Class for loading JsonConfiguration from Json through Json.Net. Inheritance Object JsonConfiguration.JsonConfigurationConverter Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class JsonConfigurationConverter : JsonConverter Properties | Improve this Doc CanWrite Gets a value indicating whether this Newtonsoft.Json.JsonConverter can write JSON. Declaration public override bool CanWrite { get; } Property Value Type Description Boolean true if this Newtonsoft.Json.JsonConverter can write JSON; otherwise, false . Methods | Improve this Doc CanConvert(Type) Determines whether this instance can convert the specified object type. Declaration public override bool CanConvert(Type objectType) Parameters Type Name Description Type objectType Type of the object. Returns Type Description Boolean true if this instance can convert the specified object type; otherwise, false . | Improve this Doc ReadJson(JsonReader, Type, Object, JsonSerializer) Reads the JSON representation of the object. Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Type Name Description JsonReader reader The Newtonsoft.Json.JsonReader to read from. Type objectType Type of the object. Object existingValue The existing value of object being read. JsonSerializer serializer The calling serializer. Returns Type Description Object The object value. | Improve this Doc WriteJson(JsonWriter, Object, JsonSerializer) Writes the JSON representation of the object. Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Type Name Description JsonWriter writer The Newtonsoft.Json.JsonWriter to write to. Object value The value. JsonSerializer serializer The calling serializer. Exceptions Type Condition NotImplementedException"
  },
  "rezolver-api/Rezolver.Configuration.Json.JsonConfiguration.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.JsonConfiguration.html",
    "title": "Class JsonConfiguration",
    "keywords": "Class JsonConfiguration Class JsonConfiguration. Inheritance Object JsonConfiguration Inherited Members Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class JsonConfiguration : IConfiguration Fields | Improve this Doc UnboundType The typename to use on a type entry when you want to register a constructor target directly for the type that is registered. E.g. { 'MyNamespace.Foo' : { 'type' : \"$auto' } } Which registers MyNamespace.Foo with a constructor target that binds to the same type. Is also used - where supported - to refer to a type from a parent object which you want to reference, but without having to specify the whole typename. Declaration public const string UnboundType = \"$auto\" Field Value Type Description String Properties | Improve this Doc Entries Gets the entries. Declaration public IEnumerable<IConfigurationEntry> Entries { get; } Property Value Type Description IEnumerable < IConfigurationEntry > The entries. Implements | Improve this Doc FileName Gets the name of the file. Declaration public string FileName { get; } Property Value Type Description String The name of the file. Implements"
  },
  "rezolver-api/Rezolver.DecoratorTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.DecoratorTargetContainerExtensions.html",
    "title": "Class DecoratorTargetContainerExtensions",
    "keywords": "Class DecoratorTargetContainerExtensions Extensions for ITargetContainerOwner which simplify the registration of decorators (via the DecoratingTargetContainer pseudo-target) Inheritance Object DecoratorTargetContainerExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class DecoratorTargetContainerExtensions Remarks Note: The decoration functionality provided by the framework is only possible on ITargetContainer implementations which also implement the ITargetContainerOwner interface. All the main target container types you'll use in your application ( TargetContainer and ChildTargetContainer ) do support this interface. Methods | Improve this Doc RegisterDecorator(ITargetContainerOwner, Type, Type) Registers a decorator container which will cause all instances of decoratedType to be decorated with the type decoratorType . Any existing registrations for decoratedType will be decorated correctly, and subsequent registrations of decoratedType will also be decorated as expected. Declaration public static void RegisterDecorator(this ITargetContainerOwner targetContainerOwner, Type decoratorType, Type decoratedType) Parameters Type Name Description ITargetContainerOwner targetContainerOwner The container into which the decorator will be registered. Type decoratorType The type to be used as the decorator implementation Type decoratedType The type which will be decorated by decoratorType . | Improve this Doc RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) Registers a decorator container which will cause all instances of TDecorated to be decorated with the type TDecorator . Any existing registrations for TDecorated will be decorated correctly, and subsequent registrations of TDecorated will also be decorated as expected. Declaration public static void RegisterDecorator<TDecorator, TDecorated>(this ITargetContainerOwner targetContainerOwner) Parameters Type Name Description ITargetContainerOwner targetContainerOwner The container into which the decorator will be registered. Type Parameters Name Description TDecorator The type to be used as the decorator implementation TDecorated The type which will be decorated by TDecorator ."
  },
  "rezolver-api/Rezolver.DefaultMemberBindingBehaviour.html": {
    "href": "rezolver-api/Rezolver.DefaultMemberBindingBehaviour.html",
    "title": "Class DefaultMemberBindingBehaviour",
    "keywords": "Class DefaultMemberBindingBehaviour The default implementation of IMemberBindingBehaviour when you are creating a or and you want publicly writable properties and public fields to be assigned values obtained from the container. If you do not require properties or fields to be bound from the container, then use a null IMemberBindingBehaviour . Inheritance Object DefaultMemberBindingBehaviour Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DefaultMemberBindingBehaviour : IMemberBindingBehaviour Remarks This is a stateless singleton accessible through the Instance static property. The class also serves as a good starting point for any custom binding behaviours you might need - as there are numerous virtual methods which allow you to change which fields and/or properties are selected for binding, as well as how those bindings are created. The default behaviour is bind each member to a new whose is set to the member's type. Constructors | Improve this Doc DefaultMemberBindingBehaviour() Constructs a new instance of the DefaultMemberBindingBehaviour class. Declaration protected DefaultMemberBindingBehaviour() Properties | Improve this Doc Instance Gets the one and only instance of DefaultMemberBindingBehaviour Declaration public static DefaultMemberBindingBehaviour Instance { get; } Property Value Type Description DefaultMemberBindingBehaviour Methods | Improve this Doc BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) Called by GetMemberBindings(ICompileContext, Type) - iterates through the fields , calling CreateBinding(ICompileContext, Type, FieldInfo) for each, and those which are non-null. Declaration protected virtual IEnumerable<MemberBinding> BindFields(ICompileContext context, Type type, IEnumerable<FieldInfo> fields) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. IEnumerable < FieldInfo > fields The fields for which bindings are to be created. This is fed by the function GetBindableFields(ICompileContext, Type) Returns Type Description IEnumerable < MemberBinding > | Improve this Doc BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) Called by GetMemberBindings(ICompileContext, Type) - iterates through the properties , calling CreateBinding(ICompileContext, Type, PropertyInfo) for each, and those which are non-null. Declaration protected virtual IEnumerable<MemberBinding> BindProperties(ICompileContext context, Type type, IEnumerable<PropertyInfo> properties) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. IEnumerable < PropertyInfo > properties The properties for which bindings are to be created. This is fed by the function GetBindableProperties(ICompileContext, Type) Returns Type Description IEnumerable < MemberBinding > An enumerable of MemberBinding objects representing the bindings to be used for each bindable property in properties . | Improve this Doc CreateBinding(ICompileContext, Type, FieldInfo) Creates a binding for the given field. Called by GetMemberBindings(ICompileContext, Type) Declaration protected virtual MemberBinding CreateBinding(ICompileContext context, Type type, FieldInfo field) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. FieldInfo field The field for which a binding is to be created. Returns Type Description MemberBinding Remarks Override this method to customise the binding that is create for the given field, or to prevent the binding from being created at all(return null if you want to abort binding the field). The base implementation simply creates a new MemberBinding whose Target is set to a new for the type - thus causing the field to be assigned a value resolved from the container when the instance is created. | Improve this Doc CreateBinding(ICompileContext, Type, PropertyInfo) Creates a binding for the given property. Called by GetMemberBindings(ICompileContext, Type) Declaration protected virtual MemberBinding CreateBinding(ICompileContext context, Type type, PropertyInfo prop) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. PropertyInfo prop The property for which a binding is to be created. Returns Type Description MemberBinding Remarks Override this method to customise the binding that is create for the given property, or to prevent the binding from being created at all(return null if you want to abort binding the property). The base implementation simply creates a new MemberBinding whose Target is set to a new for the type - thus causing the property to be assigned a value resolved from the container when the instance is created. | Improve this Doc GetBindableFields(ICompileContext, Type) Gets the bindable fields on the type . Used by GetMemberBindings(ICompileContext, Type) and passed to the BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) method. Declaration protected virtual IEnumerable<FieldInfo> GetBindableFields(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. Returns Type Description IEnumerable < FieldInfo > Remarks Override this method to filter the fields which can be bound. The base implementation returns all public instance fields declared on the type . | Improve this Doc GetBindableProperties(ICompileContext, Type) Gets the bindable properties on the type . Used by GetMemberBindings(ICompileContext, Type) and passed to the BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) method. Declaration protected virtual IEnumerable<PropertyInfo> GetBindableProperties(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. Returns Type Description IEnumerable < PropertyInfo > Remarks Override this method to filter the properties which can be bound. The base implementation returns all instance properties which have publicly accessible 'set' accessors. | Improve this Doc GetMemberBindings(ICompileContext, Type) Implementation of GetMemberBindings(ICompileContext, Type) . Declaration public virtual MemberBinding[] GetMemberBindings(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. Returns Type Description MemberBinding [] Implements Remarks The base implementation calls GetBindableProperties(ICompileContext, Type) , passing the resultant enumerable to the BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) function; it also does the same thing with GetBindableFields(ICompileContext, Type) and BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) - concatenating the two enumerables together and returning the result as an array of MemberBinding objects. See Also IMemberBindingBehaviour"
  },
  "rezolver-api/Rezolver.DefaultPropertyBindingBehaviour.html": {
    "href": "rezolver-api/Rezolver.DefaultPropertyBindingBehaviour.html",
    "title": "Class DefaultPropertyBindingBehaviour",
    "keywords": "Class DefaultPropertyBindingBehaviour The default implementation of IPropertyBindingBehaviour when you are creating a ConstructorTarget or GenericConstructorTarget and you want publicly writable properties and public fields to be assigned values obtained from the container. If you do not require properties or fields to be bound from the container, then use a null IPropertyBindingBehaviour . Inheritance Object DefaultPropertyBindingBehaviour Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DefaultPropertyBindingBehaviour : IPropertyBindingBehaviour Remarks This is a singleton class accessible through the Instance static property. Properties | Improve this Doc Instance Gets the one and only instance of DefaultPropertyBindingBehaviour Declaration public static DefaultPropertyBindingBehaviour Instance { get; } Property Value Type Description DefaultPropertyBindingBehaviour Methods | Improve this Doc BindProperties(Type, IEnumerable<PropertyInfo>) Declaration protected virtual IEnumerable<PropertyOrFieldBinding> BindProperties(Type type, IEnumerable<PropertyInfo> properties) Parameters Type Name Description Type type IEnumerable < PropertyInfo > properties Returns Type Description IEnumerable < PropertyOrFieldBinding > | Improve this Doc CreateBinding(Type, FieldInfo) Creates the binding for the given field. Called by GetPropertyBindings(CompileContext, Type) Declaration protected virtual PropertyOrFieldBinding CreateBinding(Type type, FieldInfo field) Parameters Type Name Description Type type The type. FieldInfo field The field. Returns Type Description PropertyOrFieldBinding | Improve this Doc CreateBinding(Type, PropertyInfo) Creates the binding for the given property. Called by GetPropertyBindings(CompileContext, Type) Declaration protected virtual PropertyOrFieldBinding CreateBinding(Type type, PropertyInfo prop) Parameters Type Name Description Type type The type. PropertyInfo prop The property. Returns Type Description PropertyOrFieldBinding | Improve this Doc GetBindableFields(Type) Gets the bindable fields on the type . Used by GetPropertyBindings(CompileContext, Type) . Declaration protected virtual IEnumerable<FieldInfo> GetBindableFields(Type type) Parameters Type Name Description Type type The type. Returns Type Description IEnumerable < FieldInfo > | Improve this Doc GetBindableProperties(Type) Gets the bindable properties on the type . Used by GetPropertyBindings(CompileContext, Type) . Declaration protected virtual IEnumerable<PropertyInfo> GetBindableProperties(Type type) Parameters Type Name Description Type type The type. Returns Type Description IEnumerable < PropertyInfo > | Improve this Doc GetPropertyBindings(CompileContext, Type) Implementation of GetPropertyBindings(CompileContext, Type) . Returns a binding for each publicly writable property (i.e. with a public set accessor) and each public field on the type . Declaration public virtual PropertyOrFieldBinding[] GetPropertyBindings(CompileContext context, Type type) Parameters Type Name Description CompileContext context The context. Type type The type. Returns Type Description PropertyOrFieldBinding [] Implements See Also IPropertyBindingBehaviour"
  },
  "rezolver-api/Rezolver.Targets.DelegateTarget-14.html": {
    "href": "rezolver-api/Rezolver.Targets.DelegateTarget-14.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.Targets.DelegateTarget-15.html": {
    "href": "rezolver-api/Rezolver.Targets.DelegateTarget-15.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.Targets.DelegateTarget-16.html": {
    "href": "rezolver-api/Rezolver.Targets.DelegateTarget-16.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) T15 The type of the 15th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.Targets.DelegateTarget-2.html": {
    "href": "rezolver-api/Rezolver.Targets.DelegateTarget-2.html",
    "title": "Class DelegateTarget<T, TResult>",
    "keywords": "Class DelegateTarget<T, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T, TResult> Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T, TResult> : DelegateTarget, ITarget Type Parameters Name Description T The type of the 1st delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T, TResult>, Type) Initializes a new instance of the DelegateTarget<T, TResult> class. Declaration public DelegateTarget(Func<T, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.Targets.DelegateTarget-3.html": {
    "href": "rezolver-api/Rezolver.Targets.DelegateTarget-3.html",
    "title": "Class DelegateTarget<T1, T2, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, TResult> Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, TResult> class. Declaration public DelegateTarget(Func<T1, T2, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.Targets.DelegateTarget-4.html": {
    "href": "rezolver-api/Rezolver.Targets.DelegateTarget-4.html",
    "title": "Class DelegateTarget<T1, T2, T3, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, TResult> Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.Targets.DelegateTarget-5.html": {
    "href": "rezolver-api/Rezolver.Targets.DelegateTarget-5.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, TResult> Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.Targets.DelegateTarget-6.html": {
    "href": "rezolver-api/Rezolver.Targets.DelegateTarget-6.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, TResult> Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.Targets.DelegateTarget-7.html": {
    "href": "rezolver-api/Rezolver.Targets.DelegateTarget-7.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.Targets.DelegateTarget-8.html": {
    "href": "rezolver-api/Rezolver.Targets.DelegateTarget-8.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.Targets.DelegateTarget-9.html": {
    "href": "rezolver-api/Rezolver.Targets.DelegateTarget-9.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, TResult> factory The factory. Type declaredType Type of the declared."
  },
  "rezolver-api/Rezolver.Targets.DelegateTarget.html": {
    "href": "rezolver-api/Rezolver.Targets.DelegateTarget.html",
    "title": "Class DelegateTarget",
    "keywords": "Class DelegateTarget An ITarget which resolve objects by executing a delegate with argument injection. Inheritance Object TargetBase DelegateTarget Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class DelegateTarget : TargetBase, ITarget Remarks The delegate must be non-void and can have any number of parameters. A compiler must ensure that any parameters for the Factory are automatically resolved from the container, and that a parameter of the type ResolveContext will receive the context passed to the Resolve(ResolveContext) method call for which this target is being compiled and/or executed. Constructors | Improve this Doc DelegateTarget(Delegate, Type) Initializes a new instance of the DelegateTarget class. Declaration public DelegateTarget(Delegate factory, Type declaredType = null) Parameters Type Name Description Delegate factory Required - the factory delegate. Must have a return type and can take 0 or more parameters. Type declaredType Optional - type that will be set into the DeclaredType for the target; if not provided, then it will be derived from the factory 's return type Exceptions Type Condition ArgumentNullException If factory is null ArgumentException If the factory represents a void delegate or if declaredType is passed but the type is not compatible with the return type of factory . Properties | Improve this Doc DeclaredType Gets the declared type of object that is constructed by this target, either set on construction or derived from the return type of the Factory Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc Factory Gets the factory delegate that will be invoked when this target is compiled and executed Declaration public Delegate Factory { get; } Property Value Type Description Delegate The factory. | Improve this Doc FactoryMethod Gets the MethodInfo for the Factory delegate. Declaration public MethodInfo FactoryMethod { get; } Property Value Type Description MethodInfo Remarks Whilst this can be easily obtained from the delegate yourself (by using the extension method) however, this class also uses it to determine the DeclaredType of the target or whether the delegate is actually compatible with the one supplied on construction, therefore if you need to introspect the delegate, you might as well use this."
  },
  "rezolver-api/Rezolver.Targets.ExpressionTarget.html": {
    "href": "rezolver-api/Rezolver.Targets.ExpressionTarget.html",
    "title": "Class ExpressionTarget",
    "keywords": "Class ExpressionTarget A generic target for all expressions not explicitly supported by a particular target. Enables more complex behaviours to be registered and used with the more formal ITarget implementations. Inheritance Object TargetBase ExpressionTarget Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class ExpressionTarget : TargetBase, ITarget Remarks Note to compiler implementers: This class can be used to represent simple expressions such as constants, constructor calls and so on; but can also contain whole lambda expressions with parameters. In the latter case, expression parameters are expected to receive injected arguments and, therefore, some rewriting of the expression is likely to be required. Constructors | Improve this Doc ExpressionTarget(Expression, Type, ScopeBehaviour) Initializes a new instance of the ExpressionTarget class. Declaration public ExpressionTarget(Expression expression, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description Expression expression Required. The static expression which should be used by compilers. Type declaredType Declared type of the target to be created (used when registering without an explicit type or when this target is used as a value inside another target). ScopeBehaviour scopeBehaviour Override the scoping behaviour of this expression. The default for this will be None because if you want to interact with the Scope in an expression, then you have to do it explicitly in the expression. Remarks declaredType will automatically be determined if not provided by examining the type of the expression . For lambdas, the type will be derived from the Type of the lambda's body. For all other expressions, the type is taken directly from the Type property of the expression itself. | Improve this Doc ExpressionTarget(Func<ICompileContext, Expression>, Type) Initializes a new instance of the ExpressionTarget class. Declaration public ExpressionTarget(Func<ICompileContext, Expression> expressionFactory, Type declaredType) Parameters Type Name Description Func < ICompileContext , Expression > expressionFactory Required. The factory delegate that a compiler should call to get the expression to use when compiling this target. Type declaredType Required. Static type of all expressions that will be returned by expressionFactory . Properties | Improve this Doc DeclaredType Gets the type of Expression or the type that all expressions returned by the ExpressionFactory are expected to be equal to. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc Expression Gets the static expression represented by this target - if null , then a factory is being used to produce the expression, which is available from the ExpressionFactory property. Declaration public Expression Expression { get; } Property Value Type Description Expression | Improve this Doc ExpressionFactory Gets a factory which will be executed to obtain an expression given a particular ICompileContext . If null , then a static expression will be used instead and is available from the Expression property. Declaration public Func<ICompileContext, Expression> ExpressionFactory { get; } Property Value Type Description Func < ICompileContext , Expression > | Improve this Doc ScopeBehaviour Gets the scoping behaviour for instances that will ultimately be produced by this target. Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides Methods | Improve this Doc From<TResult>(Expression<Func<TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<TResult>(Expression<Func<TResult>> expression) Parameters Type Name Description Expression < Func <TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<TResult>(Expression<Func<ResolveContext, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<TResult>(Expression<Func<ResolveContext, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) T15 The type of the 15th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) T15 The type of the 15th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T, TResult>(Expression<Func<T, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T, TResult>(Expression<Func<T, TResult>> expression) Parameters Type Name Description Expression < Func <T, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T The type of the 1st lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T, TResult>(Expression<Func<ResolveContext, T, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T, TResult>(Expression<Func<ResolveContext, T, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T The type of the 2nd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T1, T2, TResult>(Expression<Func<T1, T2, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, TResult>(Expression<Func<T1, T2, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T2, T3, TResult>(Expression<Func<ResolveContext, T2, T3, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, TResult>(Expression<Func<ResolveContext, T2, T3, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T1, T2, T3, TResult>(Expression<Func<T1, T2, T3, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, TResult>(Expression<Func<T1, T2, T3, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T2, T3, T4, TResult>(Expression<Func<ResolveContext, T2, T3, T4, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, TResult>(Expression<Func<ResolveContext, T2, T3, T4, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T1, T2, T3, T4, TResult>(Expression<Func<T1, T2, T3, T4, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, TResult>(Expression<Func<T1, T2, T3, T4, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T2, T3, T4, T5, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T1, T2, T3, T4, T5, TResult>(Expression<Func<T1, T2, T3, T4, T5, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, TResult>(Expression<Func<T1, T2, T3, T4, T5, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T2, T3, T4, T5, T6, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T1, T2, T3, T4, T5, T6, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T2, T3, T4, T5, T6, T7, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T1, T2, T3, T4, T5, T6, T7, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T2, T3, T4, T5, T6, T7, T8, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, T8, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc From<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods."
  },
  "rezolver-api/Rezolver.Targets.GenericConstructorTarget.GenericTypeMapping.html": {
    "href": "rezolver-api/Rezolver.Targets.GenericConstructorTarget.GenericTypeMapping.html",
    "title": "Class GenericConstructorTarget.GenericTypeMapping",
    "keywords": "Class GenericConstructorTarget.GenericTypeMapping Result returned from the MapType(Type) function. Represents various levels of success - from a completely incompatible mapping ( Success = false ), or a successful mapping from an open generic type to a closed generic type which can then be constructed ( Success = true and IsFullyBound = true ) or, a successful mapping from an open generic type to another open generic type ( Success = true but IsFullyBound = false ). This mapping is then used by both the SupportsType(Type) and Bind(ICompileContext) functions. Only fully bound mappings are supported by Bind(ICompileContext) , whereas SupportsType(Type) will return true so long as the Success is true. The caller, therefore, must ensure it is aware of the difference between open and closed generics. Inheritance Object GenericConstructorTarget.GenericTypeMapping Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class GenericTypeMapping Properties | Improve this Doc BindErrorMessage Gets a string describing the reason why the type could not be mapped. Can be used for exceptions, etc. Note that this can be set even if Success is true - because mappings exist between open generic types so that a target's SupportsType(Type) returns true , but the Bind(ICompileContext) function throws an exception for the same type, since you can't create an instance of an open generic. Declaration public string BindErrorMessage { get; } Property Value Type Description String The binding error message. | Improve this Doc IsFullyBound If true, then the Type is a fully closed generic type that can be constructed (and therefore would be successfully bound by the Bind(ICompileContext) method, which uses the MapType(Type) method). If this is false but Success is true , then while the target is technically compatible with the requested type, you can't create an instance. The target will, however, be able to mapped to a closed generic type based on the same Type . Declaration public bool IsFullyBound { get; } Property Value Type Description Boolean | Improve this Doc RequestedType The type requested for mapping. If this is an open generic, then the best result for this mapping will be that Success is true and IsFullyBound is false . Declaration public Type RequestedType { get; } Property Value Type Description Type | Improve this Doc Success Gets a value indicating whether the DeclaredType of the GenericConstructorTarget was successfully mapped to the requested type. If so, and IsFullyBound is true , then an instance of Type will be compatible with the type that was requested. If IsFullyBound is false , then you can't create an instance of Type because it's an open generic - but you will be able to bind the same target to a closed generic of the same Type . Declaration public bool Success { get; } Property Value Type Description Boolean true if success; otherwise, false . | Improve this Doc Type If Success = true , gets the generic type to be used for the RequestedType . Note that this could be either an open or closed generic - the IsFullyBound offers a quick means by which to determine this. If IsFullyBound is true , then the mapping will succeed when encountered by the Bind(ICompileContext) method. Declaration public Type Type { get; } Property Value Type Description Type The type."
  },
  "rezolver-api/Rezolver.Targets.GenericConstructorTarget.html": {
    "href": "rezolver-api/Rezolver.Targets.GenericConstructorTarget.html",
    "title": "Class GenericConstructorTarget",
    "keywords": "Class GenericConstructorTarget Equivalent of ConstructorTarget but for open generic types. So, this will handle the open generic MyType<,>, for example, whereas ConstructorTarget would handle the closed type MyType<int, string>. Inheritance Object TargetBase GenericConstructorTarget Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class GenericConstructorTarget : TargetBase, ITarget Constructors | Improve this Doc GenericConstructorTarget(Type, IMemberBindingBehaviour) Constructs a new instance of the GenericConstructorTarget for the given open generic type, which will utilise the optional memberBindingBehaviour when it constructs its ConstructorTarget when Bind(ICompileContext) is called. Declaration public GenericConstructorTarget(Type genericType, IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description Type genericType The type of the object that is to be built (open generic of course) IMemberBindingBehaviour memberBindingBehaviour Optional. The IMemberBindingBehaviour to be used for binding properties and/or fields on the ConstructorTarget that is generated. If null, then no property or fields will be bound on construction. Properties | Improve this Doc DeclaredType Implementation of the abstract base property. Will return the unbound generic type passed to this object on construction. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc GenericType Gets the generic type definition from which generic types are to be built and instances of which will be constructed. Declaration public Type GenericType { get; } Property Value Type Description Type | Improve this Doc MemberBindingBehaviour Gets the member binding behaviour to be used when creating an instance. Declaration public IMemberBindingBehaviour MemberBindingBehaviour { get; } Property Value Type Description IMemberBindingBehaviour The member binding behaviour. Methods | Improve this Doc Auto(Type, IMemberBindingBehaviour) Equivalent of Auto(Type, IMemberBindingBehaviour) but for open generic types. Note - there is no generic version because that could only be invoked by reflection. Declaration public static ITarget Auto(Type type, IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description Type type The type. IMemberBindingBehaviour memberBindingBehaviour Optional behaviour controlling which properties and fields, if any, will receive injected values. Returns Type Description ITarget Exceptions Type Condition ArgumentException This is raised from the GenericConstructorTarget(Type, IMemberBindingBehaviour) constructor when the passed type is either not an open generic type or is an abstract class or interface. | Improve this Doc Bind(ICompileContext) Obtains an ITarget (usually a ConstructorTarget ) which will create an instance of a generic type (whose definition is equal to GenericType ) with generic arguments set correctly according to the TargetType of the context . Declaration public ITarget Bind(ICompileContext context) Parameters Type Name Description ICompileContext context The context. Returns Type Description ITarget Remarks The process of binding a requested type to the concrete type can be very complex, when inheritance chains and interface implementation maps are taken into account. At the simplest end of the spectrum, if GenericType is MyGeneric<> and the context 's TargetType is MyGeneric<int> , then this function merely has to insert the int type as the generic parameter to the MyGeneric<> type definition, bake a new type and create an auto-bound ConstructorTarget . Consider what happens, however, when the inheritance chain is more complex: interface IMyInterfaceCore<T, U> { } class MyBaseClass<T, U> : IMyInterfaceCore<U, T> { } class MyDerivedClass<T, U> : MyBaseClass<U, T> { } A GenericConstructorTarget bound to the generic type definition MyDerivedClass<,> can create instances not only of any generic type based on that definition, but also any generic type based on the definitions of either it's immediate base, or that base's interface. In order to do so, however, the parameters must be mapped between the generic type definitions so that if an instance of MyBaseClass<string, int> is requested, then an instance of MyDerivedClass<int, string> (note the arguments are reversed) is actually created. Similarly, if an instance of IMyInterface<string, int> is requested, we actually need to create an instance of MyDerivedClass<string, int> - because the generic arguments are reversed first through the base class inheritance, and then again by the base class' implementation of the interface. Note that a GenericConstructorTarget can only bind to the context's target type if there is enough information in order to deduce the generic type arguments for GenericType . This means, in general, that the requested type will almost always need to be a generic type with at least as many type arguments as the GenericType . | Improve this Doc MapType(Type) Maps the DeclaredType open generic type to the targetType . Examine the Success of the result to check whether the result was successful. Declaration public GenericConstructorTarget.GenericTypeMapping MapType(Type targetType) Parameters Type Name Description Type targetType Type of the target. Returns Type Description GenericConstructorTarget.GenericTypeMapping | Improve this Doc SupportsType(Type) Override - introduces additional logic to cope with generic types not generally supported by the majority of other targets. This uses the MapType(Type) function to determine success, but only checks the Success flag. As a result, this method will return true if an open generic base or interface of DeclaredType Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type Returns Type Description Boolean Overrides See Also TargetBase"
  },
  "rezolver-api/Rezolver.Targets.ListTarget.html": {
    "href": "rezolver-api/Rezolver.Targets.ListTarget.html",
    "title": "Class ListTarget",
    "keywords": "Class ListTarget This target produces arrays ( AsArray = true ) or lists ( AsArray = false ) whose individual items are built by ITarget instances. Primarily used by the Rezolver.EnumerableTargetContainer and the configuration framework, but can also be used by your code. Inheritance Object TargetBase ListTarget Inherited Members Namespace :Rezolver.Targets Assembly :cs.temp.dll.dll Syntax public class ListTarget : TargetBase, ITarget Remarks The element type you feed on construction determines the type of array or the generic argument to List<T>. Each of the rezolve targets that you then pass must support that type. Constructors | Improve this Doc ListTarget(Type, IEnumerable<ITarget>, Boolean) Initializes a new instance of the ListTarget class. Declaration public ListTarget(Type elementType, IEnumerable<ITarget> items, bool asArray = false) Parameters Type Name Description Type elementType Required. Type of the elements in the array or list. IEnumerable < ITarget > items Required. The targets that will create each the individual items. Boolean asArray A boolean indicating whether the target will build an array ( true ) or a list ( false ). Exceptions Type Condition ArgumentNullException elementType or items ArgumentException All targets in the items enumerable must be non-null;items or All targets in the items enumerable must support the element type elementType Properties | Improve this Doc AsArray Gets a value indicating whether the target will build an array ( true ) or a list ( false ). Declaration public bool AsArray { get; } Property Value Type Description Boolean | Improve this Doc DeclaredType Implementation of the abstract property from the base. This will always return either a type equal to an array of ElementType , or List<T> with ElementType as the generic parameter. This is controlled by the AsArray property. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc ElementType Gets the declared type of each element in the array or list that will be constructed. The DeclaredType returned by this instance will either be ElementType[] or List<ElementType> depending on the value of AsArray . Declaration public Type ElementType { get; } Property Value Type Description Type The declared type of each element. | Improve this Doc Items Gets the rezolve targets that will build each individual item in the resulting list or array. Declaration public IEnumerable<ITarget> Items { get; } Property Value Type Description IEnumerable < ITarget > The items. | Improve this Doc ListConstructor Gets the list constructor to be invoked when AsArray is false. Declaration public ConstructorInfo ListConstructor { get; } Property Value Type Description ConstructorInfo The list constructor. Exceptions Type Condition InvalidOperationException Since this target is configured to build an array, getting the ListConstructor is not a valid operation. | Improve this Doc UseFallback Returns true if the Items enumerable is empty. Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides"
  },
  "rezolver-api/Rezolver.Configuration.Json.RezolveTargetMetadataConverter.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.RezolveTargetMetadataConverter.html",
    "title": "Class RezolveTargetMetadataConverter",
    "keywords": "Class RezolveTargetMetadataConverter This converter is registered against the type RezolveTargetMetadataWrapper Inheritance Object RezolveTargetMetadataConverter Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class RezolveTargetMetadataConverter : JsonConverter Properties | Improve this Doc CanWrite Declaration public override bool CanWrite { get; } Property Value Type Description Boolean Methods | Improve this Doc CanConvert(Type) Declaration public override bool CanConvert(Type objectType) Parameters Type Name Description Type objectType Returns Type Description Boolean | Improve this Doc ReadJson(JsonReader, Type, Object, JsonSerializer) Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Type Name Description JsonReader reader Type objectType Object existingValue JsonSerializer serializer Returns Type Description Object | Improve this Doc WriteJson(JsonWriter, Object, JsonSerializer) Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Type Name Description JsonWriter writer Object value JsonSerializer serializer"
  },
  "rezolver-api/Rezolver.Configuration.Json.RezolveTargetMetadataWrapper.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.RezolveTargetMetadataWrapper.html",
    "title": "Class RezolveTargetMetadataWrapper",
    "keywords": "Class RezolveTargetMetadataWrapper Metadata wrapper to accommodate the nature of how JSON configuration is deserialized. Of little practical use outside of the Json configuration library, unless you are creating your own metadata types which need the Unwrap semantics Inheritance Object RezolveTargetMetadataBase RezolveTargetMetadataWrapper Inherited Members Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax [Obsolete(\"no longer required\", true)] public class RezolveTargetMetadataWrapper : RezolveTargetMetadataBase, IRezolveTargetMetadataExtension, IRezolveTargetMetadata Constructors | Improve this Doc RezolveTargetMetadataWrapper(IRezolveTargetMetadata) Declaration public RezolveTargetMetadataWrapper(IRezolveTargetMetadata wrapped) Parameters Type Name Description IRezolveTargetMetadata wrapped Fields | Improve this Doc ExtensionTypeName Declaration public const string ExtensionTypeName = \"#JSONWRAPPER#\" Field Value Type Description String Properties | Improve this Doc DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides Implements | Improve this Doc ExtensionType Declaration public string ExtensionType { get; } Property Value Type Description String Implements Methods | Improve this Doc BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Type Name Description ITypeReference [] targetTypes Returns Type Description IRezolveTargetMetadata Overrides | Improve this Doc CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Implementation of CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) , except this implementation always throws a NotSupportedException , because it must be unwrapped (through a call to UnwrapMetadata(ITypeReference[]) ) before it can be used to create an ITarget . Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Type Name Description Type [] targetTypes ConfigurationAdapterContext context IConfigurationEntry entry Returns Type Description ITarget Overrides | Improve this Doc UnwrapConstructorMetadata(IRezolveTargetMetadata, ITypeReference[]) Unwraps an IConstructorTargetMetadata object by binding it to the forTargetTypes . Declaration protected virtual IRezolveTargetMetadata UnwrapConstructorMetadata(IRezolveTargetMetadata meta, ITypeReference[] forTargetTypes) Parameters Type Name Description IRezolveTargetMetadata meta ITypeReference [] forTargetTypes Returns Type Description IRezolveTargetMetadata | Improve this Doc UnwrapExtensionMetadata(IRezolveTargetMetadata, ITypeReference[]) Special case version of UnwrapMetadata(ITypeReference[]) for metadata with the type Extension . The base implementation supports instances of the RezolveTargetMetadataWrapper type only - and simply chain the call through to its UnwrapMetadata method. Declaration protected virtual IRezolveTargetMetadata UnwrapExtensionMetadata(IRezolveTargetMetadata meta, ITypeReference[] forTargetTypes) Parameters Type Name Description IRezolveTargetMetadata meta ITypeReference [] forTargetTypes Returns Type Description IRezolveTargetMetadata | Improve this Doc UnwrapListMetadata(IRezolveTargetMetadata, ITypeReference[]) Unwraps a list metadata (and any inner target metadata) for the target types. Declaration protected virtual IRezolveTargetMetadata UnwrapListMetadata(IRezolveTargetMetadata meta, ITypeReference[] forTargetTypes) Parameters Type Name Description IRezolveTargetMetadata meta ITypeReference [] forTargetTypes Returns Type Description IRezolveTargetMetadata | Improve this Doc UnwrapMetadata(ITypeReference[]) Unwraps the metadata contained within this wrapper for the passed target types in readiness to be pushed into an IConfigurationEntry. Note - if the metadata can't be unwrapped, then the method will simply return this instance. Declaration public virtual IRezolveTargetMetadata UnwrapMetadata(ITypeReference[] forTargetTypes) Parameters Type Name Description ITypeReference [] forTargetTypes Type references that the unwrapped metadata should support. Returns Type Description IRezolveTargetMetadata Remarks Unwrapping is the process whereby a type declared for registration is back-referenced using the '$auto' unbound type name in configuration for, say a constructor target or similar. | Improve this Doc UnwrapMetadataList(IRezolveTargetMetadata, ITypeReference[]) Unwraps a series of metadata objects stored in the list (passed in the meta parameter) for the target types, returning another metadata list containing the unwrapped metadata objects. Declaration protected IRezolveTargetMetadataList UnwrapMetadataList(IRezolveTargetMetadata meta, ITypeReference[] forTargetTypes) Parameters Type Name Description IRezolveTargetMetadata meta ITypeReference [] forTargetTypes Returns Type Description IRezolveTargetMetadataList | Improve this Doc UnwrapMetadataList(IRezolveTargetMetadataList, ITypeReference[]) Strongly-typed virtual method for unwrapping metadata lists (invoked by UnwrapMetadataList(IRezolveTargetMetadata, ITypeReference[]) after confirming that the metadata passed to it is of the correct type. Declaration protected virtual IRezolveTargetMetadataList UnwrapMetadataList(IRezolveTargetMetadataList listMeta, ITypeReference[] forTargetTypes) Parameters Type Name Description IRezolveTargetMetadataList listMeta ITypeReference [] forTargetTypes Returns Type Description IRezolveTargetMetadataList"
  },
  "rezolver-api/Rezolver.Configuration.Json.TypeReferenceConverter.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.TypeReferenceConverter.html",
    "title": "Class TypeReferenceConverter",
    "keywords": "Class TypeReferenceConverter Responsible for converting Json to a Rezolver Configuration TypeReference Inheritance Object TypeReferenceConverter Namespace :Rezolver.Configuration.Json Assembly :cs.temp.dll.dll Syntax public class TypeReferenceConverter : JsonConverter Properties | Improve this Doc CanWrite Declaration public override bool CanWrite { get; } Property Value Type Description Boolean Methods | Improve this Doc CanConvert(Type) Declaration public override bool CanConvert(Type objectType) Parameters Type Name Description Type objectType Returns Type Description Boolean | Improve this Doc ReadJson(JsonReader, Type, Object, JsonSerializer) Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Type Name Description JsonReader reader Type objectType Object existingValue JsonSerializer serializer Returns Type Description Object | Improve this Doc WriteJson(JsonWriter, Object, JsonSerializer) Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Type Name Description JsonWriter writer Object value JsonSerializer serializer"
  },
  "rezolver-api/Rezolver.Configuration.Json.html": {
    "href": "rezolver-api/Rezolver.Configuration.Json.html",
    "title": "Namespace Rezolver.Configuration.Json",
    "keywords": "Namespace Rezolver.Configuration.Json Classes An advanced factory which automatically loads and references all assemblies that are deployed in the application's base directory and any subfolders determined by the AppDomain 's SetupInformation's PrivateBinBath. This is a singleton - accessed through the Instance property. JSON converter for IConfigurationEntry The converter defaults to looking for type registrations; to enable it to look for a different entry type, you must instruct Json.Net to create an instance of it using the constructor that accepts a ConfigurationEntryType Class JsonConfiguration. Class for loading JsonConfiguration from Json through Json.Net. Thrown when a Json container configuration file is invalid. Special version of IObjectTargetMetadata which creates an instance of the requested type from a JToken. Some more work might be required here to This converter is registered against the type RezolveTargetMetadataWrapper Metadata wrapper to accommodate the nature of how JSON configuration is deserialized. Of little practical use outside of the Json configuration library, unless you are creating your own metadata types which need the Unwrap semantics Responsible for converting Json to a Rezolver Configuration TypeReference"
  },
  "rezolver-api/Rezolver.Configuration.ListTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.ListTargetMetadata.html",
    "title": "Class ListTargetMetadata",
    "keywords": "Class ListTargetMetadata Standard implementation of the IListTargetMetadata interface. Inheritance Object RezolveTargetMetadataBase ListTargetMetadata Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ListTargetMetadata : RezolveTargetMetadataBase, IListTargetMetadata, IRezolveTargetMetadata Constructors | Improve this Doc ListTargetMetadata(ITypeReference, IRezolveTargetMetadataList, Boolean) Initializes a new instance of the ListTargetMetadata class. Declaration public ListTargetMetadata(ITypeReference elementType, IRezolveTargetMetadataList items, bool isArray) Parameters Type Name Description ITypeReference elementType Type of the elements of the eventual array/list. IRezolveTargetMetadataList items Metadata for the targets that will eventually create the items for the array or list. Boolean isArray if set to true then an array is to be built, otherwise a list is to be built. Properties | Improve this Doc DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides Implements | Improve this Doc ElementType Gets the declared element type of the array or list that will be created from this metadata. Declaration public ITypeReference ElementType { get; } Property Value Type Description ITypeReference The type of the element. Implements Exceptions Type Condition NotImplementedException | Improve this Doc IsArray Maps to the AsArray property. If true, then an array of ElementType will be created, otherwise a List< ElementType > will be created by the ListTarget created from this metadata. Declaration public bool IsArray { get; } Property Value Type Description Boolean true if this instance represents a ListTarget that will create an array; otherwise, false . Implements | Improve this Doc Items Gets the metadata for the targets that will be used for the items that'll be returned in the Array or List that will be created by the ListTarget created from this metadata. Declaration public IRezolveTargetMetadataList Items { get; } Property Value Type Description IRezolveTargetMetadataList The elements. Implements Methods | Improve this Doc Bind(ITypeReference[]) Declaration public override IRezolveTargetMetadata Bind(ITypeReference[] targetTypes) Parameters Type Name Description ITypeReference [] targetTypes Returns Type Description IRezolveTargetMetadata Overrides Implements | Improve this Doc BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Type Name Description ITypeReference [] targetTypes Returns Type Description IRezolveTargetMetadata Overrides | Improve this Doc CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Type Name Description Type [] targetTypes ConfigurationAdapterContext context IConfigurationEntry entry Returns Type Description ITarget Overrides"
  },
  "rezolver-api/Rezolver.Configuration.ObjectTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.ObjectTargetMetadata.html",
    "title": "Class ObjectTargetMetadata",
    "keywords": "Class ObjectTargetMetadata Standard implementation of ObjectTargetMetadataBase , to encapsulate object references that are to be baked into a container as targets. Inheritance Object RezolveTargetMetadataBase ObjectTargetMetadataBase ObjectTargetMetadata Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class ObjectTargetMetadata : ObjectTargetMetadataBase, IObjectTargetMetadata, IRezolveTargetMetadata Remarks This class accepts either an object reference that is to be returned when the target is resolved; or a delegate that will be called with the desired type (passed in from GetObject(Type) ). Constructors | Improve this Doc ObjectTargetMetadata(Func<Type, Object>) Initializes a new instance of the ObjectTargetMetadata class. Declaration public ObjectTargetMetadata(Func<Type, object> valueProvider) Parameters Type Name Description Func < Type , Object > valueProvider The value provider that will be called. | Improve this Doc ObjectTargetMetadata(Object) Initializes a new instance of the ObjectTargetMetadata class. Declaration public ObjectTargetMetadata(object obj) Parameters Type Name Description Object obj The object that is to be returned from GetObject(Type) . Properties | Improve this Doc DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides Implements Methods | Improve this Doc BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Type Name Description ITypeReference [] targetTypes Returns Type Description IRezolveTargetMetadata Overrides | Improve this Doc GetObject(Type) Called to get the object that will be registered in the IRezolveTargetContainer to be returned when a caller requests one of its registered types. The method can construct an object anew everytime it is called, or it can always return the same instance; this behaviour is implementation-dependant. Declaration public override object GetObject(Type type) Parameters Type Name Description Type type The type of object that is desired. The implementation determines whether this parameter is required. If it is, and you pass null, then an ArgumentNullException will be thrown. If you pass an argument, the implementation is not bound to check or honour the type. Its purpose is to provide a hint only, not a guarantee that the object returned is compatible with the type. Returns Type Description Object An object. Note - if the operation returns null this is not an error. Overrides Implements Exceptions Type Condition ArgumentNullException type"
  },
  "rezolver-api/Rezolver.Configuration.ObjectTargetMetadataBase.html": {
    "href": "rezolver-api/Rezolver.Configuration.ObjectTargetMetadataBase.html",
    "title": "Class ObjectTargetMetadataBase",
    "keywords": "Class ObjectTargetMetadataBase Abstract base class for metadata that builds an object target. Inheritance Object RezolveTargetMetadataBase ObjectTargetMetadataBase Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public abstract class ObjectTargetMetadataBase : RezolveTargetMetadataBase, IObjectTargetMetadata, IRezolveTargetMetadata Constructors | Improve this Doc ObjectTargetMetadataBase() Declaration public ObjectTargetMetadataBase() Methods | Improve this Doc CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Type Name Description Type [] targetTypes ConfigurationAdapterContext context IConfigurationEntry entry Returns Type Description ITarget Overrides | Improve this Doc GetObject(Type) Called to get the object that will be registered in the IRezolveTargetContainer to be returned when a caller requests one of its registered types. The method can construct an object anew everytime it is called, or it can always return the same instance; this behaviour is implementation-dependant. Declaration public abstract object GetObject(Type type) Parameters Type Name Description Type type The type of object that is desired. The implementation determines whether this parameter is required. If it is, and you pass null, then an ArgumentNullException will be thrown. If you pass an argument, the implementation is not bound to check or honour the type. Its purpose is to provide a hint only, not a guarantee that the object returned is compatible with the type. Returns Type Description Object An object. Note - if the operation returns null this is not an error. Implements"
  },
  "rezolver-api/Rezolver.Configuration.RegisterInstruction.html": {
    "href": "rezolver-api/Rezolver.Configuration.RegisterInstruction.html",
    "title": "Class RegisterInstruction",
    "keywords": "Class RegisterInstruction The basic workhorse of a parsed configuration - an instruction to register a target in an IRezolveTargetContainer instance against one or more types with a given name. Inheritance Object RezolverBuilderInstruction RegisterInstruction Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class RegisterInstruction : RezolverBuilderInstruction Constructors | Improve this Doc RegisterInstruction(IEnumerable<Type>, ITarget, IConfigurationEntry) Constructs a new instance of the RegisterInstruction class. Declaration public RegisterInstruction(IEnumerable<Type> targetTypes, ITarget target, IConfigurationEntry entry) Parameters Type Name Description IEnumerable < Type > targetTypes The types that the target will be registered with ITarget target The target to be registered. IConfigurationEntry entry The original configuration entry from which this instruction was built. Exceptions Type Condition ArgumentNullException targetTypes or target ArgumentException List must contain one or more types;targetTypes or All types in list must be non-null;targetTypes Properties | Improve this Doc Target The target that is to be registered. Declaration public ITarget Target { get; } Property Value Type Description ITarget | Improve this Doc TargetTypes The types that the target will be registered with Declaration public IEnumerable<Type> TargetTypes { get; } Property Value Type Description IEnumerable < Type > Methods | Improve this Doc Apply(ITargetContainer) The implementation will register the target for the given types. In the case of multiple types, the target is registered directly against that type, and aliases are registered for all the others. Declaration public override void Apply(ITargetContainer builder) Parameters Type Name Description ITargetContainer builder Overrides"
  },
  "rezolver-api/Rezolver.Configuration.RegisterMultipleInstruction.html": {
    "href": "rezolver-api/Rezolver.Configuration.RegisterMultipleInstruction.html",
    "title": "Class RegisterMultipleInstruction",
    "keywords": "Class RegisterMultipleInstruction Similar to the RegisterInstruction except this specifically wraps the method. Construction is largely identical, except where in the aforementioned class you pass a single target, here you pass multiple targets in a list. Inheritance Object RezolverBuilderInstruction RegisterMultipleInstruction Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class RegisterMultipleInstruction : RezolverBuilderInstruction Constructors | Improve this Doc RegisterMultipleInstruction(IEnumerable<Type>, IEnumerable<ITarget>, IConfigurationEntry) Initializes a new instance of the RegisterMultipleInstruction class. Declaration public RegisterMultipleInstruction(IEnumerable<Type> targetTypes, IEnumerable<ITarget> targets, IConfigurationEntry entry) Parameters Type Name Description IEnumerable < Type > targetTypes The target types for the registration. IEnumerable < ITarget > targets The targets. Note that this is a list to support modification after the instruction is created; since this is a configuration API. IConfigurationEntry entry The source entry for this instruction - allows the system to track the instruction back to the configuration it was loaded from. Exceptions Type Condition ArgumentNullException targetTypes or targets ArgumentException List must contain one or more types;targetTypes or All types in list must be non-null;targetTypes or List must contain one or more targets;targets or All targets in list must be non-null;targets Properties | Improve this Doc Targets Gets the targets that'll be used for the registration. Declaration public IEnumerable<ITarget> Targets { get; } Property Value Type Description IEnumerable < ITarget > The targets. | Improve this Doc TargetTypes The types that the target will be registered with Declaration public IEnumerable<Type> TargetTypes { get; } Property Value Type Description IEnumerable < Type > Methods | Improve this Doc Apply(ITargetContainer) Declaration public override void Apply(ITargetContainer builder) Parameters Type Name Description ITargetContainer builder Overrides"
  },
  "rezolver-api/Rezolver.Configuration.RezolverBuilderInstruction.html": {
    "href": "rezolver-api/Rezolver.Configuration.RezolverBuilderInstruction.html",
    "title": "Class RezolverBuilderInstruction",
    "keywords": "Class RezolverBuilderInstruction An instruction to perform an operation on a container builder from an IConfigurationEntry that's been parsed from a configuration source (and which has been retrieved from an IConfiguration instance). Inheritance Object RezolverBuilderInstruction Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public abstract class RezolverBuilderInstruction Constructors | Improve this Doc RezolverBuilderInstruction(IConfigurationEntry) Inheritance constructor. Declaration protected RezolverBuilderInstruction(IConfigurationEntry entry) Parameters Type Name Description IConfigurationEntry entry The entry that built this instruction. Properties | Improve this Doc Entry The source configuration entry for this instruction. Declaration public IConfigurationEntry Entry { get; } Property Value Type Description IConfigurationEntry Methods | Improve this Doc Apply(ITargetContainer) Abstract method which performs whatever instruction this instance represents on the passed builder. Declaration public abstract void Apply(ITargetContainer builder) Parameters Type Name Description ITargetContainer builder"
  },
  "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataBase.html": {
    "href": "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataBase.html",
    "title": "Class RezolveTargetMetadataBase",
    "keywords": "Class RezolveTargetMetadataBase Suggested base class for implementations of IRezolveTargetMetadata . Inheritance Object RezolveTargetMetadataBase Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public abstract class RezolveTargetMetadataBase : IRezolveTargetMetadata Constructors | Improve this Doc RezolveTargetMetadataBase(RezolveTargetMetadataType) Initializes a new instance of the RezolveTargetMetadataBase class. Declaration protected RezolveTargetMetadataBase(RezolveTargetMetadataType type) Parameters Type Name Description RezolveTargetMetadataType type The type of target. Exceptions Type Condition ArgumentException If type is RezolveTargetMetadataType.Extension this instance must implement IRezolveTargetMetadataExtension Properties | Improve this Doc DeclaredType Gets the declared type of the object that will be created by an IRezolveTarget created by this metadata. Note - this isn't always known, or always fixed, since configuration systems will allow developers to avoid being specific about the types that are to be built. Declaration public abstract ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference The type of the declared. Implements | Improve this Doc Type The type of rezolve target that is expected to be produced from this metadata Declaration public RezolveTargetMetadataType Type { get; } Property Value Type Description RezolveTargetMetadataType The type. Implements Methods | Improve this Doc Bind(ITypeReference[]) Declaration public virtual IRezolveTargetMetadata Bind(ITypeReference[] targetTypes) Parameters Type Name Description ITypeReference [] targetTypes Returns Type Description IRezolveTargetMetadata Implements | Improve this Doc BindBase(ITypeReference[]) Creates a new instance (clone) of this metadata that's bound to the target types (although, typically, you'll only ever pick the first target type that is in the array). Only ever called if DeclaredType is unbound Declaration protected abstract IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Type Name Description ITypeReference [] targetTypes The target types. Returns Type Description IRezolveTargetMetadata IRezolveTargetMetadata. | Improve this Doc CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) Implementation of CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) - see that documentation for more detail about the intentions of this method. This implementation will check all the arguments (for nulls etc), including that all targetTypes have a common base; then it will invoke the abstract method CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) . Declaration public virtual ITarget CreateRezolveTarget(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry = null) Parameters Type Name Description Type [] targetTypes Required. One or more target types that the returned target is expected to be compatible with (i.e. able to build an instance of). Generally, this will be the target types for the configuration entry that is passed in entry . ConfigurationAdapterContext context The current context - provides access to the builder currently being constructed, as well as methods for resolving type names from ITypeReference instances or strings (and more). IConfigurationEntry entry If provided, this is a reference to the configuration entry (typically an ITypeRegistrationEntry ) against which this target will be registered. Please note - this doesn't mean that the target that is returned will become the target of the registration. It might be that the target is one that is used by a parent target that will become the target of the registration. Returns Type Description ITarget IRezolveTarget. Implements Exceptions Type Condition ArgumentNullException context or targetTypes ArgumentException Array must contain at least one target type;targetTypes or All items in the array must be non-null;targetTypes | Improve this Doc CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Called by CreateRezolveTarget(Type[], ConfigurationAdapterContext, IConfigurationEntry) to create the rezolve target that will be registered into the ITargetContainer currently being built (available on the context ) If an error occurs, you indicate that by adding to the context 's errors collection, and return null. You can also throw an exception, which will be caught and added to the errors collection for you. Declaration protected abstract ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Type Name Description Type [] targetTypes The target types. ConfigurationAdapterContext context The context. IConfigurationEntry entry The entry. Returns Type Description ITarget IRezolveTarget."
  },
  "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataList.html": {
    "href": "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataList.html",
    "title": "Class RezolveTargetMetadataList",
    "keywords": "Class RezolveTargetMetadataList Inheritance Object RezolveTargetMetadataBase RezolveTargetMetadataList Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class RezolveTargetMetadataList : RezolveTargetMetadataBase, IRezolveTargetMetadataList, IRezolveTargetMetadata Constructors | Improve this Doc RezolveTargetMetadataList() Declaration public RezolveTargetMetadataList() | Improve this Doc RezolveTargetMetadataList(IEnumerable<IRezolveTargetMetadata>) Declaration public RezolveTargetMetadataList(IEnumerable<IRezolveTargetMetadata> range) Parameters Type Name Description IEnumerable < IRezolveTargetMetadata > range Properties | Improve this Doc DeclaredType Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference Overrides Implements | Improve this Doc Targets Declaration public IList<IRezolveTargetMetadata> Targets { get; } Property Value Type Description IList < IRezolveTargetMetadata > Implements Methods | Improve this Doc Bind(ITypeReference[]) Declaration public override IRezolveTargetMetadata Bind(ITypeReference[] targetTypes) Parameters Type Name Description ITypeReference [] targetTypes Returns Type Description IRezolveTargetMetadata Overrides Implements | Improve this Doc BindBase(ITypeReference[]) Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Type Name Description ITypeReference [] targetTypes Returns Type Description IRezolveTargetMetadata Overrides | Improve this Doc CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Type Name Description Type [] targetTypes ConfigurationAdapterContext context IConfigurationEntry entry Returns Type Description ITarget Overrides | Improve this Doc CreateRezolveTargets(Type[], ConfigurationAdapterContext, IConfigurationEntry) Declaration public IEnumerable<ITarget> CreateRezolveTargets(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Type Name Description Type [] targetTypes ConfigurationAdapterContext context IConfigurationEntry entry Returns Type Description IEnumerable < ITarget > Implements"
  },
  "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataType.html": {
    "href": "rezolver-api/Rezolver.Configuration.RezolveTargetMetadataType.html",
    "title": "Enum RezolveTargetMetadataType",
    "keywords": "Enum RezolveTargetMetadataType Types of IRezolveTargetMetadata that can be expressed in configuration Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public enum RezolveTargetMetadataType Fields Name Description Constructor Binding to a constructor of a type to create new instances of that type when the object is resolved Extension A custom metadata - the instance should also have the interface IRezolveTargetMetadataExtension List A list or array whose items are individually specified as resolve targets and eventually loaded into a ListTarget. This enables configuration files to hand-crank a list directly and when multiple registration is not applicable. MetadataList Describes a list of IRezolveTargetMetadata instances - to be used for metadata objects that require multiple metadata objects. Can be created to feed a multiple instance registration for a single type (e.g. registering multiple instances of IFoo to a container, so that you can resolve all of them by resolving IEnumerable<IFoo>), or simply as a collection of targets that are to be used to build an array that is to be passed as a constructor argument or property. Object A physical instance to be returned when a resolve operation is performed Singleton A singleton - only one object will ever be created from the target that this metadata builds. A singleton might also be scoped - i.e. that the lifetime is limited to the lifetime of an external scope. Unknown"
  },
  "rezolver-api/Rezolver.Configuration.RuntimeTypeReference.html": {
    "href": "rezolver-api/Rezolver.Configuration.RuntimeTypeReference.html",
    "title": "Class RuntimeTypeReference",
    "keywords": "Class RuntimeTypeReference An ITypeReference that has been built directly from a runtime type. Inheritance Object RuntimeTypeReference Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public sealed class RuntimeTypeReference : ITypeReference, IConfigurationLineInfo Constructors | Improve this Doc RuntimeTypeReference(Type) Declaration public RuntimeTypeReference(Type runtimeType) Parameters Type Name Description Type runtimeType Properties | Improve this Doc EndLineNo Declaration public int ? EndLineNo { get; } Property Value Type Description Nullable < Int32 > Implements | Improve this Doc EndLinePos Declaration public int ? EndLinePos { get; } Property Value Type Description Nullable < Int32 > Implements | Improve this Doc GenericArguments Declaration public ITypeReference[] GenericArguments { get; } Property Value Type Description ITypeReference [] Implements | Improve this Doc IsArray Declaration public bool IsArray { get; } Property Value Type Description Boolean Implements | Improve this Doc IsOpenGenericTypeArgument Declaration public bool IsOpenGenericTypeArgument { get; } Property Value Type Description Boolean Implements | Improve this Doc IsUnbound Declaration public bool IsUnbound { get; } Property Value Type Description Boolean Implements | Improve this Doc RuntimeType Declaration public Type RuntimeType { get; } Property Value Type Description Type | Improve this Doc StartLineNo Declaration public int ? StartLineNo { get; } Property Value Type Description Nullable < Int32 > Implements | Improve this Doc StartLinePos Declaration public int ? StartLinePos { get; } Property Value Type Description Nullable < Int32 > Implements | Improve this Doc TypeName Declaration public string TypeName { get; } Property Value Type Description String Implements"
  },
  "rezolver-api/Rezolver.Configuration.SingletonTargetMetadata.html": {
    "href": "rezolver-api/Rezolver.Configuration.SingletonTargetMetadata.html",
    "title": "Class SingletonTargetMetadata",
    "keywords": "Class SingletonTargetMetadata Inheritance Object RezolveTargetMetadataBase SingletonTargetMetadata Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class SingletonTargetMetadata : RezolveTargetMetadataBase, ISingletonTargetMetadata, IRezolveTargetMetadata Constructors | Improve this Doc SingletonTargetMetadata(IRezolveTargetMetadata, Boolean) Initializes a new instance of the SingletonTargetMetadata class. Declaration public SingletonTargetMetadata(IRezolveTargetMetadata inner, bool scoped = false) Parameters Type Name Description IRezolveTargetMetadata inner The inner target that will be turned into a singleton. Boolean scoped if set to true [scoped]. Exceptions Type Condition ArgumentNullException inner Properties | Improve this Doc DeclaredType Gets the declared type of the object that will be created by an IRezolveTarget created by this metadata. Note - this isn't always known, or always fixed, since configuration systems will allow developers to avoid being specific about the types that are to be built. Declaration public override ITypeReference DeclaredType { get; } Property Value Type Description ITypeReference The type of the declared. Overrides Implements | Improve this Doc Inner Metadata for the inner target that is turned into a scoped singleton Declaration public IRezolveTargetMetadata Inner { get; } Property Value Type Description IRezolveTargetMetadata Implements | Improve this Doc Scoped If true, then the singleton object should be scope-compatible, i.e. with a lifetime limited to the lifetime of an external scope rather than to the AppDomain's lifetime. Declaration public bool Scoped { get; } Property Value Type Description Boolean Implements Methods | Improve this Doc BindBase(ITypeReference[]) Creates a new instance (clone) of this metadata that's bound to the target types (although, typically, you'll only ever pick the first target type that is in the array). Only ever called if DeclaredType is unbound Declaration protected override IRezolveTargetMetadata BindBase(params ITypeReference[] targetTypes) Parameters Type Name Description ITypeReference [] targetTypes The target types. Returns Type Description IRezolveTargetMetadata IRezolveTargetMetadata. Overrides | Improve this Doc CreateRezolveTargetBase(Type[], ConfigurationAdapterContext, IConfigurationEntry) Implementation of the abstract method from the base class of the same name. If Scoped is true, then this creates a new ScopedTarget ; if false, it creates a new SingletonTarget Declaration protected override ITarget CreateRezolveTargetBase(Type[] targetTypes, ConfigurationAdapterContext context, IConfigurationEntry entry) Parameters Type Name Description Type [] targetTypes The target types. ConfigurationAdapterContext context The context. IConfigurationEntry entry The entry. Returns Type Description ITarget Overrides"
  },
  "rezolver-api/Rezolver.Configuration.TypeReference.html": {
    "href": "rezolver-api/Rezolver.Configuration.TypeReference.html",
    "title": "Class TypeReference",
    "keywords": "Class TypeReference Concrete implementation of the TypeReferenceBase abstract class, and the default implementation of ITypeReference to use when parsing configuration. Inheritance Object TypeReferenceBase TypeReference Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class TypeReference : TypeReferenceBase, ITypeReference, IConfigurationLineInfo Constructors | Improve this Doc TypeReference(String, IConfigurationLineInfo, ITypeReference[]) Initializes a new instance of the TypeReference class. Declaration public TypeReference(string typeName, IConfigurationLineInfo lineInfo, params ITypeReference[] genericArguments) Parameters Type Name Description String typeName Name of the type. IConfigurationLineInfo lineInfo Optional. ITypeReference [] genericArguments The generic arguments. | Improve this Doc TypeReference(String, IConfigurationLineInfo, Boolean, ITypeReference[]) Declaration public TypeReference(string typeName, IConfigurationLineInfo lineInfo, bool isArray, params ITypeReference[] genericArguments) Parameters Type Name Description String typeName IConfigurationLineInfo lineInfo Boolean isArray ITypeReference [] genericArguments | Improve this Doc TypeReference(String, IConfigurationLineInfo, Boolean, Boolean, ITypeReference[]) Initializes a new instance of the TypeReference class, allowing you to create an explicitly 'unbound' type, which is expected to be replaced by whichever type is required by another component, later. Declaration public TypeReference(string typeName, IConfigurationLineInfo lineInfo, bool isArray, bool isUnbound, params ITypeReference[] genericArguments) Parameters Type Name Description String typeName Name of the type. IConfigurationLineInfo lineInfo The line information. Boolean isArray if set to true [is array]. Boolean isUnbound if set to true [is unbound]. ITypeReference [] genericArguments The generic arguments. Fields | Improve this Doc NoGenericArguments Declaration public static readonly ITypeReference[] NoGenericArguments Field Value Type Description ITypeReference [] Properties | Improve this Doc GenericArguments Declaration public override ITypeReference[] GenericArguments { get; } Property Value Type Description ITypeReference [] Overrides | Improve this Doc IsArray Declaration public override bool IsArray { get; } Property Value Type Description Boolean Overrides | Improve this Doc IsOpenGenericTypeArgument Gets a value indicating whether this instance represents an open generic type argument (e.g. the 'T' from List<T>). Declaration public override bool IsOpenGenericTypeArgument { get; } Property Value Type Description Boolean true if this instance is an open generic type argument; otherwise, false . Overrides | Improve this Doc IsUnbound Gets a value indicating whether this instance represents the Unbound special type reference. Declaration public override bool IsUnbound { get; } Property Value Type Description Boolean true if this instance is unbound; otherwise, false . Overrides | Improve this Doc OpenGenericTypeArgument The one-and-only open generic argument instance. The only way to fetch a non-derived TypeReference that returns true for IsOpenGenericTypeArgument is to use the reference from this field. Declaration public static ITypeReference OpenGenericTypeArgument { get; } Property Value Type Description ITypeReference The open generic type argument. | Improve this Doc TypeName Gets the name of the type. Declaration public override string TypeName { get; } Property Value Type Description String The name of the type. Overrides | Improve this Doc Unbound A static Unbound TypeReference that can be used in cases where a simple instance of an unbound type is required. You can also, of course, create explicitly unbound type references using the greediest constructor on this type. Declaration public static ITypeReference Unbound { get; } Property Value Type Description ITypeReference The unbound."
  },
  "rezolver-api/Rezolver.Configuration.TypeReferenceBase.html": {
    "href": "rezolver-api/Rezolver.Configuration.TypeReferenceBase.html",
    "title": "Class TypeReferenceBase",
    "keywords": "Class TypeReferenceBase abstract base class to serve as a starting point for implementing the ITypeReference interface. Inheritance Object TypeReferenceBase Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public abstract class TypeReferenceBase : ITypeReference, IConfigurationLineInfo Constructors | Improve this Doc TypeReferenceBase() Initializes a new instance of the TypeReferenceBase class. Declaration protected TypeReferenceBase() | Improve this Doc TypeReferenceBase(IConfigurationLineInfo) Initializes a new instance of the TypeReferenceBase class, copying the passed line information into this object, if provided. Declaration protected TypeReferenceBase(IConfigurationLineInfo lineInfo) Parameters Type Name Description IConfigurationLineInfo lineInfo Optional. The line information. Properties | Improve this Doc EndLineNo Gets the line number within the configuration source that sees the end of the text from which this object was parsed. Used in conjunction with EndLinePos , it allows you to zero-in on the exact ending of this parsed object. Declaration public int ? EndLineNo { get; } Property Value Type Description Nullable < Int32 > The end line number. Implements | Improve this Doc EndLinePos Gets the position from the start of the line, indicated by EndLineNo , where the configuration text ends for this parsed object. Declaration public int ? EndLinePos { get; } Property Value Type Description Nullable < Int32 > The end line position. Implements | Improve this Doc GenericArguments Any explicitly provided generic arguments are stored here. Note that it might turn out that the TypeName refers to a whole closed generic type, in which case the referenced type could still be generic even if this array is empty. It's also the case that arguments could be passed here when the root type name resolves to a non-generic type definition, in which case type resolution will likely fail. Declaration public abstract ITypeReference[] GenericArguments { get; } Property Value Type Description ITypeReference [] The generic arguments. Implements | Improve this Doc IsArray Gets a value indicating whether the type ultimately represented by this instance is an array of the type described by the rest of this instance's properties. Declaration public abstract bool IsArray { get; } Property Value Type Description Boolean true if this instance represents an array type; otherwise, false . Implements | Improve this Doc IsOpenGenericTypeArgument True if this type represents an open generic argument - this is how to explicitly reference an open generic type in a type reference: you specify a base type, then have one or more open generic arguments specified in the GenericArguments array. If all are open generic arguments, then you have created a reference to the fully open generic type. You only need to provide all-open arguments if the base TypeName could be ambiguous between a non generic and generic type, or there are multiple generic types with the same base name. Equally, you can do this to create references to partially open generics, which may or may not be supported by the adapter or the target that is built. Declaration public abstract bool IsOpenGenericTypeArgument { get; } Property Value Type Description Boolean true if this instance is open generic type argument; otherwise, false . Implements | Improve this Doc IsUnbound Gets a value indicating whether this instance represents a type that is to be late-bound for a specific target type. Declaration public abstract bool IsUnbound { get; } Property Value Type Description Boolean true if this instance is unbound; otherwise, false . Implements | Improve this Doc StartLineNo Gets the line number within the configuration source that contains the start of the text from which this object was parsed. Used in conjunction with StartLinePos , it allows you to zero-in on the exact starting point of this parsed object. Declaration public int ? StartLineNo { get; } Property Value Type Description Nullable < Int32 > The start line number. Implements | Improve this Doc StartLinePos Gets the position from the start of the line, indicated by StartLineNo , where the configuration text begins for this parsed object. Declaration public int ? StartLinePos { get; } Property Value Type Description Nullable < Int32 > The start line position. Implements | Improve this Doc TypeName The root type name. Declaration public abstract string TypeName { get; } Property Value Type Description String The name of the type. Implements Methods | Improve this Doc ToString() Produces a string representation of the type name, including generic arguments. Please note - this is not intended to produce a type name that can be fed to System.Type.GetType, even if occasionally it does. Declaration public override string ToString() Returns Type Description String Overrides"
  },
  "rezolver-api/Rezolver.Configuration.TypeRegistrationEntry.html": {
    "href": "rezolver-api/Rezolver.Configuration.TypeRegistrationEntry.html",
    "title": "Class TypeRegistrationEntry",
    "keywords": "Class TypeRegistrationEntry Inheritance Object ConfigurationEntryBase TypeRegistrationEntry Inherited Members Namespace :Rezolver.Configuration Assembly :cs.temp.dll.dll Syntax public class TypeRegistrationEntry : ConfigurationEntryBase, ITypeRegistrationEntry, IConfigurationEntry, IConfigurationLineInfo Constructors | Improve this Doc TypeRegistrationEntry(ITypeReference[], IRezolveTargetMetadata, Boolean, IConfigurationLineInfo) Declaration public TypeRegistrationEntry(ITypeReference[] types, IRezolveTargetMetadata targetMetadata, bool isMultipleRegistration, IConfigurationLineInfo lineInfo = null) Parameters Type Name Description ITypeReference [] types IRezolveTargetMetadata targetMetadata Boolean isMultipleRegistration IConfigurationLineInfo lineInfo Properties | Improve this Doc IsMultipleRegistration Declaration public bool IsMultipleRegistration { get; } Property Value Type Description Boolean Implements | Improve this Doc TargetMetadata Declaration public IRezolveTargetMetadata TargetMetadata { get; } Property Value Type Description IRezolveTargetMetadata Implements | Improve this Doc Types Declaration public ITypeReference[] Types { get; } Property Value Type Description ITypeReference [] Implements"
  },
  "rezolver-api/Rezolver.Configuration.html": {
    "href": "rezolver-api/Rezolver.Configuration.html",
    "title": "Namespace Rezolver.Configuration",
    "keywords": "Namespace Rezolver.Configuration Classes Standard implementation of the IConfigurationAdapter interface. Used by the ConfigurationAdapter class to sort configuration entries for processing. It ensures that Assembly Reference entries are given priority, followed by Namespace Imports, and then finally all the rest. This class is used to store the intermediate state for the default IConfigurationAdapter implementation's ( ConfigurationAdapter ) parsing operation on an IConfiguration instance. If you are extending the default adapter you might need also to extend this class to ensure any additional state you require is maintained. Used as a sentinel type by the ResolveType(String, Nullable<Int32>) method when the type search fails. The standard Singleton implementation of the IConfigurationAdapterContextFactory interface, and one which you can use as the starting point of your own factory. By default, it creates a new instance of the ConfigurationAdapterContext class (using the virtual method CreateContext(ConfigurationAdapter, IConfiguration) , and then instructs it to add its default assembly references. suggested starting point for implementing your own configuration entries. Standard implementation of the IListTargetMetadata interface. Standard implementation of ObjectTargetMetadataBase , to encapsulate object references that are to be baked into a container as targets. Abstract base class for metadata that builds an object target. The basic workhorse of a parsed configuration - an instruction to register a target in an IRezolveTargetContainer instance against one or more types with a given name. Similar to the RegisterInstruction except this specifically wraps the method. Construction is largely identical, except where in the aforementioned class you pass a single target, here you pass multiple targets in a list. An instruction to perform an operation on a container builder from an IConfigurationEntry that's been parsed from a configuration source (and which has been retrieved from an IConfiguration instance). Suggested base class for implementations of IRezolveTargetMetadata . An ITypeReference that has been built directly from a runtime type. Concrete implementation of the TypeReferenceBase abstract class, and the default implementation of ITypeReference to use when parsing configuration. abstract base class to serve as a starting point for implementing the ITypeReference interface. Interfaces A configuration entry instructing the configuration adapter to load an assembly before resolving types. Represents an object that is responsible for transforming configuration data into target containers. Used by this library's default implementation of IConfigurationAdapter, the ConfigurationAdapter class, to create an instance of the ConfigurationAdapterContext class for a given adapter that's processing a given configuration. Interface for an error that originates from a configuration file. Encapsulates information about where a particular object, parsed from a configuration file, can be found. Configuration metadata for building a ListTarget in a RezolverBuilder. Interface for metadata for constructing an ObjectTarget IRezolveTarget. Represents an instruction to create an IRezolveTarget from parsed configuration. Represents a list of IRezolveTargetMetadata instances - for when you want to register multiple targets against a single type. Note - although the interface IRezolveTargetMetadata is included by this interface, instances are not expected to be able to create a single target through the CreateRezolveTarget method - because by definition, multiple targets are produced by this. Use the CreateRezolveTargets method instead. The Bind method, however, will be expected to produce a new instance of the implementing type if any underlying targets are not bound to a specific type. Interface for Singleton metadata. Captures a reference to a type made in a configuration file. It does not guarantee that the type can be located, it simply provides a common interface for storing the type information written in a configuration file. An IConfigurationAdapter instance will need to resolve the actual runtime type from this when registering targets from a configuration file. Represents an instruction to register one or more targets in an ITargetContainer against one or more types. Think of it as wrapping a single call to one of the builder's Register methods. Enums Types of configuration entry that can be parsed from a configuration file Types of IRezolveTargetMetadata that can be expressed in configuration"
  },
  "rezolver-api/Rezolver.ConstructorBinding.html": {
    "href": "rezolver-api/Rezolver.ConstructorBinding.html",
    "title": "Class ConstructorBinding",
    "keywords": "Class ConstructorBinding Represents a binding specifically to a class constructor, optionally with an additional set of MemberBindings to be used to initialise a new instance's properties or fields directly. Inheritance Object MethodBinding ConstructorBinding Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ConstructorBinding : MethodBinding Constructors | Improve this Doc ConstructorBinding(ConstructorInfo, ParameterBinding[], MemberBinding[]) Initializes a new instance of the ConstructorBinding class. Declaration public ConstructorBinding(ConstructorInfo constructor, ParameterBinding[] boundArgs = null, MemberBinding[] memberBindings = null) Parameters Type Name Description ConstructorInfo constructor The constructor to be used . ParameterBinding [] boundArgs Optional. The bound arguments. Can be null or empty. MemberBinding [] memberBindings Optional. The bindings for the members of the new instance created by the constructor. Fields | Improve this Doc NoBoundMembers An empty array of MemberBinding objects used to represent a constructor binding with no bound members. The MemberBindings property will be set to this if the constructor is called with a null memberBindings argument. Declaration public static MemberBinding[] NoBoundMembers Field Value Type Description MemberBinding [] Properties | Improve this Doc Constructor Gets the constructor to be invoked. Note that this simply returns the base Method property cast to . Declaration public ConstructorInfo Constructor { get; } Property Value Type Description ConstructorInfo The constructor. | Improve this Doc MemberBindings Gets the member bindings to be applied to the new instance created by the Constructor Declaration public MemberBinding[] MemberBindings { get; } Property Value Type Description MemberBinding [] The member bindings. Remarks Member bindings represent the inline initialisation of writable properties or fields immediately after constructing a new instance of a type. See Also MethodBinding"
  },
  "rezolver-api/Rezolver.ConstructorTarget.html": {
    "href": "rezolver-api/Rezolver.ConstructorTarget.html",
    "title": "Class ConstructorTarget",
    "keywords": "Class ConstructorTarget A target that binds to a type's constructor with zero or more arguments supplied by other ITarget s and, optionally binding to the new instance's writeable properties. The target supports en explicitly supplied constructor, as well as just-in-time lookups for the best available constructor based on the available services and/or any named arguments which might been provided up front. Inheritance Object TargetBase ConstructorTarget Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ConstructorTarget : TargetBase, ITarget Remarks Although you can create this target directly through the Rezolver.ConstructorTarget.#ctor(System.Type,ConstructorInfo,Rezolver.IMemberBindingBehaviour,Rezolver.ParameterBinding[],System.Collections.Generic.IDictionary{System.String,Rezolver.ITarget}) constructor, you're more likely to create it through factory methods such as Auto<T>(IMemberBindingBehaviour) or, more likely still, extension methods such as RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) during your application's container setup phase. To compile this target, an ITargetCompiler must call the Bind(ICompileContext) method Constructors | Improve this Doc ConstructorTarget(ConstructorInfo, IMemberBindingBehaviour, ParameterBinding[]) Initializes a new instance of the ConstructorTarget class bound in advance to a specific constructor. Declaration public ConstructorTarget(ConstructorInfo ctor, IMemberBindingBehaviour memberBindingBehaviour = null, ParameterBinding[] parameterBindings = null) Parameters Type Name Description ConstructorInfo ctor Required - the constructor that is to be bound. The DeclaredType of the new instance will be set to the of this object. IMemberBindingBehaviour memberBindingBehaviour Optional. If provided, can be used to select properties which are to be initialised before the new instance is returned. ParameterBinding [] parameterBindings Optional. Specific bindings for the parameters of the given ctor which should be used during code generation. Note that this array can contain fewer or more entries than there are parameters on the ctor . Any missing bindings will be automatically generated when Bind(ICompileContext) is called. | Improve this Doc ConstructorTarget(Type, IMemberBindingBehaviour, IDictionary<String, ITarget>) Initializes a just-in-time-bound instance of the ConstructorTarget class which must be bound to the best constructor at compile-time by calling the Bind(ICompileContext) method. Declaration public ConstructorTarget(Type type, IMemberBindingBehaviour memberBindingBehaviour = null, IDictionary<string, ITarget> namedArgs = null) Parameters Type Name Description Type type Required. The type whose constructor is to bound. IMemberBindingBehaviour memberBindingBehaviour Optional. If provided, can be used to select properties which are to be initialised before the new instance is returned. IDictionary < String , ITarget > namedArgs Optional. The named arguments which will be passed to, and used to find, the best-matched constructor. These are taken into account when the constructor is sought - with the constructor containing the most matched parameters matched being selected. Remarks To compile this target, a ITargetCompiler first calls the Bind(ICompileContext) method to discover the constructor to be executed, along with the final set of arguments to be provided to it (see ConstructorBinding ). The best available constructor is defined as the constructor with the most parameters for which arguments can be resolved from the ICompileContext at compile-time to the fewest number of ITarget objects whose UseFallback is false. Properties | Improve this Doc Ctor Can be null. Gets the constructor that this target is bound to, if it was known when the target was created. Declaration public ConstructorInfo Ctor { get; } Property Value Type Description ConstructorInfo Remarks ConstructorTargets can be bound to a particular constructor in advance, or they can search for a best-match constructor at the point where Bind(ICompileContext) is called. This property will only be set ultimately if it was passed to the ConstructorTarget(ConstructorInfo, IMemberBindingBehaviour, ParameterBinding[]) constructor, possibly by a factory method like WithArgs(ConstructorInfo, IDictionary<String, ITarget>) , or FromNewExpression(Type, NewExpression) , where the constructor is captured within the expression. | Improve this Doc DeclaredType Implementation of DeclaredType . Always equal to the type whose constructor will be bound by this target. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc MemberBindingBehaviour Gets the member binding behaviour to be used when Bind(ICompileContext) is called. Declaration public IMemberBindingBehaviour MemberBindingBehaviour { get; } Property Value Type Description IMemberBindingBehaviour | Improve this Doc NamedArgs Named arguments (as ITarget objects) to be supplied to the object on construction, also aiding the search for a constructor. This equivalent to the way that languages such as C# can bind to overloaded functions based solely on named arguments. Declaration public IReadOnlyDictionary<string, ITarget> NamedArgs { get; } Property Value Type Description IReadOnlyDictionary < String , ITarget > Remarks Note the difference between this and ParameterBindings - this property might be used when the constructor is not known in advance, whereas ParameterBindings is used when it is. | Improve this Doc ParameterBindings If this target was created with a specific constructor then this might contain argument bindings for that constructor's parameters. Declaration public IReadOnlyList<ParameterBinding> ParameterBindings { get; } Property Value Type Description IReadOnlyList < ParameterBinding > Remarks This is not the same as NamedArgs - as is noted by the documentation on that property. This property is for when the constructor is known in advance and when certain parameters are to be bound with specific arguments; whereas NamedArgs is for when the constructor is not known. Methods | Improve this Doc Auto(Type, IMemberBindingBehaviour) Creates a late bound ConstructorTarget or GenericConstructorTarget for the given type . Declaration public static ITarget Auto(Type type, IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description Type type The type that is to be constructed when this target is compiled and executed. IMemberBindingBehaviour memberBindingBehaviour Optional. An object which selects properties on the new instance which are to be bound from the container. Returns Type Description ITarget Either a ConstructorTarget or GenericConstructorTarget , depending on whether the type is a generic type definition. Remarks This factory is merely a shortcut for calling the ConstructorTarget(Type, IMemberBindingBehaviour, IDictionary<String, ITarget>) with only the type and memberBindingBehaviour arguments supplied. When creating a GenericConstructorTarget , the function uses the GenericConstructorTarget(Type, IMemberBindingBehaviour) constructor. | Improve this Doc Auto<T>(IMemberBindingBehaviour) Generic version of the Auto(Type, IMemberBindingBehaviour) method. Declaration public static ITarget Auto<T>(IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description IMemberBindingBehaviour memberBindingBehaviour See the documentation for the memberBindingBehaviour parameter on the non-generic version of this method. Returns Type Description ITarget Either a ConstructorTarget or GenericConstructorTarget , depending on whether T is a generic type definition. Type Parameters Name Description T The type that is to be constructed when the new target is compiled and executed. | Improve this Doc Bind(ICompileContext) Gets the ConstructorBinding for the DeclaredType using the targets available in the context for dependency lookup. The constructor is either resolved by checking available targets for the best match, or is pre-selected on construction ( Ctor will be non-null in this case). Declaration public ConstructorBinding Bind(ICompileContext context) Parameters Type Name Description ICompileContext context The current compilation context. Returns Type Description ConstructorBinding Exceptions Type Condition InvalidOperationException If no sutiable constructors can be found. | Improve this Doc FromNewExpression(Type, NewExpression) Non-generic version of FromNewExpression<T>(Expression<Func<T>>) . See the documentation on that method for more. Declaration public static ITarget FromNewExpression(Type declaredType, NewExpression newExpr) Parameters Type Name Description Type declaredType The of the object to be created by the new ConstructorTarget NewExpression newExpr An expression from which the target can be built - parameter bindings and the specific constructor called in the expression will be used to seed the new target. Returns Type Description ITarget | Improve this Doc FromNewExpression<T>(Expression<Func<T>>) Creates a new ConstructorTarget from the passed lambda expression (whose must be a ) Declaration public static ITarget FromNewExpression<T>(Expression<Func<T>> newExpr) Parameters Type Name Description Expression < Func <T>> newExpr Required. The expression from which to create the target. Returns Type Description ITarget An ITarget which, when compiled, will perform that same construction as provided in the given expression. Type Parameters Name Description T The type of the object to be created by the new ConstructorTarget Remarks This method does not support member binding expressions - e.g. c => new MyObject() { A = \"hello\" } - these can be converted into targets - for these you should construct an ExpressionTarget and let the compiler do the rest. When providing custom expressions to be used as targets in an ITargetContainer , it is possible to explicitly define properties/arguments as being resolved from the container itself, in exactly the same way as generated by the other factory methods such as Auto<T>(IMemberBindingBehaviour) and RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) . To do this, simply call the Resolve<T>() function on the object passed into your expression (see the signature of the lambda newExpr ), and Rezolver will convert that call into a RezolvedTarget . Exceptions Type Condition ArgumentNullException If newExpr is null. ArgumentException If the newExpr does not have a NewExpression as its root (Body) node, or if the type of that expression does not equal T | Improve this Doc WithArgs(ConstructorInfo, IDictionary<String, ITarget>) Similar to WithArgs(Type, IDictionary<String, ITarget>) except this one creates a ConstructorTarget that is specifically bound to a particular constructor on a given type, using any matched argument bindings from the provided namedArgs dictionary, and using RezolvedTarget targets for any that are not matched. Declaration public static ITarget WithArgs(ConstructorInfo ctor, IDictionary<string, ITarget> namedArgs) Parameters Type Name Description ConstructorInfo ctor Required. The constructor to be bound. IDictionary < String , ITarget > namedArgs Optional. Any arguments to be supplied to parameters on the ctor by name. Any parameters for which matches are not found in this dictionary will be automatically bound either from compile-time defaults or by resolving those types dynamically. Returns Type Description ITarget Remarks Although this overload accepts a dictionary of arguments, note that it will not result in the NamedArgs property being set on the target that is created - it's just an alternative for deriving the ParameterBindings with which the target will be created. Also, this function will not fail if the args dictionary contains named arguments that cannot be matched to parameters on the ctor . | Improve this Doc WithArgs(ConstructorInfo, Object) Performs the same operation as WithArgs(ConstructorInfo, IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration public static ITarget WithArgs(ConstructorInfo ctor, object namedArgs) Parameters Type Name Description ConstructorInfo ctor Required. The constructor to be bound. Object namedArgs An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Remarks Although this overload accepts a dictionary of arguments, note that it will not result in the NamedArgs property being set on the target that is created - it's just an alternative for deriving the ParameterBindings with which the target will be created. Also, this function will not fail if the args dictionary contains named arguments that cannot be matched to parameters on the ctor . | Improve this Doc WithArgs(Type, IDictionary<String, ITarget>) Non-generic version of WithArgs<T>(IDictionary<String, ITarget>) . Creates a ConstructorTarget with a set of named targets which will be used like named arguments to late-bind the constructor when code-generation occurs. Declaration public static ITarget WithArgs(Type declaredType, IDictionary<string, ITarget> namedArgs) Parameters Type Name Description Type declaredType The type whose constructor is to be bound. IDictionary < String , ITarget > namedArgs The named arguments to be used when building the expression. Returns Type Description ITarget Remarks Both versions of this method will create a target which will try to find the best-matching constructor where all of the named arguments match, and with the fewest number of auto-resolved arguments. So, a class with a constructor such as Foo(IService1 s1, IService2 s2) Can happily be bound if you only provide a named argument for 's1'; the target will simply attempt to auto-resolve the argument for the IService2 s2 parameter when constructing the object - and will fail only if it can't be resolved at that point. | Improve this Doc WithArgs(Type, Object) Performs the same operation as WithArgs(Type, IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration public static ITarget WithArgs(Type declaredType, object namedArgs) Parameters Type Name Description Type declaredType The type whose constructor is to be bound. Object namedArgs An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Remarks This overload exists to simplify the process of creating a ConstructorTarget with argument bindings by removing the need to create an argument dictionary in advance. An anonymous type can instead be used to supply the arguments. Examples This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a ConstructorTarget for the type 'MyType': ConstructorTarget.WithArgs(typeof(MyType), new { param1 = new ObjectTarget(\"Hello World\") }); | Improve this Doc WithArgs<T>(IDictionary<String, ITarget>) Creates a ConstructorTarget with a set of named targets which will be used like named arguments to late-bind the constructor when code-generation occurs. Declaration public static ITarget WithArgs<T>(IDictionary<string, ITarget> namedArgs) Parameters Type Name Description IDictionary < String , ITarget > namedArgs The named arguments to be used when building the expression. Returns Type Description ITarget Type Parameters Name Description T The type whose constructor is to be bound Remarks Both versions of this method will create a target which will try to find the best-matching constructor where all of the named arguments match, and with the fewest number of auto-resolved arguments. So, a class with a constructor such as Foo(IService1 s1, IService2 s2) Can happily be bound if you only provide a named argument for 's1'; the target will simply attempt to auto-resolve the argument for the IService2 s2 parameter when constructing the object - and will fail only if it can't be resolved at that point. | Improve this Doc WithArgs<T>(Object) Performs the same operation as WithArgs<T>(IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration public static ITarget WithArgs<T>(object namedArgs) Parameters Type Name Description Object namedArgs An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Type Parameters Name Description T Remarks This overload exists to simplify the process of creating a ConstructorTarget with argument bindings by removing the need to create an argument dictionary in advance. An anonymous type can instead be used to supply the arguments. Examples This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a ConstructorTarget for the type 'MyType': ConstructorTarget.WithArgs<MyType>(new { param1 = new ObjectTarget(\"Hello World\") });"
  },
  "rezolver-api/Rezolver.Container.html": {
    "href": "rezolver-api/Rezolver.Container.html",
    "title": "Class Container",
    "keywords": "Class Container The standard IOC container class in Rezolver. Inheritance Object ContainerBase CachingContainerBase Container Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class Container : CachingContainerBase, IContainer, IServiceProvider, ITargetContainer Remarks All of this class' functionality is inherited through CachingContainerBase and its base classes. Note that it doesn't implement lifetime scoping (although you can create a lifetime scope from it by calling its CreateScope() method). Also note that the class implements ITargetContainer through its ContainerBase base (which merely wraps around the Targets property. The reason for this is simplicity: in many applications, you'll want to simply create a new container, register services into it, and then start using it. Constructors | Improve this Doc Container(ICompilerConfigurationProvider) Constructs a new instance of the Container class using a default empty ITargetContainer Declaration public Container(ICompilerConfigurationProvider compilerConfig) Parameters Type Name Description ICompilerConfigurationProvider compilerConfig An object which will be used to configure this container and its targets to use a specific compilation strategy. If null , then the DefaultProvider provider will be used. | Improve this Doc Container(ITargetContainer) Constructs a new instance of the Container class using the given target container and the default compiler configuration ( DefaultProvider ). Declaration public Container(ITargetContainer targets) Parameters Type Name Description ITargetContainer targets The targets that will be used to resolve objects. If left null, then a new, empty, target container will be constructed. | Improve this Doc Container(ITargetContainer, ICompilerConfigurationProvider) Constructs a new instance of the Container class. Declaration public Container(ITargetContainer targets = null, ICompilerConfigurationProvider compilerConfig = null) Parameters Type Name Description ITargetContainer targets Optional. The targets that will be used to resolve objects. If left null, then a new, empty, target container will be constructed. ICompilerConfigurationProvider compilerConfig Optional. An object which will be used to configure this container and its targets to use a specific compilation strategy. If null , then the DefaultProvider provider will be used."
  },
  "rezolver-api/Rezolver.ContainerBase.DirectResolveCompiledTarget.html": {
    "href": "rezolver-api/Rezolver.ContainerBase.DirectResolveCompiledTarget.html",
    "title": "Class ContainerBase.DirectResolveCompiledTarget",
    "keywords": "Class ContainerBase.DirectResolveCompiledTarget Used when an ITarget is also of the same type as the one for which it is returned by the Fetch(Type) method of the Targets container. In this case, the target is not compiled, but instead is simply returned as the desired object. Inheritance Object ContainerBase.DirectResolveCompiledTarget Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax protected class DirectResolveCompiledTarget : ICompiledTarget Constructors | Improve this Doc DirectResolveCompiledTarget(ITarget) Constructs a new instance of the ContainerBase.DirectResolveCompiledTarget Declaration public DirectResolveCompiledTarget(ITarget target) Parameters Type Name Description ITarget target Methods | Improve this Doc GetObject(ResolveContext) Implementation of GetObject(ResolveContext) - simply returns the target with which this instance was constructed. Declaration public object GetObject(ResolveContext context) Parameters Type Name Description ResolveContext context ignored Returns Type Description Object Implements"
  },
  "rezolver-api/Rezolver.ContainerBase.MissingCompiledTarget.html": {
    "href": "rezolver-api/Rezolver.ContainerBase.MissingCompiledTarget.html",
    "title": "Class ContainerBase.MissingCompiledTarget",
    "keywords": "Class ContainerBase.MissingCompiledTarget Used as a sentinel type when a type cannot be resolved by a ContainerBase instance. Instead of returning a null ICompiledTarget instance, the container will construct an instance of this type (typically through GetMissingTarget(Type) , which caches singleton instances of this class on a per-type basis) which can then be used just as if the lookup succeeded. Inheritance Object ContainerBase.MissingCompiledTarget Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax protected class MissingCompiledTarget : ICompiledTarget Remarks The GetObject(ResolveContext) always throws an InvalidOperationException with the message 'Could resolve type [[type]]' Constructors | Improve this Doc MissingCompiledTarget(Type) Constructs a new instance of the ContainerBase.MissingCompiledTarget class. Declaration public MissingCompiledTarget(Type type) Parameters Type Name Description Type type Methods | Improve this Doc GetObject(ResolveContext) Implementation of GetObject(ResolveContext) . Always throws an InvalidOperationException . Declaration public object GetObject(ResolveContext context) Parameters Type Name Description ResolveContext context The current rezolve context. Returns Type Description Object Implements Exceptions Type Condition InvalidOperationException Always thrown. See Also ICompiledTarget"
  },
  "rezolver-api/Rezolver.ContainerBase.html": {
    "href": "rezolver-api/Rezolver.ContainerBase.html",
    "title": "Class ContainerBase",
    "keywords": "Class ContainerBase Starting point for implementations of IContainer - only creatable through inheritance. Inheritance Object ContainerBase Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ContainerBase : IContainer, IServiceProvider, ITargetContainer Remarks This class also implements ITargetContainer by proxying the Targets that are provided to it on construction (or created anew if not supplied). All of those interface methods are implemented explicitly except the Register(ITarget, Type) method, which is available through the class' public API. Note: IContainer s are generally not expected to implement ITargetContainer , and the framework will never assume they do. The reason this class does is to make it easier to create a new container and to register targets into it without having to worry about managing a separate ITargetContainer instance in your application root - because all the registration extension methods defined in classes like RegisterTypeTargetContainerExtensions , SingletonTargetDictionaryExtensions plus many more will be available to developers in code which has a reference to this class, or one derived from it. Note also that calling CombineWith(ITargetContainer, Type) on an instance of this type will always cause a NotSupportedException to be thrown. Constructors | Improve this Doc ContainerBase(ITargetContainer, ICompilerConfigurationProvider) Constructs a new instance of the ContainerBase , optionally initialising it with the given targets and compilerConfig Declaration protected ContainerBase(ITargetContainer targets = null, ICompilerConfigurationProvider compilerConfig = null) Parameters Type Name Description ITargetContainer targets Optional. The target container whose registrations will be used for dependency lookup when Resolve(ResolveContext) (and other operations) is called. If not provided, a new TargetContainer instance is constructed. This will ultimately be available to inherited types, after construction, through the Targets property. ICompilerConfigurationProvider compilerConfig Optional. An object which will be used to configure this container and its targets to use a specific compilation strategy. If null , then the DefaultProvider provider will be used. Properties | Improve this Doc NoChangeCompilerConfiguration Gets the compiler configuration provider to be passed when a derived container does not want the DefaultProvider provider to be used if one is not passed on construction. This provider is guaranteed not to add/modify any registrations in the underlying target container which are connected with compilation. Declaration protected static ICompilerConfigurationProvider NoChangeCompilerConfiguration { get; } Property Value Type Description ICompilerConfigurationProvider | Improve this Doc Targets Provides the ITarget instances that will be compiled into ICompiledTarget instances. Declaration protected ITargetContainer Targets { get; } Property Value Type Description ITargetContainer Remarks Notes to implementers: This property must NEVER be null. This class implements the ITargetContainer interface by wrapping around this instance so that an application can create an instance of ContainerBase and directly register targets into it; rather than having to create and setup the target container first. You can add registrations to this target container at any point in the lifetime of any ContainerBase instances which are attached to it. In reality, however, if any Resolve(ResolveContext) operations have been performed prior to adding more registrations, then there's no guarantee that new dependencies will be picked up - especially if the CachingContainerBase is being used as your application's container (which it nearly always will be). Methods | Improve this Doc CanResolve(ResolveContext) Implementation of the CanResolve(ResolveContext) method. Returns true if, and only if, the Targets ITargetContainer returns a non-null ITarget when the RequestedType is passed to its Fetch(Type) method. Declaration public virtual bool CanResolve(ResolveContext context) Parameters Type Name Description ResolveContext context The resolve context containing the requested type. Returns Type Description Boolean Implements | Improve this Doc CreateScope() Implementation of the CreateScope() method. The base definition creates a ContainerScope with this container passed as the scope's container. Thus, the new scope is a 'root' scope. Declaration public virtual IContainerScope CreateScope() Returns Type Description IContainerScope Implements | Improve this Doc FetchCompiled(ResolveContext) Base implementation of FetchCompiled(ResolveContext) . Note that any container already defined in the Container is ignored in favour of this container. Declaration public virtual ICompiledTarget FetchCompiled(ResolveContext context) Parameters Type Name Description ResolveContext context The context containing the requested type and any scope which is currently in force. Returns Type Description ICompiledTarget Always returns a reference to a compiled target - but note that if CanResolve(ResolveContext) returns false for the same context, then the target's GetObject(ResolveContext) method will likely throw an exception - in line with the behaviour of the ContainerBase.MissingCompiledTarget class' behaviour. Implements | Improve this Doc GetCompiledRezolveTarget(ResolveContext) The main workhorse of the resolve process - obtains an ICompiledTarget for the given context by looking up an ITarget from the Targets target container, then compiling it. Declaration protected virtual ICompiledTarget GetCompiledRezolveTarget(ResolveContext context) Parameters Type Name Description ResolveContext context The current resolve context Returns Type Description ICompiledTarget Remarks The specifics of how this process works are not important if you simply want to use the container, but if you are looking to extend it, then it's essential you understand the different steps that the process goes through. If the Fetch(Type) method of the Targets target container returns a null ITarget , or one which has its UseFallback set to true , then the method gets an alternative compiled target by calling the GetFallbackCompiledRezolveTarget(ResolveContext) method. This fallback compiled target will be used instead of compiling the target unless the target was not null and its UseFallback is true AND the compiled target returned by the fallback method is a ContainerBase.MissingCompiledTarget - in which case the fallback target will be compiled as normal. Before proceeding with compilation, the container checks whether the target can resolve the required object directly. This means that the target either implements the ICompiledTarget interface (in which case it is immediately returned) or the RequestedType is not Object and the target's type is compatible with it (in which case the target is simply embedded in a new ContainerBase.DirectResolveCompiledTarget , which will later just return the target when its GetObject(ResolveContext) is called). The supports the ICompiledTarget interface, therefore any objects which are directly registered through this target will always use that class' implementation of ICompiledTarget if requested through the Resolve(ResolveContext) method. Once the decision has been taken to compile the target, the container first needs a compiler ( ITargetCompiler ) and a compile context provider ( ICompileContextProvider ). Note that classes which implement the ITargetCompiler interface also frequently implement the ICompileContextProvider interface so that any additional state they require is correctly attached to the ICompileContext which will be fed to their CompileTarget(ITarget, ICompileContext) implementation. These are both obtained by resolving them directly from the Container of the context (since a container can be delegated to from another container which originally received the Resolve(ResolveContext) call). Attentive readers will realise at this point that this could lead to an infinite recursion - i.e. since compiling a target means resolving a compiler, which in turn must mean compiling that target. The class sidesteps this potential pitfall by requiring that the targets registered for these types support direct resolving, as per the description a couple of paragraphs back. Therefore, compilers and context providers are typically registered as objects via the target. Finally, a new ICompileContext is created via the CreateContext(ResolveContext, ITargetContainer, IContainer) method of the resolved context provider, and then passed to the CompileTarget(ITarget, ICompileContext) method of the resolved compiler. The result of that operation is then returned to the caller. | Improve this Doc GetFallbackCompiledRezolveTarget(ResolveContext) Called by GetCompiledRezolveTarget(ResolveContext) if no valid ITarget can be found for the context or if the one found has its UseFallback property set to true . Declaration protected virtual ICompiledTarget GetFallbackCompiledRezolveTarget(ResolveContext context) Parameters Type Name Description ResolveContext context Returns Type Description ICompiledTarget An ICompiledTarget to be used as the result of a Resolve(ResolveContext) operation where the search for a valid target either fails or is inconclusive (e.g. - empty enumerables). Remarks The base implementation always returns an instance of the ContainerBase.MissingCompiledTarget via the GetMissingTarget(Type) static method. | Improve this Doc GetMissingTarget(Type) Gets an ICompiledTarget for the given type which will always throw an InvalidOperationException whenever its GetObject(ResolveContext) method is called. Use this when you can't resolve a target for a type. Declaration protected static ICompiledTarget GetMissingTarget(Type type) Parameters Type Name Description Type type The type for which you wish to create a missing target. Returns Type Description ICompiledTarget | Improve this Doc GetService(Type) Protected virtual implementation of GetService(Type) . Uses the TryResolve(ResolveContext, out Object) method to resolve the service, returning null if the operation fails. Declaration protected virtual object GetService(Type serviceType) Parameters Type Name Description Type serviceType Type of service to be resolved. Returns Type Description Object | Improve this Doc IsMissingTarget(ICompiledTarget) Determines whether the given target is an instance of ContainerBase.MissingCompiledTarget . Declaration protected static bool IsMissingTarget(ICompiledTarget target) Parameters Type Name Description ICompiledTarget target The target. Returns Type Description Boolean | Improve this Doc Register(ITarget, Type) Implementation of Register(ITarget, Type) - simply proxies the call to the target container referenced by the Targets property. Declaration public void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target Type serviceType Implements Remarks Remember: registering new targets into an ITargetContainer after an IContainer has started compiling targets within it can yield unpredictable results. If you create a new container and perform all your registrations before you use it, however, then everything will work as expected. Note also the other ITargetContainer interface methods are implemented explicitly so as to hide them from the list of class members. | Improve this Doc Resolve(ResolveContext) Implementation of the Resolve(ResolveContext) method. Obtains an ICompiledTarget by calling the GetCompiledRezolveTarget(ResolveContext) method, and then immediately calls its GetObject(ResolveContext) method, returning the result. Declaration public virtual object Resolve(ResolveContext context) Parameters Type Name Description ResolveContext context The context containing the type that's requested, any active scope and so on. Returns Type Description Object Implements | Improve this Doc TryResolve(ResolveContext, out Object) Implementation of the TryResolve(ResolveContext, out Object) method. Attempts to resolve the requested type (given on the context , returning a boolean indicating whether the operation was successful. If successful, then result receives a reference to the resolved object. Declaration public virtual bool TryResolve(ResolveContext context, out object result) Parameters Type Name Description ResolveContext context The context containing the type that's requested, any active scope and so on. Object result Receives a reference to the object that was resolved, if successful, or null if not. Returns Type Description Boolean A boolean indicating whether the operation completed successfully. Implements Explicit Interface Implementations | Improve this Doc ITargetContainer.CombineWith(ITargetContainer, Type) Declaration ITargetContainer ITargetContainer.CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Type type Returns Type Description ITargetContainer Implements | Improve this Doc ITargetContainer.Fetch(Type) Declaration ITarget ITargetContainer.Fetch(Type type) Parameters Type Name Description Type type Returns Type Description ITarget Implements | Improve this Doc ITargetContainer.FetchAll(Type) Declaration IEnumerable<ITarget> ITargetContainer.FetchAll(Type type) Parameters Type Name Description Type type Returns Type Description IEnumerable < ITarget > Implements | Improve this Doc IServiceProvider.GetService(Type) Declaration object IServiceProvider.GetService(Type serviceType) Parameters Type Name Description Type serviceType Returns Type Description Object Implements"
  },
  "rezolver-api/Rezolver.ContainerRezolveExtensions.html": {
    "href": "rezolver-api/Rezolver.ContainerRezolveExtensions.html",
    "title": "Class ContainerRezolveExtensions",
    "keywords": "Class ContainerRezolveExtensions Extension methods for IContainer which provide shortcuts for the Resolve(ResolveContext) operation. Inheritance Object ContainerRezolveExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ContainerRezolveExtensions Methods | Improve this Doc Resolve(IContainer, Type) Resolves an object of the given type Declaration public static object Resolve(this IContainer container, Type type) Parameters Type Name Description IContainer container The container. Type type The type to be resolved. Returns Type Description Object An instance of the type . | Improve this Doc Resolve<TObject>(IContainer) Resolves an object of type TObject Declaration public static TObject Resolve<TObject>(this IContainer container) Parameters Type Name Description IContainer container The container. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject The type to be resolved. | Improve this Doc TryResolve(IContainer, Type, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer container, Type type, out object result) Parameters Type Name Description IContainer container The container. Type type The type to be resolved. Object result Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type) overloads | Improve this Doc TryResolve<TObject>(IContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer container, out TObject result) Parameters Type Name Description IContainer container The container. TObject result Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved."
  },
  "rezolver-api/Rezolver.ContainerScope.html": {
    "href": "rezolver-api/Rezolver.ContainerScope.html",
    "title": "Class ContainerScope",
    "keywords": "Class ContainerScope Standard implementation of the IContainerScope interface. Inheritance Object ContainerScope Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ContainerScope : IContainerScope, IDisposable, IServiceProvider Constructors | Improve this Doc ContainerScope(IContainer) Creates a new root scope tied to the given container Declaration public ContainerScope(IContainer container) Parameters Type Name Description IContainer container | Improve this Doc ContainerScope(IContainerScope, IContainer) Creates a new container that is a child of another. The Container will be inherited from the parentScope by default, unless it's overriden by containerOverride . Declaration public ContainerScope(IContainerScope parentScope, IContainer containerOverride = null) Parameters Type Name Description IContainerScope parentScope Required - the parent scope IContainer containerOverride Optional - the container which should be used for resolve operations executed against this scope (note - all the resolve methods are declared as extension methods which mirror those present on IContainer . Properties | Improve this Doc Container The container that this scope is tied to. All standard resolve operations should be made against this container. Declaration public IContainer Container { get; } Property Value Type Description IContainer The container. Implements | Improve this Doc Disposed Gets a value indicating whether this ContainerScope is disposed. Declaration public bool Disposed { get; } Property Value Type Description Boolean true if disposed; otherwise, false . | Improve this Doc Parent If this scope has a parent scope, this is it. Declaration public IContainerScope Parent { get; } Property Value Type Description IContainerScope The parent. Implements Methods | Improve this Doc ChildScopeDisposed(IContainerScope) Called by child scopes when they are disposed to notify the parent that they will no longer need to be disposed of when the parent is disposed. Declaration public void ChildScopeDisposed(IContainerScope child) Parameters Type Name Description IContainerScope child The child. Implements Remarks This is an infrastructure method and not something you would usually need to call. It's exposed for developers who are extending the container scoping functionality only. | Improve this Doc CreateScope() Called to create a child scope from this scope. The implementation adds the new scope to a private collection so that it can dispose of the new child if it is not already disposed. Declaration public IContainerScope CreateScope() Returns Type Description IContainerScope Implements | Improve this Doc Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() Implements | Improve this Doc Dispose(Boolean) Releases unmanaged and - optionally - managed resources. Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description Boolean disposing true to release both managed and unmanaged resources; false to release only unmanaged resources. Explicit Interface Implementations | Improve this Doc IContainerScope.Resolve(ResolveContext, Func<ResolveContext, Object>, ScopeBehaviour) Declaration object IContainerScope.Resolve(ResolveContext context, Func<ResolveContext, object> factory, ScopeBehaviour behaviour) Parameters Type Name Description ResolveContext context Func < ResolveContext , Object > factory ScopeBehaviour behaviour Returns Type Description Object Implements | Improve this Doc IServiceProvider.GetService(Type) Declaration object IServiceProvider.GetService(Type serviceType) Parameters Type Name Description Type serviceType Returns Type Description Object Implements See Also IContainerScope"
  },
  "rezolver-api/Rezolver.ContainerScopeExtensions.html": {
    "href": "rezolver-api/Rezolver.ContainerScopeExtensions.html",
    "title": "Class ContainerScopeExtensions",
    "keywords": "Class ContainerScopeExtensions Standard extensions for the IContainerScope Inheritance Object ContainerScopeExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ContainerScopeExtensions Methods | Improve this Doc GetRootScope(IContainerScope) Gets the root-most scope for the scope on which this method is called. Note that the result is calculated by walking up the tree of Parent scopes until one is reached that does not have a parent. Declaration public static IContainerScope GetRootScope(this IContainerScope scope) Parameters Type Name Description IContainerScope scope The scope. Returns Type Description IContainerScope Exceptions Type Condition ArgumentNullException If scope is null"
  },
  "rezolver-api/Rezolver.ContainerScopeResolveExtensions.html": {
    "href": "rezolver-api/Rezolver.ContainerScopeResolveExtensions.html",
    "title": "Class ContainerScopeResolveExtensions",
    "keywords": "Class ContainerScopeResolveExtensions Extensions for IContainerScope so that instances of that interface present a similar set of functionality to IContainer . Inheritance Object ContainerScopeResolveExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class ContainerScopeResolveExtensions Methods | Improve this Doc Resolve(IContainerScope, Type) Non-generic variant of the Resolve<TResult>(IContainerScope) extension method. Declaration public static object Resolve(this IContainerScope scope, Type requestedType) Parameters Type Name Description IContainerScope scope The scope. Type requestedType Type of object required. Returns Type Description Object Exceptions Type Condition ArgumentNullException | Improve this Doc Resolve<TResult>(IContainerScope) Resolves an object through the scope's Container Declaration public static TResult Resolve<TResult>(this IContainerScope scope) Parameters Type Name Description IContainerScope scope The active scope within which the call is to be made. Returns Type Description TResult Type Parameters Name Description TResult The type of object required. Remarks Resolving an object via a scope does not guarantee that it will be tracked. Ultimately, it's up to the behaviour of the individual underlying targets to determine whether they should interact with the scope. Indeed, all this extension method does is to forward the method call on to the Container of the given scope, ensuring that the scope is set on the ResolveContext that is passed to its Resolve(ResolveContext) method."
  },
  "rezolver-api/Rezolver.DecoratingTargetContainer.html": {
    "href": "rezolver-api/Rezolver.DecoratingTargetContainer.html",
    "title": "Class DecoratingTargetContainer",
    "keywords": "Class DecoratingTargetContainer Implements service decoration in an ITargetContainer , producing instances of the when Fetch(Type) or FetchAll(Type) are called. The best way to add a decorator to your target container is to use the extension method RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) or its non-generic equivalent. Inheritance Object DecoratingTargetContainer Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DecoratingTargetContainer : ITargetContainerOwner, ITargetContainer Remarks This class does not implement ITarget , rather it's an ITargetContainerOwner into which other targets can be added, and when Fetch(Type) or FetchAll(Type) are called, a temporary is created which wraps around the targets that have been registered within and which will ultimately create instances of DecoratorType Constructors | Improve this Doc DecoratingTargetContainer(Type, Type) Initializes a new instance of the DecoratingTargetContainer class. Declaration public DecoratingTargetContainer(Type decoratorType, Type decoratedType) Parameters Type Name Description Type decoratorType Type of the decorator. Type decoratedType Type being decorated. Properties | Improve this Doc DecoratedType Gets the type that's being decorated - in essence, this is the type that this decorator target Declaration public Type DecoratedType { get; } Property Value Type Description Type | Improve this Doc DecoratorType Gets the type which will be used to decorate the instances produced by targets in this decorator target. Declaration public Type DecoratorType { get; } Property Value Type Description Type Methods | Improve this Doc CombineWith(ITargetContainer, Type) Implements CombineWith(ITargetContainer, Type) by wrapping the existing container and returning itself. This allows decorators to be applied on top of decorators; and decorators to be added after types have begun to be registered in another target container. Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing The existing ITargetContainer instance that this instance is to be combined with Type type The type that the combined container owner will be registered under. Returns Type Description ITargetContainer Implements Exceptions Type Condition InvalidOperationException If this target container is already decorating another container | Improve this Doc Fetch(Type) Implementation of Fetch(Type) - wraps a special target around the target returned by the target container that's decorated by this one. Declaration public ITarget Fetch(Type type) Parameters Type Name Description Type type Required. The type for which an ITarget is to be retrieved. Returns Type Description ITarget Implements Remarks If the inner container returns null, then so does this one. | Improve this Doc FetchAll(Type) Implementation of FetchAll(Type) - passes the call on to the inner container that's decorated by this one, and then wraps each of those targets in a which represents the decoration logic for each instance. Declaration public IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type Required. The type for which the ITarget instances are to be retrieved. Returns Type Description IEnumerable < ITarget > Implements | Improve this Doc FetchContainer(Type) Retrieves an existing container registered against the given type , or null if not found. Declaration public ITargetContainer FetchContainer(Type type) Parameters Type Name Description Type type The type. Returns Type Description ITargetContainer Implements Remarks This is an implementation of FetchContainer(Type) which wraps around the inner target container and passes the call on to that. Exceptions Type Condition InvalidOperationException If this decorator's inner container isn't an instance of ITargetContainerOwner | Improve this Doc Register(ITarget, Type) Registers a target, either for the serviceType specified or, if null, the DeclaredType of the target . Implementation of Register(ITarget, Type) . Declaration public void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target Required. The target to be registered Type serviceType Optional. The type the target is to be registered against, if different from the DeclaredType of the target . If provided, then the target must be compatible with this type. Implements Remarks The decorator target does not accept registrations directly; rather it passes the call on to its inner container which could be a TargetListContainer , or GenericTargetContainer in the most basic cases; or it could be another DecoratingTargetContainer in situations where a type has had multiple decorators registered against it. | Improve this Doc RegisterContainer(Type, ITargetContainer) Implementation of RegisterContainer(Type, ITargetContainer) - the call is automatically forwarded on to the inner target container that's being decorated, since decorator targets don't support direct registration of targets or containers. Declaration public void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type The type. ITargetContainer container The container. Implements Exceptions Type Condition InvalidOperationException This decorator must be decorating another ITargetContainerOwner , or be decorating a generic type"
  },
  "rezolver-api/Rezolver.DecoratorTarget.html": {
    "href": "rezolver-api/Rezolver.DecoratorTarget.html",
    "title": "Class DecoratorTarget",
    "keywords": "Class DecoratorTarget Represents the action of implementing a common DecoratedType by decorating one instance (produced by DecoratedTarget ) with another ( Target , which will create an instance of DecoratorType ). NOTE - You shouldn't register or otherwise create instances of this target unless you absolutely know what you're doing. Rather, decorators should be registered using the extension method RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) or its non-generic alternative because the target needs a DecoratingTargetContainer to work properly (the creation of which is automatically handled by these extension methods). Inheritance Object TargetBase DecoratorTarget Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class DecoratorTarget : TargetBase, ITarget Constructors | Improve this Doc DecoratorTarget(Type, ITarget, Type) Creates a new instance of the DecoratorTarget type, initialising the Target to a just-in-time-bound ConstructorTarget for the decoratorType . Declaration public DecoratorTarget(Type decoratorType, ITarget decoratedTarget, Type decoratedType) Parameters Type Name Description Type decoratorType The type which is decorating the decoratedType ITarget decoratedTarget The target which is being decorated Type decoratedType The common type which is being decorated - e.g. IService when the decoratedTarget is bound to the type MyService : IService and the decoratorType is set to MyServiceDecorator : IService . Properties | Improve this Doc DeclaredType Always returns DecoratorType Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc DecoratedTarget Gets the target whose instance will be wrapped (decorated) by the one produced by Target . Declaration public ITarget DecoratedTarget { get; } Property Value Type Description ITarget | Improve this Doc DecoratedType Gets the underlying type (e.g. a common service interface or base) that is being implemented through decoration. Declaration public Type DecoratedType { get; } Property Value Type Description Type | Improve this Doc DecoratorType Gets the type which is decorating the instance produced by the DecoratedTarget for the common service type DecoratedType Declaration public Type DecoratorType { get; } Property Value Type Description Type | Improve this Doc Target Gets the target which will create an instance of the DecoratorType Declaration public ITarget Target { get; } Property Value Type Description ITarget Remarks The constructor currently auto-initialises this to a just-in-time-bound ConstructorTarget targetting the DecoratorType by using the Auto(Type, IMemberBindingBehaviour) method. Methods | Improve this Doc SupportsType(Type) Overrides SupportsType(Type) to forward the call to Target . Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type The type which is to be checked. Returns Type Description Boolean true if the type is compatible with the object created by Target , false if not. Overrides See Also TargetBase"
  },
  "index.html": {
    "href": "index.html",
    "title": "Rezolver",
    "keywords": "Rezolver Welcome to the home of Rezolver - here you'll find guides, walkthroughs, deep-dives and reference for all of the APIs and functionality in the Rezolver library. What is Rezolver? Rezolver is an open source IOC container that, out of the box, supports all the standard features supported by most =other popular IOC containers out there. It's also highly extensible - with practically the entire stack open to extension immediately after referencing the core library. It's been built specifically with the .Net Core framework in mind, supporting the NetStandard1.1 profile for (almost!) maximum portability Features 'Intelligent' constructor discovery based on registered services Open generics (with specific closed generics taking precedence) Decorators (non-generic and generic) Enumerables (empty enumerables returned by default) Child containers (overriding registrations in one container with those of another) Lifetime scoping (incl. child lifetimes) Delegates and Expressions as factories, with argument injection Singletons Pre-built objects Scoped objects (i.e. 'singleton per scope') Extensible compiler framework Expression tree compiler used by default Integration with Microsoft.Extensions.DependencyInjection via nuget packages Extensible configuration framework (still in development) Json configuration (still in development) Quick Links Getting Started <!--- [Nuget Packages](rezolver-usage/nuget-packages/) --> API Reference Please note - this documentation is a work in progress! Rezolver is currently undergoing an API change which has invalidated some of the documentation we had before. Once everything is built and re-tested, all the documentation will be added ASAP to provide in-depth guides and tutorials which are then guaranteed to stand the test of time! So, keep coming back! We'll get there :) On Github If you're the kind of person who likes to learn from seeing the code - then check out the Rezolver repo on Github , there are some example applications on there, and you can look at the unit tests to get an idea of how to create and configure containers."
  },
  "rezolver-api/index.html": {
    "href": "rezolver-api/index.html",
    "title": "Rezolver API reference",
    "keywords": "Rezolver API reference Looking for documentation on individual classes or methods in the Rezolver project? You've come to the right place! Crucial types to look at are: TargetContainer (implements @Rezolver.ITargetContainer): Stores ITarget instances, and is the main class you'll use for your 'registration' phase. Container (implements @Rezolver.IContainer): The standard, non-scoped, container you'll use in your composition root - you can create child scopes from this by calling its implementation of CreateScope() , which returns instances of IContainerScope . This class uses an ITargetContainer for its registrations, which you can supply construction if required. ScopedContainer - A container which also acts as a 'root' scope."
  },
  "rezolver-usage/details1.html": {
    "href": "rezolver-usage/details1.html",
    "title": "Details 1",
    "keywords": "Details 1 This is the first details page."
  },
  "rezolver-usage/details2.html": {
    "href": "rezolver-usage/details2.html",
    "title": "Details 2",
    "keywords": "Details 2 This is the second details page. And the same image underneath:"
  },
  "rezolver-usage/details3.html": {
    "href": "rezolver-usage/details3.html",
    "title": "Details 3",
    "keywords": "Details 3 This is the third details page - getting a bit boring now huh?"
  },
  "rezolver-usage/index.html": {
    "href": "rezolver-usage/index.html",
    "title": "1. Getting started",
    "keywords": "1. Getting started As with many open source .Net projects, there are two primary ways to get Rezolver integrated into your project. The easiest is via the Nuget packages By using the Nuget packages, you ensure that you're using the latest (hopefully stable!) releases. Alpha packages will also be made available for in-development features. Fork or download the source from Github Use this if you can't integrate nuget into your build pipeline, or if you'd like to customise or contribute to the project. If you're looking to customise, though, then there should be enough extensibility points in the framework to allow you to do so without having to change core types. If that's not the case, post an issue on the Github project so we can get it added in and make it better for everyone! Once you have the main assembly referenced (Rezolver.dll) - then you can create a Container , register targets in it and resolve objects from it. What's a 'target'? A target (@Rezolver.ITarget) is an object stored by an ITargetContainer which contains information about how an object is to be created or retrieved when a container's @Rezolver.IContainer.Resolve operation is called. ITarget t = new ObjectTarget(null); ITargetContainer r = new TargetContainer(); r.Register(t, serviceType: typeof(object)); var t2 = r.Fetch(typeof(object)); Assert.Same(t, t2); More code using Rezolver.Targets; using Rezolver.Tests.Types; using System; using System.Collections.Generic; using System.Linq; using System.Threading.Tasks; using Xunit; namespace Rezolver.Tests.Compilation.Specification { public partial class CompilerTestsBase { //tests in here are based on similar scenarios to the Binding tests //for ConstructorTarget in the main test suite - except there are fewer, because //there are actually very few unique cases for a compiler to deal with when it comes //to executing constructors. //Most of the complexity comes from things like RezolvedTargets etc. [Fact] public void ConstructorTarget_ImplicitCtor() { var targets = CreateTargetContainer(); targets.RegisterType<NoCtor>(); var container = CreateContainer(targets); var result = container.Resolve<NoCtor>(); Assert.NotNull(result); } [Fact] public void ConstructorTarget_OneParamCtor_WithResolvedArg() { var targets = CreateTargetContainer(); targets.RegisterType<OneCtor>(); targets.RegisterObject(OneCtor.ExpectedValue); var container = CreateContainer(targets); var result = container.Resolve<OneCtor>(); Assert.NotNull(result); Assert.Equal(OneCtor.ExpectedValue, result.Value); } [Fact] public void ConstructorTarget_TwoParamCtor_WithResolvedArgs() { Output.WriteLine(\"Both arguments are supplied by automatically resolving them (using ResolvedTarget)\"); var targets = CreateTargetContainer(); targets.RegisterType<TwoCtors>(); targets.RegisterObject(10); targets.RegisterObject(\"hello world\"); var container = CreateContainer(targets); var result = container.Resolve<TwoCtors>(); Assert.NotNull(result); Assert.Equal(10, result.I); Assert.Equal(\"hello world\", result.S); } [Fact] public void ConstructorTarget_CtorSelectedByNamedArgs() { Output.WriteLine(\"The constructor is located JIT based on a single named argument\"); var targets = CreateTargetContainer(); var target = ConstructorTarget.WithArgs<TwoCtors>(new { s = \"hello world\".AsObjectTarget() }); targets.Register(target); var container = CreateContainer(targets); var result = container.Resolve<TwoCtors>(); Assert.NotNull(result); Assert.Equal(\"hello world\", result.S); } } }"
  },
  "rezolver-usage/advanced/index.html": {
    "href": "rezolver-usage/advanced/index.html",
    "title": "",
    "keywords": "In addition to the standard functionality you'd expect from an IOC container, Rezolver supports many additional features which require some extra discussion."
  },
  "rezolver-usage/advanced/rezolving-with-expressions.html": {
    "href": "rezolver-usage/advanced/rezolving-with-expressions.html",
    "title": "",
    "keywords": "TODO: Article covering functions such as the RegisterExpression<T>(ITargetContainer, Expression<Func<RezolveContextExpressionHelper, T>>, Type, ITargetAdapter) method"
  },
  "rezolver-usage/nuget-packages/index.html": {
    "href": "rezolver-usage/nuget-packages/index.html",
    "title": "Rezolver Nuget Packages",
    "keywords": "Rezolver Nuget Packages Rezolver is primarily distributed as a suite of Nuget packages whose functionality stacks one on top of another. Depending on the level of functionality you require, there should be a Nuget package which contains only the code you need. All the core nuget packages support the new .NetStandard 1.3 profile (don't know what this is? Learn more ), .Net 4.5.1 and .Net 4.6. Where a package has a dependency on a third party package (such as Newtonsoft's Json.Net or .Net Core's Microsoft.Extensions.DependencyInjection packages), then we try to maintain full support for the same frameworks and profiles that those packages support. List of packages Rezolver . Rezolver.Configuration"
  },
  "rezolver-usage/nuget-packages/rezolver.configuration.html": {
    "href": "rezolver-usage/nuget-packages/rezolver.configuration.html",
    "title": "Nuget Package: Rezolver.Configuration",
    "keywords": "Nuget Package: Rezolver.Configuration This package provides the Rezolver configuration object model, whose purpose is to describe how a Target Container should be constructed and configured based on a configuration file/script loaded at runtime. It doesn't define any specific code for parsing configuration files - but it does provide a standard implementation of the IConfigurationAdapter , whose job it is to create a ITargetContainer from a IConfiguration instance. You can implement your own configuration file formats with this simply by writing code to read your desired format and getting your parser to create an instance of IConfiguration"
  },
  "rezolver-usage/nuget-packages/rezolver.html": {
    "href": "rezolver-usage/nuget-packages/rezolver.html",
    "title": "Nuget Package: Rezolver",
    "keywords": "Nuget Package: Rezolver See package page on nuget . The core nuget package for using Rezolver in your class library or application, includes all the core abstractions and classes required to create @TargetContainer objects and @Container objects in your composition root. Also contains the core ITarget implementations and logic which allow you to create/retrieve objects in numerous ways: Binding generic and non-generic class constructors using dynamically resolved arguments ( ConstructorTarget , GenericConstructorTarget and @Rezolver.RezolvedTarget) Invoking pre-built delegates (@Rezolver.DelegateTarget) Pre-built objects (@Rezolver.ObjectTarget) Dynamic code built from custom expression trees (@Rezolver.ExpressionTarget) Decoration (@Rezolver.DecoratorTarget) Singleton objects (@Rezolver.SingletonTarget) Scoped objects (@Rezolver.ScopedTarget)"
  },
  "rezolver-api/toc.html": {
    "href": "rezolver-api/toc.html",
    "title": "Table of Content",
    "keywords": ""
  },
  "toc.html": {
    "href": "toc.html",
    "title": "Table of Content",
    "keywords": ""
  },
  "rezolver-usage/toc.html": {
    "href": "rezolver-usage/toc.html",
    "title": "Table of Content",
    "keywords": ""
  },
  "rezolver-api/Microsoft.Extensions.DependencyInjection.IServiceCollectionExtensions.html": {
    "href": "rezolver-api/Microsoft.Extensions.DependencyInjection.IServiceCollectionExtensions.html",
    "title": "Class IServiceCollectionExtensions",
    "keywords": "Class IServiceCollectionExtensions Rezolver interop extension methods for the IServiceCollection class in Microsoft.Extensions.DependencyInjection Inheritance Object IServiceCollectionExtensions Inherited Members Namespace :Microsoft.Extensions.DependencyInjection Assembly :cs.temp.dll.dll Syntax public static class IServiceCollectionExtensions Methods | Improve this Doc CreateRezolverContainer(IServiceCollection) Creates a new default and registers the services in services as targets. Declaration public static IContainer CreateRezolverContainer(this IServiceCollection services) Parameters Type Name Description IServiceCollection services The services to be registered. Returns Type Description IContainer An instance Exceptions Type Condition ArgumentNullException If services is null. | Improve this Doc RegisterTargets(IServiceCollection, ITargetContainer) Registers services in services as targets in the passed targetContainer Declaration public static void RegisterTargets(this IServiceCollection services, ITargetContainer targetContainer) Parameters Type Name Description IServiceCollection services The services to b registered. ITargetContainer targetContainer The target container that is to receive the new registrations. Remarks This extension method just uses the method also found in this library. Exceptions Type Condition ArgumentNullException If either services or targetContainer are null."
  },
  "rezolver-api/Microsoft.Extensions.DependencyInjection.RezolverServiceCollectionExtensions.html": {
    "href": "rezolver-api/Microsoft.Extensions.DependencyInjection.RezolverServiceCollectionExtensions.html",
    "title": "Class RezolverServiceCollectionExtensions",
    "keywords": "Class RezolverServiceCollectionExtensions Rezolver interop extension methods for the IServiceCollection class in Microsoft.Extensions.DependencyInjection Inheritance Object RezolverServiceCollectionExtensions Inherited Members Namespace :Microsoft.Extensions.DependencyInjection Assembly :cs.temp.dll.dll Syntax public static class RezolverServiceCollectionExtensions Methods | Improve this Doc CreateRezolverContainer(IServiceCollection) Creates a new default and registers the services in services as targets. Declaration public static IContainer CreateRezolverContainer(this IServiceCollection services) Parameters Type Name Description IServiceCollection services The services to be registered. Returns Type Description IContainer An instance Exceptions Type Condition ArgumentNullException If services is null. | Improve this Doc RegisterTargets(IServiceCollection, ITargetContainer) Registers services in services as targets in the passed targetContainer Declaration public static void RegisterTargets(this IServiceCollection services, ITargetContainer targetContainer) Parameters Type Name Description IServiceCollection services The services to be registered. ITargetContainer targetContainer The target container that is to receive the new registrations. Remarks This extension method just uses the method also found in this library. Exceptions Type Condition ArgumentNullException If either services or targetContainer are null."
  },
  "rezolver-api/Microsoft.Extensions.DependencyInjection.html": {
    "href": "rezolver-api/Microsoft.Extensions.DependencyInjection.html",
    "title": "Namespace Microsoft.Extensions.DependencyInjection",
    "keywords": "Namespace Microsoft.Extensions.DependencyInjection Classes Rezolver interop extension methods for the IServiceCollection class in Microsoft.Extensions.DependencyInjection"
  },
  "rezolver-api/Rezolver.AliasTargetContainerExtensions.html": {
    "href": "rezolver-api/Rezolver.AliasTargetContainerExtensions.html",
    "title": "Class AliasTargetContainerExtensions",
    "keywords": "Class AliasTargetContainerExtensions Contains extension methods for ITargetContainer to create targets which alias others by different types. Inheritance Object AliasTargetContainerExtensions Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public static class AliasTargetContainerExtensions Methods | Improve this Doc RegisterAlias(ITargetContainer, Type, Type) Registers an alias for one type to another type. The created entry will effectively represent a second Resolve call into the container for the aliased type. Declaration public static void RegisterAlias(this ITargetContainer targetContainer, Type aliasType, Type originalType) Parameters Type Name Description ITargetContainer targetContainer The builder in which the alias is to be registered Type aliasType The type to be registered as an alias Type originalType The type being aliased. Remarks Use this when it's important that a given target type is always served through the same compiled target, even when the consumer expects it to be of a different type. A very common scenario is when you have a singleton instance of the originalType , and need to serve that same instance for aliasType . If you register the same singleton for both types, you get two separate singletons for each type, whereas if you create an alias, both will be served by the same alias. | Improve this Doc RegisterAlias<TAlias, TOriginal>(ITargetContainer) Generic version of RegisterAlias(ITargetContainer, Type, Type) , see that method for more. Declaration public static void RegisterAlias<TAlias, TOriginal>(this ITargetContainer targetContainer) Parameters Type Name Description ITargetContainer targetContainer The target container in which the alias is to be registered Type Parameters Name Description TAlias Type being registered as an alias to another type TOriginal The target type of the alias."
  },
  "rezolver-api/Rezolver.Builder.html": {
    "href": "rezolver-api/Rezolver.Builder.html",
    "title": "Class Builder",
    "keywords": "Class Builder Stores and retrieves registrations of ITarget s, is also Generic type aware, unlike its base class - TargetDictionaryContainer . Should be used as the root target container for implementations of IContainer . Inheritance Object TargetDictionaryContainer Builder Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class Builder : TargetDictionaryContainer, ITargetContainerOwner, ITargetContainer Remarks This is the type used by default for the Rezolver.IContainer.Builder of the Container and ScopedContainer when you don't supply an instance of an ITargetContainer explicitly on construction. Constructors | Improve this Doc Builder(Boolean) Constructs a new instance of the Builder class Declaration public Builder(bool autoRezolveIEnumerable = true) Parameters Type Name Description Boolean autoRezolveIEnumerable If true, then IEnumerable<T> will be automatically resolved as a concatenation of all the ITarget s that are registered against a particular type. Note - this parameter might be removed in a future version - you can achieve the same thing by using the extension method Rezolver.EnumerableTargetBuilderExtensions.EnableEnumerableResolving(Rezolver.Builder) Methods | Improve this Doc CreateContainer(Type, ITarget) Called to create and register a container for the given serviceType and target . This class overrides the base version ( CreateContainer(Type, ITarget) ) to create a specialised container for generic types ( GenericTargetContainer ) if serviceType if a generic type or generic type definition. Declaration protected override ITargetContainer CreateContainer(Type serviceType, ITarget target) Parameters Type Name Description Type serviceType The type for which a container is to be created and registered. ITarget target Optional. The target that will be added to the container that is returned. Returns Type Description ITargetContainer An ITargetContainer in which the passed target will be registered. Overrides Remarks The main caller for this method will be the base Register method, which will create a new container for a target that's being registered against a new type. It is, however, also called by this class' implementation of RegisterContainer(Type, ITargetContainer) when the type is a generic type - as all generics must have a container registered against their generic type definitions as a starting point. | Improve this Doc CreateGenericTypeDefContainer(Type, ITarget) Called by CreateContainer(Type, ITarget) to create a container suitable for handling targets that are registered against generic types. Declaration protected virtual ITargetContainer CreateGenericTypeDefContainer(Type genericTypeDefinition, ITarget target) Parameters Type Name Description Type genericTypeDefinition Will be an open generic type (generic type definition) ITarget target Optional. The initial target for which the container is being constructed Returns Type Description ITargetContainer The base implementation always creates an instance of CreateGenericTypeDefContainer(Type, ITarget) | Improve this Doc FetchContainer(Type) Retrieves Declaration public override ITargetContainer FetchContainer(Type type) Parameters Type Name Description Type type Returns Type Description ITargetContainer Overrides | Improve this Doc Register(ITarget, Type) Declaration public override void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target Type serviceType Overrides | Improve this Doc RegisterContainer(Type, ITargetContainer) Overrides the base method so that if type is a generic type, then the container will be registered inside another which will be registered for the generic type definition first. Declaration public override void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container Overrides | Improve this Doc RegisterContainerDirect(Type, ITargetContainer) Version of RegisterContainer(Type, ITargetContainer) which does not interrogate the type to see if it's generic - simply registers the passed container directly against the passed type (it just chains through directly to the RegisterContainer(Type, ITargetContainer) method non-virtually. Declaration protected virtual void RegisterContainerDirect(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container"
  },
  "rezolver-api/Rezolver.CachingContainerBase.html": {
    "href": "rezolver-api/Rezolver.CachingContainerBase.html",
    "title": "Class CachingContainerBase",
    "keywords": "Class CachingContainerBase Builds on the ContainerBase base class to introduce thread-safe caching of compiled targets so they are only compiled once per requested type. Only creatable through inheritance. Inheritance Object ContainerBase CachingContainerBase Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class CachingContainerBase : ContainerBase, IContainer, IServiceProvider, ITargetContainer Remarks Internally, the class uses a ConcurrentDictionary<TKey, TValue> to store ICompiledTarget s keyed by the requested type. All the main IContainer implementations used directly in an application should ideally inherit from this class, because otherwise every Resolve(ResolveContext) operation would require a compilation phase before the object could be returned, which would be incredibly slow. It's because of this caching that registering new targets in any ITargetContainer used by this class is not recommended: because after the first request for a particular type is made, the resultant ICompiledTarget is fixed until the container is thrown away. Constructors | Improve this Doc CachingContainerBase(ITargetContainer, ICompilerConfigurationProvider) Initializes a new instance of the CachingContainerBase class. Declaration protected CachingContainerBase(ITargetContainer targets = null, ICompilerConfigurationProvider compilerConfig = null) Parameters Type Name Description ITargetContainer targets Optional. Contains the targets that will be used to create the ICompiledTarget s that this container will use to produce objects when requested. If not provided, then the base class' default (see ContainerBase(ITargetContainer, ICompilerConfigurationProvider) ) will be used. ICompilerConfigurationProvider compilerConfig Optional. An object which will be used to configure this container and its targets to use a specific compilation strategy. If null , then the DefaultProvider provider will be used. Methods | Improve this Doc GetCompiledRezolveTarget(ResolveContext) Obtains an ICompiledTarget for the given context . Declaration protected override ICompiledTarget GetCompiledRezolveTarget(ResolveContext context) Parameters Type Name Description ResolveContext context Returns Type Description ICompiledTarget Overrides Remarks The method is called by Resolve(ResolveContext) to get the compiled target whose GetObject(ResolveContext) method is to be used to get the instance that is to be resolved for a given request. The internal cache is examined first to see if an entry exists for the RequestedType type and, if not, then the result of the base class' GetCompiledRezolveTarget(ResolveContext) is cached and returned."
  },
  "rezolver-api/Rezolver.ChangeTypeTarget.html": {
    "href": "rezolver-api/Rezolver.ChangeTypeTarget.html",
    "title": "Class ChangeTypeTarget",
    "keywords": "Class ChangeTypeTarget This target is specifically used for explicitly casting the result of one target to another type. Its use is rare, since the framework already caters for downcasting the result of targets to base types. Inheritance Object TargetBase ChangeTypeTarget Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ChangeTypeTarget : TargetBase, ITarget Remarks A valid use of this target is when you have a SingletonTarget registered against one type, and you want the same singleton (backed by the same instance) to server another type. In this case, instead of registering the same singleton target multiple times, you can register it once for its primary type, then register one of these for the other type, with a RezolvedTarget as its inner target. Constructors | Improve this Doc ChangeTypeTarget(ITarget, Type) Creates a new instance of the ChangeTypeTarget class. Declaration public ChangeTypeTarget(ITarget innerTarget, Type targetType) Parameters Type Name Description ITarget innerTarget Required. See InnerTarget Type targetType Required. See DeclaredType Properties | Improve this Doc DeclaredType Always returns the target type that was passed in the ChangeTypeTarget(ITarget, Type) constructor. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides | Improve this Doc InnerTarget The target whose type will be changed to DeclaredType . Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget | Improve this Doc SuppressScopeTracking Always returns true. Declaration protected override bool SuppressScopeTracking { get; } Property Value Type Description Boolean Overrides"
  },
  "rezolver-api/Rezolver.ChildBuilder.html": {
    "href": "rezolver-api/Rezolver.ChildBuilder.html",
    "title": "Class ChildBuilder",
    "keywords": "Class ChildBuilder A Builder which acts as a child of another builder. When it's looking to find an entry for a type, if it cannot find one within its own registrations, it will forward the call on to its Parent . This means that a child builder can override any registrations that are present in its parent. Inheritance Object TargetDictionaryContainer Builder ChildBuilder Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ChildBuilder : Builder, ITargetContainerOwner, IChildTargetContainer, ITargetContainer Constructors | Improve this Doc ChildBuilder(ITargetContainer) Declaration public ChildBuilder(ITargetContainer parent) Parameters Type Name Description ITargetContainer parent Properties | Improve this Doc Parent Declaration public ITargetContainer Parent { get; } Property Value Type Description ITargetContainer Implements Methods | Improve this Doc Fetch(Type) Declaration public override ITarget Fetch(Type type) Parameters Type Name Description Type type Returns Type Description ITarget Overrides Implements | Improve this Doc FetchAll(Type) Declaration public override IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type Returns Type Description IEnumerable < ITarget > Overrides Implements"
  },
  "rezolver-api/Rezolver.ChildTargetContainer.html": {
    "href": "rezolver-api/Rezolver.ChildTargetContainer.html",
    "title": "Class ChildTargetContainer",
    "keywords": "Class ChildTargetContainer A version of TargetContainer which overrides the registrations of another (the Parent ). Inheritance Object TargetDictionaryContainer TargetContainer ChildTargetContainer Inherited Members Namespace :Rezolver Assembly :cs.temp.dll.dll Syntax public class ChildTargetContainer : TargetContainer, ITargetContainerOwner, IChildTargetContainer, ITargetContainer Remarks When it's looking to find an entry for a type, if it cannot find one within its own registrations, it will forward the call on to its ancestors (starting with its Parent ). As a result, any dependencies required by registrations in this container can be provided by any ancestor. Fallback logic in the Fetch(Type) is triggered by the UseFallback property. Constructors | Improve this Doc ChildTargetContainer(ITargetContainer) Initializes a new instance of the ChildTargetContainer class. Declaration public ChildTargetContainer(ITargetContainer parent) Parameters Type Name Description ITargetContainer parent Required. The parent target container Properties | Improve this Doc Parent Gets the parent. Declaration public ITargetContainer Parent { get; } Property Value Type Description ITargetContainer The parent. Implements Methods | Improve this Doc Fetch(Type) Fetches the registered target for the given type , if found, or forwards the call to the Parent container. Declaration public override ITarget Fetch(Type type) Parameters Type Name Description Type type The type whose registration is sought. Returns Type Description ITarget The target which is registered for the given type, or null if no registration can be found. Overrides Implements | Improve this Doc FetchAll(Type) Implementation of FetchAll(Type) Declaration public override IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type The type whose targets are to be retrieved. Returns Type Description IEnumerable < ITarget > A non-null enumerable containing the targets that match the type, or an empty enumerable if the type is not registered. Overrides Implements See Also TargetContainer IChildTargetContainer"
  },
  "rezolver-api/Rezolver.Compilation.CompileContext.html": {
    "href": "rezolver-api/Rezolver.Compilation.CompileContext.html",
    "title": "Class CompileContext",
    "keywords": "Class CompileContext Core implementation of ICompileContext . A root context (i.e. where ParentContext is null ; created via the CompileContext(IContainer, ITargetContainer, Type) constructor) is the starting point for all shared state, such as the Container and the compilation stack. The ITargetContainer implementation is done by decorating a new ChildTargetContainer , so that new registrations can be added without interfering with upstream containers. Note that many of the interface members are implemented explicitly - therefore most of your interaction with this type is through its implementation of ICompileContext and ITargetContainer . Inheritance Object CompileContext Inherited Members Namespace :Rezolver.Compilation Assembly :cs.temp.dll.dll Syntax public class CompileContext : ICompileContext, ITargetContainer Remarks Note that you can only create an instance of this either through inheritance, via the explicit implementation of NewContext(Type, Nullable<ScopeBehaviour>) , or (preferably) via an ICompileContextProvider resolved from an IContainer or ITargetContainer directly from a registered target. Constructors | Improve this Doc CompileContext(ICompileContext, Type, Nullable<ScopeBehaviour>) Creates a new CompileContext as a child of another. Declaration protected CompileContext(ICompileContext parentContext, Type targetType = null, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description ICompileContext parentContext Used to seed the compilation stack, container, dependency container (which will still be wrapped in a new ChildTargetContainer for isolation) and, optionally, the target type (unless you pass a non-null type for targetType , which would override that). Type targetType The target type that is expected to be compiled, or null if the TargetType is to be inherited from the parentContext . Nullable < ScopeBehaviour > scopeBehaviourOverride Override the scope behaviour to be used for the target that is compiled with this context. | Improve this Doc CompileContext(IContainer, ITargetContainer, Type) Creates a new CompileContext Declaration protected CompileContext(IContainer container, ITargetContainer dependencyTargetContainer, Type targetType = null) Parameters Type Name Description IContainer container Required. The container for which compilation is being performed. Will be set into the Container property. ITargetContainer dependencyTargetContainer Required - An ITargetContainer that contains the ITarget s that will be required to complete compilation. Note - this argument is passed to a new ChildTargetContainer that is created and proxied by this class' implementation of ITargetContainer . As a result, it's possible to register new targets directly into the context via its implementation of ITargetContainer , without modifying the underlying targets in the container you pass. Type targetType Optional. Will be set into the TargetType property. If null, then any ITarget that is compiled should be compiled for its own DeclaredType . Properties | Improve this Doc CompileStack Gets the stack entries for all the targets that are being compiled. Declaration public IEnumerable<CompileStackEntry> CompileStack { get; } Property Value Type Description IEnumerable < CompileStackEntry > The compile stack. Implements | Improve this Doc Container The container that is considered the current compilation 'scope' - i.e. the container for which the compilation is being performed and, usually, the one on which the Resolve(ResolveContext) method was originally called which triggered the compilation call. Declaration public IContainer Container { get; } Property Value Type Description IContainer The container. Implements | Improve this Doc DependencyTargetContainer This is the ITargetContainer through which dependencies are resolved by this context in its implementation of ITargetContainer . In essence, this class acts as a decorator for this inner target container. Declaration protected ITargetContainer DependencyTargetContainer { get; } Property Value Type Description ITargetContainer | Improve this Doc ParentContext Gets the parent context from which this context was created, if applicable. Declaration public ICompileContext ParentContext { get; } Property Value Type Description ICompileContext The parent context. Implements | Improve this Doc ScopeBehaviourOverride Implementation of ScopeBehaviourOverride Declaration public ScopeBehaviour? ScopeBehaviourOverride { get; } Property Value Type Description Nullable < ScopeBehaviour > Implements | Improve this Doc TargetType Any ICompiledTarget built for a ITarget with this context should target this type. If null, then the DeclaredType of the target being compiled should be used. Declaration public Type TargetType { get; } Property Value Type Description Type Implements Remarks Note that when creating a child context with a null targetType argument, this property will be inherited from the ParentContext . Methods | Improve this Doc NewContext(Type, Nullable<ScopeBehaviour>) Used by the explicit implementation of NewContext(Type, Nullable<ScopeBehaviour>) . Override this in your derived class to create the correct implementation of ICompileContext . Declaration protected virtual ICompileContext NewContext(Type targetType = null, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Nullable < ScopeBehaviour > scopeBehaviourOverride Override the scope behaviour to be used for the target that is compiled with the new context. Returns Type Description ICompileContext Explicit Interface Implementations | Improve this Doc ICompileContext.NewContext(Type, Nullable<ScopeBehaviour>) Creates a new child context from this one, except the TargetType and ScopeBehaviour properties can be overriden if required, with the rest of the state inherited from this context. Declaration ICompileContext ICompileContext.NewContext(Type targetType, ScopeBehaviour? scopeBehaviourOverride) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Nullable < ScopeBehaviour > scopeBehaviourOverride Override the scope behaviour to be used for the target that is compiled with the new context. Returns Type Description ICompileContext Implements | Improve this Doc ICompileContext.PopCompileStack() Pops a target from the stack and returns it. Note that if there are no targets on the stack, an InvalidOperationException will occur. Declaration CompileStackEntry ICompileContext.PopCompileStack() Returns Type Description CompileStackEntry The CompileStackEntry that was popped off the compilation stack. Implements Remarks If ParentContext is not null, then the call is redirected to that context, so that the compilation stack is always shared between all contexts spawned from the same root. | Improve this Doc ICompileContext.PushCompileStack(ITarget, Type) Adds the target to the compilation stack if it doesn't already exist. Declaration bool ICompileContext.PushCompileStack(ITarget toCompile, Type targetType) Parameters Type Name Description ITarget toCompile The target to be pushed Type targetType The type for which the target is being compiled, if different from DeclaredType Returns Type Description Boolean Implements Remarks Targets can appear on the compilation stack more than once for different types, since the ICompiledTarget produced for a target for one type can be different than it is for another. Ultimately, if a target does in fact have a cyclic dependency graph, then this method will detect that. | Improve this Doc ITargetContainer.CombineWith(ITargetContainer, Type) Always throws a NotSupportedException Declaration ITargetContainer ITargetContainer.CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Ignored Type type Ignored Returns Type Description ITargetContainer Implements Exceptions Type Condition NotSupportedException Always thrown | Improve this Doc ITargetContainer.Fetch(Type) Implements Fetch(Type) by wrapping around the child target container created by this context on construction. Declaration ITarget ITargetContainer.Fetch(Type type) Parameters Type Name Description Type type See Fetch(Type) for more. Returns Type Description ITarget Implements | Improve this Doc ITargetContainer.FetchAll(Type) Implements FetchAll(Type) by wrapping around the child target container created by this context on construction. Declaration IEnumerable<ITarget> ITargetContainer.FetchAll(Type type) Parameters Type Name Description Type type See FetchAll(Type) for more Returns Type Description IEnumerable < ITarget > Implements | Improve this Doc ITargetContainer.Register(ITarget, Type) Implements Register(ITarget, Type) by wrapping around the child target container created by this context on construction. Declaration void ITargetContainer.Register(ITarget target, Type serviceType) Parameters Type Name Description ITarget target See Register(ITarget, Type) for more Type serviceType See Register(ITarget, Type) for more Implements See Also ICompileContext ITargetContainer"
  },
  "rezolver-api/Rezolver.Compilation.CompilerConfiguration.html": {
    "href": "rezolver-api/Rezolver.Compilation.CompilerConfiguration.html",
    "title": "Class CompilerConfiguration",
    "keywords": "Class CompilerConfiguration Controls the system-wide compiler configuration used by default by all standard Rezolver containers. Inheritance Object CompilerConfiguration Inherited Members Namespace :Rezolver.Compilation Assembly :cs.temp.dll.dll Syntax public static class CompilerConfiguration Properties | Improve this Doc DefaultProvider Gets or sets the default ICompilerConfigurationProvider used by classes derived from ContainerBase to self-configure for target compilation. Declaration public static ICompilerConfigurationProvider DefaultProvider { get; set; } Property Value Type Description ICompilerConfigurationProvider Remarks The default implementation will throw an InvalidOperationException as soon as its Configure(IContainer, ITargetContainer) method is called - therefore it's imperative either that you change this provider for one which actually configures the container to support compilation, or that you explicitly pass a provider to the container when you create it. The standard expression compiler defined in the Rezolver.Compilation.Expressions library defines a provider in Rezolver.Compilation.Expressions.ConfigProvider , and a static configuration method UseAsDefaultCompiler which automatically sets it into this property for you."
  },
  "rezolver-api/Rezolver.Compilation.CompileStackEntry.html": {
    "href": "rezolver-api/Rezolver.Compilation.CompileStackEntry.html",
    "title": "Class CompileStackEntry",
    "keywords": "Class CompileStackEntry Represents an entry in the compilation stack of a ICompileContext , recording both a target that is being compiled, and the type for which it is being compiled. Inheritance Object CompileStackEntry Inherited Members Namespace :Rezolver.Compilation Assembly :cs.temp.dll.dll Syntax public class CompileStackEntry : IEquatable<CompileStackEntry> Constructors | Improve this Doc CompileStackEntry(ITarget, Type) Initializes a new instance of the CompileStackEntry class. Declaration public CompileStackEntry(ITarget target, Type targetType) Parameters Type Name Description ITarget target The target being compiled. Type targetType Type for which the target is being compiled. Properties | Improve this Doc Target Gets the target being compiled. Declaration public ITarget Target { get; } Property Value Type Description ITarget | Improve this Doc TargetType Gets the type for which the target is being compiled. Declaration public Type TargetType { get; } Property Value Type Description Type Methods | Improve this Doc Equals(CompileStackEntry) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(CompileStackEntry other) Parameters Type Name Description CompileStackEntry other An object to compare with this object. Returns Type Description Boolean Implements Remarks Equality is defined as both the Target and the TargetType being equal between this instance and the other instance. | Improve this Doc Equals(Object) Determines whether the specified Object is equal to this instance. Declaration public override bool Equals(object obj) Parameters Type Name Description Object obj The object to compare with the current object. Returns Type Description Boolean Overrides | Improve this Doc GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description Int32 Overrides"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ChangeTypeTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ChangeTypeTargetBuilder.html",
    "title": "Class ChangeTypeTargetBuilder",
    "keywords": "Class ChangeTypeTargetBuilder Implementation of IExpressionBuilder specialised to build expressions for the This always produces a conversion expression (i.e. cast or box/unbox) Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ChangeTypeTarget > ChangeTypeTargetBuilder Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class ChangeTypeTargetBuilder : ExpressionBuilderBase<ChangeTypeTarget>, IExpressionBuilder<ChangeTypeTarget>, IExpressionBuilder Methods | Improve this Doc Build(ChangeTypeTarget, IExpressionCompileContext, IExpressionCompiler) Builds the conversion expression represented by the target Declaration protected override Expression Build(ChangeTypeTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ChangeTypeTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Returns Type Description Expression Overrides"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.ConstructorTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.ConstructorTargetBuilder.html",
    "title": "Class ConstructorTargetBuilder",
    "keywords": "Class ConstructorTargetBuilder An IExpressionBuilder specialised for building the target Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ConstructorTarget > ConstructorTargetBuilder Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class ConstructorTargetBuilder : ExpressionBuilderBase<ConstructorTarget>, IExpressionBuilder<ConstructorTarget>, IExpressionBuilder Methods | Improve this Doc Build(ConstructorTarget, IExpressionCompileContext, IExpressionCompiler) Override of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Declaration protected override Expression Build(ConstructorTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ConstructorTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The compiler to be used to build the target Returns Type Description Expression Overrides | Improve this Doc Build(ConstructorBinding, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the specified ConstructorBinding . Called by Build(ConstructorTarget, IExpressionCompileContext, IExpressionCompiler) Declaration protected virtual Expression Build(ConstructorBinding binding, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ConstructorBinding binding The binding. IExpressionCompileContext context The context. IExpressionCompiler compiler The compiler to be used to build the target. Returns Type Description Expression Remarks The returned expression will either be a NewExpression or a MemberInitExpression"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.DecoratorTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.DecoratorTargetBuilder.html",
    "title": "Class DecoratorTargetBuilder",
    "keywords": "Class DecoratorTargetBuilder Specialised builder for targets. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < DecoratorTarget > DecoratorTargetBuilder Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class DecoratorTargetBuilder : ExpressionBuilderBase<DecoratorTarget>, IExpressionBuilder<DecoratorTarget>, IExpressionBuilder Methods | Improve this Doc Build(DecoratorTarget, IExpressionCompileContext, IExpressionCompiler) Creates a new compilation context, registers the target's into it as the correct target for the , and then builds the expression for the (which is typically a constructor target). Declaration protected override Expression Build(DecoratorTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description DecoratorTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides"
  },
  "rezolver-api/Rezolver.Compilation.Expressions.DefaultTargetBuilder.html": {
    "href": "rezolver-api/Rezolver.Compilation.Expressions.DefaultTargetBuilder.html",
    "title": "Class DefaultTargetBuilder",
    "keywords": "Class DefaultTargetBuilder An IExpressionBuilder specialised for building the expression for the target. Essentially, it just calls for the . Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < DefaultTarget > DefaultTargetBuilder Inherited Members Namespace :Rezolver.Compilation.Expressions Assembly :cs.temp.dll.dll Syntax public class DefaultTargetBuilder : ExpressionBuilderBase<DefaultTarget>, IExpressionBuilder<DefaultTarget>, IExpressionBuilder Methods | Improve this Doc Build(DefaultTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target for the given ICompileContext Declaration protected override Expression Build(DefaultTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description DefaultTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides"
  }
}