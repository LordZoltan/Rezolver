{
  "api/Rezolver.Targets.html": {
    "href": "api/Rezolver.Targets.html",
    "title": "Namespace Rezolver.Targets",
    "keywords": "Namespace Rezolver.Targets Classes ChangeTypeTarget This target is specifically used for explicitly casting the result of one target to another type. Its use is rare, since the framework already caters for downcasting the result of targets to base types. ConstructorTarget A target that binds to a type's constructor with zero or more arguments supplied by other ITarget s and, optionally binding to the new instance's writeable properties. The target supports en explicitly supplied constructor, as well as just-in-time lookups for the best available constructor based on the available services and/or any named arguments which might been provided up front. DecoratorTarget Represents the action of implementing a common DecoratedType by decorating one instance (produced by DecoratedTarget ) with another ( Target , which will create an instance of DecoratorType ). NOTE - You shouldn't register or otherwise create instances of this target unless you absolutely know what you're doing. Rather, decorators should be registered using the extension method RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) or its non-generic alternative because the target needs a DecoratingTargetContainer to work properly (the creation of which is automatically handled by these extension methods). DefaultTarget A target that simply creates a default instance of a given type. I.e. the same as doing default(type) in C#. DelegateTarget An ITarget which resolve objects by executing a delegate with argument injection. DelegateTarget<TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget<T, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget<T1, T2, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget<T1, T2, T3, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget<T1, T2, T3, T4, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget<T1, T2, T3, T4, T5, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. ExpressionTarget A generic target for all expressions not explicitly supported by a particular target. Enables more complex behaviours to be registered and used with the more formal ITarget implementations. GenericConstructorTarget Equivalent of ConstructorTarget but for open generic types. So, this will handle the open generic MyType<,>, for example, whereas ConstructorTarget would handle the closed type MyType<int, string>. GenericConstructorTarget.GenericTypeMapping Result returned from the MapType(Type) function. Represents various levels of success - from a completely incompatible mapping ( Success = false ), or a successful mapping from an open generic type to a closed generic type which can then be constructed ( Success = true and IsFullyBound = true ) or, a successful mapping from an open generic type to another open generic type ( Success = true but IsFullyBound = false ). This mapping is then used by both the SupportsType(Type) and Bind(ICompileContext) functions. Only fully bound mappings are supported by Bind(ICompileContext) , whereas SupportsType(Type) will return true so long as the Success is true. The caller, therefore, must ensure it is aware of the difference between open and closed generics. ListTarget This target produces arrays ( AsArray = true ) or lists ( AsArray = false ) whose individual items are built by ITarget instances. Primarily used by the Rezolver.EnumerableTargetContainer and the configuration framework, but can also be used by your code. ObjectTarget Implements ITarget by wrapping a single instance that's already been constructed by application code. OptionalParameterTarget Used specifically when binding arguments to method parameters when a parameter is optional and its default value is to be used when binding to it. It is highly unlikely you'll ever create one of these directly. ResolvedTarget Represents a target that is rezolved statically at compile time via the ICompileContext , or dynamically (at 'resolve time') from the IContainer that is attached to the current ResolveContext when Resolve(ResolveContext) is called. This is the most common way that we bind constructor parameters, for example - i.e. 'I want an IService instance - go get it'. ScopedTarget A target that produces or fetches a single instance of an object within a lifetime scope. SingletonTarget A target which applies the singleton pattern to any ITarget . The inner target is available from the InnerTarget property. TargetBase Abstract base class, suggested as a starting point for implementations of ITarget . UnscopedTarget Wraps another target to force scoping to be ignored for the object that it produces, regardless of whether that object is IDisposable or otherwise has its own scoping behaviour."
  },
  "api/Rezolver.html": {
    "href": "api/Rezolver.html",
    "title": "Namespace Rezolver",
    "keywords": "Namespace Rezolver Classes AliasTargetContainerExtensions Contains extension methods for ITargetContainer to create targets which alias others by different types. CachingContainerBase Builds on the ContainerBase base class to introduce thread-safe caching of compiled targets so they are only compiled once per requested type. Only creatable through inheritance. ChildTargetContainer A version of TargetContainer which overrides the registrations of another (the Parent ). ConstructorBinding Represents a binding specifically to a class constructor, optionally with an additional set of MemberBindings to be used to initialise a new instance's properties or fields directly. Container The standard IOC container class in Rezolver. ContainerBase Starting point for implementations of IContainer - only creatable through inheritance. ContainerBase.DirectResolveCompiledTarget Used when an ITarget is also of the same type as the one for which it is returned by the Fetch(Type) method of the Targets container. In this case, the target is not compiled, but instead is simply returned as the desired object. ContainerBase.MissingCompiledTarget Used as a sentinel type when a type cannot be resolved by a ContainerBase instance. Instead of returning a null ICompiledTarget instance, the container will construct an instance of this type (typically through GetMissingTarget(Type) , which caches singleton instances of this class on a per-type basis) which can then be used just as if the lookup succeeded. ContainerResolveExtensions Extension methods for IContainer which provide shortcuts for the Resolve(ResolveContext) operation. ContainerScope Standard implementation of the IContainerScope interface. ContainerScopeExtensions Standard extensions for the IContainerScope ContainerScopeResolveExtensions Extensions for IContainerScope so that instances of that interface present a similar set of functionality to IContainer . DecoratingTargetContainer Implements service decoration in an ITargetContainer , producing instances of the DecoratorTarget when Fetch(Type) or FetchAll(Type) are called. The best way to add a decorator to your target container is to use the extension method RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) or its non-generic equivalent. DecoratorTargetContainerExtensions Extensions for ITargetContainerOwner which simplify the registration of decorators (via the DecoratingTargetContainer pseudo-target) DefaultMemberBindingBehaviour The default implementation of IMemberBindingBehaviour when you are creating a ConstructorTarget or GenericConstructorTarget and you want publicly writable properties and public fields to be assigned values obtained from the container. If you do not require properties or fields to be bound from the container, then use a null IMemberBindingBehaviour . DelegateTargetContainerExtensions Extension methods for ITargetContainer designed to simplify the registration of DelegateTarget and its numerous generic variants. EnumerableTargetBuilderExtensions Houses an extension method which enables native resolving of IEnumerables of services on ITargetContainer containers which, in turn, enables it for any ContainerBase containers which use that target container. ExceptionResources A strongly-typed resource class, for looking up localized strings, etc. ExpressionTargetContainerExtensions Extensions for to simplify registering expressions in an ITargetContainer . Functions This type is only used when using expressions as targets (via the ExpressionTarget type) - it's functions server no actual purpose other than to act as hooks to create specific ITarget objects in place of static code. For example, the Resolve<T>() function is used to trigger the creation of a ResolvedTarget in its place - thus allowing expressions to leverage the full power of the Rezolver API all through a simple method call. GenericTargetContainer A special type of ITargetContainerOwner which stores targets (and potentially other containers) which are specifically keyed either to a particular open generic type or a closed generic built from it. MemberBinding Represents the binding of an ITarget to a property or field of a given type. Not to be confused with the type of the same name from the System.Linq.Expressions namespace, although they are technically equivalent. MethodBinding Represents a binding to a method whose arguments will be supplied by ITarget instances. MethodCallExtractor Used to help grab method and constructor info from expressions (which is easier than writing long strings of reflection code). For example: MethodCallExtractor.ExtractCalledMethod(() => Console.WriteLine(\"foo\")) Will return the MethodInfo for the WriteLine method of the Console class. MultipleTargetContainerExtensions Extensions for registering multiple targets individually and against the same type ObjectTargetContainerExtensions Extensions for ITargetContainer relating to registering concrete instances via the ObjectTarget target. OverridingContainer An IContainer which can override the resolve operations of another. This is useful when you have a core application-wide container, with some objects being customised based on some ambient information, e.g. configuration, MVC Area/Controller, Brand (in a multi-tenant application for example) or more. ParameterBinding Represents a binding between a method parameter and an ITarget RegisterTypeTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for the simplest cases of registering ConstructorTarget and GenericConstructorTarget targets. ResolveContext Captures the state for a call to Resolve(ResolveContext) (or TryResolve(ResolveContext, out Object) ), including the container on which the operation is invoked, any IScopedContainer that might be active for the call (if different), and the type which is being resolved from the IContainer . ScopedContainer Extends the Container to implement lifetime implicit scoping through the Scope that's created along with it. Implementation of the IScopedContainer interface. ScopedTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for registering constructor-injected types whose lifetimes are slaved to that of a parent IScopedContainer . All of the extension methods ultimately create a ScopedTarget SingletonTargetContainerExtensions Extension methods for the ITargetContainer interface which simplify the registration of singletons. TargetContainer Root container for ITarget s that can be used as the backing for the standard IContainer classes - Container and ScopedContainer . Stores and retrieves registrations of ITarget s, is also Generic type aware, unlike its base class - TargetDictionaryContainer . TargetCreationExtensions Extensions which provide shortcuts for creating some of the targets in the Rezolver.Targets namespace. TargetDictionaryContainer An ITargetContainerOwner implementation that stores and retrieves ITarget and ITargetContainer by type. TargetListContainer An ITargetContainer that stores multiple targets in a list. This is not a type that you would typically use directly in your code, unless you are writing custom logic/behaviour for ITarget registration. Interfaces IChildTargetContainer An ITargetContainer that inherits all registrations from a ( Parent ) target container. If it cannot resolve a target for a particular type, will defer to its parent for fallback. ICompiledTarget Provides an abstraction for creating objects based on a given ResolveContext - this is the ultimate target of all Resolve(ResolveContext) calls in the standard container implementations within the Rezolver framework. IContainer The primary IOC container interface in the Rezolver framework. IContainerScope This is an IContainer -like object (resolving functionality is provided through the extension methods in the ContainerScopeResolveExtensions class) which IMemberBindingBehaviour Describes a type which discovers and creates property/field bindings, typically for use when creating a new instance. IScopedContainer An IContainer that also has a Scope attached to it. Many applications will use such a container as the root container to use as anchors for things like scoped singletons. ITarget Represents an action to be performed in order to obtain an object to satisfy a call to Resolve(ResolveContext) , when the standard implementations of IContainer are used (e.g. Container ). ITargetContainer Stores and retrieves ITarget instances, keyed by the type of service that the targets are registered against. This is where all your service registrations will ultimately go. ITargetContainerOwner Interface for an ITargetContainer which also contains other target containers. It is not typically used by your application code since it's primarily an infrastructure interface - if you are extending the API, however, then you might need to work with it. Enums ScopeBehaviour Describes different ways in which objeects interact with scopes."
  },
  "api/Rezolver.Compilation.CompilerConfiguration.html": {
    "href": "api/Rezolver.Compilation.CompilerConfiguration.html",
    "title": "Class CompilerConfiguration",
    "keywords": "Class CompilerConfiguration Controls the system-wide compiler configuration used by default by all standard Rezolver containers. Inheritance Object CompilerConfiguration Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation Assembly :Rezolver.dll Syntax public static class CompilerConfiguration Properties | Improve this Doc View Source DefaultProvider Gets or sets the default ICompilerConfigurationProvider used by classes derived from ContainerBase to self-configure for target compilation. Declaration public static ICompilerConfigurationProvider DefaultProvider { get; set; } Property Value Type Description ICompilerConfigurationProvider Remarks The default implementation will throw an InvalidOperationException as soon as its Configure(IContainer, ITargetContainer) method is called - therefore it's imperative either that you change this provider for one which actually configures the container to support compilation, or that you explicitly pass a provider to the container when you create it. The standard expression compiler defined in the Rezolver.Compilation.Expressions library defines a provider in Rezolver.Compilation.Expressions.ConfigProvider , and a static configuration method UseAsDefaultCompiler which automatically sets it into this property for you."
  },
  "api/Rezolver.Compilation.Expressions.ExpressionCompilerBuildExtensions.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionCompilerBuildExtensions.html",
    "title": "Class ExpressionCompilerBuildExtensions",
    "keywords": "Class ExpressionCompilerBuildExtensions Extensions for IExpressionCompiler . Inheritance Object ExpressionCompilerBuildExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public static class ExpressionCompilerBuildExtensions Methods | Improve this Doc View Source BuildResolveLambda(IExpressionCompiler, ITarget, IExpressionCompileContext) This method is a shortcut for building a lambda expression directly from an ITarget . It calls Build(ITarget, IExpressionCompileContext) and passes the result to BuildResolveLambda(Expression, IExpressionCompileContext) , which should yield an optimised lambda expression for the expression produced from the target which can then be compiled and used as the factory for that target. Declaration public static Expression<Func<ResolveContext, object>> BuildResolveLambda(this IExpressionCompiler compiler, ITarget target, IExpressionCompileContext context) Parameters Type Name Description IExpressionCompiler compiler The compiler. ITarget target The target. IExpressionCompileContext context The current compilation context. Returns Type Description Expression < Func < ResolveContext , Object >>"
  },
  "api/Rezolver.Compilation.Expressions.ListTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ListTargetBuilder.html",
    "title": "Class ListTargetBuilder",
    "keywords": "Class ListTargetBuilder An IExpressionBuilder specialised for building expressions for the ListTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ListTarget > ListTargetBuilder Inherited Members ExpressionBuilderBase<ListTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ListTarget>.IExpressionBuilder<ListTarget>.Build(ListTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ListTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class ListTargetBuilder : ExpressionBuilderBase<ListTarget>, IExpressionBuilder<ListTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ListTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression which either represents creating an array or a list of objects using an enumerable of targets from the target 's Items . The target's AsArray flag is used to determine which expression to build. Declaration protected override Expression Build(ListTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ListTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ListTarget>.Build(Rezolver.Targets.ListTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.TargetExpression.html": {
    "href": "api/Rezolver.Compilation.Expressions.TargetExpression.html",
    "title": "Class TargetExpression",
    "keywords": "Class TargetExpression An expression which represents an ITarget . Inheritance Object Expression TargetExpression Inherited Members Expression.Accept(ExpressionVisitor) Expression.Add(Expression, Expression) Expression.Add(Expression, Expression, MethodInfo) Expression.AddAssign(Expression, Expression) Expression.AddAssign(Expression, Expression, MethodInfo) Expression.AddAssign(Expression, Expression, MethodInfo, LambdaExpression) Expression.AddAssignChecked(Expression, Expression) Expression.AddAssignChecked(Expression, Expression, MethodInfo) Expression.AddAssignChecked(Expression, Expression, MethodInfo, LambdaExpression) Expression.AddChecked(Expression, Expression) Expression.AddChecked(Expression, Expression, MethodInfo) Expression.And(Expression, Expression) Expression.And(Expression, Expression, MethodInfo) Expression.AndAlso(Expression, Expression) Expression.AndAlso(Expression, Expression, MethodInfo) Expression.AndAssign(Expression, Expression) Expression.AndAssign(Expression, Expression, MethodInfo) Expression.AndAssign(Expression, Expression, MethodInfo, LambdaExpression) Expression.ArrayAccess(Expression, IEnumerable<Expression>) Expression.ArrayAccess(Expression, Expression[]) Expression.ArrayIndex(Expression, IEnumerable<Expression>) Expression.ArrayIndex(Expression, Expression) Expression.ArrayIndex(Expression, Expression[]) Expression.ArrayLength(Expression) Expression.Assign(Expression, Expression) Expression.Bind(MemberInfo, Expression) Expression.Bind(MethodInfo, Expression) Expression.Block(IEnumerable<Expression>) Expression.Block(IEnumerable<ParameterExpression>, IEnumerable<Expression>) Expression.Block(IEnumerable<ParameterExpression>, Expression[]) Expression.Block(Expression, Expression) Expression.Block(Expression, Expression, Expression) Expression.Block(Expression, Expression, Expression, Expression) Expression.Block(Expression, Expression, Expression, Expression, Expression) Expression.Block(Expression[]) Expression.Block(Type, IEnumerable<Expression>) Expression.Block(Type, IEnumerable<ParameterExpression>, IEnumerable<Expression>) Expression.Block(Type, IEnumerable<ParameterExpression>, Expression[]) Expression.Block(Type, Expression[]) Expression.Break(LabelTarget) Expression.Break(LabelTarget, Expression) Expression.Break(LabelTarget, Expression, Type) Expression.Break(LabelTarget, Type) Expression.Call(Expression, MethodInfo) Expression.Call(Expression, MethodInfo, IEnumerable<Expression>) Expression.Call(Expression, MethodInfo, Expression, Expression) Expression.Call(Expression, MethodInfo, Expression, Expression, Expression) Expression.Call(Expression, MethodInfo, Expression[]) Expression.Call(Expression, String, Type[], Expression[]) Expression.Call(MethodInfo, IEnumerable<Expression>) Expression.Call(MethodInfo, Expression) Expression.Call(MethodInfo, Expression, Expression) Expression.Call(MethodInfo, Expression, Expression, Expression) Expression.Call(MethodInfo, Expression, Expression, Expression, Expression) Expression.Call(MethodInfo, Expression, Expression, Expression, Expression, Expression) Expression.Call(MethodInfo, Expression[]) Expression.Call(Type, String, Type[], Expression[]) Expression.Catch(ParameterExpression, Expression) Expression.Catch(ParameterExpression, Expression, Expression) Expression.Catch(Type, Expression) Expression.Catch(Type, Expression, Expression) Expression.ClearDebugInfo(SymbolDocumentInfo) Expression.Coalesce(Expression, Expression) Expression.Coalesce(Expression, Expression, LambdaExpression) Expression.Condition(Expression, Expression, Expression) Expression.Condition(Expression, Expression, Expression, Type) Expression.Constant(Object) Expression.Constant(Object, Type) Expression.Continue(LabelTarget) Expression.Continue(LabelTarget, Type) Expression.Convert(Expression, Type) Expression.Convert(Expression, Type, MethodInfo) Expression.ConvertChecked(Expression, Type) Expression.ConvertChecked(Expression, Type, MethodInfo) Expression.DebugInfo(SymbolDocumentInfo, Int32, Int32, Int32, Int32) Expression.Decrement(Expression) Expression.Decrement(Expression, MethodInfo) Expression.Default(Type) Expression.Divide(Expression, Expression) Expression.Divide(Expression, Expression, MethodInfo) Expression.DivideAssign(Expression, Expression) Expression.DivideAssign(Expression, Expression, MethodInfo) Expression.DivideAssign(Expression, Expression, MethodInfo, LambdaExpression) Expression.ElementInit(MethodInfo, IEnumerable<Expression>) Expression.ElementInit(MethodInfo, Expression[]) Expression.Empty() Expression.Equal(Expression, Expression) Expression.Equal(Expression, Expression, Boolean, MethodInfo) Expression.ExclusiveOr(Expression, Expression) Expression.ExclusiveOr(Expression, Expression, MethodInfo) Expression.ExclusiveOrAssign(Expression, Expression) Expression.ExclusiveOrAssign(Expression, Expression, MethodInfo) Expression.ExclusiveOrAssign(Expression, Expression, MethodInfo, LambdaExpression) Expression.Field(Expression, FieldInfo) Expression.Field(Expression, String) Expression.Field(Expression, Type, String) Expression.GetActionType(Type[]) Expression.GetDelegateType(Type[]) Expression.GetFuncType(Type[]) Expression.Goto(LabelTarget) Expression.Goto(LabelTarget, Expression) Expression.Goto(LabelTarget, Expression, Type) Expression.Goto(LabelTarget, Type) Expression.GreaterThan(Expression, Expression) Expression.GreaterThan(Expression, Expression, Boolean, MethodInfo) Expression.GreaterThanOrEqual(Expression, Expression) Expression.GreaterThanOrEqual(Expression, Expression, Boolean, MethodInfo) Expression.IfThen(Expression, Expression) Expression.IfThenElse(Expression, Expression, Expression) Expression.Increment(Expression) Expression.Increment(Expression, MethodInfo) Expression.Invoke(Expression, IEnumerable<Expression>) Expression.Invoke(Expression, Expression[]) Expression.IsFalse(Expression) Expression.IsFalse(Expression, MethodInfo) Expression.IsTrue(Expression) Expression.IsTrue(Expression, MethodInfo) Expression.Label() Expression.Label(LabelTarget) Expression.Label(LabelTarget, Expression) Expression.Label(String) Expression.Label(Type) Expression.Label(Type, String) Expression.Lambda(Expression, Boolean, IEnumerable<ParameterExpression>) Expression.Lambda(Expression, Boolean, ParameterExpression[]) Expression.Lambda(Expression, IEnumerable<ParameterExpression>) Expression.Lambda(Expression, ParameterExpression[]) Expression.Lambda(Expression, String, Boolean, IEnumerable<ParameterExpression>) Expression.Lambda(Expression, String, IEnumerable<ParameterExpression>) Expression.Lambda(Type, Expression, Boolean, IEnumerable<ParameterExpression>) Expression.Lambda(Type, Expression, Boolean, ParameterExpression[]) Expression.Lambda(Type, Expression, IEnumerable<ParameterExpression>) Expression.Lambda(Type, Expression, ParameterExpression[]) Expression.Lambda(Type, Expression, String, Boolean, IEnumerable<ParameterExpression>) Expression.Lambda(Type, Expression, String, IEnumerable<ParameterExpression>) Expression.Lambda<TDelegate>(Expression, Boolean, IEnumerable<ParameterExpression>) Expression.Lambda<TDelegate>(Expression, Boolean, ParameterExpression[]) Expression.Lambda<TDelegate>(Expression, IEnumerable<ParameterExpression>) Expression.Lambda<TDelegate>(Expression, ParameterExpression[]) Expression.Lambda<TDelegate>(Expression, String, Boolean, IEnumerable<ParameterExpression>) Expression.Lambda<TDelegate>(Expression, String, IEnumerable<ParameterExpression>) Expression.LeftShift(Expression, Expression) Expression.LeftShift(Expression, Expression, MethodInfo) Expression.LeftShiftAssign(Expression, Expression) Expression.LeftShiftAssign(Expression, Expression, MethodInfo) Expression.LeftShiftAssign(Expression, Expression, MethodInfo, LambdaExpression) Expression.LessThan(Expression, Expression) Expression.LessThan(Expression, Expression, Boolean, MethodInfo) Expression.LessThanOrEqual(Expression, Expression) Expression.LessThanOrEqual(Expression, Expression, Boolean, MethodInfo) Expression.ListBind(MemberInfo, IEnumerable<ElementInit>) Expression.ListBind(MemberInfo, ElementInit[]) Expression.ListBind(MethodInfo, IEnumerable<ElementInit>) Expression.ListBind(MethodInfo, ElementInit[]) Expression.ListInit(NewExpression, IEnumerable<ElementInit>) Expression.ListInit(NewExpression, IEnumerable<Expression>) Expression.ListInit(NewExpression, ElementInit[]) Expression.ListInit(NewExpression, Expression[]) Expression.ListInit(NewExpression, MethodInfo, IEnumerable<Expression>) Expression.ListInit(NewExpression, MethodInfo, Expression[]) Expression.Loop(Expression) Expression.Loop(Expression, LabelTarget) Expression.Loop(Expression, LabelTarget, LabelTarget) Expression.MakeBinary(ExpressionType, Expression, Expression) Expression.MakeBinary(ExpressionType, Expression, Expression, Boolean, MethodInfo) Expression.MakeBinary(ExpressionType, Expression, Expression, Boolean, MethodInfo, LambdaExpression) Expression.MakeCatchBlock(Type, ParameterExpression, Expression, Expression) Expression.MakeGoto(GotoExpressionKind, LabelTarget, Expression, Type) Expression.MakeIndex(Expression, PropertyInfo, IEnumerable<Expression>) Expression.MakeMemberAccess(Expression, MemberInfo) Expression.MakeTry(Type, Expression, Expression, Expression, IEnumerable<CatchBlock>) Expression.MakeUnary(ExpressionType, Expression, Type) Expression.MakeUnary(ExpressionType, Expression, Type, MethodInfo) Expression.MemberBind(MemberInfo, IEnumerable<MemberBinding>) Expression.MemberBind(MemberInfo, MemberBinding[]) Expression.MemberBind(MethodInfo, IEnumerable<MemberBinding>) Expression.MemberBind(MethodInfo, MemberBinding[]) Expression.MemberInit(NewExpression, IEnumerable<MemberBinding>) Expression.MemberInit(NewExpression, MemberBinding[]) Expression.Modulo(Expression, Expression) Expression.Modulo(Expression, Expression, MethodInfo) Expression.ModuloAssign(Expression, Expression) Expression.ModuloAssign(Expression, Expression, MethodInfo) Expression.ModuloAssign(Expression, Expression, MethodInfo, LambdaExpression) Expression.Multiply(Expression, Expression) Expression.Multiply(Expression, Expression, MethodInfo) Expression.MultiplyAssign(Expression, Expression) Expression.MultiplyAssign(Expression, Expression, MethodInfo) Expression.MultiplyAssign(Expression, Expression, MethodInfo, LambdaExpression) Expression.MultiplyAssignChecked(Expression, Expression) Expression.MultiplyAssignChecked(Expression, Expression, MethodInfo) Expression.MultiplyAssignChecked(Expression, Expression, MethodInfo, LambdaExpression) Expression.MultiplyChecked(Expression, Expression) Expression.MultiplyChecked(Expression, Expression, MethodInfo) Expression.Negate(Expression) Expression.Negate(Expression, MethodInfo) Expression.NegateChecked(Expression) Expression.NegateChecked(Expression, MethodInfo) Expression.New(ConstructorInfo) Expression.New(ConstructorInfo, IEnumerable<Expression>) Expression.New(ConstructorInfo, IEnumerable<Expression>, IEnumerable<MemberInfo>) Expression.New(ConstructorInfo, IEnumerable<Expression>, MemberInfo[]) Expression.New(ConstructorInfo, Expression[]) Expression.New(Type) Expression.NewArrayBounds(Type, IEnumerable<Expression>) Expression.NewArrayBounds(Type, Expression[]) Expression.NewArrayInit(Type, IEnumerable<Expression>) Expression.NewArrayInit(Type, Expression[]) Expression.Not(Expression) Expression.Not(Expression, MethodInfo) Expression.NotEqual(Expression, Expression) Expression.NotEqual(Expression, Expression, Boolean, MethodInfo) Expression.OnesComplement(Expression) Expression.OnesComplement(Expression, MethodInfo) Expression.Or(Expression, Expression) Expression.Or(Expression, Expression, MethodInfo) Expression.OrAssign(Expression, Expression) Expression.OrAssign(Expression, Expression, MethodInfo) Expression.OrAssign(Expression, Expression, MethodInfo, LambdaExpression) Expression.OrElse(Expression, Expression) Expression.OrElse(Expression, Expression, MethodInfo) Expression.Parameter(Type) Expression.Parameter(Type, String) Expression.PostDecrementAssign(Expression) Expression.PostDecrementAssign(Expression, MethodInfo) Expression.PostIncrementAssign(Expression) Expression.PostIncrementAssign(Expression, MethodInfo) Expression.Power(Expression, Expression) Expression.Power(Expression, Expression, MethodInfo) Expression.PowerAssign(Expression, Expression) Expression.PowerAssign(Expression, Expression, MethodInfo) Expression.PowerAssign(Expression, Expression, MethodInfo, LambdaExpression) Expression.PreDecrementAssign(Expression) Expression.PreDecrementAssign(Expression, MethodInfo) Expression.PreIncrementAssign(Expression) Expression.PreIncrementAssign(Expression, MethodInfo) Expression.Property(Expression, MethodInfo) Expression.Property(Expression, PropertyInfo) Expression.Property(Expression, PropertyInfo, IEnumerable<Expression>) Expression.Property(Expression, PropertyInfo, Expression[]) Expression.Property(Expression, String) Expression.Property(Expression, String, Expression[]) Expression.Property(Expression, Type, String) Expression.PropertyOrField(Expression, String) Expression.Quote(Expression) Expression.ReduceAndCheck() Expression.ReduceExtensions() Expression.ReferenceEqual(Expression, Expression) Expression.ReferenceNotEqual(Expression, Expression) Expression.Rethrow() Expression.Rethrow(Type) Expression.Return(LabelTarget) Expression.Return(LabelTarget, Expression) Expression.Return(LabelTarget, Expression, Type) Expression.Return(LabelTarget, Type) Expression.RightShift(Expression, Expression) Expression.RightShift(Expression, Expression, MethodInfo) Expression.RightShiftAssign(Expression, Expression) Expression.RightShiftAssign(Expression, Expression, MethodInfo) Expression.RightShiftAssign(Expression, Expression, MethodInfo, LambdaExpression) Expression.RuntimeVariables(IEnumerable<ParameterExpression>) Expression.RuntimeVariables(ParameterExpression[]) Expression.Subtract(Expression, Expression) Expression.Subtract(Expression, Expression, MethodInfo) Expression.SubtractAssign(Expression, Expression) Expression.SubtractAssign(Expression, Expression, MethodInfo) Expression.SubtractAssign(Expression, Expression, MethodInfo, LambdaExpression) Expression.SubtractAssignChecked(Expression, Expression) Expression.SubtractAssignChecked(Expression, Expression, MethodInfo) Expression.SubtractAssignChecked(Expression, Expression, MethodInfo, LambdaExpression) Expression.SubtractChecked(Expression, Expression) Expression.SubtractChecked(Expression, Expression, MethodInfo) Expression.Switch(Expression, Expression, SwitchCase[]) Expression.Switch(Expression, Expression, MethodInfo, IEnumerable<SwitchCase>) Expression.Switch(Expression, Expression, MethodInfo, SwitchCase[]) Expression.Switch(Expression, SwitchCase[]) Expression.Switch(Type, Expression, Expression, MethodInfo, IEnumerable<SwitchCase>) Expression.Switch(Type, Expression, Expression, MethodInfo, SwitchCase[]) Expression.SwitchCase(Expression, IEnumerable<Expression>) Expression.SwitchCase(Expression, Expression[]) Expression.SymbolDocument(String) Expression.SymbolDocument(String, Guid) Expression.SymbolDocument(String, Guid, Guid) Expression.SymbolDocument(String, Guid, Guid, Guid) Expression.Throw(Expression) Expression.Throw(Expression, Type) Expression.ToString() Expression.TryCatch(Expression, CatchBlock[]) Expression.TryCatchFinally(Expression, Expression, CatchBlock[]) Expression.TryFault(Expression, Expression) Expression.TryFinally(Expression, Expression) Expression.TryGetActionType(Type[], Type) Expression.TryGetFuncType(Type[], Type) Expression.TypeAs(Expression, Type) Expression.TypeEqual(Expression, Type) Expression.TypeIs(Expression, Type) Expression.UnaryPlus(Expression) Expression.UnaryPlus(Expression, MethodInfo) Expression.Unbox(Expression, Type) Expression.Variable(Type) Expression.Variable(Type, String) Expression.VisitChildren(ExpressionVisitor) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class TargetExpression : Expression Remarks The ExpressionTargetBuilder uses this class extensively when translating expressions into targets and back again. It's highly unlikely you'll need to use it in your code. It acts as a placeholder for targets until the point at which the expression compiler wants to build a complete expression tree for a target. Constructors | Improve this Doc View Source TargetExpression(ITarget) Initializes a new instance of the TargetExpression class. Declaration public TargetExpression(ITarget target) Parameters Type Name Description ITarget target The target. Properties | Improve this Doc View Source CanReduce Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form. Declaration public override bool CanReduce { get; } Property Value Type Description Boolean true if this instance can reduce; otherwise, false . Overrides Expression.CanReduce Remarks The implementation always returns true ; although the Reduce() methodd is not implemented. | Improve this Doc View Source NodeType Gets the node type of this Expression . Declaration public override ExpressionType NodeType { get; } Property Value Type Description ExpressionType Always returns Extension . Overrides Expression.NodeType | Improve this Doc View Source Target Gets the target whose expression will be subsituted for this TargetExpression in the final expression tree. Declaration public ITarget Target { get; } Property Value Type Description ITarget | Improve this Doc View Source Type Gets the static type of the expression that this Expression represents. Declaration public override Type Type { get; } Property Value Type Description Type Overrides Expression.Type Remarks Always returns the type referenced by the DeclaredType property of Target . Methods | Improve this Doc View Source Reduce() Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced. Declaration public override Expression Reduce() Returns Type Description Expression Overrides Expression.Reduce() Exceptions Type Condition NotSupportedException RezolveTargetExpression must be rewritten as a bona-fide expression before walking the expression tree for any other purpose Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.html": {
    "href": "api/Rezolver.Compilation.html",
    "title": "Namespace Rezolver.Compilation",
    "keywords": "Namespace Rezolver.Compilation Classes CompileContext Core implementation of ICompileContext . A root context (i.e. where ParentContext is null ; created via the CompileContext(IContainer, ITargetContainer, Type) constructor) is the starting point for all shared state, such as the Container and the compilation stack. The ITargetContainer implementation is done by decorating a new ChildTargetContainer , so that new registrations can be added without interfering with upstream containers. Note that many of the interface members are implemented explicitly - therefore most of your interaction with this type is through its implementation of ICompileContext and ITargetContainer . CompilerConfiguration Controls the system-wide compiler configuration used by default by all standard Rezolver containers. CompileStackEntry Represents an entry in the compilation stack of a ICompileContext , recording both a target that is being compiled, and the type for which it is being compiled. TargetCompiler Holds a reference to the default compiler for this application. Interfaces ICompileContext Tracks state and provides services during the compilation phase in which ITarget targets are compiled into ICompiledTarget targets, which produce actual instances of objects. ICompileContextProvider Interface for an object which creates ICompileContext instances for when the system needs to compile an ITarget into an ICompiledTarget . ICompilerConfigurationProvider Interface for an object which configures the compiler for the given container and/or targets object to use a specific ITargetCompiler and ICompileContextProvider . Used by all the standard container types in the Rezolver framework. You can provide a specific provider to most containers on creation, and you can configure the default system-wide provider via the DefaultProvider static property. ITargetCompiler An object that produces ICompiledTarget s from ITarget s given a particular ICompileContext ."
  },
  "api/Rezolver.ContainerScope.html": {
    "href": "api/Rezolver.ContainerScope.html",
    "title": "Class ContainerScope",
    "keywords": "Class ContainerScope Standard implementation of the IContainerScope interface. Inheritance Object ContainerScope Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class ContainerScope : IContainerScope, IDisposable, IServiceProvider Constructors | Improve this Doc View Source ContainerScope(IContainer) Creates a new root scope tied to the given container Declaration public ContainerScope(IContainer container) Parameters Type Name Description IContainer container | Improve this Doc View Source ContainerScope(IContainerScope, IContainer) Creates a new container that is a child of another. The Container will be inherited from the parentScope by default, unless it's overriden by containerOverride . Declaration public ContainerScope(IContainerScope parentScope, IContainer containerOverride = null) Parameters Type Name Description IContainerScope parentScope Required - the parent scope IContainer containerOverride Optional - the container which should be used for resolve operations executed against this scope (note - all the resolve methods are declared as extension methods which mirror those present on IContainer . Properties | Improve this Doc View Source Container The container that this scope is tied to. All standard resolve operations should be made against this container. Declaration public IContainer Container { get; } Property Value Type Description IContainer The container. Implements IContainerScope.Container | Improve this Doc View Source Disposed Gets a value indicating whether this ContainerScope is disposed. Declaration public bool Disposed { get; } Property Value Type Description Boolean true if disposed; otherwise, false . | Improve this Doc View Source Parent If this scope has a parent scope, this is it. Declaration public IContainerScope Parent { get; } Property Value Type Description IContainerScope The parent. Implements IContainerScope.Parent Methods | Improve this Doc View Source ChildScopeDisposed(IContainerScope) Called by child scopes when they are disposed to notify the parent that they will no longer need to be disposed of when the parent is disposed. Declaration public void ChildScopeDisposed(IContainerScope child) Parameters Type Name Description IContainerScope child The child. Implements IContainerScope.ChildScopeDisposed(IContainerScope) Remarks This is an infrastructure method and not something you would usually need to call. It's exposed for developers who are extending the container scoping functionality only. | Improve this Doc View Source CreateScope() Called to create a child scope from this scope. The implementation adds the new scope to a private collection so that it can dispose of the new child if it is not already disposed. Declaration public IContainerScope CreateScope() Returns Type Description IContainerScope Implements IContainerScope.CreateScope() | Improve this Doc View Source Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() Implements IDisposable.Dispose() | Improve this Doc View Source Dispose(Boolean) Releases unmanaged and - optionally - managed resources. Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description Boolean disposing true to release both managed and unmanaged resources; false to release only unmanaged resources. Explicit Interface Implementations | Improve this Doc View Source IContainerScope.Resolve(ResolveContext, Func<ResolveContext, Object>, ScopeBehaviour) Declaration object IContainerScope.Resolve(ResolveContext context, Func<ResolveContext, object> factory, ScopeBehaviour behaviour) Parameters Type Name Description ResolveContext context Func < ResolveContext , Object > factory ScopeBehaviour behaviour Returns Type Description Object Implements IContainerScope.Resolve(ResolveContext, Func<ResolveContext, Object>, ScopeBehaviour) | Improve this Doc View Source IServiceProvider.GetService(Type) Declaration object IServiceProvider.GetService(Type serviceType) Parameters Type Name Description Type serviceType Returns Type Description Object Implements IServiceProvider.GetService(Type) Extension Methods ContainerScopeExtensions.GetRootScope(IContainerScope) ContainerScopeResolveExtensions.Resolve<TResult>(IContainerScope) ContainerScopeResolveExtensions.Resolve(IContainerScope, Type) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also IContainerScope"
  },
  "api/Rezolver.RegisterTypeTargetContainerExtensions.html": {
    "href": "api/Rezolver.RegisterTypeTargetContainerExtensions.html",
    "title": "Class RegisterTypeTargetContainerExtensions",
    "keywords": "Class RegisterTypeTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for the simplest cases of registering ConstructorTarget and GenericConstructorTarget targets. Inheritance Object RegisterTypeTargetContainerExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public static class RegisterTypeTargetContainerExtensions Methods | Improve this Doc View Source RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) Registers an instance of objectType (optionally for the service type serviceType ) to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. Type objectType The type of the object that is to be constructed when resolved. Type serviceType Optional. The type against which the registration will be performed, if different from objectType . objectType must be compatible with this type, if it's provided. IMemberBindingBehaviour propertyBindingBehaviour Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto(Type, IMemberBindingBehaviour) or Auto(Type, IMemberBindingBehaviour) static methods and then registering it against the type serviceType or objectType . | Improve this Doc View Source RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) Registers an instance of TObject to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType<TObject>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IMemberBindingBehaviour propertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto<T>(IMemberBindingBehaviour) or Auto(Type, IMemberBindingBehaviour) static methods and then registering it. | Improve this Doc View Source RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) Registers an instance of TObject for the service type TService to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterType<TObject, TService>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null)where TObject : TService Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IMemberBindingBehaviour propertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. TService The type against which the registration will be performed. TObject must be compatible with this type. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto<T>(IMemberBindingBehaviour) or Auto(Type, IMemberBindingBehaviour) static methods and then registering it against the type TService ."
  },
  "api/Rezolver.Targets.DelegateTarget-1.html": {
    "href": "api/Rezolver.Targets.DelegateTarget-1.html",
    "title": "Class DelegateTarget<TResult>",
    "keywords": "Class DelegateTarget<TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<TResult> Inherited Members DelegateTarget.Factory DelegateTarget.FactoryMethod DelegateTarget.DeclaredType TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DelegateTarget<TResult> : DelegateTarget, ITarget Type Parameters Name Description TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc View Source DelegateTarget(Func<TResult>, Type) Initializes a new instance of the DelegateTarget<TResult> class. Declaration public DelegateTarget(Func<TResult> factory, Type declaredType = null) Parameters Type Name Description Func <TResult> factory The factory. Type declaredType Type of the declared. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.DelegateTarget-10.html": {
    "href": "api/Rezolver.Targets.DelegateTarget-10.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.FactoryMethod DelegateTarget.DeclaredType TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc View Source DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> factory The factory. Type declaredType Type of the declared. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.GenericConstructorTarget.GenericTypeMapping.html": {
    "href": "api/Rezolver.Targets.GenericConstructorTarget.GenericTypeMapping.html",
    "title": "Class GenericConstructorTarget.GenericTypeMapping",
    "keywords": "Class GenericConstructorTarget.GenericTypeMapping Result returned from the MapType(Type) function. Represents various levels of success - from a completely incompatible mapping ( Success = false ), or a successful mapping from an open generic type to a closed generic type which can then be constructed ( Success = true and IsFullyBound = true ) or, a successful mapping from an open generic type to another open generic type ( Success = true but IsFullyBound = false ). This mapping is then used by both the SupportsType(Type) and Bind(ICompileContext) functions. Only fully bound mappings are supported by Bind(ICompileContext) , whereas SupportsType(Type) will return true so long as the Success is true. The caller, therefore, must ensure it is aware of the difference between open and closed generics. Inheritance Object GenericConstructorTarget.GenericTypeMapping Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class GenericTypeMapping Properties | Improve this Doc View Source BindErrorMessage Gets a string describing the reason why the type could not be mapped. Can be used for exceptions, etc. Note that this can be set even if Success is true - because mappings exist between open generic types so that a target's SupportsType(Type) returns true , but the Bind(ICompileContext) function throws an exception for the same type, since you can't create an instance of an open generic. Declaration public string BindErrorMessage { get; } Property Value Type Description String The binding error message. | Improve this Doc View Source IsFullyBound If true, then the Type is a fully closed generic type that can be constructed (and therefore would be successfully bound by the Bind(ICompileContext) method, which uses the MapType(Type) method). If this is false but Success is true , then while the target is technically compatible with the requested type, you can't create an instance. The target will, however, be able to mapped to a closed generic type based on the same Type . Declaration public bool IsFullyBound { get; } Property Value Type Description Boolean | Improve this Doc View Source RequestedType The type requested for mapping. If this is an open generic, then the best result for this mapping will be that Success is true and IsFullyBound is false . Declaration public Type RequestedType { get; } Property Value Type Description Type | Improve this Doc View Source Success Gets a value indicating whether the DeclaredType of the GenericConstructorTarget was successfully mapped to the requested type. If so, and IsFullyBound is true , then an instance of Type will be compatible with the type that was requested. If IsFullyBound is false , then you can't create an instance of Type because it's an open generic - but you will be able to bind the same target to a closed generic of the same Type . Declaration public bool Success { get; } Property Value Type Description Boolean true if success; otherwise, false . | Improve this Doc View Source Type If Success = true , gets the generic type to be used for the RequestedType . Note that this could be either an open or closed generic - the IsFullyBound offers a quick means by which to determine this. If IsFullyBound is true , then the mapping will succeed when encountered by the Bind(ICompileContext) method. Declaration public Type Type { get; } Property Value Type Description Type The type. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Targets.GenericConstructorTarget.html": {
    "href": "api/Rezolver.Targets.GenericConstructorTarget.html",
    "title": "Class GenericConstructorTarget",
    "keywords": "Class GenericConstructorTarget Equivalent of ConstructorTarget but for open generic types. So, this will handle the open generic MyType<,>, for example, whereas ConstructorTarget would handle the closed type MyType<int, string>. Inheritance Object TargetBase GenericConstructorTarget Inherited Members TargetBase.UseFallback TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class GenericConstructorTarget : TargetBase, ITarget Constructors | Improve this Doc View Source GenericConstructorTarget(Type, IMemberBindingBehaviour) Constructs a new instance of the GenericConstructorTarget for the given open generic type, which will utilise the optional memberBindingBehaviour when it constructs its ConstructorTarget when Bind(ICompileContext) is called. Declaration public GenericConstructorTarget(Type genericType, IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description Type genericType The type of the object that is to be built (open generic of course) IMemberBindingBehaviour memberBindingBehaviour Optional. The IMemberBindingBehaviour to be used for binding properties and/or fields on the ConstructorTarget that is generated. If null, then no property or fields will be bound on construction. Properties | Improve this Doc View Source DeclaredType Implementation of the abstract base property. Will return the unbound generic type passed to this object on construction. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source GenericType Gets the generic type definition from which generic types are to be built and instances of which will be constructed. Declaration public Type GenericType { get; } Property Value Type Description Type | Improve this Doc View Source MemberBindingBehaviour Gets the member binding behaviour to be used when creating an instance. Declaration public IMemberBindingBehaviour MemberBindingBehaviour { get; } Property Value Type Description IMemberBindingBehaviour The member binding behaviour. Methods | Improve this Doc View Source Auto(Type, IMemberBindingBehaviour) Equivalent of Auto(Type, IMemberBindingBehaviour) but for open generic types. Note - there is no generic version because that could only be invoked by reflection. Declaration public static ITarget Auto(Type type, IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description Type type The type. IMemberBindingBehaviour memberBindingBehaviour Optional behaviour controlling which properties and fields, if any, will receive injected values. Returns Type Description ITarget Exceptions Type Condition ArgumentException This is raised from the GenericConstructorTarget(Type, IMemberBindingBehaviour) constructor when the passed type is either not an open generic type or is an abstract class or interface. | Improve this Doc View Source Bind(ICompileContext) Obtains an ITarget (usually a ConstructorTarget ) which will create an instance of a generic type (whose definition is equal to GenericType ) with generic arguments set correctly according to the TargetType of the context . Declaration public ITarget Bind(ICompileContext context) Parameters Type Name Description ICompileContext context The context. Returns Type Description ITarget Remarks The process of binding a requested type to the concrete type can be very complex, when inheritance chains and interface implementation maps are taken into account. At the simplest end of the spectrum, if GenericType is MyGeneric<> and the context 's TargetType is MyGeneric<int> , then this function merely has to insert the int type as the generic parameter to the MyGeneric<> type definition, bake a new type and create an auto-bound ConstructorTarget . Consider what happens, however, when the inheritance chain is more complex: interface IMyInterfaceCore<T, U> { } class MyBaseClass<T, U> : IMyInterfaceCore<U, T> { } class MyDerivedClass<T, U> : MyBaseClass<U, T> { } A GenericConstructorTarget bound to the generic type definition MyDerivedClass<,> can create instances not only of any generic type based on that definition, but also any generic type based on the definitions of either it's immediate base, or that base's interface. In order to do so, however, the parameters must be mapped between the generic type definitions so that if an instance of MyBaseClass<string, int> is requested, then an instance of MyDerivedClass<int, string> (note the arguments are reversed) is actually created. Similarly, if an instance of IMyInterface<string, int> is requested, we actually need to create an instance of MyDerivedClass<string, int> - because the generic arguments are reversed first through the base class inheritance, and then again by the base class' implementation of the interface. Note that a GenericConstructorTarget can only bind to the context's target type if there is enough information in order to deduce the generic type arguments for GenericType . This means, in general, that the requested type will almost always need to be a generic type with at least as many type arguments as the GenericType . | Improve this Doc View Source MapType(Type) Maps the DeclaredType open generic type to the targetType . Examine the Success of the result to check whether the result was successful. Declaration public GenericConstructorTarget.GenericTypeMapping MapType(Type targetType) Parameters Type Name Description Type targetType Type of the target. Returns Type Description GenericConstructorTarget.GenericTypeMapping | Improve this Doc View Source SupportsType(Type) Override - introduces additional logic to cope with generic types not generally supported by the majority of other targets. This uses the MapType(Type) function to determine success, but only checks the Success flag. As a result, this method will return true if an open generic base or interface of DeclaredType Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget) See Also TargetBase"
  },
  "api/Rezolver.CachingContainerBase.html": {
    "href": "api/Rezolver.CachingContainerBase.html",
    "title": "Class CachingContainerBase",
    "keywords": "Class CachingContainerBase Builds on the ContainerBase base class to introduce thread-safe caching of compiled targets so they are only compiled once per requested type. Only creatable through inheritance. Inheritance Object ContainerBase CachingContainerBase Container Inherited Members ContainerBase.NoChangeCompilerConfiguration ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Targets ContainerBase.Resolve(ResolveContext) ContainerBase.TryResolve(ResolveContext, Object) ContainerBase.CreateScope() ContainerBase.FetchCompiled(ResolveContext) ContainerBase.CanResolve(ResolveContext) ContainerBase.GetFallbackCompiledRezolveTarget(ResolveContext) ContainerBase.IServiceProvider.GetService(Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) ContainerBase.ITargetContainer.Fetch(Type) ContainerBase.ITargetContainer.FetchAll(Type) ContainerBase.ITargetContainer.CombineWith(ITargetContainer, Type) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class CachingContainerBase : ContainerBase, IContainer, IServiceProvider, ITargetContainer Remarks Internally, the class uses a ConcurrentDictionary<TKey, TValue> to store ICompiledTarget s keyed by the requested type. All the main IContainer implementations used directly in an application should ideally inherit from this class, because otherwise every Resolve(ResolveContext) operation would require a compilation phase before the object could be returned, which would be incredibly slow. It's because of this caching that registering new targets in any ITargetContainer used by this class is not recommended: because after the first request for a particular type is made, the resultant ICompiledTarget is fixed until the container is thrown away. Constructors | Improve this Doc View Source CachingContainerBase(ITargetContainer, ICompilerConfigurationProvider) Initializes a new instance of the CachingContainerBase class. Declaration protected CachingContainerBase(ITargetContainer targets = null, ICompilerConfigurationProvider compilerConfig = null) Parameters Type Name Description ITargetContainer targets Optional. Contains the targets that will be used to create the ICompiledTarget s that this container will use to produce objects when requested. If not provided, then the base class' default (see ContainerBase(ITargetContainer, ICompilerConfigurationProvider) ) will be used. ICompilerConfigurationProvider compilerConfig Optional. An object which will be used to configure this container and its targets to use a specific compilation strategy. If null , then the DefaultProvider provider will be used. Methods | Improve this Doc View Source GetCompiledRezolveTarget(ResolveContext) Obtains an ICompiledTarget for the given context . Declaration protected override ICompiledTarget GetCompiledRezolveTarget(ResolveContext context) Parameters Type Name Description ResolveContext context Returns Type Description ICompiledTarget Overrides ContainerBase.GetCompiledRezolveTarget(ResolveContext) Remarks The method is called by Resolve(ResolveContext) to get the compiled target whose GetObject(ResolveContext) method is to be used to get the instance that is to be resolved for a given request. The internal cache is examined first to see if an entry exists for the RequestedType type and, if not, then the result of the base class' GetCompiledRezolveTarget(ResolveContext) is cached and returned. Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionCompileContext.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionCompileContext.html",
    "title": "Class ExpressionCompileContext",
    "keywords": "Class ExpressionCompileContext An implementation of ICompileContext which is specialised for use by an IExpressionCompiler . Inheritance Object CompileContext ExpressionCompileContext Inherited Members CompileContext.Container CompileContext.TargetType CompileContext.ScopeBehaviourOverride CompileContext.DependencyTargetContainer CompileContext.CompileStack CompileContext.ICompileContext.NewContext(Type, Nullable<ScopeBehaviour>) CompileContext.ICompileContext.PushCompileStack(ITarget, Type) CompileContext.ICompileContext.PopCompileStack() CompileContext.ITargetContainer.Register(ITarget, Type) CompileContext.ITargetContainer.Fetch(Type) CompileContext.ITargetContainer.FetchAll(Type) CompileContext.ITargetContainer.CombineWith(ITargetContainer, Type) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class ExpressionCompileContext : CompileContext, IExpressionCompileContext, ICompileContext, ITargetContainer Constructors | Improve this Doc View Source ExpressionCompileContext(IExpressionCompileContext, Type, Boolean, Nullable<ScopeBehaviour>) Initializes a new instance of the ExpressionCompileContext class as a child of another. Note that all the expression properties ( ResolveContextExpression , ContextContainerPropertyExpression and ContextScopePropertyExpression ) are always inherited from the source context to ensure consistency across all expressions being built during a particular compilation chain. Declaration protected ExpressionCompileContext(IExpressionCompileContext sourceContext, Type targetType = null, bool useParentSharedExpressions = true, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description IExpressionCompileContext sourceContext The source context. Type targetType If not null, the type for which expressions are to be compiled. If null, then the sourceContext 's TargetType will be inherited. Boolean useParentSharedExpressions If true then the SharedExpressions of the sourceContext will be reused by this new context. If false , then this context will start with a new empty set of shared expressions. Nullable < ScopeBehaviour > scopeBehaviourOverride Override the scope behaviour to be used for the target that is compiled with this context. | Improve this Doc View Source ExpressionCompileContext(IContainer, ITargetContainer, Type, ParameterExpression) Initializes a new instance of the ExpressionCompileContext class. Declaration protected ExpressionCompileContext(IContainer container, ITargetContainer dependencyTargetContainer, Type targetType = null, ParameterExpression resolveContextExpression = null) Parameters Type Name Description IContainer container Required. The container for which the compilation is being performed. When compiling in response to a call to Resolve(ResolveContext) , the container which first receives the call should be the one passed here. ITargetContainer dependencyTargetContainer Required - target container used for dependency lookups. As with the base class this is actually wrapped in a new ChildTargetContainer and used as this class' implementation of ITargetContainer . Type targetType Optional. Will be set into the TargetType property. If null, then any ITarget that is compiled should be compiled for its own DeclaredType . ParameterExpression resolveContextExpression Optional, mapped to ResolveContextExpression - the default for this (i.e. when you leave it as null) is to use the static DefaultResolveContextParameterExpression and generally it should always be left as that. The ExpressionCompiler , when building expressions to turn into compiled lambdas, uses this as the main parameter on the lambda itself. See Also Rezolver.Compilation.CompileContext. Properties | Improve this Doc View Source ContainerExpression Gets an expression which gives a reference to the IContainer for this context - i.e. the same reference as given by the Container property. Declaration public Expression ContainerExpression { get; } Property Value Type Description Expression The container expression. Implements IExpressionCompileContext.ContainerExpression Remarks Note that this is not the same as ContextContainerPropertyExpression - but is provided to allow expressions to be compiled which compare the container supplied at compile time to the one from the Container at resolve-time. | Improve this Doc View Source ContextContainerPropertyExpression Gets an expression for reading the Container property of the ResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration public MemberExpression ContextContainerPropertyExpression { get; } Property Value Type Description MemberExpression The context container property expression. Implements IExpressionCompileContext.ContextContainerPropertyExpression | Improve this Doc View Source ContextScopePropertyExpression Gets an expression for reading the Scope property of the ResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration public MemberExpression ContextScopePropertyExpression { get; } Property Value Type Description MemberExpression The context scope property expression. Implements IExpressionCompileContext.ContextScopePropertyExpression | Improve this Doc View Source DefaultResolveContextParameterExpression The default ResolveContext parameter expression used by the expression-based code generators defined in this library, although it's not used directly for that purpose - instead, the ResolveContextExpression of new contexts is initialised to this if not explicitly provided on construction and when not being inherited from another context. Declaration public static ParameterExpression DefaultResolveContextParameterExpression { get; } Property Value Type Description ParameterExpression | Improve this Doc View Source ParentContext Gets the parent context. Declaration public IExpressionCompileContext ParentContext { get; } Property Value Type Description IExpressionCompileContext Implements IExpressionCompileContext.ParentContext Remarks Note that this property hides the inherited ParentContext property, since an IExpressionCompileContext can only be a child of another IExpressionCompileContext . | Improve this Doc View Source ResolveContextExpression This is the parameter expression which represents the ResolveContext that is passed to the ICompiledTarget at resolve-time. The other expressions - ContextContainerPropertyExpression and ContextScopePropertyExpression are both built from this too. Declaration public ParameterExpression ResolveContextExpression { get; } Property Value Type Description ParameterExpression The resolve context expression. Implements IExpressionCompileContext.ResolveContextExpression Remarks If the code produced by the IExpressionBuilder for a given target needs to read or use the ResolveContext that was originally passed to the Resolve(ResolveContext) method, then it does it by using this expression, which will be set as the only parameter on the lambda expression which is eventually compiled (in the case of the default expression compiler, ExpressionCompiler . | Improve this Doc View Source SharedExpressions Gets a read-only enumerable of all the shared expressions that have been inherited from any parent context and/or added via calls to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) or GetOrAddSharedLocal(Type, String, Type) . Declaration public IEnumerable<Expression> SharedExpressions { get; } Property Value Type Description IEnumerable < Expression > Implements IExpressionCompileContext.SharedExpressions Methods | Improve this Doc View Source GetOrAddSharedExpression(Type, String, Func<Expression>, Type) Gets or adds a shared expression (created by the expressionFactory if it's not already cached) with the given name, type, optionally for the given requestingType . Declaration public Expression GetOrAddSharedExpression(Type type, string name, Func<Expression> expressionFactory, Type requestingType = null) Parameters Type Name Description Type type The runtime type of the Expression. String name The runtime name of the Expression - and also the name used to retrieve it later. Func < Expression > expressionFactory The factory method to use to construct the shared expression from scratch, if it's not already cached. Type requestingType Optional - to avoid naming clashes with shared expressions created by other targets, you can pass a type here (usually the runtime type of your ITarget implementation). Returns Type Description Expression Expression. Implements IExpressionCompileContext.GetOrAddSharedExpression(Type, String, Func<Expression>, Type) | Improve this Doc View Source GetOrAddSharedLocal(Type, String, Type) Similar to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) , except this is used when expression builders want to use local variables in block expressions to store the result of some operation in the expression tree built for a particular target. Reusing one local variable is more efficient than declaring the same local multiple times. Declaration public ParameterExpression GetOrAddSharedLocal(Type type, string name, Type requestingType = null) Parameters Type Name Description Type type The type. String name The name. Type requestingType Optional - the type of the object requesting this shared expression. If this is provided, then the search for an existing shared expression will only work if the same requesting type was passed previously. Returns Type Description ParameterExpression Implements IExpressionCompileContext.GetOrAddSharedLocal(Type, String, Type) Remarks When multiple expression trees from multiple targets are brought together into one lambda, there will often be many duplicate variables which could be shared. So, if an IExpressionBuilder needs a local variable for a block, instead of simply declaring it directly through the Parameter(Type, String) function, it can use this function instead, which will return a previously created one if available. Exceptions Type Condition InvalidOperationException Cannot add ParameterExpression: A shared expression of a different type has already been added with the same type and name. | Improve this Doc View Source NewContext(Type, Nullable<ScopeBehaviour>) Used by the explicit implementation of NewContext(Type, Nullable<ScopeBehaviour>) . This is overriden to ensure that the correct type of context is created when created directly through the ICompileContext interface. Declaration protected override ICompileContext NewContext(Type targetType = null, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Nullable < ScopeBehaviour > scopeBehaviourOverride Override the ScopeBehaviourOverride to be used for the target that is compiled with the new context. This is never inherited automatically from one context to another. Returns Type Description ICompileContext Overrides CompileContext.NewContext(Type, Nullable<ScopeBehaviour>) Remarks Note all child contexts created through this virtual method will always inherit the parent context's shared expressions. | Improve this Doc View Source RegisterExpressionTargets() Registers some additional targets into the compile context to support compilation. Declaration protected void RegisterExpressionTargets() Explicit Interface Implementations | Improve this Doc View Source IExpressionCompileContext.NewContext(Type, Boolean, Nullable<ScopeBehaviour>) Creates a new IExpressionCompileContext using this one as a seed. This function is identical to NewContext(Type, Nullable<ScopeBehaviour>) but allows you to control whether the SharedExpressions are inherited (the default); and is more convenient because it returns another IExpressionCompileContext . Declaration IExpressionCompileContext IExpressionCompileContext.NewContext(Type targetType, bool useParentSharedExpressions, ScopeBehaviour? scopeBehaviourOverride) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Boolean useParentSharedExpressions If true then the shared expressions in this context will be inherited by the new context by reference. That is, when the new context goes out of scope, any new shared expressions it created will still be available. If false, then the new context will get a brand new, empty, set of shared expressions. Nullable < ScopeBehaviour > scopeBehaviourOverride Override the ScopeBehaviourOverride to be used for the target that is compiled with the new context. This is never inherited automatically from one context to another. Returns Type Description IExpressionCompileContext Implements IExpressionCompileContext.NewContext(Type, Boolean, Nullable<ScopeBehaviour>) Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also CompileContext"
  },
  "api/Rezolver.Compilation.Expressions.IExpressionCompiler.html": {
    "href": "api/Rezolver.Compilation.Expressions.IExpressionCompiler.html",
    "title": "Interface IExpressionCompiler",
    "keywords": "Interface IExpressionCompiler Interface for an object which is responsible for coordinating the production of expressions for targets during the compilation phase. Objects implementing this are expected to be implementations of ITargetCompiler ; this library provides the one implementation, too: ExpressionCompiler . Inherited Members ITargetCompiler.CompileTarget(ITarget, ICompileContext) Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public interface IExpressionCompiler : ITargetCompiler Remarks All expressions are built to be called from the GetObject(ResolveContext) function which, in turn, is typically called in response to a container's Resolve(ResolveContext) function being called. Note that the Build(ITarget, IExpressionCompileContext) method declared here is effectively an analogue to the Build(ITarget, IExpressionCompileContext, IExpressionCompiler) . Indeed, the default implementation resolves IExpressionBuilder instances to delegate the building of expressions. Methods | Improve this Doc View Source Build(ITarget, IExpressionCompileContext) Gets an unoptimised expression containing the logic required to create or fetch an instance of the target 's DeclaredType when invoked for a particular ResolveContext . Use this method if you want the raw expression for a target (possibly when integrating it into your own expressions during custom compilation). Declaration Expression Build(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context Contains the supporting expressions (shared locals, shared expressions, ResolveContext expression etc) that have been used in the generation of the expression. Returns Type Description Expression Remarks If you want to build the optimised code for the passed target, you should use the BuildResolveLambda(IExpressionCompiler, ITarget, IExpressionCompileContext) extension method, which uses this method and then passes the result to the BuildResolveLambda(Expression, IExpressionCompileContext) function also defined on this interface. | Improve this Doc View Source BuildResolveLambda(Expression, IExpressionCompileContext) This function optimises and prepares an expression that's (most likely) previously been produced by the Build(ITarget, IExpressionCompileContext) function into a lambda expression which can be compiled into a delegate and executed; or quoted inside another expression as a callback. The ResolveContextExpression of the context will be used to define the single parameter for the lambda that is created. Declaration Expression<Func<ResolveContext, object>> BuildResolveLambda(Expression targetExpression, IExpressionCompileContext context) Parameters Type Name Description Expression targetExpression Expression to be optimised and used as the body of the lambda. Any expression produced by the Build(ITarget, IExpressionCompileContext) method must be compatible with this. IExpressionCompileContext context Contains the supporting expressions (shared locals, shared expressions, ResolveContext expression etc) that have been used in the generation of the expression. Returns Type Description Expression < Func < ResolveContext , Object >> A lambda expression which, when compiled and executed, will produce an object consistent with the ITarget from which the code was produced. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) ExpressionCompilerBuildExtensions.BuildResolveLambda(IExpressionCompiler, ITarget, IExpressionCompileContext)"
  },
  "api/Rezolver.Compilation.Expressions.RezolvedTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.RezolvedTargetBuilder.html",
    "title": "Class RezolvedTargetBuilder",
    "keywords": "Class RezolvedTargetBuilder An IExpressionBuilder specialised for building the expression for the ResolvedTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ResolvedTarget > RezolvedTargetBuilder Inherited Members ExpressionBuilderBase<ResolvedTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ResolvedTarget>.IExpressionBuilder<ResolvedTarget>.Build(ResolvedTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ResolvedTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class RezolvedTargetBuilder : ExpressionBuilderBase<ResolvedTarget>, IExpressionBuilder<ResolvedTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ResolvedTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(ResolvedTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ResolvedTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ResolvedTarget>.Build(Rezolver.Targets.ResolvedTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Exceptions Type Condition InvalidOperationException Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.ICompileContext.html": {
    "href": "api/Rezolver.Compilation.ICompileContext.html",
    "title": "Interface ICompileContext",
    "keywords": "Interface ICompileContext Tracks state and provides services during the compilation phase in which ITarget targets are compiled into ICompiledTarget targets, which produce actual instances of objects. Inherited Members ITargetContainer.Register(ITarget, Type) ITargetContainer.Fetch(Type) ITargetContainer.FetchAll(Type) ITargetContainer.CombineWith(ITargetContainer, Type) Namespace :Rezolver.Compilation Assembly :Rezolver.dll Syntax public interface ICompileContext : ITargetContainer Remarks Implementations must also implement the ITargetContainer so the compile context can be used for dependency lookups during compilation time. Indeed, if you are developing your own compilation component (possibly for a custom ITarget implementation) and need to resolve any dependencies from an ITargetContainer during compilation, it should be done through the context's implementation of ITargetContainer. Properties | Improve this Doc View Source CompileStack Gets the stack entries for all the targets that are being compiled. Declaration IEnumerable<CompileStackEntry> CompileStack { get; } Property Value Type Description IEnumerable < CompileStackEntry > The compile stack. | Improve this Doc View Source Container The container that is considered the current compilation 'scope' - i.e. the container for which the compilation is being performed and, usually, the one on which the Resolve(ResolveContext) method was originally called which triggered the compilation call. Declaration IContainer Container { get; } Property Value Type Description IContainer | Improve this Doc View Source ParentContext Gets the parent context from which this context was created, if applicable. Declaration ICompileContext ParentContext { get; } Property Value Type Description ICompileContext The parent context. | Improve this Doc View Source ScopeBehaviourOverride If not null then this overrides the ScopeBehaviour of the ITarget that's currently being compiled. Declaration ScopeBehaviour? ScopeBehaviourOverride { get; } Property Value Type Description Nullable < ScopeBehaviour > | Improve this Doc View Source TargetType Any ICompiledTarget built for a ITarget with this context should target this type. If null, then the DeclaredType of the target being compiled should be used. Declaration Type TargetType { get; } Property Value Type Description Type Methods | Improve this Doc View Source NewContext(Type, Nullable<ScopeBehaviour>) Creates a new child context from this one, except the TargetType and ScopeBehaviourOverride properties can be overriden if required. Implementations must make sure that the ScopeBehaviourOverride is never inherited. Declaration ICompileContext NewContext(Type targetType = null, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Nullable < ScopeBehaviour > scopeBehaviourOverride Override the ScopeBehaviourOverride to be used for the target that is compiled with the new context. This is never inherited automatically from one context to another. Returns Type Description ICompileContext A new ICompileContext . | Improve this Doc View Source PopCompileStack() Pops the compile stack, returning the entry that was popped. Declaration CompileStackEntry PopCompileStack() Returns Type Description CompileStackEntry | Improve this Doc View Source PushCompileStack(ITarget, Type) Pushes the passed target on to the compile stack if it's not already on it for the same TargetType Compilers should consult the return value and abort compilation if it's true - since that implies a cyclic dependency graph. Declaration bool PushCompileStack(ITarget toCompile, Type targetType = null) Parameters Type Name Description ITarget toCompile To compile. Type targetType The type for which the target is being compiled, if different from DeclaredType Returns Type Description Boolean Remarks Targets can appear on the compilation stack more than once for different types, since the ICompiledTarget produced for a target for one type can be different than it is for another. Ultimately, if a target does in fact have a cyclic dependency graph, then this method will detect that. Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also ITargetContainer"
  },
  "api/Rezolver.ContainerBase.DirectResolveCompiledTarget.html": {
    "href": "api/Rezolver.ContainerBase.DirectResolveCompiledTarget.html",
    "title": "Class ContainerBase.DirectResolveCompiledTarget",
    "keywords": "Class ContainerBase.DirectResolveCompiledTarget Used when an ITarget is also of the same type as the one for which it is returned by the Fetch(Type) method of the Targets container. In this case, the target is not compiled, but instead is simply returned as the desired object. Inheritance Object ContainerBase.DirectResolveCompiledTarget Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax protected class DirectResolveCompiledTarget : ICompiledTarget Constructors | Improve this Doc View Source DirectResolveCompiledTarget(ITarget) Constructs a new instance of the ContainerBase.DirectResolveCompiledTarget Declaration public DirectResolveCompiledTarget(ITarget target) Parameters Type Name Description ITarget target Methods | Improve this Doc View Source GetObject(ResolveContext) Implementation of GetObject(ResolveContext) - simply returns the target with which this instance was constructed. Declaration public object GetObject(ResolveContext context) Parameters Type Name Description ResolveContext context ignored Returns Type Description Object Implements ICompiledTarget.GetObject(ResolveContext) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.DecoratorTargetContainerExtensions.html": {
    "href": "api/Rezolver.DecoratorTargetContainerExtensions.html",
    "title": "Class DecoratorTargetContainerExtensions",
    "keywords": "Class DecoratorTargetContainerExtensions Extensions for ITargetContainerOwner which simplify the registration of decorators (via the DecoratingTargetContainer pseudo-target) Inheritance Object DecoratorTargetContainerExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public static class DecoratorTargetContainerExtensions Remarks Note: The decoration functionality provided by the framework is only possible on ITargetContainer implementations which also implement the ITargetContainerOwner interface. All the main target container types you'll use in your application ( TargetContainer and ChildTargetContainer ) do support this interface. Methods | Improve this Doc View Source RegisterDecorator(ITargetContainerOwner, Type, Type) Registers a decorator container which will cause all instances of decoratedType to be decorated with the type decoratorType . Any existing registrations for decoratedType will be decorated correctly, and subsequent registrations of decoratedType will also be decorated as expected. Declaration public static void RegisterDecorator(this ITargetContainerOwner targetContainerOwner, Type decoratorType, Type decoratedType) Parameters Type Name Description ITargetContainerOwner targetContainerOwner The container into which the decorator will be registered. Type decoratorType The type to be used as the decorator implementation Type decoratedType The type which will be decorated by decoratorType . | Improve this Doc View Source RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) Registers a decorator container which will cause all instances of TDecorated to be decorated with the type TDecorator . Any existing registrations for TDecorated will be decorated correctly, and subsequent registrations of TDecorated will also be decorated as expected. Declaration public static void RegisterDecorator<TDecorator, TDecorated>(this ITargetContainerOwner targetContainerOwner) Parameters Type Name Description ITargetContainerOwner targetContainerOwner The container into which the decorator will be registered. Type Parameters Name Description TDecorator The type to be used as the decorator implementation TDecorated The type which will be decorated by TDecorator ."
  },
  "api/Rezolver.IChildTargetContainer.html": {
    "href": "api/Rezolver.IChildTargetContainer.html",
    "title": "Interface IChildTargetContainer",
    "keywords": "Interface IChildTargetContainer An ITargetContainer that inherits all registrations from a ( Parent ) target container. If it cannot resolve a target for a particular type, will defer to its parent for fallback. Inherited Members ITargetContainer.Register(ITarget, Type) ITargetContainer.Fetch(Type) ITargetContainer.FetchAll(Type) ITargetContainer.CombineWith(ITargetContainer, Type) Namespace :Rezolver Assembly :Rezolver.dll Syntax public interface IChildTargetContainer : ITargetContainer Remarks Note that the framework does not require that enumerables of targets (retrieved by calling FetchAll(Type) are merged between a child and parent container. Typically, as soon as one registration exists in a child container for the same type as in the parent, it overrides all registrations in the parent for that same type. Properties | Improve this Doc View Source Parent Gets the parent target container. Declaration ITargetContainer Parent { get; } Property Value Type Description ITargetContainer The parent. Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also ITargetContainer"
  },
  "api/Rezolver.ITarget.html": {
    "href": "api/Rezolver.ITarget.html",
    "title": "Interface ITarget",
    "keywords": "Interface ITarget Represents an action to be performed in order to obtain an object to satisfy a call to Resolve(ResolveContext) , when the standard implementations of IContainer are used (e.g. Container ). Namespace :Rezolver Assembly :Rezolver.dll Syntax public interface ITarget Remarks As mentioned in the summary, the role of this interface is largely determined by the framework's own standard implementations of the IContainer interface - all of which use an ITargetContainer to store service registrations which, when Resolve(ResolveContext) is called, is queried to obtain one or more targets which will have been registered for the requested type. After obtaining a target, an ITargetCompiler is then used to compile the target(s) into an ICompiledTarget whose GetObject(ResolveContext) method will ultimately then be called to 'resolve' the instance. The role of the target, then, is to act as a description of the action that is to be performed by that compiled target that is built from it. The interface doesn't describe the type of target in hand - it only provides the core data required to query the static type of the target (the type of object that the target will produce) and to determine compatibility with a request for a particular type. The framework's many implementations of this interface - e.g. ConstructorTarget , SingletonTarget , ResolvedTarget plus many others - then define the behaviour and any additional data required in order for a compiler to produce an ICompiledTarget which matches the target's intent. E.g, the ConstructorTarget , which represents creating a new instance via a constructor, provides all the necessary information to bind to the correct constructor (including parameter bindings etc) - and the compiler's job is to translate that into an ICompiledTarget which executes that constructor, returning the result. Properties | Improve this Doc View Source DeclaredType Gets the static type of the object produced from this target. For example, if this target represents executing a constructor on a type, then this property should equal the type to which that constructor belongs. Declaration Type DeclaredType { get; } Property Value Type Description Type | Improve this Doc View Source ScopeBehaviour Gets the scoping behaviour for instances that will ultimately be produced by this target. Declaration ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. | Improve this Doc View Source UseFallback If true , then the consumer should consider falling back to a more suitable target if available, as the object produced from this target is most likely a default of some kind - e.g. empty enumerable, default parameter value. Declaration bool UseFallback { get; } Property Value Type Description Boolean Methods | Improve this Doc View Source SelectScope(ResolveContext) Selects the scope in which instances produced from this target should be tracked. This should be executed only during a resolve operation when a scope is detected. Declaration IContainerScope SelectScope(ResolveContext context) Parameters Type Name Description ResolveContext context The context passed to a container's Resolve(ResolveContext) method. Returns Type Description IContainerScope | Improve this Doc View Source SupportsType(Type) Returns a boolean indicating whether the target is able to produce an instance of, or an instance that is compatible with, the passed type . Declaration bool SupportsType(Type type) Parameters Type Name Description Type type The type. Returns Type Description Boolean true if type is supported, false otherwise. Remarks It is strongly suggested that you use this method to check whether the target can construct an instance of a given type rather than performing any type checking yourself on the DeclaredType , because an ITarget might be able to support a much wider range of types other than just those which are directly compatible with its DeclaredType . For example, the GenericConstructorTarget is statically bound to an open generic, so therefore traditional type checks on the DeclaredType do not work. That class' implementation of this method, however, contains the complex logic necessary to determine if the open generic can be closed into a generic type which is compatible with the given type . Implementations of ITargetCompiler should always consult this function in their implementation of CompileTarget(ITarget, ICompileContext) to determine if the target is compatible with the TargetType of the CompileContext Please note that any type that's a generic type definition will always yield a false result, because it's impossible to build an instance of an open generic type. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.ITargetContainer.html": {
    "href": "api/Rezolver.ITargetContainer.html",
    "title": "Interface ITargetContainer",
    "keywords": "Interface ITargetContainer Stores and retrieves ITarget instances, keyed by the type of service that the targets are registered against. This is where all your service registrations will ultimately go. Namespace :Rezolver Assembly :Rezolver.dll Syntax public interface ITargetContainer Remarks You do not resolve objects from a target container, instead, it holds the ITarget s which will later be compiled to produce the objects. A target container is considered mutable for its entire lifetime, because it's only a glorified dictionary of targets from which multiple IContainer objects can be built (when using the types provided in the framework). As an example, the Container class uses this as the source of the registrations that it uses to resolve objects in its Resolve(ResolveContext) implementation. Note that there are multiple implementations of this interface in the framework, however the two you will use most commonly are TargetContainer and ChildTargetContainer . Methods | Improve this Doc View Source CombineWith(ITargetContainer, Type) If supported by the implementation, this gets the container built from combining this container with an existing container as part of a registration inside another ITargetContainerOwner . Declaration ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing The existing ITargetContainer instance that this instance is to be combined with Type type The type that the combined container owner will be registered under. Returns Type Description ITargetContainer Remarks Used most frequently in implementations of RegisterContainer(Type, ITargetContainer) when a container owner is already registered against the type, and a new container owner is then registered against the same type. This behaviour is used to implement open generics and decorators, and can be used to implement more besides. Exceptions Type Condition NotSupportedException If this container doesn't support being combined with another. | Improve this Doc View Source Fetch(Type) Retrieves a target for a particular type, or null if no target is registered against that type. Declaration ITarget Fetch(Type type) Parameters Type Name Description Type type Required. The type for which an ITarget is to be retrieved. Returns Type Description ITarget The target for the given type , or null if no target is found. Remarks The target you receive from this method depends entirely on the implementation. It could be the last target to be registered against the type or the first, or another target entirely. As mentioned in the documentation for the Register(ITarget, Type) method - the only guarantee is that if at least one target has been registered for the same type, then this method should return a valid target. | Improve this Doc View Source FetchAll(Type) Retrieves an enumerable of all targets that have been registered for a particular type . Declaration IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type Required. The type for which the ITarget s are to be retrieved. Returns Type Description IEnumerable < ITarget > An enumerable containing all the targets that have been registered against the given type , or, an empty enumerable if no targets have been registered. Remarks As with Fetch(Type) , the only guarantee is that if a target has been registered for the type through a call to Register(ITarget, Type) , then the returned enumerable will contain at least one valid target. | Improve this Doc View Source Register(ITarget, Type) Registers a target, either for the serviceType specified or, if null, the DeclaredType of the target . Declaration void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target Required. The target to be registered Type serviceType Optional. The type the target is to be registered against, if different from the DeclaredType of the target . If provided, then the target must be compatible with this type. Remarks The interface does not define the behaviour for when multiple targets are registered against the same type - although the default behaviour of the framework (via the TargetContainer class) is to allow this, with the last registered target being treated as the 'default' for that type. The only guarantee expected by the framework from implementations of this interface is that if a target is registered against a given type with this method, then a Fetch(Type) operation with the same type should return a valid target, and a FetchAll(Type) operation should return a non-empty enumerable of targets. Exceptions Type Condition ArgumentException If serviceType is non-null and the target 's SupportsType(Type) method returns false for that type. Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Targets.DefaultTarget.html": {
    "href": "api/Rezolver.Targets.DefaultTarget.html",
    "title": "Class DefaultTarget",
    "keywords": "Class DefaultTarget A target that simply creates a default instance of a given type. I.e. the same as doing default(type) in C#. Inheritance Object TargetBase DefaultTarget Inherited Members TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DefaultTarget : TargetBase, ITarget, ICompiledTarget Remarks The type also implements the ICompiledTarget interface for direct resolving. Constructors | Improve this Doc View Source DefaultTarget(Type) Initializes a new instance of the DefaultTarget class. Declaration public DefaultTarget(Type type) Parameters Type Name Description Type type The type. Properties | Improve this Doc View Source DeclaredType Always equal to the type for which the default value will be returned Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source ScopeBehaviour Override of ScopeBehaviour - always returns None . Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour | Improve this Doc View Source Value Gets the actual default value represented by this instance. Declaration public object Value { get; } Property Value Type Description Object Explicit Interface Implementations | Improve this Doc View Source ICompiledTarget.GetObject(ResolveContext) Declaration object ICompiledTarget.GetObject(ResolveContext context) Parameters Type Name Description ResolveContext context Returns Type Description Object Implements ICompiledTarget.GetObject(ResolveContext) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.DelegateTarget-8.html": {
    "href": "api/Rezolver.Targets.DelegateTarget-8.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.FactoryMethod DelegateTarget.DeclaredType TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc View Source DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, TResult> factory The factory. Type declaredType Type of the declared. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.DelegateTarget-9.html": {
    "href": "api/Rezolver.Targets.DelegateTarget-9.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.FactoryMethod DelegateTarget.DeclaredType TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc View Source DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, TResult> factory The factory. Type declaredType Type of the declared. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Compilation.Expressions.ConstructorTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ConstructorTargetBuilder.html",
    "title": "Class ConstructorTargetBuilder",
    "keywords": "Class ConstructorTargetBuilder An IExpressionBuilder specialised for building the target ConstructorTarget Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ConstructorTarget > ConstructorTargetBuilder Inherited Members ExpressionBuilderBase<ConstructorTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ConstructorTarget>.IExpressionBuilder<ConstructorTarget>.Build(ConstructorTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ConstructorTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class ConstructorTargetBuilder : ExpressionBuilderBase<ConstructorTarget>, IExpressionBuilder<ConstructorTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ConstructorBinding, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the specified ConstructorBinding . Called by Build(ConstructorTarget, IExpressionCompileContext, IExpressionCompiler) Declaration protected virtual Expression Build(ConstructorBinding binding, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ConstructorBinding binding The binding. IExpressionCompileContext context The context. IExpressionCompiler compiler The compiler to be used to build the target. Returns Type Description Expression Remarks The returned expression will either be a NewExpression or a MemberInitExpression | Improve this Doc View Source Build(ConstructorTarget, IExpressionCompileContext, IExpressionCompiler) Override of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Declaration protected override Expression Build(ConstructorTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ConstructorTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The compiler to be used to build the target Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ConstructorTarget>.Build(Rezolver.Targets.ConstructorTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.DecoratorTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.DecoratorTargetBuilder.html",
    "title": "Class DecoratorTargetBuilder",
    "keywords": "Class DecoratorTargetBuilder Specialised builder for DecoratorTarget targets. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < DecoratorTarget > DecoratorTargetBuilder Inherited Members ExpressionBuilderBase<DecoratorTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DecoratorTarget>.IExpressionBuilder<DecoratorTarget>.Build(DecoratorTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DecoratorTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class DecoratorTargetBuilder : ExpressionBuilderBase<DecoratorTarget>, IExpressionBuilder<DecoratorTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(DecoratorTarget, IExpressionCompileContext, IExpressionCompiler) Creates a new compilation context, registers the target's DecoratedTarget into it as the correct target for the DecoratedType , and then builds the expression for the Target (which is typically a constructor target). Declaration protected override Expression Build(DecoratorTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description DecoratorTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.DecoratorTarget>.Build(Rezolver.Targets.DecoratorTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionCompilerConfigurationProvider.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionCompilerConfigurationProvider.html",
    "title": "Class ExpressionCompilerConfigurationProvider",
    "keywords": "Class ExpressionCompilerConfigurationProvider Implements the ICompilerConfigurationProvider to configure expression-based compilation for targets in containers. The implementation registers all the targets necessary to use the expression tree-based compilation provided by the Rezolver.Compilation.Expressions library. This configuration provider is automatically configured as the default for all containers when the Rezolver library is referenced. Inheritance Object ExpressionCompilerConfigurationProvider Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class ExpressionCompilerConfigurationProvider : ICompilerConfigurationProvider Methods | Improve this Doc View Source Configure(IContainer, ITargetContainer) Implements the Configure(IContainer, ITargetContainer) method, registering all the targets necessary to use expression-based compilation for all the standard targets defined in the Rezolver core library. Declaration public virtual void Configure(IContainer container, ITargetContainer targets) Parameters Type Name Description IContainer container The container - ignored. ITargetContainer targets Required - the target container into which the various targets will be registered. Implements ICompilerConfigurationProvider.Configure(IContainer, ITargetContainer) Remarks All targets registered by this function are ObjectTarget targets backed by concrete instances of the various components (compiler etc). Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.RedundantConvertRewriter.html": {
    "href": "api/Rezolver.Compilation.Expressions.RedundantConvertRewriter.html",
    "title": "Class RedundantConvertRewriter",
    "keywords": "Class RedundantConvertRewriter Removes unnecessary convert expressions from an expression. An unnecessary conversion is one where the target type is equal to, or a base of, the source type. Only boxing/unboxing conversions or upcasts are left intact. Inheritance Object ExpressionVisitor RedundantConvertRewriter Inherited Members ExpressionVisitor.Visit(ReadOnlyCollection<Expression>) ExpressionVisitor.Visit(Expression) ExpressionVisitor.Visit<T>(ReadOnlyCollection<T>, Func<T, T>) ExpressionVisitor.VisitAndConvert<T>(T, String) ExpressionVisitor.VisitAndConvert<T>(ReadOnlyCollection<T>, String) ExpressionVisitor.VisitBinary(BinaryExpression) ExpressionVisitor.VisitBlock(BlockExpression) ExpressionVisitor.VisitCatchBlock(CatchBlock) ExpressionVisitor.VisitConditional(ConditionalExpression) ExpressionVisitor.VisitConstant(ConstantExpression) ExpressionVisitor.VisitDebugInfo(DebugInfoExpression) ExpressionVisitor.VisitDefault(DefaultExpression) ExpressionVisitor.VisitElementInit(ElementInit) ExpressionVisitor.VisitExtension(Expression) ExpressionVisitor.VisitGoto(GotoExpression) ExpressionVisitor.VisitIndex(IndexExpression) ExpressionVisitor.VisitInvocation(InvocationExpression) ExpressionVisitor.VisitLabel(LabelExpression) ExpressionVisitor.VisitLabelTarget(LabelTarget) ExpressionVisitor.VisitLambda<T>(Expression<T>) ExpressionVisitor.VisitListInit(ListInitExpression) ExpressionVisitor.VisitLoop(LoopExpression) ExpressionVisitor.VisitMember(MemberExpression) ExpressionVisitor.VisitMemberAssignment(MemberAssignment) ExpressionVisitor.VisitMemberBinding(MemberBinding) ExpressionVisitor.VisitMemberInit(MemberInitExpression) ExpressionVisitor.VisitMemberListBinding(MemberListBinding) ExpressionVisitor.VisitMemberMemberBinding(MemberMemberBinding) ExpressionVisitor.VisitMethodCall(MethodCallExpression) ExpressionVisitor.VisitNew(NewExpression) ExpressionVisitor.VisitNewArray(NewArrayExpression) ExpressionVisitor.VisitParameter(ParameterExpression) ExpressionVisitor.VisitRuntimeVariables(RuntimeVariablesExpression) ExpressionVisitor.VisitSwitch(SwitchExpression) ExpressionVisitor.VisitSwitchCase(SwitchCase) ExpressionVisitor.VisitTry(TryExpression) ExpressionVisitor.VisitTypeBinary(TypeBinaryExpression) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class RedundantConvertRewriter : ExpressionVisitor Methods | Improve this Doc View Source VisitUnary(UnaryExpression) Visits the children of the UnaryExpression . Declaration protected override Expression VisitUnary(UnaryExpression node) Parameters Type Name Description UnaryExpression node The expression to visit. Returns Type Description Expression Overrides ExpressionVisitor.VisitUnary(UnaryExpression) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also ExpressionVisitor"
  },
  "api/Rezolver.DelegateTargetContainerExtensions.html": {
    "href": "api/Rezolver.DelegateTargetContainerExtensions.html",
    "title": "Class DelegateTargetContainerExtensions",
    "keywords": "Class DelegateTargetContainerExtensions Extension methods for ITargetContainer designed to simplify the registration of DelegateTarget and its numerous generic variants. Inheritance Object DelegateTargetContainerExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public static class DelegateTargetContainerExtensions Methods | Improve this Doc View Source RegisterDelegate(ITargetContainer, Delegate, Type) Constructs a DelegateTarget from the passed factory delegate (optionally with the given declaredType ) and registers it in the target container. Declaration public static void RegisterDelegate(this ITargetContainer targetContainer, Delegate factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Delegate factory Type declaredType | Improve this Doc View Source RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) Creates a DelegateTarget<TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<TResult>(this ITargetContainer targetContainer, Func<TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <TResult> factory Type declaredType Type Parameters Name Description TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) T15 The type of the 15th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc View Source RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) Creates a DelegateTarget<T, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T, TResult>(this ITargetContainer targetContainer, Func<T, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T, TResult> factory Type declaredType Type Parameters Name Description T The type of the 1st delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc View Source RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) Creates a DelegateTarget<T1, T2, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, TResult>(this ITargetContainer targetContainer, Func<T1, T2, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) Creates a DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> and registers it in the given targetContainer , optionally with the given declaredType as its DeclaredType Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(this ITargetContainer targetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> factory, Type declaredType = null) Parameters Type Name Description ITargetContainer targetContainer Func <T1, T2, T3, T4, T5, T6, T7, T8, TResult> factory Type declaredType Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This is one of many generic extension methods that exist purely to simplify registering a DelegateTarget with a delegate expressed as a lambda expression. Each of these generic overloads simply calls the non-generic RegisterDelegate(ITargetContainer, Delegate, Type) extension method."
  },
  "api/Rezolver.IContainer.html": {
    "href": "api/Rezolver.IContainer.html",
    "title": "Interface IContainer",
    "keywords": "Interface IContainer The primary IOC container interface in the Rezolver framework. Inherited Members IServiceProvider.GetService(Type) Namespace :Rezolver Assembly :Rezolver.dll Syntax public interface IContainer : IServiceProvider Remarks Instances of objects (typically known as 'services' in IOC-speak) are resolved via the Resolve(ResolveContext) or TryResolve(ResolveContext, out Object) methods. You can introspect the container to check in advance whether a given type can be resolved through the CanResolve(ResolveContext) method. Lifetime scoping (where IDisposable objects are created within a scope and destroyed when that scope is destroyed) can be achieved by obtaining a new scope through the CreateScope() method; although a container might also implement the IScopedContainer interface, in which case the container itself is a lifetime scope. Many of the functions which accept a ResolveContext also have alternatives (in the form of extension methods) in the ContainerResolveExtensions class. If you're looking for the 'traditional' IOC container methods (e.g. Resolve<TObject>(IContainer) , that's where you'll find them. Note that while the standard implementation of this interface supplied by the framework ( ContainerBase and its derivatives) all utilitise the ITargetContainer to actually locate registrations for types which are ultimately requested from the container; the interface doesn't actually mandate that pattern. Methods | Improve this Doc View Source CanResolve(ResolveContext) Returns true if a resolve operation for the given context will succeed. If you're going to be calling Resolve(ResolveContext) immediately afterwards, consider using the TryResolve(ResolveContext, out Object) method instead, which allows you to check and obtain the result at the same time. Declaration bool CanResolve(ResolveContext context) Parameters Type Name Description ResolveContext context The resolve context. Returns Type Description Boolean true if this instance can resolve a type for the specified context; otherwise, false . | Improve this Doc View Source CreateScope() Called to create an IContainerScope which can resolve the same objects as this container, but which will track, and dispose of, any disposable objects that it creates. Declaration IContainerScope CreateScope() Returns Type Description IContainerScope | Improve this Doc View Source FetchCompiled(ResolveContext) Fetches the ICompiledTarget for the given context, whose GetObject(ResolveContext) method would ultimately be called if the same context was passed to Resolve(ResolveContext) or TryResolve(ResolveContext, out Object) . Declaration ICompiledTarget FetchCompiled(ResolveContext context) Parameters Type Name Description ResolveContext context The context. Returns Type Description ICompiledTarget Remarks This is not typically a method that you're likely to use as the consumer of an IContainer . It's more typically used by implementations of ITargetCompiler or implementations of IContainer when communicating with other containers. As such, its use at an application level is limited. | Improve this Doc View Source Resolve(ResolveContext) Called to resolve a reference to an object for the given context (which provides the RequestedType of the object that is required, among other things). Declaration object Resolve(ResolveContext context) Parameters Type Name Description ResolveContext context The context. Returns Type Description Object The resolved object, if successful. Exceptions Type Condition InvalidOperationException If the requested type cannot be resolved. | Improve this Doc View Source TryResolve(ResolveContext, out Object) Merges the CanResolve(ResolveContext) and Resolve(ResolveContext) operations into one operation. Declaration bool TryResolve(ResolveContext context, out object result) Parameters Type Name Description ResolveContext context The context. Object result Receives the resultant resolved object if the operation succeeds. Returns Type Description Boolean true if the operation succeeded (the resolved object will be set into the result parameter); false otherwise. Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ScopedContainer.html": {
    "href": "api/Rezolver.ScopedContainer.html",
    "title": "Class ScopedContainer",
    "keywords": "Class ScopedContainer Extends the Container to implement lifetime implicit scoping through the Scope that's created along with it. Implementation of the IScopedContainer interface. Inheritance Object ContainerBase CachingContainerBase Container ScopedContainer Inherited Members CachingContainerBase.GetCompiledRezolveTarget(ResolveContext) ContainerBase.NoChangeCompilerConfiguration ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Targets ContainerBase.FetchCompiled(ResolveContext) ContainerBase.GetFallbackCompiledRezolveTarget(ResolveContext) ContainerBase.IServiceProvider.GetService(Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) ContainerBase.ITargetContainer.Fetch(Type) ContainerBase.ITargetContainer.FetchAll(Type) ContainerBase.ITargetContainer.CombineWith(ITargetContainer, Type) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class ScopedContainer : Container, ITargetContainer, IScopedContainer, IContainer, IServiceProvider, IDisposable Remarks Both the Resolve(ResolveContext) and TryResolve(ResolveContext, out Object) methods will inject the Scope into ResolveContext that's passed if the context doesn't already have a scope. If you want your root container to act as a lifetime scope, then you should use this class instead of using Container . Note that this class does NOT implement the IContainerScope interface because the two interfaces are not actually compatible with each other, thanks to identical sets of extension methods. Constructors | Improve this Doc View Source ScopedContainer(ITargetContainer, ICompilerConfigurationProvider) Initializes a new instance of the ScopedContainer class. Declaration public ScopedContainer(ITargetContainer targets = null, ICompilerConfigurationProvider compilerConfig = null) Parameters Type Name Description ITargetContainer targets Optional. The underlying target container to be used to resolve objects. ICompilerConfigurationProvider compilerConfig Optional. The compiler configuration. Properties | Improve this Doc View Source Scope Gets the scope for this scoped container. Note that this is used automatically by the container for Resolve(ResolveContext) operations where the Scope property is not already set. Declaration public IContainerScope Scope { get; } Property Value Type Description IContainerScope Implements IScopedContainer.Scope Methods | Improve this Doc View Source CanResolve(ResolveContext) Overrides the base implementation to ensure that the context has the Scope assigned. Declaration public override bool CanResolve(ResolveContext context) Parameters Type Name Description ResolveContext context The resolve context containing the requested type. Returns Type Description Boolean Overrides ContainerBase.CanResolve(ResolveContext) Implements IContainer.CanResolve(ResolveContext) | Improve this Doc View Source CreateScope() Overrides the base method to pass the Scope as the new scope's parent. Declaration public override IContainerScope CreateScope() Returns Type Description IContainerScope Overrides ContainerBase.CreateScope() Implements IContainer.CreateScope() | Improve this Doc View Source Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() Implements IDisposable.Dispose() | Improve this Doc View Source Dispose(Boolean) Releases unmanaged and - optionally - managed resources. Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description Boolean disposing true to release both managed and unmanaged resources; false to release only unmanaged resources. | Improve this Doc View Source Resolve(ResolveContext) Overrides the base implementation to ensure that the context has the Scope assigned. Declaration public override object Resolve(ResolveContext context) Parameters Type Name Description ResolveContext context The context containing the type that's requested, any active scope and so on. Returns Type Description Object Overrides ContainerBase.Resolve(ResolveContext) Implements IContainer.Resolve(ResolveContext) | Improve this Doc View Source TryResolve(ResolveContext, out Object) Overrides the base implementation to ensure that the context has the Scope assigned. Declaration public override bool TryResolve(ResolveContext context, out object result) Parameters Type Name Description ResolveContext context The context containing the type that's requested, any active scope and so on. Object result Receives a reference to the object that was resolved, if successful, or null if not. Returns Type Description Boolean Overrides ContainerBase.TryResolve(ResolveContext, out Object) Implements IContainer.TryResolve(ResolveContext, out Object) Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ScopedTargetContainerExtensions.html": {
    "href": "api/Rezolver.ScopedTargetContainerExtensions.html",
    "title": "Class ScopedTargetContainerExtensions",
    "keywords": "Class ScopedTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for registering constructor-injected types whose lifetimes are slaved to that of a parent IScopedContainer . All of the extension methods ultimately create a ScopedTarget Inheritance Object ScopedTargetContainerExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public static class ScopedTargetContainerExtensions Methods | Improve this Doc View Source RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) Registers an explicitly instance of objectType (optionally for the service type serviceType ) to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterScoped(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. Type objectType The type of the object that is to be constructed when resolved. Type serviceType Optional. The type against which the registration will be performed, if different from objectType . objectType must be compatible with this type, if it's provided. IMemberBindingBehaviour propertyBindingBehaviour Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto(Type, IMemberBindingBehaviour) or Auto(Type, IMemberBindingBehaviour) static methods, wrapping it with a ScopedTarget and then registering it against the type serviceType or objectType . | Improve this Doc View Source RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) Registers an explicitly scoped instance of TObject to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterScoped<TObject>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IMemberBindingBehaviour propertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto<T>(IMemberBindingBehaviour) or Auto(Type, IMemberBindingBehaviour) static methods, wrapping it with a ScopedTarget and registering it. | Improve this Doc View Source RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) Registers an explicitly scoped instance of TObject for the service type TService to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter propertyBindingBehaviour . Declaration public static void RegisterScoped<TObject, TService>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IMemberBindingBehaviour propertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. TService The type against which the registration will be performed. TObject must be compatible with this type. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto<T>(IMemberBindingBehaviour) or Auto(Type, IMemberBindingBehaviour) static methods, wrapping it with a ScopedTarget and then registering it against the type TService ."
  },
  "api/Rezolver.Targets.DelegateTarget-13.html": {
    "href": "api/Rezolver.Targets.DelegateTarget-13.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.FactoryMethod DelegateTarget.DeclaredType TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc View Source DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> factory The factory. Type declaredType Type of the declared. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.DelegateTarget-14.html": {
    "href": "api/Rezolver.Targets.DelegateTarget-14.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.FactoryMethod DelegateTarget.DeclaredType TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc View Source DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> factory The factory. Type declaredType Type of the declared. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.ListTarget.html": {
    "href": "api/Rezolver.Targets.ListTarget.html",
    "title": "Class ListTarget",
    "keywords": "Class ListTarget This target produces arrays ( AsArray = true ) or lists ( AsArray = false ) whose individual items are built by ITarget instances. Primarily used by the Rezolver.EnumerableTargetContainer and the configuration framework, but can also be used by your code. Inheritance Object TargetBase ListTarget Inherited Members TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class ListTarget : TargetBase, ITarget Remarks The element type you feed on construction determines the type of array or the generic argument to List<T>. Each of the rezolve targets that you then pass must support that type. Constructors | Improve this Doc View Source ListTarget(Type, IEnumerable<ITarget>, Boolean) Initializes a new instance of the ListTarget class. Declaration public ListTarget(Type elementType, IEnumerable<ITarget> items, bool asArray = false) Parameters Type Name Description Type elementType Required. Type of the elements in the array or list. IEnumerable < ITarget > items Required. The targets that will create each the individual items. Boolean asArray A boolean indicating whether the target will build an array ( true ) or a list ( false ). Exceptions Type Condition ArgumentNullException elementType or items ArgumentException All targets in the items enumerable must be non-null;items or All targets in the items enumerable must support the element type elementType Properties | Improve this Doc View Source AsArray Gets a value indicating whether the target will build an array ( true ) or a list ( false ). Declaration public bool AsArray { get; } Property Value Type Description Boolean | Improve this Doc View Source DeclaredType Implementation of the abstract property from the base. This will always return either a type equal to an array of ElementType , or List<T> with ElementType as the generic parameter. This is controlled by the AsArray property. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source ElementType Gets the declared type of each element in the array or list that will be constructed. The DeclaredType returned by this instance will either be ElementType[] or List<ElementType> depending on the value of AsArray . Declaration public Type ElementType { get; } Property Value Type Description Type The declared type of each element. | Improve this Doc View Source Items Gets the rezolve targets that will build each individual item in the resulting list or array. Declaration public IEnumerable<ITarget> Items { get; } Property Value Type Description IEnumerable < ITarget > The items. | Improve this Doc View Source ListConstructor Gets the list constructor to be invoked when AsArray is false. Declaration public ConstructorInfo ListConstructor { get; } Property Value Type Description ConstructorInfo The list constructor. Exceptions Type Condition InvalidOperationException Since this target is configured to build an array, getting the ListConstructor is not a valid operation. | Improve this Doc View Source UseFallback Returns true if the Items enumerable is empty. Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides TargetBase.UseFallback Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.ObjectTarget.html": {
    "href": "api/Rezolver.Targets.ObjectTarget.html",
    "title": "Class ObjectTarget",
    "keywords": "Class ObjectTarget Implements ITarget by wrapping a single instance that's already been constructed by application code. Inheritance Object TargetBase ObjectTarget Inherited Members TargetBase.UseFallback TargetBase.SupportsType(Type) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class ObjectTarget : TargetBase, ITarget, ICompiledTarget Constructors | Improve this Doc View Source ObjectTarget(Object, Type, ScopeBehaviour) Creates a new instance of the ObjectTarget class. Declaration public ObjectTarget(object obj, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description Object obj The object to be returned by this target when resolved. Type declaredType Optional. The declared type of this target, if different from the absolute type of the obj ScopeBehaviour scopeBehaviour Optional. If you want the object to be disposed by Rezolver when the root scope is disposed, then specify a behaviour other than the default. Note - the only real behaviour that makes sense for this is Explicit , since the Implicit behaviour will typically fool a scope that multiple instances are being created and, therefore, the object will be tracked multiple times by that scope. Remarks Please note - if you enable scope tracking, but the object is never resolved, then the object will not be disposed and you will need to ensure you dispose of it. Properties | Improve this Doc View Source DeclaredType Gets the declared type of object that is returned by this target. Might be different from the type of Value if explicitly defined when this target was constructed. Declaration public override Type DeclaredType { get; } Property Value Type Description Type The type of the declared. Overrides TargetBase.DeclaredType | Improve this Doc View Source ScopeBehaviour Gets the scope behaviour. Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour | Improve this Doc View Source Value Gets the value that will be exposed by expressions built by this instance. Declaration public object Value { get; } Property Value Type Description Object The value. Methods | Improve this Doc View Source SelectScope(ResolveContext) Selects the scopem in which instance should be tracked for disposal. Declaration public override IContainerScope SelectScope(ResolveContext context) Parameters Type Name Description ResolveContext context The context. Returns Type Description IContainerScope Overrides TargetBase.SelectScope(ResolveContext) Explicit Interface Implementations | Improve this Doc View Source ICompiledTarget.GetObject(ResolveContext) Declaration object ICompiledTarget.GetObject(ResolveContext context) Parameters Type Name Description ResolveContext context Returns Type Description Object Implements ICompiledTarget.GetObject(ResolveContext) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.UnscopedTarget.html": {
    "href": "api/Rezolver.Targets.UnscopedTarget.html",
    "title": "Class UnscopedTarget",
    "keywords": "Class UnscopedTarget Wraps another target to force scoping to be ignored for the object that it produces, regardless of whether that object is IDisposable or otherwise has its own scoping behaviour. Inheritance Object TargetBase UnscopedTarget Inherited Members TargetBase.SelectScope(ResolveContext) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class UnscopedTarget : TargetBase, ITarget Constructors | Improve this Doc View Source UnscopedTarget(ITarget) Initializes a new instance of the UnscopedTarget class. Declaration public UnscopedTarget(ITarget inner) Parameters Type Name Description ITarget inner Required - the inner target. Properties | Improve this Doc View Source DeclaredType Gets the declared type of object that is constructed by this target - always forwards the call to the Inner target. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source Inner Gets the inner target whose scoping rules are to be stripped by this target. Declaration public ITarget Inner { get; } Property Value Type Description ITarget | Improve this Doc View Source ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour Overrides TargetBase.ScopeBehaviour | Improve this Doc View Source UseFallback Implementation of UseFallback Always forwards the call to Inner target. Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides TargetBase.UseFallback Methods | Improve this Doc View Source SupportsType(Type) Always forward the call to the Inner target's implementation. Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type The type. Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.ChildTargetContainer.html": {
    "href": "api/Rezolver.ChildTargetContainer.html",
    "title": "Class ChildTargetContainer",
    "keywords": "Class ChildTargetContainer A version of TargetContainer which overrides the registrations of another (the Parent ). Inheritance Object TargetDictionaryContainer TargetContainer ChildTargetContainer Inherited Members TargetContainer.CreateContainer(Type, ITarget) TargetContainer.CreateGenericTypeDefContainer(Type, ITarget) TargetContainer.FetchContainer(Type) TargetContainer.Register(ITarget, Type) TargetContainer.RegisterContainer(Type, ITargetContainer) TargetContainer.RegisterContainerDirect(Type, ITargetContainer) TargetDictionaryContainer.CombineWith(ITargetContainer, Type) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class ChildTargetContainer : TargetContainer, ITargetContainerOwner, IChildTargetContainer, ITargetContainer Remarks When it's looking to find an entry for a type, if it cannot find one within its own registrations, it will forward the call on to its ancestors (starting with its Parent ). As a result, any dependencies required by registrations in this container can be provided by any ancestor. Fallback logic in the Fetch(Type) is triggered by the UseFallback property. Constructors | Improve this Doc View Source ChildTargetContainer(ITargetContainer) Initializes a new instance of the ChildTargetContainer class. Declaration public ChildTargetContainer(ITargetContainer parent) Parameters Type Name Description ITargetContainer parent Required. The parent target container Properties | Improve this Doc View Source Parent Gets the parent. Declaration public ITargetContainer Parent { get; } Property Value Type Description ITargetContainer The parent. Implements IChildTargetContainer.Parent Methods | Improve this Doc View Source Fetch(Type) Fetches the registered target for the given type , if found, or forwards the call to the Parent container. Declaration public override ITarget Fetch(Type type) Parameters Type Name Description Type type The type whose registration is sought. Returns Type Description ITarget The target which is registered for the given type, or null if no registration can be found. Overrides TargetDictionaryContainer.Fetch(Type) Implements ITargetContainer.Fetch(Type) | Improve this Doc View Source FetchAll(Type) Implementation of FetchAll(Type) Declaration public override IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type The type whose targets are to be retrieved. Returns Type Description IEnumerable < ITarget > A non-null enumerable containing the targets that match the type, or an empty enumerable if the type is not registered. Overrides TargetDictionaryContainer.FetchAll(Type) Implements ITargetContainer.FetchAll(Type) Extension Methods EnumerableTargetBuilderExtensions.EnableEnumerableResolving(ITargetContainerOwner) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) DecoratorTargetContainerExtensions.RegisterDecorator(ITargetContainerOwner, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also TargetContainer IChildTargetContainer"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionCompiler.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionCompiler.html",
    "title": "Class ExpressionCompiler",
    "keywords": "Class ExpressionCompiler Implementation of the ITargetCompiler interface which produces ICompiledTarget objects by building and compiling expression trees from the ITarget objects which are registered. Inheritance Object ExpressionCompiler Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class ExpressionCompiler : IExpressionCompiler, ITargetCompiler, ICompileContextProvider Remarks This compiler is automatically configured as the default for all containers because the ConfigProvider from this class is set as the DefaultProvider . This class works by directly resolving IExpressionBuilder instances which can build an expression for a given ITarget from the IExpressionCompileContext . Typically, this is done by searching for an IExpressionBuilder<TTarget> where 'TTarget' is equal to the runtime type of the target - e.g. ConstructorTarget . If one cannot be found, it will then search for an IExpressionBuilder whose CanBuild(ITarget, IExpressionCompileContext) function returns true for the given target. With a correctly configured target dictionary (using the ConfigProvider which, as mentioned previously, is used by default if no configuration provider is explicitly passed to the constructor of one of the ContainerBase deriving types) this should resolve to an instance of the ConstructorTargetBuilder class, which implements IExpressionBuilder<ConstructorTarget> . As such, the compiler can be extended to support extra target types and its existing expression builders can be replaced for customised behaviour because they are all resolved from the ITargetContainer underpinning a particular CompileContext . There is a caveat for this, however: you cannot use the traditional targets ( ConstructorTarget etc) to extend the compiler because they need to be compiled in order to work - which would cause an infinite recursion. Therefore, the targets which are registered as expression builders must directly implement either the IExpressionBuilder<TTarget> or IExpressionBuilder interfaces; or implement the ICompiledTarget interface and produce an instance of those interfaces when GetObject(ResolveContext) is called on them. Because of this requirement, the most common way to register an expression builder is to register an instance inside an ObjectTarget against the correct type, because that class does implement ICompiledTarget in addition to ITarget . Using this pattern, it's important that an expression builder is completely threadsafe and recursion safe (since one target's compilation might depend on the compilation of another of the same type). Under the default configuration, if you want to get hold of this compiler then you should request the type IExpressionCompiler from the current compilation context, or from your target container. Properties | Improve this Doc View Source ConfigProvider Gets the default expression compiler configuration provider which is also set, by default, into the DefaultProvider property. Declaration public static ExpressionCompilerConfigurationProvider ConfigProvider { get; } Property Value Type Description ExpressionCompilerConfigurationProvider | Improve this Doc View Source Default Gets the default expression compiler which is registered by the ConfigProvider by default. Declaration public static ExpressionCompiler Default { get; } Property Value Type Description ExpressionCompiler Methods | Improve this Doc View Source Build(ITarget, IExpressionCompileContext) Called to build an expression for the specified target for the given IExpressionCompileContext - implementation of the Build(ITarget, IExpressionCompileContext) method. Declaration public Expression Build(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target for which an expression is to be built IExpressionCompileContext context The compilation context. Returns Type Description Expression Implements IExpressionCompiler.Build(ITarget, IExpressionCompileContext) Remarks This implementation attempts to resolve an IExpressionBuilder<TTarget> (with TTarget\" equal to the runtime type of the target ) or IExpressionBuilder whose CanBuild(ITarget, IExpressionCompileContext) function returns true for the given target and context. If that lookup fails, then an ArgumentException is raised. If the lookup succeeds, then the builder's Build(ITarget, IExpressionCompileContext, IExpressionCompiler) function is called, and the expression it produces is returned. Exceptions Type Condition ArgumentException If the compiler is unable to resolve an IExpressionBuilder from the context for the target | Improve this Doc View Source BuildCompiledTargetForLambda(Expression<Func<ResolveContext, Object>>) Creates an ICompiledTarget from the finalised lambda expression which was previously built for a target. Declaration protected virtual ICompiledTarget BuildCompiledTargetForLambda(Expression<Func<ResolveContext, object>> lambda) Parameters Type Name Description Expression < Func < ResolveContext , Object >> lambda The lambda expression representing the code to be executed in order to get the underlying object which will be resolved. Typically, this is fed directly from the BuildResolveLambda(Expression, IExpressionCompileContext) implementation. Returns Type Description ICompiledTarget | Improve this Doc View Source BuildResolveLambda(Expression, IExpressionCompileContext) Takes the unoptimised expression built for a target and optimises it and turns it into a lambda expression ready to be compiled into an ICompiledTarget . Declaration public virtual Expression<Func<ResolveContext, object>> BuildResolveLambda(Expression expression, IExpressionCompileContext context) Parameters Type Name Description Expression expression The expression. IExpressionCompileContext context The context. Returns Type Description Expression < Func < ResolveContext , Object >> Implements IExpressionCompiler.BuildResolveLambda(Expression, IExpressionCompileContext) | Improve this Doc View Source CompileTarget(ITarget, ICompileContext) Create the ICompiledTarget for the given target using the context to inform the type of object that is to be built, and for compile-time dependency resolution. Declaration public ICompiledTarget CompileTarget(ITarget target, ICompileContext context) Parameters Type Name Description ITarget target Required. The target to be compiled. ICompileContext context Required. The current compilation context. Returns Type Description ICompiledTarget Implements ITargetCompiler.CompileTarget(ITarget, ICompileContext) Exceptions Type Condition ArgumentException context must be an instance of IExpressionCompileContext | Improve this Doc View Source CreateContext(ResolveContext, ITargetContainer, IContainer) Implementation of CreateContext(ResolveContext, ITargetContainer, IContainer) Declaration public ICompileContext CreateContext(ResolveContext resolveContext, ITargetContainer targets, IContainer containerOverride = null) Parameters Type Name Description ResolveContext resolveContext ITargetContainer targets IContainer containerOverride Returns Type Description ICompileContext Implements ICompileContextProvider.CreateContext(ResolveContext, ITargetContainer, IContainer) | Improve this Doc View Source ResolveBuilder(ITarget, IExpressionCompileContext) Resolves an expression builder that can build the given target for the given compile context. Or Returns null if no builder can be found. Declaration public virtual IExpressionBuilder ResolveBuilder(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context The context. Returns Type Description IExpressionBuilder Remarks The function builds a list of all the types in the hierarchy represented by the type of the target and, for each of those types which are compatible with ITarget , it looks for an IExpressionBuilder<TTarget> which is specialised for that type. If no compatible builder is found, then it attempts to find a general purpose IExpressionBuilder which can build the type. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) ExpressionCompilerBuildExtensions.BuildResolveLambda(IExpressionCompiler, ITarget, IExpressionCompileContext) See Also IExpressionCompiler ITargetCompiler"
  },
  "api/Rezolver.Compilation.Expressions.IExpressionCompileContext.html": {
    "href": "api/Rezolver.Compilation.Expressions.IExpressionCompileContext.html",
    "title": "Interface IExpressionCompileContext",
    "keywords": "Interface IExpressionCompileContext Extension to the ICompileContext interface which provides additional state and functionality for the IExpressionCompiler and the IExpressionBuilder implementations which are used by the default expression compiler, the ExpressionCompiler class. Inherited Members ICompileContext.Container ICompileContext.ScopeBehaviourOverride ICompileContext.TargetType ICompileContext.CompileStack ICompileContext.NewContext(Type, Nullable<ScopeBehaviour>) ICompileContext.PopCompileStack() ICompileContext.PushCompileStack(ITarget, Type) ITargetContainer.Register(ITarget, Type) ITargetContainer.Fetch(Type) ITargetContainer.FetchAll(Type) ITargetContainer.CombineWith(ITargetContainer, Type) Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public interface IExpressionCompileContext : ICompileContext, ITargetContainer Properties | Improve this Doc View Source ContainerExpression Gets an expression which gives a reference to the IContainer for this context - i.e. the same reference as given by the Container property. Declaration Expression ContainerExpression { get; } Property Value Type Description Expression Remarks Note that this is not the same as ContextContainerPropertyExpression - but is provided to allow expressions to be compiled which compare the container supplied at compile time to the one from the Container at resolve-time. | Improve this Doc View Source ContextContainerPropertyExpression Gets an expression for reading the Container property of the ResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration MemberExpression ContextContainerPropertyExpression { get; } Property Value Type Description MemberExpression | Improve this Doc View Source ContextScopePropertyExpression Gets an expression for reading the Scope property of the ResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration MemberExpression ContextScopePropertyExpression { get; } Property Value Type Description MemberExpression | Improve this Doc View Source ParentContext Gets the parent context. Declaration IExpressionCompileContext ParentContext { get; } Property Value Type Description IExpressionCompileContext Remarks Note that this property hides the inherited ParentContext property, since an IExpressionCompileContext can only be a child of another IExpressionCompileContext . | Improve this Doc View Source ResolveContextExpression This is the parameter expression which represents the ResolveContext that is passed to the ICompiledTarget at resolve-time. The other expressions - ContextContainerPropertyExpression and ContextScopePropertyExpression are both built from this too. Declaration ParameterExpression ResolveContextExpression { get; } Property Value Type Description ParameterExpression Remarks If the code produced by the IExpressionBuilder for a given target needs to read or use the ResolveContext that was originally passed to the Resolve(ResolveContext) method, then it does it by using this expression, which will be set as the only parameter on the lambda expression which is eventually compiled (in the case of the default expression compiler, ExpressionCompiler . | Improve this Doc View Source SharedExpressions Gets a read-only enumerable of all the shared expressions that have been inherited from any parent context or added via calls to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) or GetOrAddSharedLocal(Type, String, Type) . Declaration IEnumerable<Expression> SharedExpressions { get; } Property Value Type Description IEnumerable < Expression > The shared expressions. Methods | Improve this Doc View Source GetOrAddSharedExpression(Type, String, Func<Expression>, Type) Gets or adds an expression which is potentially shared between multiple targets' expression trees. Declaration Expression GetOrAddSharedExpression(Type type, string name, Func<Expression> expressionFactory, Type requestingType = null) Parameters Type Name Description Type type Required - the type of the expression. String name Required - the caller-defined name for this expression. Func < Expression > expressionFactory Required - Delegate to call to create the expression if it does not already exist. Type requestingType Optional - the type of the object requesting this shared expression. If this is provided, then the search for an existing shared expression will only work if the same requesting type was passed previously. Returns Type Description Expression Remarks Using shared expressions opens the door to potentially multiple optimisations, depending on the type of expression in question. For example, conditional expressions which share the same operand and comparand can all be merged into one with all the 'true' and 'false' branches being combined into one of each, thus saving multiple identical comparisons. | Improve this Doc View Source GetOrAddSharedLocal(Type, String, Type) Similar to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) , except this is used when expression builders want to use local variables in block expressions to store the result of some operation in the expression tree built for a particular target. Reusing one local variable is more efficient than declaring the same local multiple times. Declaration ParameterExpression GetOrAddSharedLocal(Type type, string name, Type requestingType = null) Parameters Type Name Description Type type The type. String name The name. Type requestingType Optional - the type of the object requesting this shared expression. If this is provided, then the search for an existing shared expression will only work if the same requesting type was passed previously. Returns Type Description ParameterExpression Remarks When multiple expression trees from multiple targets are brought together into one lambda, there will often be many duplicate variables which could be shared. So, if an IExpressionBuilder needs a local variable for a block, instead of simply declaring it directly through the Parameter(Type, String) function, it can use this function instead, which will return a previously created one if available. | Improve this Doc View Source NewContext(Type, Boolean, Nullable<ScopeBehaviour>) Creates a new IExpressionCompileContext using this one as a seed. This function is identical to NewContext(Type, Nullable<ScopeBehaviour>) but allows you to control whether the SharedExpressions are inherited (the default); and is more convenient because it returns another IExpressionCompileContext . Declaration IExpressionCompileContext NewContext(Type targetType = null, bool inheritSharedExpressions = true, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Boolean inheritSharedExpressions If true then the shared expressions in this context will be inherited by the new context by reference. That is, when the new context goes out of scope, any new shared expressions it created will still be available. If false, then the new context will get a brand new, empty, set of shared expressions. Nullable < ScopeBehaviour > scopeBehaviourOverride Override the ScopeBehaviourOverride to be used for the target that is compiled with the new context. This is never inherited automatically from one context to another. Returns Type Description IExpressionCompileContext Remarks When you have a reference to an IExpressionCompileContext the compiler will favour this method to the one defined on the ICompileContext interface because it is 'closer', even if you do not explicitly provide an argument for the inheritSharedExpressions parameter. Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also ICompileContext"
  },
  "api/Rezolver.Compilation.Expressions.SingletonTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.SingletonTargetBuilder.html",
    "title": "Class SingletonTargetBuilder",
    "keywords": "Class SingletonTargetBuilder An IExpressionBuilder specialised for the building the expression for a SingletonTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < SingletonTarget > SingletonTargetBuilder Inherited Members ExpressionBuilderBase<SingletonTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<SingletonTarget>.IExpressionBuilder<SingletonTarget>.Build(SingletonTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<SingletonTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class SingletonTargetBuilder : ExpressionBuilderBase<SingletonTarget>, IExpressionBuilder<SingletonTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(SingletonTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(SingletonTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description SingletonTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.SingletonTarget>.Build(Rezolver.Targets.SingletonTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.TargetCompiler.html": {
    "href": "api/Rezolver.Compilation.TargetCompiler.html",
    "title": "Class TargetCompiler",
    "keywords": "Class TargetCompiler Holds a reference to the default compiler for this application. Inheritance Object TargetCompiler Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation Assembly :Rezolver.dll Syntax public static class TargetCompiler Properties | Improve this Doc View Source Default The default compiler to be used by rezolvers when they are not explicitly provided one. Declaration public static ITargetCompiler Default { get; set; } Property Value Type Description ITargetCompiler"
  },
  "api/Rezolver.ContainerBase.html": {
    "href": "api/Rezolver.ContainerBase.html",
    "title": "Class ContainerBase",
    "keywords": "Class ContainerBase Starting point for implementations of IContainer - only creatable through inheritance. Inheritance Object ContainerBase CachingContainerBase Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class ContainerBase : IContainer, IServiceProvider, ITargetContainer Remarks This class also implements ITargetContainer by proxying the Targets that are provided to it on construction (or created anew if not supplied). All of those interface methods are implemented explicitly except the Register(ITarget, Type) method, which is available through the class' public API. Note: IContainer s are generally not expected to implement ITargetContainer , and the framework will never assume they do. The reason this class does is to make it easier to create a new container and to register targets into it without having to worry about managing a separate ITargetContainer instance in your application root - because all the registration extension methods defined in classes like RegisterTypeTargetContainerExtensions , SingletonTargetContainerExtensions plus many more will be available to developers in code which has a reference to this class, or one derived from it. Note also that calling CombineWith(ITargetContainer, Type) on an instance of this type will always cause a NotSupportedException to be thrown. Constructors | Improve this Doc View Source ContainerBase(ITargetContainer, ICompilerConfigurationProvider) Constructs a new instance of the ContainerBase , optionally initialising it with the given targets and compilerConfig Declaration protected ContainerBase(ITargetContainer targets = null, ICompilerConfigurationProvider compilerConfig = null) Parameters Type Name Description ITargetContainer targets Optional. The target container whose registrations will be used for dependency lookup when Resolve(ResolveContext) (and other operations) is called. If not provided, a new TargetContainer instance is constructed. This will ultimately be available to inherited types, after construction, through the Targets property. ICompilerConfigurationProvider compilerConfig Optional. An object which will be used to configure this container and its targets to use a specific compilation strategy. If null , then the DefaultProvider provider will be used. Properties | Improve this Doc View Source NoChangeCompilerConfiguration Gets the compiler configuration provider to be passed when a derived container does not want the DefaultProvider provider to be used if one is not passed on construction. This provider is guaranteed not to add/modify any registrations in the underlying target container which are connected with compilation. Declaration protected static ICompilerConfigurationProvider NoChangeCompilerConfiguration { get; } Property Value Type Description ICompilerConfigurationProvider | Improve this Doc View Source Targets Provides the ITarget instances that will be compiled into ICompiledTarget instances. Declaration protected ITargetContainer Targets { get; } Property Value Type Description ITargetContainer Remarks Notes to implementers: This property must NEVER be null. This class implements the ITargetContainer interface by wrapping around this instance so that an application can create an instance of ContainerBase and directly register targets into it; rather than having to create and setup the target container first. You can add registrations to this target container at any point in the lifetime of any ContainerBase instances which are attached to it. In reality, however, if any Resolve(ResolveContext) operations have been performed prior to adding more registrations, then there's no guarantee that new dependencies will be picked up - especially if the CachingContainerBase is being used as your application's container (which it nearly always will be). Methods | Improve this Doc View Source CanResolve(ResolveContext) Implementation of the CanResolve(ResolveContext) method. Returns true if, and only if, the Targets ITargetContainer returns a non-null ITarget when the RequestedType is passed to its Fetch(Type) method. Declaration public virtual bool CanResolve(ResolveContext context) Parameters Type Name Description ResolveContext context The resolve context containing the requested type. Returns Type Description Boolean Implements IContainer.CanResolve(ResolveContext) | Improve this Doc View Source CreateScope() Implementation of the CreateScope() method. The base definition creates a ContainerScope with this container passed as the scope's container. Thus, the new scope is a 'root' scope. Declaration public virtual IContainerScope CreateScope() Returns Type Description IContainerScope Implements IContainer.CreateScope() | Improve this Doc View Source FetchCompiled(ResolveContext) Base implementation of FetchCompiled(ResolveContext) . Note that any container already defined in the Container is ignored in favour of this container. Declaration public virtual ICompiledTarget FetchCompiled(ResolveContext context) Parameters Type Name Description ResolveContext context The context containing the requested type and any scope which is currently in force. Returns Type Description ICompiledTarget Always returns a reference to a compiled target - but note that if CanResolve(ResolveContext) returns false for the same context, then the target's GetObject(ResolveContext) method will likely throw an exception - in line with the behaviour of the ContainerBase.MissingCompiledTarget class' behaviour. Implements IContainer.FetchCompiled(ResolveContext) | Improve this Doc View Source GetCompiledRezolveTarget(ResolveContext) The main workhorse of the resolve process - obtains an ICompiledTarget for the given context by looking up an ITarget from the Targets target container, then compiling it. Declaration protected virtual ICompiledTarget GetCompiledRezolveTarget(ResolveContext context) Parameters Type Name Description ResolveContext context The current resolve context Returns Type Description ICompiledTarget Remarks The specifics of how this process works are not important if you simply want to use the container, but if you are looking to extend it, then it's essential you understand the different steps that the process goes through. If the Fetch(Type) method of the Targets target container returns a null ITarget , or one which has its UseFallback set to true , then the method gets an alternative compiled target by calling the GetFallbackCompiledRezolveTarget(ResolveContext) method. This fallback compiled target will be used instead of compiling the target unless the target was not null and its UseFallback is true AND the compiled target returned by the fallback method is a ContainerBase.MissingCompiledTarget - in which case the fallback target will be compiled as normal. Before proceeding with compilation, the container checks whether the target can resolve the required object directly. This means that the target either implements the ICompiledTarget interface (in which case it is immediately returned) or the RequestedType is not Object and the target's type is compatible with it (in which case the target is simply embedded in a new ContainerBase.DirectResolveCompiledTarget , which will later just return the target when its GetObject(ResolveContext) is called). The ObjectTarget supports the ICompiledTarget interface, therefore any objects which are directly registered through this target will always use that class' implementation of ICompiledTarget if requested through the Resolve(ResolveContext) method. Once the decision has been taken to compile the target, the container first needs a compiler ( ITargetCompiler ) and a compile context provider ( ICompileContextProvider ). Note that classes which implement the ITargetCompiler interface also frequently implement the ICompileContextProvider interface so that any additional state they require is correctly attached to the ICompileContext which will be fed to their CompileTarget(ITarget, ICompileContext) implementation. These are both obtained by resolving them directly from the Container of the context (since a container can be delegated to from another container which originally received the Resolve(ResolveContext) call). Attentive readers will realise at this point that this could lead to an infinite recursion - i.e. since compiling a target means resolving a compiler, which in turn must mean compiling that target. The class sidesteps this potential pitfall by requiring that the targets registered for these types support direct resolving, as per the description a couple of paragraphs back. Therefore, compilers and context providers are typically registered as objects via the ObjectTarget target. Finally, a new ICompileContext is created via the CreateContext(ResolveContext, ITargetContainer, IContainer) method of the resolved context provider, and then passed to the CompileTarget(ITarget, ICompileContext) method of the resolved compiler. The result of that operation is then returned to the caller. | Improve this Doc View Source GetFallbackCompiledRezolveTarget(ResolveContext) Called by GetCompiledRezolveTarget(ResolveContext) if no valid ITarget can be found for the context or if the one found has its UseFallback property set to true . Declaration protected virtual ICompiledTarget GetFallbackCompiledRezolveTarget(ResolveContext context) Parameters Type Name Description ResolveContext context Returns Type Description ICompiledTarget An ICompiledTarget to be used as the result of a Resolve(ResolveContext) operation where the search for a valid target either fails or is inconclusive (e.g. - empty enumerables). Remarks The base implementation always returns an instance of the ContainerBase.MissingCompiledTarget via the GetMissingTarget(Type) static method. | Improve this Doc View Source GetMissingTarget(Type) Gets an ICompiledTarget for the given type which will always throw an InvalidOperationException whenever its GetObject(ResolveContext) method is called. Use this when you can't resolve a target for a type. Declaration protected static ICompiledTarget GetMissingTarget(Type type) Parameters Type Name Description Type type The type for which you wish to create a missing target. Returns Type Description ICompiledTarget | Improve this Doc View Source GetService(Type) Protected virtual implementation of GetService(Type) . Uses the TryResolve(ResolveContext, out Object) method to resolve the service, returning null if the operation fails. Declaration protected virtual object GetService(Type serviceType) Parameters Type Name Description Type serviceType Type of service to be resolved. Returns Type Description Object | Improve this Doc View Source IsMissingTarget(ICompiledTarget) Determines whether the given target is an instance of ContainerBase.MissingCompiledTarget . Declaration protected static bool IsMissingTarget(ICompiledTarget target) Parameters Type Name Description ICompiledTarget target The target. Returns Type Description Boolean | Improve this Doc View Source Register(ITarget, Type) Implementation of Register(ITarget, Type) - simply proxies the call to the target container referenced by the Targets property. Declaration public void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target Type serviceType Implements ITargetContainer.Register(ITarget, Type) Remarks Remember: registering new targets into an ITargetContainer after an IContainer has started compiling targets within it can yield unpredictable results. If you create a new container and perform all your registrations before you use it, however, then everything will work as expected. Note also the other ITargetContainer interface methods are implemented explicitly so as to hide them from the list of class members. | Improve this Doc View Source Resolve(ResolveContext) Implementation of the Resolve(ResolveContext) method. Obtains an ICompiledTarget by calling the GetCompiledRezolveTarget(ResolveContext) method, and then immediately calls its GetObject(ResolveContext) method, returning the result. Declaration public virtual object Resolve(ResolveContext context) Parameters Type Name Description ResolveContext context The context containing the type that's requested, any active scope and so on. Returns Type Description Object Implements IContainer.Resolve(ResolveContext) | Improve this Doc View Source TryResolve(ResolveContext, out Object) Implementation of the TryResolve(ResolveContext, out Object) method. Attempts to resolve the requested type (given on the context , returning a boolean indicating whether the operation was successful. If successful, then result receives a reference to the resolved object. Declaration public virtual bool TryResolve(ResolveContext context, out object result) Parameters Type Name Description ResolveContext context The context containing the type that's requested, any active scope and so on. Object result Receives a reference to the object that was resolved, if successful, or null if not. Returns Type Description Boolean A boolean indicating whether the operation completed successfully. Implements IContainer.TryResolve(ResolveContext, out Object) Explicit Interface Implementations | Improve this Doc View Source ITargetContainer.CombineWith(ITargetContainer, Type) Declaration ITargetContainer ITargetContainer.CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Type type Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) | Improve this Doc View Source ITargetContainer.Fetch(Type) Declaration ITarget ITargetContainer.Fetch(Type type) Parameters Type Name Description Type type Returns Type Description ITarget Implements ITargetContainer.Fetch(Type) | Improve this Doc View Source ITargetContainer.FetchAll(Type) Declaration IEnumerable<ITarget> ITargetContainer.FetchAll(Type type) Parameters Type Name Description Type type Returns Type Description IEnumerable < ITarget > Implements ITargetContainer.FetchAll(Type) | Improve this Doc View Source IServiceProvider.GetService(Type) Declaration object IServiceProvider.GetService(Type serviceType) Parameters Type Name Description Type serviceType Returns Type Description Object Implements IServiceProvider.GetService(Type) Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.AliasTargetContainerExtensions.html": {
    "href": "api/Rezolver.AliasTargetContainerExtensions.html",
    "title": "Class AliasTargetContainerExtensions",
    "keywords": "Class AliasTargetContainerExtensions Contains extension methods for ITargetContainer to create targets which alias others by different types. Inheritance Object AliasTargetContainerExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public static class AliasTargetContainerExtensions Methods | Improve this Doc View Source RegisterAlias(ITargetContainer, Type, Type) Registers an alias for one type to another type. The created entry will effectively represent a second Resolve call into the container for the aliased type. Declaration public static void RegisterAlias(this ITargetContainer targetContainer, Type aliasType, Type originalType) Parameters Type Name Description ITargetContainer targetContainer The builder in which the alias is to be registered Type aliasType The type to be registered as an alias Type originalType The type being aliased. Remarks Use this when it's important that a given target type is always served through the same compiled target, even when the consumer expects it to be of a different type. A very common scenario is when you have a singleton instance of the originalType , and need to serve that same instance for aliasType . If you register the same singleton for both types, you get two separate singletons for each type, whereas if you create an alias, both will be served by the same alias. | Improve this Doc View Source RegisterAlias<TAlias, TOriginal>(ITargetContainer) Generic version of RegisterAlias(ITargetContainer, Type, Type) , see that method for more. Declaration public static void RegisterAlias<TAlias, TOriginal>(this ITargetContainer targetContainer) Parameters Type Name Description ITargetContainer targetContainer The target container in which the alias is to be registered Type Parameters Name Description TAlias Type being registered as an alias to another type TOriginal The target type of the alias."
  },
  "api/Rezolver.Compilation.Expressions.DefaultTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.DefaultTargetBuilder.html",
    "title": "Class DefaultTargetBuilder",
    "keywords": "Class DefaultTargetBuilder An IExpressionBuilder specialised for building the expression for the DefaultTarget target. Essentially, it just calls Default(Type) for the DeclaredType . Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < DefaultTarget > DefaultTargetBuilder Inherited Members ExpressionBuilderBase<DefaultTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DefaultTarget>.IExpressionBuilder<DefaultTarget>.Build(DefaultTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DefaultTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class DefaultTargetBuilder : ExpressionBuilderBase<DefaultTarget>, IExpressionBuilder<DefaultTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(DefaultTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target for the given ICompileContext Declaration protected override Expression Build(DefaultTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description DefaultTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.DefaultTarget>.Build(Rezolver.Targets.DefaultTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.GenericConstructorTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.GenericConstructorTargetBuilder.html",
    "title": "Class GenericConstructorTargetBuilder",
    "keywords": "Class GenericConstructorTargetBuilder An IExpressionBuilder specialised for building expressions for GenericConstructorTarget targets. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < GenericConstructorTarget > GenericConstructorTargetBuilder Inherited Members ExpressionBuilderBase<GenericConstructorTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<GenericConstructorTarget>.IExpressionBuilder<GenericConstructorTarget>.Build(GenericConstructorTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<GenericConstructorTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class GenericConstructorTargetBuilder : ExpressionBuilderBase<GenericConstructorTarget>, IExpressionBuilder<GenericConstructorTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(GenericConstructorTarget, IExpressionCompileContext, IExpressionCompiler) Obtains the bound target for the target passed (by calling Bind(ICompileContext) , and passes it to the compiler to have an expression built for it. Declaration protected override Expression Build(GenericConstructorTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description GenericConstructorTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.GenericConstructorTarget>.Build(Rezolver.Targets.GenericConstructorTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ExceptionResources.html": {
    "href": "api/Rezolver.ExceptionResources.html",
    "title": "Class ExceptionResources",
    "keywords": "Class ExceptionResources A strongly-typed resource class, for looking up localized strings, etc. Inheritance Object ExceptionResources Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class ExceptionResources Properties | Improve this Doc View Source _MOVETOSHAREDPROJECT Looks up a localized string similar to REMINDER TO MOVE THIS TO THE SHARED PROJECT AND MARK AS INTERNAL WHEN YOU FINALY CAN. Declaration public static string _MOVETOSHAREDPROJECT { get; } Property Value Type Description String | Improve this Doc View Source Culture Overrides the current thread's CurrentUICulture property for all resource lookups using this strongly typed resource class. Declaration public static CultureInfo Culture { get; set; } Property Value Type Description CultureInfo | Improve this Doc View Source CyclicDependencyDetectedInTargetFormat Looks up a localized string similar to Cyclic dependency detected in targets - current target of type {0} with DeclaredType of {1} has tried to include itself in its expression.. Declaration public static string CyclicDependencyDetectedInTargetFormat { get; } Property Value Type Description String | Improve this Doc View Source DeclaredTypeIsNotCompatible_Format Looks up a localized string similar to The declared type {0} is not compatible with the type {1}. Declaration public static string DeclaredTypeIsNotCompatible_Format { get; } Property Value Type Description String | Improve this Doc View Source LambdaBodyIsNotNewExpressionFormat Looks up a localized string similar to The body of the lambda \"{0}\" is not a NewExpression. Declaration public static string LambdaBodyIsNotNewExpressionFormat { get; } Property Value Type Description String | Improve this Doc View Source LambdaBodyNewExpressionIsWrongTypeFormat Looks up a localized string similar to The expression {0} does not represent calling a constructor of the type {1}. Declaration public static string LambdaBodyNewExpressionIsWrongTypeFormat { get; } Property Value Type Description String | Improve this Doc View Source MoreThanOneBestConstructorFormat Looks up a localized string similar to More than one constructor for {0} found that could be bound from the current context. Possible candidates: {1}. Declaration public static string MoreThanOneBestConstructorFormat { get; } Property Value Type Description String | Improve this Doc View Source MoreThanOneConstructorFormat Looks up a localized string similar to More than one constructor for {0} qualifies as a target for Auto construction. Declaration public static string MoreThanOneConstructorFormat { get; } Property Value Type Description String | Improve this Doc View Source MoreThanOneObjectFoundInScope Looks up a localized string similar to More than one matching object was found in the scope. Declaration public static string MoreThanOneObjectFoundInScope { get; } Property Value Type Description String | Improve this Doc View Source NoApplicableConstructorForContextFormat Looks up a localized string similar to No constructor found on the type {0} which can be satisfied by the CompileContext. Declaration public static string NoApplicableConstructorForContextFormat { get; } Property Value Type Description String | Improve this Doc View Source NoConstructorSetOnNewExpression Looks up a localized string similar to No constructor has been set on the NewExpression - this is not allowed.. Declaration public static string NoConstructorSetOnNewExpression { get; } Property Value Type Description String | Improve this Doc View Source NoDefaultOrAllOptionalConstructorFormat Looks up a localized string similar to The type {0} has no default constructor, nor any constructors where all the parameters are optional.. Declaration public static string NoDefaultOrAllOptionalConstructorFormat { get; } Property Value Type Description String | Improve this Doc View Source NoPublicConstructorsDefinedFormat Looks up a localized string similar to No public constructors declared on the type {0}. Declaration public static string NoPublicConstructorsDefinedFormat { get; } Property Value Type Description String | Improve this Doc View Source NotRuntimeMethod Looks up a localized string similar to This method is not to be called at run-time - it is only used for static expression analysis in creating IRezolveTargets for an IRezolveBuilder. Declaration public static string NotRuntimeMethod { get; } Property Value Type Description String | Improve this Doc View Source PathIsAtEnd Looks up a localized string similar to path's Next must not be null - pass path as null once it's reached the last item. Declaration public static string PathIsAtEnd { get; } Property Value Type Description String | Improve this Doc View Source PathIsInvalid Looks up a localized string similar to The path {0} is invalid. All path steps must contain non-whitespace characters and be at least one character in length. Declaration public static string PathIsInvalid { get; } Property Value Type Description String | Improve this Doc View Source ResourceManager Returns the cached ResourceManager instance used by this class. Declaration public static ResourceManager ResourceManager { get; } Property Value Type Description ResourceManager | Improve this Doc View Source RezolverTargetEntryHasBeenRealised Looks up a localized string similar to No more targets can be added to this entry. Declaration public static string RezolverTargetEntryHasBeenRealised { get; } Property Value Type Description String | Improve this Doc View Source ScopedSingletonRequiresAScope Looks up a localized string similar to A lifetime scope is required for a scoped singleton. Declaration public static string ScopedSingletonRequiresAScope { get; } Property Value Type Description String | Improve this Doc View Source TargetDoesntSupportType_Format Looks up a localized string similar to The target does not support the type {0}. Declaration public static string TargetDoesntSupportType_Format { get; } Property Value Type Description String | Improve this Doc View Source TargetIsNullButTypeIsNotNullable_Format Looks up a localized string similar to The type {0} is not a nullable type. Declaration public static string TargetIsNullButTypeIsNotNullable_Format { get; } Property Value Type Description String | Improve this Doc View Source TargetReturnedNullExpressionFormat Looks up a localized string similar to Target of type {0} returned a null expression for context {1} - implementation is invalid, targets must never return a null expression.. Declaration public static string TargetReturnedNullExpressionFormat { get; } Property Value Type Description String | Improve this Doc View Source TypeIsAlreadyRegistered Looks up a localized string similar to The type {0} has already been registered. Declaration public static string TypeIsAlreadyRegistered { get; } Property Value Type Description String | Improve this Doc View Source UnableToResolveTypeFromBuilderFormat Looks up a localized string similar to Unable to resolve type {0} from builder. Declaration public static string UnableToResolveTypeFromBuilderFormat { get; } Property Value Type Description String Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.IContainerScope.html": {
    "href": "api/Rezolver.IContainerScope.html",
    "title": "Interface IContainerScope",
    "keywords": "Interface IContainerScope This is an IContainer -like object (resolving functionality is provided through the extension methods in the ContainerScopeResolveExtensions class) which Inherited Members IDisposable.Dispose() IServiceProvider.GetService(Type) Namespace :Rezolver Assembly :Rezolver.dll Syntax public interface IContainerScope : IDisposable, IServiceProvider Properties | Improve this Doc View Source Container The container that this scope is tied to. All standard resolve operations should be made against this container to begin with. Declaration IContainer Container { get; } Property Value Type Description IContainer | Improve this Doc View Source Parent If this scope has a parent scope, this is it. Declaration IContainerScope Parent { get; } Property Value Type Description IContainerScope Methods | Improve this Doc View Source ChildScopeDisposed(IContainerScope) Called by child scopes when they are disposed to notify the parent that they will no longer need to be disposed of when the parent is disposed. Declaration void ChildScopeDisposed(IContainerScope child) Parameters Type Name Description IContainerScope child Remarks This is an infrastructure method and not something you would usually need to call. It's exposed for developers who are extending the container scoping functionality only. | Improve this Doc View Source CreateScope() Called to create a child scope from this scope. Declaration IContainerScope CreateScope() Returns Type Description IContainerScope | Improve this Doc View Source Resolve(ResolveContext, Func<ResolveContext, Object>, ScopeBehaviour) Execute the given object factory within this scope. Depending on the scoping behaviour passed, the object will either be resolved directly from the scope (i.e. existing objects contained within it) or obtained by executing the factory and optionally tracking the object if it's IDisposable. Declaration object Resolve(ResolveContext context, Func<ResolveContext, object> factory, ScopeBehaviour behaviour) Parameters Type Name Description ResolveContext context The resolve context - please note that the container that's present on this is the actual container that should be used to resolve objects Func < ResolveContext , Object > factory The factory to be executed ScopeBehaviour behaviour Returns Type Description Object Remarks This function is the primary workhorse of all scopes. Most importantly, the object produced from the factory DOES NOT have to come from this scope's Container - the implementing type simply has to ensure that it tracks whatever object is ultimately returned; potentially returning a previously tracked object if behaviour is Explicit Extension Methods ContainerScopeExtensions.GetRootScope(IContainerScope) ContainerScopeResolveExtensions.Resolve<TResult>(IContainerScope) ContainerScopeResolveExtensions.Resolve(IContainerScope, Type) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also IDisposable IServiceProvider"
  },
  "api/Rezolver.ParameterBinding.html": {
    "href": "api/Rezolver.ParameterBinding.html",
    "title": "Class ParameterBinding",
    "keywords": "Class ParameterBinding Represents a binding between a method parameter and an ITarget Inheritance Object ParameterBinding Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class ParameterBinding Constructors | Improve this Doc View Source ParameterBinding(ParameterInfo, ITarget) Constructs a new instance of the ParameterBinding class. Declaration public ParameterBinding(ParameterInfo parameter, ITarget target = null) Parameters Type Name Description ParameterInfo parameter Required - the parameter being bound ITarget target Optional - the argument supplied for the parameter. Fields | Improve this Doc View Source None Represents an empty parameter bindings array. Declaration public static readonly ParameterBinding[] None Field Value Type Description ParameterBinding [] Properties | Improve this Doc View Source IsValid Gets a boolean indicating whether the parameter binding is valid Ultimately, this returns true if Target is non-null. Declaration public bool IsValid { get; } Property Value Type Description Boolean | Improve this Doc View Source Parameter The parameter to be bound Declaration public ParameterInfo Parameter { get; } Property Value Type Description ParameterInfo | Improve this Doc View Source Target The initial target that was bound to this parameter. Declaration public ITarget Target { get; } Property Value Type Description ITarget Methods | Improve this Doc View Source BindMethod(MethodBase, ParameterBinding[]) Binds the method using explicit bindings for each parameter supplied in the suppliedBindings array, or defaults (which will be resolved from the compile or run-time container) if not present. Declaration public static ParameterBinding[] BindMethod(MethodBase method, ParameterBinding[] suppliedBindings) Parameters Type Name Description MethodBase method The method to be bound ParameterBinding [] suppliedBindings Optional. The supplied bindings for the parameters of the method. Any parameters not matched from this array will be automatically bound with default (resolved from the container). Returns Type Description ParameterBinding [] | Improve this Doc View Source BindMethod(MethodBase, IDictionary<String, ITarget>) Matches named targets in args to parameters on the passed method , creating default ParameterBinding s (which will be resolved from the compile or run-time container), for any parameters for which named targets cannot be found. Declaration public static ParameterBinding[] BindMethod(MethodBase method, IDictionary<string, ITarget> args) Parameters Type Name Description MethodBase method IDictionary < String , ITarget > args Returns Type Description ParameterBinding [] | Improve this Doc View Source BindOverload(MethodBase[], IDictionary<String, ITarget>, out MethodBase) Searches for a method in the methods collection whose parameters can be filled by the targets provided in the args dictionary, returning the parameter bindings, and passing out the resolved target method in resolvedMethod if found. Note - if no match can be found, or if more than one method could be bound, then an InvalidOperationException will occur. Declaration public static ParameterBinding[] BindOverload(MethodBase[] methods, IDictionary<string, ITarget> args, out MethodBase resolvedMethod) Parameters Type Name Description MethodBase [] methods The methods. IDictionary < String , ITarget > args The arguments. MethodBase resolvedMethod The resolved method. Returns Type Description ParameterBinding [] ParameterBinding[]. | Improve this Doc View Source BindWithRezolvedArguments(MethodBase) Creates parameter bindings for each parameter in the passed method where each value will be resolved. For any optional parameters - their default values will be used as a fallback if the ResolvedTarget cannot either resolve a target at compile time or from the IContainer at resolve-time. Declaration public static ParameterBinding[] BindWithRezolvedArguments(MethodBase method) Parameters Type Name Description MethodBase method Returns Type Description ParameterBinding [] | Improve this Doc View Source Resolve(ICompileContext) Fetch the target that would be bound to this parameter given the passed ICompileContext Declaration public virtual ITarget Resolve(ICompileContext context) Parameters Type Name Description ICompileContext context The current compile context - a new one is created for the Parameter type Returns Type Description ITarget The target that should be used for the parameter, or null if no target could be found. Note that if the returned target's UseFallback property is set to true , then it means either the parameter's default value is being used, or that the target fetched from the target container in the context is a stub (e.g. empty enumerable) Remarks During compilation - you should not use the target returned by this function as a direct part of your expression tree - you should Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ICompiledTarget.html": {
    "href": "api/Rezolver.ICompiledTarget.html",
    "title": "Interface ICompiledTarget",
    "keywords": "Interface ICompiledTarget Provides an abstraction for creating objects based on a given ResolveContext - this is the ultimate target of all Resolve(ResolveContext) calls in the standard container implementations within the Rezolver framework. Namespace :Rezolver Assembly :Rezolver.dll Syntax public interface ICompiledTarget Remarks In the standard implementations of IContainer (e.g. Container ), a ITargetCompiler creates instances of this from ITarget s which are registered in an ITargetContainer . When the container is then called upon to resolve an instance of a particular type, the ICompiledTarget is first obtained, and then the responsibility for creating the object is delegated to its GetObject(ResolveContext) method. Methods | Improve this Doc View Source GetObject(ResolveContext) Called to get/create an object, potentially using the passed context to resolve additional dependencies (via its Container ), or interact with any lifetime scope which is 'active' for that request (through Scope ). Declaration object GetObject(ResolveContext context) Parameters Type Name Description ResolveContext context The current rezolve context. Returns Type Description Object The object that is constructed. The return value can legitimately be null. Exceptions Type Condition InvalidOperationException If the target fails to create the object Exception Any other application-level exception could be raised by this operation Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.MethodBinding.html": {
    "href": "api/Rezolver.MethodBinding.html",
    "title": "Class MethodBinding",
    "keywords": "Class MethodBinding Represents a binding to a method whose arguments will be supplied by ITarget instances. Inheritance Object MethodBinding ConstructorBinding Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class MethodBinding Constructors | Improve this Doc View Source MethodBinding(MethodBase, ParameterBinding[]) Initializes a new instance of the MethodBinding class. Declaration public MethodBinding(MethodBase method, ParameterBinding[] boundArgs = null) Parameters Type Name Description MethodBase method The method. ParameterBinding [] boundArgs Optional. The bound arguments. Can be null or empty. Properties | Improve this Doc View Source BoundArguments Gets the argument bindings for the method call. Never null but can be empty. Declaration public ParameterBinding[] BoundArguments { get; } Property Value Type Description ParameterBinding [] The bound arguments. | Improve this Doc View Source Method Gets the method to be invoked. Declaration public MethodBase Method { get; } Property Value Type Description MethodBase The method. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.MethodCallExtractor.html": {
    "href": "api/Rezolver.MethodCallExtractor.html",
    "title": "Class MethodCallExtractor",
    "keywords": "Class MethodCallExtractor Used to help grab method and constructor info from expressions (which is easier than writing long strings of reflection code). For example: MethodCallExtractor.ExtractCalledMethod(() => Console.WriteLine(\"foo\")) Will return the MethodInfo for the WriteLine method of the Console class. Inheritance Object ExpressionVisitor MethodCallExtractor Inherited Members ExpressionVisitor.Visit(ReadOnlyCollection<Expression>) ExpressionVisitor.Visit(Expression) ExpressionVisitor.Visit<T>(ReadOnlyCollection<T>, Func<T, T>) ExpressionVisitor.VisitAndConvert<T>(T, String) ExpressionVisitor.VisitAndConvert<T>(ReadOnlyCollection<T>, String) ExpressionVisitor.VisitBinary(BinaryExpression) ExpressionVisitor.VisitBlock(BlockExpression) ExpressionVisitor.VisitCatchBlock(CatchBlock) ExpressionVisitor.VisitConditional(ConditionalExpression) ExpressionVisitor.VisitConstant(ConstantExpression) ExpressionVisitor.VisitDebugInfo(DebugInfoExpression) ExpressionVisitor.VisitDefault(DefaultExpression) ExpressionVisitor.VisitElementInit(ElementInit) ExpressionVisitor.VisitExtension(Expression) ExpressionVisitor.VisitGoto(GotoExpression) ExpressionVisitor.VisitIndex(IndexExpression) ExpressionVisitor.VisitInvocation(InvocationExpression) ExpressionVisitor.VisitLabel(LabelExpression) ExpressionVisitor.VisitLabelTarget(LabelTarget) ExpressionVisitor.VisitLambda<T>(Expression<T>) ExpressionVisitor.VisitListInit(ListInitExpression) ExpressionVisitor.VisitLoop(LoopExpression) ExpressionVisitor.VisitMember(MemberExpression) ExpressionVisitor.VisitMemberAssignment(MemberAssignment) ExpressionVisitor.VisitMemberBinding(MemberBinding) ExpressionVisitor.VisitMemberInit(MemberInitExpression) ExpressionVisitor.VisitMemberListBinding(MemberListBinding) ExpressionVisitor.VisitMemberMemberBinding(MemberMemberBinding) ExpressionVisitor.VisitNewArray(NewArrayExpression) ExpressionVisitor.VisitParameter(ParameterExpression) ExpressionVisitor.VisitRuntimeVariables(RuntimeVariablesExpression) ExpressionVisitor.VisitSwitch(SwitchExpression) ExpressionVisitor.VisitSwitchCase(SwitchCase) ExpressionVisitor.VisitTry(TryExpression) ExpressionVisitor.VisitTypeBinary(TypeBinaryExpression) ExpressionVisitor.VisitUnary(UnaryExpression) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public sealed class MethodCallExtractor : ExpressionVisitor Methods | Improve this Doc View Source ExtractCalledMethod(Expression<Action>) Extracts the MethodInfo of the first method call found in the expression. Declaration public static MethodInfo ExtractCalledMethod(Expression<Action> expr) Parameters Type Name Description Expression < System.Action > expr The expression to be read Returns Type Description MethodInfo A MethodInfo representing the method - if the expression contains a method call; otherwise null | Improve this Doc View Source ExtractCalledMethod<T>(Expression<Action<T>>) Extracts the MethodInfo of the first method call found in the expression. Declaration public static MethodInfo ExtractCalledMethod<T>(Expression<Action<T>> expr) Parameters Type Name Description Expression < System.Action <T>> expr The expression to be read Returns Type Description MethodInfo A MethodInfo representing the method - if the expression contains a method call; otherwise null Type Parameters Name Description T Allows the expression to declare a parameter to aid overload resolution, but doesn't actually have any material influence on the expression analysis. | Improve this Doc View Source ExtractCalledMethod<TResult>(Expression<Func<TResult>>) Extracts the MethodInfo of the first method call found in the expression. Declaration public static MethodInfo ExtractCalledMethod<TResult>(Expression<Func<TResult>> expr) Parameters Type Name Description Expression < Func <TResult>> expr The expression to be read Returns Type Description MethodInfo A MethodInfo representing the method - if the expression contains a method call; otherwise null Type Parameters Name Description TResult Return type of the expression. Not actually used in any way, it's just here to allow overload resolution when an expression represents a non-void function call | Improve this Doc View Source ExtractCalledMethod<TInstance, TResult>(Expression<Func<TInstance, TResult>>) Extracts the MethodInfo of the first method call found in the expression. Declaration public static MethodInfo ExtractCalledMethod<TInstance, TResult>(Expression<Func<TInstance, TResult>> expr) Parameters Type Name Description Expression < Func <TInstance, TResult>> expr The expression to be read Returns Type Description MethodInfo A MethodInfo representing the method - if the expression contains a method call; otherwise null Type Parameters Name Description TInstance Allows the expression to declare a parameter to aid overload resolution, but doesn't actually have any material influence on the expression analysis. TResult Return type of the expression. Not actually used in any way, it's just here to allow overload resolution when an expression represents a non-void function call | Improve this Doc View Source ExtractConstructorCall(Expression<Action>) Extracts the ConstructorInfo of the first 'new' statement found in the expression Declaration public static ConstructorInfo ExtractConstructorCall(Expression<Action> expr) Parameters Type Name Description Expression < System.Action > expr The expression to be analysed. Returns Type Description ConstructorInfo A ConstructorInfo representing the constructor being called in the expression; otherwise null if not found. | Improve this Doc View Source ExtractConstructorCall<T>(Expression<Action<T>>) Extracts the ConstructorInfo of the first 'new' statement found in the expression Declaration public static ConstructorInfo ExtractConstructorCall<T>(Expression<Action<T>> expr) Parameters Type Name Description Expression < System.Action <T>> expr The expression to be analysed. Returns Type Description ConstructorInfo A ConstructorInfo representing the constructor being called in the expression; otherwise null if not found. Type Parameters Name Description T Allows the expression to declare a parameter to aid overload resolution, but doesn't actually have any material influence on the expression analysis. | Improve this Doc View Source ExtractConstructorCall<TResult>(Expression<Func<TResult>>) Extracts the ConstructorInfo of the first 'new' statement found in the expression Declaration public static ConstructorInfo ExtractConstructorCall<TResult>(Expression<Func<TResult>> expr) Parameters Type Name Description Expression < Func <TResult>> expr The expression to be analysed. Returns Type Description ConstructorInfo A ConstructorInfo representing the constructor being called in the expression; otherwise null if not found. Type Parameters Name Description TResult Return type of the expression. Not actually used in any way, it's just here to allow overload resolution when an expression represents a non-void function call | Improve this Doc View Source ExtractConstructorCall<TInstance, TResult>(Expression<Func<TInstance, TResult>>) Extracts the ConstructorInfo of the first 'new' statement found in the expression Declaration public static ConstructorInfo ExtractConstructorCall<TInstance, TResult>(Expression<Func<TInstance, TResult>> expr) Parameters Type Name Description Expression < Func <TInstance, TResult>> expr The expression to be analysed. Returns Type Description ConstructorInfo A ConstructorInfo representing the constructor being called in the expression; otherwise null if not found. Type Parameters Name Description TInstance Allows the expression to declare a parameter to aid overload resolution, but doesn't actually have any material influence on the expression analysis. TResult Return type of the expression. Not actually used in any way, it's just here to allow overload resolution when an expression represents a non-void function call | Improve this Doc View Source VisitMethodCall(MethodCallExpression) Visits the children of the MethodCallExpression . Declaration protected override Expression VisitMethodCall(MethodCallExpression node) Parameters Type Name Description MethodCallExpression node The expression to visit. Returns Type Description Expression Overrides ExpressionVisitor.VisitMethodCall(MethodCallExpression) | Improve this Doc View Source VisitNew(NewExpression) Visits the children of the NewExpression . Declaration protected override Expression VisitNew(NewExpression node) Parameters Type Name Description NewExpression node The expression to visit. Returns Type Description Expression Overrides ExpressionVisitor.VisitNew(NewExpression) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Targets.ChangeTypeTarget.html": {
    "href": "api/Rezolver.Targets.ChangeTypeTarget.html",
    "title": "Class ChangeTypeTarget",
    "keywords": "Class ChangeTypeTarget This target is specifically used for explicitly casting the result of one target to another type. Its use is rare, since the framework already caters for downcasting the result of targets to base types. Inheritance Object TargetBase ChangeTypeTarget Inherited Members TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class ChangeTypeTarget : TargetBase, ITarget Remarks A valid use of this target is when you have a SingletonTarget registered against one type, and you want the same singleton (backed by the same instance) to server another type. In this case, instead of registering the same singleton target multiple times, you can register it once for its primary type, then register one of these for the other type, with a ResolvedTarget as its inner target. When creating this target, the DeclaredType of the InnerTarget must be able to cast up or down to the DeclaredType of this target. Constructors | Improve this Doc View Source ChangeTypeTarget(ITarget, Type) Creates a new instance of the ChangeTypeTarget class. Declaration public ChangeTypeTarget(ITarget innerTarget, Type targetType) Parameters Type Name Description ITarget innerTarget Required. See InnerTarget Type targetType Required. See DeclaredType Properties | Improve this Doc View Source DeclaredType Always returns the target type that was passed in the ChangeTypeTarget(ITarget, Type) constructor. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source InnerTarget The target whose type will be changed to DeclaredType . Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget | Improve this Doc View Source ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.ConstructorTarget.html": {
    "href": "api/Rezolver.Targets.ConstructorTarget.html",
    "title": "Class ConstructorTarget",
    "keywords": "Class ConstructorTarget A target that binds to a type's constructor with zero or more arguments supplied by other ITarget s and, optionally binding to the new instance's writeable properties. The target supports en explicitly supplied constructor, as well as just-in-time lookups for the best available constructor based on the available services and/or any named arguments which might been provided up front. Inheritance Object TargetBase ConstructorTarget Inherited Members TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class ConstructorTarget : TargetBase, ITarget Remarks Although you can create this target directly through the Rezolver.Targets.ConstructorTarget.#ctor(System.Type,System.Reflection.ConstructorInfo,Rezolver.IMemberBindingBehaviour,Rezolver.ParameterBinding[],System.Collections.Generic.IDictionary{System.String,Rezolver.ITarget}) constructor, you're more likely to create it through factory methods such as Auto<T>(IMemberBindingBehaviour) or, more likely still, extension methods such as RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) during your application's container setup phase. To compile this target, an ITargetCompiler must call the Bind(ICompileContext) method Constructors | Improve this Doc View Source ConstructorTarget(ConstructorInfo, IMemberBindingBehaviour, ParameterBinding[]) Initializes a new instance of the ConstructorTarget class bound in advance to a specific constructor. Declaration public ConstructorTarget(ConstructorInfo ctor, IMemberBindingBehaviour memberBindingBehaviour = null, ParameterBinding[] parameterBindings = null) Parameters Type Name Description ConstructorInfo ctor Required - the constructor that is to be bound. The DeclaredType of the new instance will be set to the DeclaringType of this object. IMemberBindingBehaviour memberBindingBehaviour Optional. If provided, can be used to select properties which are to be initialised before the new instance is returned. ParameterBinding [] parameterBindings Optional. Specific bindings for the parameters of the given ctor which should be used during code generation. Note that this array can contain fewer or more entries than there are parameters on the ctor . Any missing bindings will be automatically generated when Bind(ICompileContext) is called. | Improve this Doc View Source ConstructorTarget(Type, IMemberBindingBehaviour, IDictionary<String, ITarget>) Initializes a just-in-time-bound instance of the ConstructorTarget class which must be bound to the best constructor at compile-time by calling the Bind(ICompileContext) method. Declaration public ConstructorTarget(Type type, IMemberBindingBehaviour memberBindingBehaviour = null, IDictionary<string, ITarget> namedArgs = null) Parameters Type Name Description Type type Required. The type whose constructor is to bound. IMemberBindingBehaviour memberBindingBehaviour Optional. If provided, can be used to select properties which are to be initialised before the new instance is returned. IDictionary < String , ITarget > namedArgs Optional. The named arguments which will be passed to, and used to find, the best-matched constructor. These are taken into account when the constructor is sought - with the constructor containing the most matched parameters matched being selected. Remarks To compile this target, a ITargetCompiler first calls the Bind(ICompileContext) method to discover the constructor to be executed, along with the final set of arguments to be provided to it (see ConstructorBinding ). The best available constructor is defined as the constructor with the most parameters for which arguments can be resolved from the ICompileContext at compile-time to the fewest number of ITarget objects whose UseFallback is false. Properties | Improve this Doc View Source Ctor Can be null. Gets the constructor that this target is bound to, if it was known when the target was created. Declaration public ConstructorInfo Ctor { get; } Property Value Type Description ConstructorInfo Remarks ConstructorTargets can be bound to a particular constructor in advance, or they can search for a best-match constructor at the point where Bind(ICompileContext) is called. This property will only be set ultimately if it was passed to the ConstructorTarget(ConstructorInfo, IMemberBindingBehaviour, ParameterBinding[]) constructor, possibly by a factory method like WithArgs(ConstructorInfo, IDictionary<String, ITarget>) , or FromNewExpression(Type, NewExpression) , where the constructor is captured within the expression. | Improve this Doc View Source DeclaredType Implementation of DeclaredType . Always equal to the type whose constructor will be bound by this target. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source MemberBindingBehaviour Gets the member binding behaviour to be used when Bind(ICompileContext) is called. Declaration public IMemberBindingBehaviour MemberBindingBehaviour { get; } Property Value Type Description IMemberBindingBehaviour | Improve this Doc View Source NamedArgs Named arguments (as ITarget objects) to be supplied to the object on construction, also aiding the search for a constructor. This equivalent to the way that languages such as C# can bind to overloaded functions based solely on named arguments. Declaration public IReadOnlyDictionary<string, ITarget> NamedArgs { get; } Property Value Type Description IReadOnlyDictionary < String , ITarget > Remarks Note the difference between this and ParameterBindings - this property might be used when the constructor is not known in advance, whereas ParameterBindings is used when it is. | Improve this Doc View Source ParameterBindings If this target was created with a specific constructor then this might contain argument bindings for that constructor's parameters. Declaration public IReadOnlyList<ParameterBinding> ParameterBindings { get; } Property Value Type Description IReadOnlyList < ParameterBinding > Remarks This is not the same as NamedArgs - as is noted by the documentation on that property. This property is for when the constructor is known in advance and when certain parameters are to be bound with specific arguments; whereas NamedArgs is for when the constructor is not known. Methods | Improve this Doc View Source Auto(Type, IMemberBindingBehaviour) Creates a late bound ConstructorTarget or GenericConstructorTarget for the given type . Declaration public static ITarget Auto(Type type, IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description Type type The type that is to be constructed when this target is compiled and executed. IMemberBindingBehaviour memberBindingBehaviour Optional. An object which selects properties on the new instance which are to be bound from the container. Returns Type Description ITarget Either a ConstructorTarget or GenericConstructorTarget , depending on whether the type is a generic type definition. Remarks This factory is merely a shortcut for calling the ConstructorTarget(Type, IMemberBindingBehaviour, IDictionary<String, ITarget>) with only the type and memberBindingBehaviour arguments supplied. When creating a GenericConstructorTarget , the function uses the GenericConstructorTarget(Type, IMemberBindingBehaviour) constructor. | Improve this Doc View Source Auto<T>(IMemberBindingBehaviour) Generic version of the Auto(Type, IMemberBindingBehaviour) method. Declaration public static ITarget Auto<T>(IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description IMemberBindingBehaviour memberBindingBehaviour See the documentation for the memberBindingBehaviour parameter on the non-generic version of this method. Returns Type Description ITarget Either a ConstructorTarget or GenericConstructorTarget , depending on whether T is a generic type definition. Type Parameters Name Description T The type that is to be constructed when the new target is compiled and executed. | Improve this Doc View Source Bind(ICompileContext) Gets the ConstructorBinding for the DeclaredType using the targets available in the context for dependency lookup. The constructor is either resolved by checking available targets for the best match, or is pre-selected on construction ( Ctor will be non-null in this case). Declaration public ConstructorBinding Bind(ICompileContext context) Parameters Type Name Description ICompileContext context The current compilation context. Returns Type Description ConstructorBinding Exceptions Type Condition AmbiguousMatchException If more than one constructor can be bound with an equal amount of all-resolved arguments or default arguments. InvalidOperationException If no sutiable constructors can be found. | Improve this Doc View Source FromNewExpression(Type, NewExpression) Non-generic version of FromNewExpression<T>(Expression<Func<T>>) . See the documentation on that method for more. Declaration public static ITarget FromNewExpression(Type declaredType, NewExpression newExpr) Parameters Type Name Description Type declaredType The of the object to be created by the new ConstructorTarget NewExpression newExpr An expression from which the target can be built - parameter bindings and the specific constructor called in the expression will be used to seed the new target. Returns Type Description ITarget | Improve this Doc View Source FromNewExpression<T>(Expression<Func<T>>) Creates a new ConstructorTarget from the passed lambda expression (whose Body must be a NewExpression ) Declaration public static ITarget FromNewExpression<T>(Expression<Func<T>> newExpr) Parameters Type Name Description Expression < Func <T>> newExpr Required. The expression from which to create the target. Returns Type Description ITarget An ITarget which, when compiled, will perform that same construction as provided in the given expression. Type Parameters Name Description T The type of the object to be created by the new ConstructorTarget Remarks This method does not support member binding expressions - e.g. c => new MyObject() { A = \"hello\" } - these can be converted into targets - for these you should construct an ExpressionTarget and let the compiler do the rest. When providing custom expressions to be used as targets in an ITargetContainer , it is possible to explicitly define properties/arguments as being resolved from the container itself, in exactly the same way as generated by the other factory methods such as Auto<T>(IMemberBindingBehaviour) and RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) . To do this, simply call the Resolve<T>() function on the object passed into your expression (see the signature of the lambda newExpr ), and Rezolver will convert that call into a ResolvedTarget . Exceptions Type Condition ArgumentNullException If newExpr is null. ArgumentException If the newExpr does not have a NewExpression as its root (Body) node, or if the type of that expression does not equal T | Improve this Doc View Source WithArgs(ConstructorInfo, IDictionary<String, ITarget>) Similar to WithArgs(Type, IDictionary<String, ITarget>) except this one creates a ConstructorTarget that is specifically bound to a particular constructor on a given type, using any matched argument bindings from the provided namedArgs dictionary, and using ResolvedTarget targets for any that are not matched. Declaration public static ITarget WithArgs(ConstructorInfo ctor, IDictionary<string, ITarget> namedArgs) Parameters Type Name Description ConstructorInfo ctor Required. The constructor to be bound. IDictionary < String , ITarget > namedArgs Optional. Any arguments to be supplied to parameters on the ctor by name. Any parameters for which matches are not found in this dictionary will be automatically bound either from compile-time defaults or by resolving those types dynamically. Returns Type Description ITarget Remarks Although this overload accepts a dictionary of arguments, note that it will not result in the NamedArgs property being set on the target that is created - it's just an alternative for deriving the ParameterBindings with which the target will be created. Also, this function will not fail if the args dictionary contains named arguments that cannot be matched to parameters on the ctor . | Improve this Doc View Source WithArgs(ConstructorInfo, Object) Performs the same operation as WithArgs(ConstructorInfo, IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration public static ITarget WithArgs(ConstructorInfo ctor, object namedArgs) Parameters Type Name Description ConstructorInfo ctor Required. The constructor to be bound. Object namedArgs An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Remarks Although this overload accepts a dictionary of arguments, note that it will not result in the NamedArgs property being set on the target that is created - it's just an alternative for deriving the ParameterBindings with which the target will be created. Also, this function will not fail if the args dictionary contains named arguments that cannot be matched to parameters on the ctor . | Improve this Doc View Source WithArgs(Type, IDictionary<String, ITarget>) Non-generic version of WithArgs<T>(IDictionary<String, ITarget>) . Creates a ConstructorTarget with a set of named targets which will be used like named arguments to late-bind the constructor when code-generation occurs. Declaration public static ITarget WithArgs(Type declaredType, IDictionary<string, ITarget> namedArgs) Parameters Type Name Description Type declaredType The type whose constructor is to be bound. IDictionary < String , ITarget > namedArgs The named arguments to be used when building the expression. Returns Type Description ITarget Remarks Both versions of this method will create a target which will try to find the best-matching constructor where all of the named arguments match, and with the fewest number of auto-resolved arguments. So, a class with a constructor such as Foo(IService1 s1, IService2 s2) Can happily be bound if you only provide a named argument for 's1'; the target will simply attempt to auto-resolve the argument for the IService2 s2 parameter when constructing the object - and will fail only if it can't be resolved at that point. | Improve this Doc View Source WithArgs(Type, Object) Performs the same operation as WithArgs(Type, IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration public static ITarget WithArgs(Type declaredType, object namedArgs) Parameters Type Name Description Type declaredType The type whose constructor is to be bound. Object namedArgs An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Remarks This overload exists to simplify the process of creating a ConstructorTarget with argument bindings by removing the need to create an argument dictionary in advance. An anonymous type can instead be used to supply the arguments. Examples This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a ConstructorTarget for the type 'MyType': ConstructorTarget.WithArgs(typeof(MyType), new { param1 = new ObjectTarget(\"Hello World\") }); | Improve this Doc View Source WithArgs<T>(IDictionary<String, ITarget>) Creates a ConstructorTarget with a set of named targets which will be used like named arguments to late-bind the constructor when code-generation occurs. Declaration public static ITarget WithArgs<T>(IDictionary<string, ITarget> namedArgs) Parameters Type Name Description IDictionary < String , ITarget > namedArgs The named arguments to be used when building the expression. Returns Type Description ITarget Type Parameters Name Description T The type whose constructor is to be bound Remarks Both versions of this method will create a target which will try to find the best-matching constructor where all of the named arguments match, and with the fewest number of auto-resolved arguments. So, a class with a constructor such as Foo(IService1 s1, IService2 s2) Can happily be bound if you only provide a named argument for 's1'; the target will simply attempt to auto-resolve the argument for the IService2 s2 parameter when constructing the object - and will fail only if it can't be resolved at that point. | Improve this Doc View Source WithArgs<T>(Object) Performs the same operation as WithArgs<T>(IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration public static ITarget WithArgs<T>(object namedArgs) Parameters Type Name Description Object namedArgs An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Type Parameters Name Description T Remarks This overload exists to simplify the process of creating a ConstructorTarget with argument bindings by removing the need to create an argument dictionary in advance. An anonymous type can instead be used to supply the arguments. Examples This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a ConstructorTarget for the type 'MyType': ConstructorTarget.WithArgs<MyType>(new { param1 = new ObjectTarget(\"Hello World\") }); Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.DelegateTarget-6.html": {
    "href": "api/Rezolver.Targets.DelegateTarget-6.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.FactoryMethod DelegateTarget.DeclaredType TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc View Source DelegateTarget(Func<T1, T2, T3, T4, T5, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, TResult> factory The factory. Type declaredType Type of the declared. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.DelegateTarget-7.html": {
    "href": "api/Rezolver.Targets.DelegateTarget-7.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.FactoryMethod DelegateTarget.DeclaredType TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc View Source DelegateTarget(Func<T1, T2, T3, T4, T5, T6, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, TResult> factory The factory. Type declaredType Type of the declared. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.DelegateTarget-16.html": {
    "href": "api/Rezolver.Targets.DelegateTarget-16.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.FactoryMethod DelegateTarget.DeclaredType TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) T15 The type of the 15th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc View Source DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> factory The factory. Type declaredType Type of the declared. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.OptionalParameterTarget.html": {
    "href": "api/Rezolver.Targets.OptionalParameterTarget.html",
    "title": "Class OptionalParameterTarget",
    "keywords": "Class OptionalParameterTarget Used specifically when binding arguments to method parameters when a parameter is optional and its default value is to be used when binding to it. It is highly unlikely you'll ever create one of these directly. Inheritance Object TargetBase OptionalParameterTarget Inherited Members TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class OptionalParameterTarget : TargetBase, ITarget Constructors | Improve this Doc View Source OptionalParameterTarget(ParameterInfo) Constructs a new instance of the OptionalParameterTarget class. Declaration public OptionalParameterTarget(ParameterInfo methodParameter) Parameters Type Name Description ParameterInfo methodParameter Required - parameter to which this target will be bound. Its IsOptional property must be true otherwise an ArgumentException is thrown. Properties | Improve this Doc View Source DeclaredType Always returns the ParameterType of the MethodParameter Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source MethodParameter The parameter to which this target is bound. Declaration public ParameterInfo MethodParameter { get; } Property Value Type Description ParameterInfo | Improve this Doc View Source ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour | Improve this Doc View Source UseFallback Always returns true, since using a default argument of a parameter is always considered to be a last-resort. Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides TargetBase.UseFallback | Improve this Doc View Source Value Gets the value represented by this target. This is either the default value of the MethodParameter , if applicable, or the default for the parameter type. Declaration public object Value { get; } Property Value Type Description Object The value. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.ResolvedTarget.html": {
    "href": "api/Rezolver.Targets.ResolvedTarget.html",
    "title": "Class ResolvedTarget",
    "keywords": "Class ResolvedTarget Represents a target that is rezolved statically at compile time via the ICompileContext , or dynamically (at 'resolve time') from the IContainer that is attached to the current ResolveContext when Resolve(ResolveContext) is called. This is the most common way that we bind constructor parameters, for example - i.e. 'I want an IService instance - go get it'. Inheritance Object TargetBase ResolvedTarget Inherited Members TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class ResolvedTarget : TargetBase, ITarget Remarks Represents an object that will be resolved from the container when its ICompiledTarget is executed, or when the target is used perhaps by another ITarget (e.g. - a ConstructorTarget with a constructor parameter bound to one of these). So, in essence, a ResolvedTarget represents an automatic call to a container's Resolve(ResolveContext) method, for the DeclaredType . In practise - an ITargetCompiler might take advantage of the fact that, during compilation, targets can be discovered directly from the ICompileContext that is passed to CompileTarget(ITarget, ICompileContext) by leveraging its ITargetContainer implementation. Indeed - the expressions compiler uses this to avoid repeated recursion into the Resolve method of the container, instead choosing to compile all the expressions for all targets required for an operation into one dynamically built method - which results in very fast execution times for all resolve operations. Not only this, but the behaviour can be extended still further by realising that a Container on which a resolve operation is invoked might not be the same container for which this ResolvedTarget was first compiled. In this case - it's possible that the other container has alternative registrations for a given service type which the application expects to take precedence over those which were originally resolved when compilation took place. The expressions compiler, again, detects this - allowing compiled code from a root container to detect an 'overriding' container and to dynamically resolve a different dependency in this situation. It's this behaviour which is almost unique to the Rezolver framework out of the box. Constructors | Improve this Doc View Source ResolvedTarget(Type, ITarget) Creates a new ResolvedTarget for the given type which will attempt to resolve a value at compile time and/or resolve-time and, if it can't, will either use the fallbackTarget or will throw an exception. Declaration public ResolvedTarget(Type type, ITarget fallbackTarget = null) Parameters Type Name Description Type type Required. The type to be resolved ITarget fallbackTarget Optional. The target to be used if the value cannot be resolved at either compile time or resolve-time. An ArgumentException is thrown if this target's SupportsType(Type) function returns false when called with the type . Properties | Improve this Doc View Source DeclaredType The type that is to be resolved from the container at resolve-time. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source FallbackTarget Gets the target that this ResolvedTarget will fallback to if a satisfactory target cannot be found at compile time or resolve-time. Declaration public ITarget FallbackTarget { get; } Property Value Type Description ITarget Remarks The UseFallback property is also used to determine whether this will be used. If the target resolved from the ICompileContext has its UseFallback property set to true, and this property is non-null for this target, then this target will be used. Note also that extension containers such as OverridingContainer also have the ability to override the use of this fallback if they successfully resolve the type. | Improve this Doc View Source ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour Methods | Improve this Doc View Source Bind(ICompileContext) Attempts to obtain the target that this ResolvedTarget resolves to for the given ICompileContext . This function should be used by ITargetCompiler implementations when producing the ICompiledTarget for this instance, who wish to perform some form of up-front optimisations. Declaration public virtual ITarget Bind(ICompileContext context) Parameters Type Name Description ICompileContext context The context from which a target is to be resolved. Returns Type Description ITarget The target resolved by this target - could be the FallbackTarget , could be null. Remarks The target that is returned depends both on the context passed and also whether a FallbackTarget has been provided to this target. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Compilation.Expressions.ChangeTypeTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ChangeTypeTargetBuilder.html",
    "title": "Class ChangeTypeTargetBuilder",
    "keywords": "Class ChangeTypeTargetBuilder Implementation of IExpressionBuilder specialised to build expressions for the ChangeTypeTarget This always produces a conversion expression (i.e. cast or box/unbox) Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ChangeTypeTarget > ChangeTypeTargetBuilder Inherited Members ExpressionBuilderBase<ChangeTypeTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ChangeTypeTarget>.IExpressionBuilder<ChangeTypeTarget>.Build(ChangeTypeTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ChangeTypeTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class ChangeTypeTargetBuilder : ExpressionBuilderBase<ChangeTypeTarget>, IExpressionBuilder<ChangeTypeTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ChangeTypeTarget, IExpressionCompileContext, IExpressionCompiler) Builds the conversion expression represented by the target Declaration protected override Expression Build(ChangeTypeTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ChangeTypeTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ChangeTypeTarget>.Build(Rezolver.Targets.ChangeTypeTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionBuilderBase-1.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionBuilderBase-1.html",
    "title": "Class ExpressionBuilderBase<TTarget>",
    "keywords": "Class ExpressionBuilderBase<TTarget> Abstract base class for implementations of IExpressionBuilder<TTarget> . Provide an implementation of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) and then register an instance in an ObjectTarget in the active container. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase<TTarget> ChangeTypeTargetBuilder ConstructorTargetBuilder DecoratorTargetBuilder DefaultTargetBuilder DelegateTargetBuilder ExpressionTargetBuilder GenericConstructorTargetBuilder ListTargetBuilder ObjectTargetBuilder OptionalParameterTargetBuilder RezolvedTargetBuilder ScopedTargetBuilder SingletonTargetBuilder UnscopedTargetBuilder Inherited Members ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public abstract class ExpressionBuilderBase<TTarget> : ExpressionBuilderBase, IExpressionBuilder<TTarget>, IExpressionBuilder where TTarget : ITarget Type Parameters Name Description TTarget The type of target for which this builder can build an expression. Remarks This is a generic extension of the ExpressionBuilderBase class, designed to simplify the process of implementating the IExpressionBuilder<TTarget> (and, by extension, IExpressionBuilder ) interface. This is the class from which most of the built-in expression builders derive, because the ExpressionCompiler , when asked to compile an expression, attempts to resolve an IExpressionBuilder<TTarget> whose TTarget is the same type as the target that needs compiling. Inheriting from ExpressionBuilderBase is more appropriate if your builder is capable of handling multiple types of ITarget - a scenario that's much less common. Note that this class' implementation of IExpressionBuilder<TTarget> is entirely explicit and non-virtual, the same as with its base class, hence the only way to build an expression via an instance of this class without exposing the behaviour to external callers yourself is via the interface. Methods | Improve this Doc View Source Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target for the given ICompileContext OVerride this to implement the compilation for your target type. Declaration protected abstract Expression Build(TTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description TTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression | Improve this Doc View Source Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Overrides the abstract Build(ITarget, IExpressionCompileContext, IExpressionCompiler) (and seals it from further overrides); checks that target is an instance of TTarget (throwing an ArgumentException if not) and then calls this class' Build(TTarget, IExpressionCompileContext, IExpressionCompiler) abstract function. Declaration protected override sealed Expression Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ITarget target The target for which an expression is to be built. Must be an instance of TTarget . IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides ExpressionBuilderBase.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Exceptions Type Condition ArgumentException target must be an instance of { typeof(TTarget) } ArgumentException If the passed target is not an instance of TTarget | Improve this Doc View Source CanBuild(ITarget, IExpressionCompileContext) Determines whether this instance can build an expression from the specified target. This base implementation simply checks that the type of target is compatible with the type TTarget . Declaration public override bool CanBuild(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context The compilation context. Returns Type Description Boolean Overrides ExpressionBuilderBase.CanBuild(ITarget, IExpressionCompileContext) Implements IExpressionBuilder.CanBuild(ITarget, IExpressionCompileContext) Explicit Interface Implementations | Improve this Doc View Source IExpressionBuilder<TTarget>.Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Builds the specified target. Declaration Expression IExpressionBuilder<TTarget>.Build(TTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description TTarget target The target. IExpressionCompileContext context The context. IExpressionCompiler compiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the implementation attempts to locate the context compiler using the GetContextCompiler(IExpressionCompileContext) method, and will throw an InvalidOperationException if it cannot do so. Returns Type Description Expression Implements IExpressionBuilder<TTarget>.Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Exceptions Type Condition ArgumentNullException target is null or context is null InvalidOperationException compiler is null and an IExpressionCompiler couldn't be resolved for the current context (via GetContextCompiler(IExpressionCompileContext) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also IExpressionBuilder <TTarget> ExpressionBuilderBase"
  },
  "api/Rezolver.Compilation.Expressions.IExpressionBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.IExpressionBuilder.html",
    "title": "Interface IExpressionBuilder",
    "keywords": "Interface IExpressionBuilder The interface for an object that produces expressions (which can be compiled to delegates) from ITarget instances. Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public interface IExpressionBuilder Methods | Improve this Doc View Source Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the specified target. Declaration Expression Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler = null) Parameters Type Name Description ITarget target The target for which an expression is to be built IExpressionCompileContext context The compilation context. IExpressionCompiler compiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the builder should attempt to fetch the compiler from the context; or throw an exception if it is required but not provided and cannot be resolved fromm the context. Returns Type Description Expression Remarks When invoked by the ExpressionCompiler class, the compiler parameter will always be provided. | Improve this Doc View Source CanBuild(ITarget, IExpressionCompileContext) Determines whether this instance can build an expression for the specified target. Declaration bool CanBuild(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context The compilation context. Returns Type Description Boolean Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.OptionalParameterTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.OptionalParameterTargetBuilder.html",
    "title": "Class OptionalParameterTargetBuilder",
    "keywords": "Class OptionalParameterTargetBuilder An IExpressionBuilder specialised for building an expression for the OptionalParameterTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < OptionalParameterTarget > OptionalParameterTargetBuilder Inherited Members ExpressionBuilderBase<OptionalParameterTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<OptionalParameterTarget>.IExpressionBuilder<OptionalParameterTarget>.Build(OptionalParameterTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<OptionalParameterTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class OptionalParameterTargetBuilder : ExpressionBuilderBase<OptionalParameterTarget>, IExpressionBuilder<OptionalParameterTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(OptionalParameterTarget, IExpressionCompileContext, IExpressionCompiler) Always returns a ConstantExpression which contains the Value . Declaration protected override Expression Build(OptionalParameterTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description OptionalParameterTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.OptionalParameterTarget>.Build(Rezolver.Targets.OptionalParameterTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.html": {
    "href": "api/Rezolver.Compilation.Expressions.html",
    "title": "Namespace Rezolver.Compilation.Expressions",
    "keywords": "Namespace Rezolver.Compilation.Expressions Classes ChangeTypeTargetBuilder Implementation of IExpressionBuilder specialised to build expressions for the ChangeTypeTarget This always produces a conversion expression (i.e. cast or box/unbox) ConstructorTargetBuilder An IExpressionBuilder specialised for building the target ConstructorTarget DecoratorTargetBuilder Specialised builder for DecoratorTarget targets. DefaultTargetBuilder An IExpressionBuilder specialised for building the expression for the DefaultTarget target. Essentially, it just calls Default(Type) for the DeclaredType . DelegateTargetBuilder Specialised builder for the DelegateTarget class and all its derivatives. ExpressionBuilderBase Abstract starting point for implementing IExpressionBuilder . Note that the interface is implemented explicitly; but exposes protected abstract or virtual methods for inheritors to extend. ExpressionBuilderBase<TTarget> Abstract base class for implementations of IExpressionBuilder<TTarget> . Provide an implementation of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) and then register an instance in an ObjectTarget in the active container. ExpressionCompileContext An implementation of ICompileContext which is specialised for use by an IExpressionCompiler . ExpressionCompiler Implementation of the ITargetCompiler interface which produces ICompiledTarget objects by building and compiling expression trees from the ITarget objects which are registered. ExpressionCompilerBuildExtensions Extensions for IExpressionCompiler . ExpressionCompilerConfigurationProvider Implements the ICompilerConfigurationProvider to configure expression-based compilation for targets in containers. The implementation registers all the targets necessary to use the expression tree-based compilation provided by the Rezolver.Compilation.Expressions library. This configuration provider is automatically configured as the default for all containers when the Rezolver library is referenced. ExpressionTargetBuilder An IExpressionBuilder specialised for building the expression trees for the ExpressionTarget target type. This builder takes care of all expressions, including lambdas (where additional parameters beyond the standard ResolveContext are turned into local variables with injected values), producing an expression which can be compiled by an IExpressionCompiler after a Rezolver.Compilation.Expressions.TargetExpressionRewriter has been used to expand any targets embedded in the expression. GenericConstructorTargetBuilder An IExpressionBuilder specialised for building expressions for GenericConstructorTarget targets. ListTargetBuilder An IExpressionBuilder specialised for building expressions for the ListTarget target. ObjectTargetBuilder An IExpressionBuilder specialised to build expressions for the ObjectTarget target. OptionalParameterTargetBuilder An IExpressionBuilder specialised for building an expression for the OptionalParameterTarget target. RedundantConvertRewriter Removes unnecessary convert expressions from an expression. An unnecessary conversion is one where the target type is equal to, or a base of, the source type. Only boxing/unboxing conversions or upcasts are left intact. RezolvedTargetBuilder An IExpressionBuilder specialised for building the expression for the ResolvedTarget target. ScopedTargetBuilder An IExpressionBuilder specialised for building expressions for ScopedTarget targets. SharedExpressionKey Key for a shared expression used during expression tree generation. As a consumer of this library, you are unlikely ever to need to use it. SingletonTargetBuilder An IExpressionBuilder specialised for the building the expression for a SingletonTarget target. TargetExpression An expression which represents an ITarget . UnscopedTargetBuilder Builder for the UnscopedTarget . Interfaces IExpressionBuilder The interface for an object that produces expressions (which can be compiled to delegates) from ITarget instances. IExpressionBuilder<TTarget> Interface for an object that produces expressions from instances of TTarget . This is a generic extension to the IExpressionBuilder interface. IExpressionCompileContext Extension to the ICompileContext interface which provides additional state and functionality for the IExpressionCompiler and the IExpressionBuilder implementations which are used by the default expression compiler, the ExpressionCompiler class. IExpressionCompiler Interface for an object which is responsible for coordinating the production of expressions for targets during the compilation phase. Objects implementing this are expected to be implementations of ITargetCompiler ; this library provides the one implementation, too: ExpressionCompiler ."
  },
  "api/Rezolver.Container.html": {
    "href": "api/Rezolver.Container.html",
    "title": "Class Container",
    "keywords": "Class Container The standard IOC container class in Rezolver. Inheritance Object ContainerBase CachingContainerBase Container OverridingContainer ScopedContainer Inherited Members CachingContainerBase.GetCompiledRezolveTarget(ResolveContext) ContainerBase.NoChangeCompilerConfiguration ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Targets ContainerBase.Resolve(ResolveContext) ContainerBase.TryResolve(ResolveContext, Object) ContainerBase.CreateScope() ContainerBase.FetchCompiled(ResolveContext) ContainerBase.CanResolve(ResolveContext) ContainerBase.GetFallbackCompiledRezolveTarget(ResolveContext) ContainerBase.IServiceProvider.GetService(Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) ContainerBase.ITargetContainer.Fetch(Type) ContainerBase.ITargetContainer.FetchAll(Type) ContainerBase.ITargetContainer.CombineWith(ITargetContainer, Type) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class Container : CachingContainerBase, IContainer, IServiceProvider, ITargetContainer Remarks All of this class' functionality is inherited through CachingContainerBase and its base classes. Note that it doesn't implement lifetime scoping (although you can create a lifetime scope from it by calling its CreateScope() method). Also note that the class implements ITargetContainer through its ContainerBase base (which merely wraps around the Targets property. The reason for this is simplicity: in many applications, you'll want to simply create a new container, register services into it, and then start using it. Constructors | Improve this Doc View Source Container(ICompilerConfigurationProvider) Constructs a new instance of the Container class using a default empty ITargetContainer Declaration public Container(ICompilerConfigurationProvider compilerConfig) Parameters Type Name Description ICompilerConfigurationProvider compilerConfig An object which will be used to configure this container and its targets to use a specific compilation strategy. If null , then the DefaultProvider provider will be used. | Improve this Doc View Source Container(ITargetContainer) Constructs a new instance of the Container class using the given target container and the default compiler configuration ( DefaultProvider ). Declaration public Container(ITargetContainer targets) Parameters Type Name Description ITargetContainer targets The targets that will be used to resolve objects. If left null, then a new, empty, target container will be constructed. | Improve this Doc View Source Container(ITargetContainer, ICompilerConfigurationProvider) Constructs a new instance of the Container class. Declaration public Container(ITargetContainer targets = null, ICompilerConfigurationProvider compilerConfig = null) Parameters Type Name Description ITargetContainer targets Optional. The targets that will be used to resolve objects. If left null, then a new, empty, target container will be constructed. ICompilerConfigurationProvider compilerConfig Optional. An object which will be used to configure this container and its targets to use a specific compilation strategy. If null , then the DefaultProvider provider will be used. Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ContainerScopeResolveExtensions.html": {
    "href": "api/Rezolver.ContainerScopeResolveExtensions.html",
    "title": "Class ContainerScopeResolveExtensions",
    "keywords": "Class ContainerScopeResolveExtensions Extensions for IContainerScope so that instances of that interface present a similar set of functionality to IContainer . Inheritance Object ContainerScopeResolveExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public static class ContainerScopeResolveExtensions Methods | Improve this Doc View Source Resolve(IContainerScope, Type) Non-generic variant of the Resolve<TResult>(IContainerScope) extension method. Declaration public static object Resolve(this IContainerScope scope, Type requestedType) Parameters Type Name Description IContainerScope scope The scope. Type requestedType Type of object required. Returns Type Description Object Exceptions Type Condition ArgumentNullException | Improve this Doc View Source Resolve<TResult>(IContainerScope) Resolves an object through the scope's Container Declaration public static TResult Resolve<TResult>(this IContainerScope scope) Parameters Type Name Description IContainerScope scope The active scope within which the call is to be made. Returns Type Description TResult Type Parameters Name Description TResult The type of object required. Remarks Resolving an object via a scope does not guarantee that it will be tracked. Ultimately, it's up to the behaviour of the individual underlying targets to determine whether they should interact with the scope. Indeed, all this extension method does is to forward the method call on to the Container of the given scope, ensuring that the scope is set on the ResolveContext that is passed to its Resolve(ResolveContext) method."
  },
  "api/Rezolver.Functions.html": {
    "href": "api/Rezolver.Functions.html",
    "title": "Class Functions",
    "keywords": "Class Functions This type is only used when using expressions as targets (via the ExpressionTarget type) - it's functions server no actual purpose other than to act as hooks to create specific ITarget objects in place of static code. For example, the Resolve<T>() function is used to trigger the creation of a ResolvedTarget in its place - thus allowing expressions to leverage the full power of the Rezolver API all through a simple method call. Inheritance Object Functions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public static class Functions Methods | Improve this Doc View Source Resolve<T>() Translated to a ResolvedTarget with T being the type that will be resolved in this function's place. Declaration public static T Resolve<T>() Returns Type Description T Type Parameters Name Description T The type to be resolved. Exceptions Type Condition NotImplementedException Always. The method is not intended to be used outside of an expression."
  },
  "api/Rezolver.ITargetContainerOwner.html": {
    "href": "api/Rezolver.ITargetContainerOwner.html",
    "title": "Interface ITargetContainerOwner",
    "keywords": "Interface ITargetContainerOwner Interface for an ITargetContainer which also contains other target containers. It is not typically used by your application code since it's primarily an infrastructure interface - if you are extending the API, however, then you might need to work with it. Inherited Members ITargetContainer.Register(ITarget, Type) ITargetContainer.Fetch(Type) ITargetContainer.FetchAll(Type) ITargetContainer.CombineWith(ITargetContainer, Type) Namespace :Rezolver Assembly :Rezolver.dll Syntax public interface ITargetContainerOwner : ITargetContainer Remarks This interface, its implementations and everything else associated with it, is at the heart of functionality such as open generics, automatic enumerables and decorators. Methods | Improve this Doc View Source FetchContainer(Type) Retrieves an existing container registered against the given type , or null if not found. Declaration ITargetContainer FetchContainer(Type type) Parameters Type Name Description Type type Returns Type Description ITargetContainer | Improve this Doc View Source RegisterContainer(Type, ITargetContainer) Registers a container against a given type . If a container already exists against this type, then the existing container's CombineWith(ITargetContainer, Type) method is called with the container as the argument, and the resulting container will replace the existing one. Declaration void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container Extension Methods EnumerableTargetBuilderExtensions.EnableEnumerableResolving(ITargetContainerOwner) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) DecoratorTargetContainerExtensions.RegisterDecorator(ITargetContainerOwner, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.MemberBinding.html": {
    "href": "api/Rezolver.MemberBinding.html",
    "title": "Class MemberBinding",
    "keywords": "Class MemberBinding Represents the binding of an ITarget to a property or field of a given type. Not to be confused with the type of the same name from the System.Linq.Expressions namespace, although they are technically equivalent. Inheritance Object MemberBinding Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class MemberBinding Remarks You typically don't create this type directly - instead, other targets such as ConstructorTarget will create it as needed through the use of an IMemberBindingBehaviour object. Constructors | Improve this Doc View Source MemberBinding(MemberInfo, ITarget) Initializes a new instance of the MemberBinding class. Declaration public MemberBinding(MemberInfo member, ITarget target) Parameters Type Name Description MemberInfo member The member to be bound. ITarget target The target whose value will be written to the member. Fields | Improve this Doc View Source None Empty bindings. Declaration public static readonly MemberBinding[] None Field Value Type Description MemberBinding [] Properties | Improve this Doc View Source Member Gets the member against which this binding is to be applied. Declaration public MemberInfo Member { get; } Property Value Type Description MemberInfo The member. | Improve this Doc View Source MemberType Gets the type of the Member . E.g. if the member represents a String property on the declaring type, then this will return the String type. If the member represents an integer field, this it will return the Int32 type. Declaration public Type MemberType { get; } Property Value Type Description Type The type of the member. | Improve this Doc View Source Target Gets the target whose value when resolved will be written to the Member Declaration public ITarget Target { get; } Property Value Type Description ITarget The target. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.TargetDictionaryContainer.html": {
    "href": "api/Rezolver.TargetDictionaryContainer.html",
    "title": "Class TargetDictionaryContainer",
    "keywords": "Class TargetDictionaryContainer An ITargetContainerOwner implementation that stores and retrieves ITarget and ITargetContainer by type. Inheritance Object TargetDictionaryContainer GenericTargetContainer TargetContainer Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class TargetDictionaryContainer : ITargetContainerOwner, ITargetContainer Remarks This type is not thread-safe Note that for generic type, a special container is registered first against the open generic version of the type, with concrete (closed) generics being registered within that. Methods | Improve this Doc View Source CombineWith(ITargetContainer, Type) Always adds this container into the existing container as a child. Declaration public virtual ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Type type Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) | Improve this Doc View Source CreateContainer(Type, ITarget) Called by Register(ITarget, Type) to create and register the container instance most suited for the passed target. The base implementation always creates a TargetListContainer , capable of storing multiple targets against a single type. Declaration protected virtual ITargetContainer CreateContainer(Type serviceType, ITarget target) Parameters Type Name Description Type serviceType ITarget target The initial target for which the container is being created. Can be null. Note - the function is not expected to add this target to the new container. Returns Type Description ITargetContainer | Improve this Doc View Source Fetch(Type) Implementation of Fetch(Type) . Declaration public virtual ITarget Fetch(Type type) Parameters Type Name Description Type type The type whose default target is to be retrieved. Returns Type Description ITarget A single target representing the last target registered against the type , or, null if no target is found. Implements ITargetContainer.Fetch(Type) Remarks Note - in scenarios where you are chaining multiple containers, then you should consult the return value's UseFallback property if the method returns non-null because, if true, then it's an instruction to use a parent container's result for the same type. | Improve this Doc View Source FetchAll(Type) Implementation of FetchAll(Type) Declaration public virtual IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type The type whose targets are to be retrieved. Returns Type Description IEnumerable < ITarget > A non-null enumerable containing the targets that match the type, or an empty enumerable if the type is not registered. Implements ITargetContainer.FetchAll(Type) | Improve this Doc View Source FetchContainer(Type) Obtains a child container that was previously registered by the passed type . Returns null if no entry is found. Declaration public virtual ITargetContainer FetchContainer(Type type) Parameters Type Name Description Type type Returns Type Description ITargetContainer Implements ITargetContainerOwner.FetchContainer(Type) | Improve this Doc View Source Register(ITarget, Type) Implementation of Register(ITarget, Type) . Declaration public virtual void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target The target to be registered Type serviceType Implements ITargetContainer.Register(ITarget, Type) Remarks This implementation creates an ITargetContainer for the serviceType with a call to the protected method CreateContainer(Type, ITarget) if one doesn't exist (it calls FetchContainer(Type) to check for existence), and then chains to its Register(ITarget, Type) method. | Improve this Doc View Source RegisterContainer(Type, ITargetContainer) Implementation of RegisterContainer(Type, ITargetContainer) Declaration public virtual void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container Implements ITargetContainerOwner.RegisterContainer(Type, ITargetContainer) Remarks This container implementation actually stores containers against the types that targets are registered against, rather than simply storing a dictionary of targets. This method allows you to add your own containers against type (instead of the default, which is TargetListContainer ) so you can plug in some advanced behaviour into this container. For example, decorators are not actually ITarget implementations but specialised ITargetContainer instances into which the 'standard' targets are registered. Extension Methods EnumerableTargetBuilderExtensions.EnableEnumerableResolving(ITargetContainerOwner) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) DecoratorTargetContainerExtensions.RegisterDecorator(ITargetContainerOwner, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.TargetListContainer.html": {
    "href": "api/Rezolver.TargetListContainer.html",
    "title": "Class TargetListContainer",
    "keywords": "Class TargetListContainer An ITargetContainer that stores multiple targets in a list. This is not a type that you would typically use directly in your code, unless you are writing custom logic/behaviour for ITarget registration. Inheritance Object TargetListContainer Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class TargetListContainer : ITargetContainer Remarks This type is not thread-safe, nor does it perform any type checking on the targets that are added to it. Constructors | Improve this Doc View Source TargetListContainer(Type, ITarget[]) Initializes a new instance of the TargetListContainer class. Declaration public TargetListContainer(Type registeredType, params ITarget[] targets) Parameters Type Name Description Type registeredType Required - the type against which this list will be registered. ITarget [] targets Optional array of targets with which to initialise the list. Properties | Improve this Doc View Source Count Gets the number of targets which have been added to the list. Declaration public int Count { get; } Property Value Type Description Int32 The count. | Improve this Doc View Source DefaultTarget Gets the default target for this list - which will always be the last target added to the list, or null if no targets have been added yet. Declaration public ITarget DefaultTarget { get; } Property Value Type Description ITarget | Improve this Doc View Source Item[Int32] Gets the ITarget at the specified index. Declaration public ITarget this[int index] { get; } Parameters Type Name Description Int32 index The index. Property Value Type Description ITarget ITarget. Exceptions Type Condition IndexOutOfRangeException If index is less than zero, or if Count is zero, or if index represents an index greater than last item's index | Improve this Doc View Source RegisteredType Gets the type against which this list container is registered in its ITargetContainerOwner . Declaration public Type RegisteredType { get; } Property Value Type Description Type | Improve this Doc View Source Targets Gets the targets stored in this list container. Declaration public IEnumerable<ITarget> Targets { get; } Property Value Type Description IEnumerable < ITarget > | Improve this Doc View Source TargetsList Provides deriving classes a means to manipulate the underlying list. Declaration protected List<ITarget> TargetsList { get; } Property Value Type Description List < ITarget > Methods | Improve this Doc View Source CombineWith(ITargetContainer, Type) Not supported. Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Ignored Type type Ignored. Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) Exceptions Type Condition NotSupportedException Always | Improve this Doc View Source Fetch(Type) Always returns the DefaultTarget Declaration public virtual ITarget Fetch(Type type) Parameters Type Name Description Type type Ignored. Returns Type Description ITarget Implements ITargetContainer.Fetch(Type) | Improve this Doc View Source FetchAll(Type) Retrieves an enumerable of all targets that have been registered to this list. Declaration public virtual IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type Ignored. Returns Type Description IEnumerable < ITarget > Implements ITargetContainer.FetchAll(Type) | Improve this Doc View Source Register(ITarget, Type) Registers the specified target into the list. Note - the target is not checked to see if it supports this list's RegisteredType . Declaration public virtual void Register(ITarget target, Type registeredType = null) Parameters Type Name Description ITarget target The target. Type registeredType Ignored. Implements ITargetContainer.Register(ITarget, Type) Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.ScopedTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ScopedTargetBuilder.html",
    "title": "Class ScopedTargetBuilder",
    "keywords": "Class ScopedTargetBuilder An IExpressionBuilder specialised for building expressions for ScopedTarget targets. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ScopedTarget > ScopedTargetBuilder Inherited Members ExpressionBuilderBase<ScopedTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ScopedTarget>.IExpressionBuilder<ScopedTarget>.Build(ScopedTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ScopedTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class ScopedTargetBuilder : ExpressionBuilderBase<ScopedTarget>, IExpressionBuilder<ScopedTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ScopedTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(ScopedTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ScopedTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ScopedTarget>.Build(Rezolver.Targets.ScopedTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.ICompilerConfigurationProvider.html": {
    "href": "api/Rezolver.Compilation.ICompilerConfigurationProvider.html",
    "title": "Interface ICompilerConfigurationProvider",
    "keywords": "Interface ICompilerConfigurationProvider Interface for an object which configures the compiler for the given container and/or targets object to use a specific ITargetCompiler and ICompileContextProvider . Used by all the standard container types in the Rezolver framework. You can provide a specific provider to most containers on creation, and you can configure the default system-wide provider via the DefaultProvider static property. Namespace :Rezolver.Compilation Assembly :Rezolver.dll Syntax public interface ICompilerConfigurationProvider Methods | Improve this Doc View Source Configure(IContainer, ITargetContainer) Called to configure the compiler and context provider for the given container and/or targets. When using the standard container types (based on ContainerBase ), the method should register directly-resolvable targets in the targets target container for the types ITargetCompiler and ICompileContextProvider so that the container can resolve the compiler and context provider. Declaration void Configure(IContainer container, ITargetContainer targets) Parameters Type Name Description IContainer container The container. ITargetContainer targets The targets. Remarks The built-in container classes (all those which inherit from ContainerBase ) rely on their ITargetContainer to directly resolve the compiler and context provider that is used to compile ITarget objects into ICompiledTarget instances. Therefore, in order to use a specific compilation strategy, the framework needs some way of knowing how the underlying ITargetContainer should be configured to use that strategy. Since this requires adding registrations to the container, the most flexible way to do that is via a callback, which is what this method technically represents. Note that the registered targets must NOT require compilation - i.e. - the target must either directly implement ITargetCompiler / ICompileContextProvider or also implement ICompiledTarget such that when GetObject(ResolveContext) is called, the actual compiler or context provider are returned. The simplest way to achieve this is to build the compiler/context provider conventionally, and then use the ObjectTarget target to store them directly in the target container against the types for which they should be used. This is how the default expression compiler does it - in addition to registering additional targets to support the different compilation strategies required for the different target types. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ContainerRezolveExtensions.html": {
    "href": "api/Rezolver.ContainerRezolveExtensions.html",
    "title": "Class ContainerRezolveExtensions",
    "keywords": "Class ContainerRezolveExtensions Extension methods for IContainer which provide shortcuts for the Resolve(ResolveContext) operation. Inheritance Object ContainerRezolveExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public static class ContainerRezolveExtensions Methods | Improve this Doc View Source Resolve(IContainer, Type) Resolves an object of the given type Declaration public static object Resolve(this IContainer container, Type type) Parameters Type Name Description IContainer container The container. Type type The type to be resolved. Returns Type Description Object An instance of the type . | Improve this Doc View Source Resolve<TObject>(IContainer) Resolves an object of type TObject Declaration public static TObject Resolve<TObject>(this IContainer container) Parameters Type Name Description IContainer container The container. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject The type to be resolved. | Improve this Doc View Source TryResolve(IContainer, Type, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer container, Type type, out object result) Parameters Type Name Description IContainer container The container. Type type The type to be resolved. Object result Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type) overloads | Improve this Doc View Source TryResolve<TObject>(IContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer container, out TObject result) Parameters Type Name Description IContainer container The container. TObject result Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved."
  },
  "api/Rezolver.EnumerableTargetBuilderExtensions.html": {
    "href": "api/Rezolver.EnumerableTargetBuilderExtensions.html",
    "title": "Class EnumerableTargetBuilderExtensions",
    "keywords": "Class EnumerableTargetBuilderExtensions Houses an extension method which enables native resolving of IEnumerables of services on ITargetContainer containers which, in turn, enables it for any ContainerBase containers which use that target container. Inheritance Object EnumerableTargetBuilderExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public static class EnumerableTargetBuilderExtensions Methods | Improve this Doc View Source EnableEnumerableResolving(ITargetContainerOwner) Enables resolving of enumerables of services on the target container. Declaration public static void EnableEnumerableResolving(this ITargetContainerOwner targetContainer) Parameters Type Name Description ITargetContainerOwner targetContainer The target container. Remarks After calling this, you can immediately request a target for IEnumerable<T> of any type and you will receive a ListTarget (with AsArray set to true) which contains all the targets which have previously been registered for the type T , in the order they were registered. If a service has not been registered, then the returned ListTarget will be empty and its UseFallback property will be true ."
  },
  "api/Rezolver.MultipleTargetContainerExtensions.html": {
    "href": "api/Rezolver.MultipleTargetContainerExtensions.html",
    "title": "Class MultipleTargetContainerExtensions",
    "keywords": "Class MultipleTargetContainerExtensions Extensions for registering multiple targets individually and against the same type Inheritance Object MultipleTargetContainerExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public static class MultipleTargetContainerExtensions Methods | Improve this Doc View Source RegisterAll(ITargetContainer, ITarget[]) Performs the same operations as RegisterAll(ITargetContainer, IEnumerable<ITarget>) except via a variable number of ITarget arguments. Declaration public static void RegisterAll(this ITargetContainer targetContainer, params ITarget[] targets) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registrations are to be performed. ITarget [] targets The targets to be registered. | Improve this Doc View Source RegisterAll(ITargetContainer, IEnumerable<ITarget>) Batch-registers multiple targets against their DeclaredType . This is the same as calling Register(ITarget, Type) for each of the targets , except the type cannot be overriden from the target's DeclaredType. Declaration public static void RegisterAll(this ITargetContainer targetContainer, IEnumerable<ITarget> targets) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registrations are to be performed. IEnumerable < ITarget > targets The targets to be registered | Improve this Doc View Source RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) Called to register multiple targets against the same type. It is the same as calling Register(ITarget, Type) multiple times with the different targets. Declaration public static void RegisterMultiple(this ITargetContainer targetContainer, IEnumerable<ITarget> targets, Type commonServiceType = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registration is to be performed. IEnumerable < ITarget > targets The targets to be registered - all must support a common service type (potentially passed in the commonServiceType argument. Type commonServiceType Optional - if provided, then this will be used as the common service type for registration. If not provided, then the DeclaredType of the first target will be used. Remarks If the container has the capability to handle enumerables, then each target will be returned when an IEnumerable of the common service type is requested. This is an opt-in behaviour in Rezolver - implemented by the Rezolver.EnumerableTargetContainer and can be added to a target container with the extension method EnableEnumerableResolving(ITargetContainerOwner) . Note that default behaviour of TargetContainer is for this to be enabled."
  },
  "api/Rezolver.ResolveContext.html": {
    "href": "api/Rezolver.ResolveContext.html",
    "title": "Class ResolveContext",
    "keywords": "Class ResolveContext Captures the state for a call to Resolve(ResolveContext) (or TryResolve(ResolveContext, out Object) ), including the container on which the operation is invoked, any IScopedContainer that might be active for the call (if different), and the type which is being resolved from the IContainer . Inheritance Object ResolveContext Inherited Members Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace :Rezolver Assembly :Rezolver.dll Syntax public class ResolveContext : IEquatable<ResolveContext> Constructors | Improve this Doc View Source ResolveContext(IContainer, Type) Initializes a new instance of the ResolveContext class. Declaration public ResolveContext(IContainer container, Type requestedType) Parameters Type Name Description IContainer container The container. Type requestedType The type of object to be resolved from the container. | Improve this Doc View Source ResolveContext(IContainer, Type, IContainerScope) Initializes a new instance of the ResolveContext class. Declaration public ResolveContext(IContainer container, Type requestedType, IContainerScope scope) Parameters Type Name Description IContainer container The container. Type requestedType The type of object to be resolved from the container. IContainerScope scope The scope for this context. | Improve this Doc View Source ResolveContext(IContainerScope, Type) Initializes a new instance of the ResolveContext class from the given scope. The Container is inherited from the scope's Container . Declaration public ResolveContext(IContainerScope scope, Type requestedType) Parameters Type Name Description IContainerScope scope The scope. Type requestedType The of object to be resolved from the container. Properties | Improve this Doc View Source Container The container for this context. Declaration public IContainer Container { get; } Property Value Type Description IContainer Remarks This is the container which received the original call to Resolve(ResolveContext) , but is not necessarily the same container that will eventually end up resolving the object. | Improve this Doc View Source RequestedType Gets the type being requested from the container Declaration public Type RequestedType { get; } Property Value Type Description Type The type of the requested. | Improve this Doc View Source Scope Gets the scope that's active for all calls for this context. Declaration public IContainerScope Scope { get; } Property Value Type Description IContainerScope The scope. Methods | Improve this Doc View Source CreateNew(IContainer) Returns a clone of this context, but replaces the Container . Declaration public ResolveContext CreateNew(IContainer container) Parameters Type Name Description IContainer container The container for the new context. Returns Type Description ResolveContext | Improve this Doc View Source CreateNew(IContainer, IContainerScope) Returns a clone of this context, but replaces the Container and the Scope . Declaration public ResolveContext CreateNew(IContainer container, IContainerScope scope) Parameters Type Name Description IContainer container The container for the new context - regardless of what the Container of the scope is. IContainerScope scope The scope for the new context. Returns Type Description ResolveContext | Improve this Doc View Source CreateNew(IContainer, Type) Returns a clone of this context, but replaces the RequestedType and Container . Declaration public ResolveContext CreateNew(IContainer container, Type requestedType) Parameters Type Name Description IContainer container The container for the new context. Type requestedType The type of object to be resolved from the container. Returns Type Description ResolveContext | Improve this Doc View Source CreateNew(IContainerScope) Returns a clone of this context, but replaces the Scope . Declaration public ResolveContext CreateNew(IContainerScope scope) Parameters Type Name Description IContainerScope scope The scope for the new context. Returns Type Description ResolveContext | Improve this Doc View Source CreateNew(Type) Returns a clone of this context, but replaces the type. Declaration public ResolveContext CreateNew(Type requestedType) Parameters Type Name Description Type requestedType The type of object to be resolved from the container. Returns Type Description ResolveContext | Improve this Doc View Source CreateNew(Type, IContainerScope) Returns a clone of this context, but replaces the RequestedType and the Scope . Declaration public ResolveContext CreateNew(Type requestedType, IContainerScope scope) Parameters Type Name Description Type requestedType The type of object to be resolved from the container. IContainerScope scope The scope for the new context. Returns Type Description ResolveContext | Improve this Doc View Source Equals(ResolveContext) Indicates whether the current object is equal to another object of the same type. Declaration public virtual bool Equals(ResolveContext other) Parameters Type Name Description ResolveContext other An object to compare with this object. Returns Type Description Boolean Implements IEquatable<T>.Equals(T) | Improve this Doc View Source Equals(Object) Determines whether the specified Object is equal to this instance. Declaration public override bool Equals(object obj) Parameters Type Name Description Object obj The object to compare with the current object. Returns Type Description Boolean Overrides Object.Equals(Object) | Improve this Doc View Source GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description Int32 Overrides Object.GetHashCode() | Improve this Doc View Source ToString() Returns a String that represents this instance. Declaration public override string ToString() Returns Type Description String Overrides Object.ToString() Operators | Improve this Doc View Source Equality(ResolveContext, ResolveContext) Implements the equality operator. Contexts are checked for reference equality, and then their RequestedType properties are checked for equality also. Declaration public static bool operator ==(ResolveContext left, ResolveContext right) Parameters Type Name Description ResolveContext left The left. ResolveContext right The right. Returns Type Description Boolean | Improve this Doc View Source Inequality(ResolveContext, ResolveContext) Implements the inequality operator. Declaration public static bool operator !=(ResolveContext left, ResolveContext right) Parameters Type Name Description ResolveContext left The left. ResolveContext right The right. Returns Type Description Boolean Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ScopeBehaviour.html": {
    "href": "api/Rezolver.ScopeBehaviour.html",
    "title": "Enum ScopeBehaviour",
    "keywords": "Enum ScopeBehaviour Describes different ways in which objeects interact with scopes. Namespace :Rezolver Assembly :Rezolver.dll Syntax public enum ScopeBehaviour Remarks Note: this enum might be replaced with an abstraction in the future. If so, it will not alter how regatrations are performed, but it will affect any low-level code which uses this enum directly. Fields Name Description Explicit Explicitly scoped objects act like singletons in the current scope, regardless of whether they are disposable or not. Implicit Implicitly scoped objects are only added to the scope for the purposes of disposing when the scope is disposed None The object will not be tracked in any scope, regardless of whether there is one active, or whether the object is disposable. Extension Methods TargetCreationExtensions.AsObjectTarget<ScopeBehaviour>(Type, ScopeBehaviour)"
  },
  "api/Rezolver.Targets.DelegateTarget-11.html": {
    "href": "api/Rezolver.Targets.DelegateTarget-11.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.FactoryMethod DelegateTarget.DeclaredType TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc View Source DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> factory The factory. Type declaredType Type of the declared. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.DelegateTarget-12.html": {
    "href": "api/Rezolver.Targets.DelegateTarget-12.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.FactoryMethod DelegateTarget.DeclaredType TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc View Source DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> factory The factory. Type declaredType Type of the declared. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.DelegateTarget.html": {
    "href": "api/Rezolver.Targets.DelegateTarget.html",
    "title": "Class DelegateTarget",
    "keywords": "Class DelegateTarget An ITarget which resolve objects by executing a delegate with argument injection. Inheritance Object TargetBase DelegateTarget DelegateTarget<TResult> DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> DelegateTarget<T, TResult> DelegateTarget<T1, T2, TResult> DelegateTarget<T1, T2, T3, TResult> DelegateTarget<T1, T2, T3, T4, TResult> DelegateTarget<T1, T2, T3, T4, T5, TResult> DelegateTarget<T1, T2, T3, T4, T5, T6, TResult> DelegateTarget<T1, T2, T3, T4, T5, T6, T7, TResult> DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, TResult> Inherited Members TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DelegateTarget : TargetBase, ITarget Remarks The delegate must be non-void and can have any number of parameters. A compiler must ensure that any parameters for the Factory are automatically resolved from the container, and that a parameter of the type ResolveContext will receive the context passed to the Resolve(ResolveContext) method call for which this target is being compiled and/or executed. Constructors | Improve this Doc View Source DelegateTarget(Delegate, Type) Initializes a new instance of the DelegateTarget class. Declaration public DelegateTarget(Delegate factory, Type declaredType = null) Parameters Type Name Description Delegate factory Required - the factory delegate. Must have a return type and can take 0 or more parameters. Type declaredType Optional - type that will be set into the DeclaredType for the target; if not provided, then it will be derived from the factory 's return type Exceptions Type Condition ArgumentNullException If factory is null ArgumentException If the factory represents a void delegate or if declaredType is passed but the type is not compatible with the return type of factory . Properties | Improve this Doc View Source DeclaredType Gets the declared type of object that is constructed by this target, either set on construction or derived from the return type of the Factory Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source Factory Gets the factory delegate that will be invoked when this target is compiled and executed Declaration public Delegate Factory { get; } Property Value Type Description Delegate The factory. | Improve this Doc View Source FactoryMethod Gets the MethodInfo for the Factory delegate. Declaration public MethodInfo FactoryMethod { get; } Property Value Type Description MethodInfo Remarks Whilst this can be easily obtained from the delegate yourself (by using the GetMethodInfo(Delegate) extension method) however, this class also uses it to determine the DeclaredType of the target or whether the delegate is actually compatible with the one supplied on construction, therefore if you need to introspect the delegate, you might as well use this. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.ExpressionTarget.html": {
    "href": "api/Rezolver.Targets.ExpressionTarget.html",
    "title": "Class ExpressionTarget",
    "keywords": "Class ExpressionTarget A generic target for all expressions not explicitly supported by a particular target. Enables more complex behaviours to be registered and used with the more formal ITarget implementations. Inheritance Object TargetBase ExpressionTarget Inherited Members TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class ExpressionTarget : TargetBase, ITarget Remarks Note to compiler implementers: This class can be used to represent simple expressions such as constants, constructor calls and so on; but can also contain whole lambda expressions with parameters. In the latter case, expression parameters are expected to receive injected arguments and, therefore, some rewriting of the expression is likely to be required. Constructors | Improve this Doc View Source ExpressionTarget(Func<ICompileContext, Expression>, Type) Initializes a new instance of the ExpressionTarget class. Declaration public ExpressionTarget(Func<ICompileContext, Expression> expressionFactory, Type declaredType) Parameters Type Name Description Func < ICompileContext , Expression > expressionFactory Required. The factory delegate that a compiler should call to get the expression to use when compiling this target. Type declaredType Required. Static type of all expressions that will be returned by expressionFactory . | Improve this Doc View Source ExpressionTarget(Expression, Type, ScopeBehaviour) Initializes a new instance of the ExpressionTarget class. Declaration public ExpressionTarget(Expression expression, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description Expression expression Required. The static expression which should be used by compilers. Type declaredType Declared type of the target to be created (used when registering without an explicit type or when this target is used as a value inside another target). ScopeBehaviour scopeBehaviour Override the scoping behaviour of this expression. The default for this will be None because if you want to interact with the Scope in an expression, then you have to do it explicitly in the expression. Remarks declaredType will automatically be determined if not provided by examining the type of the expression . For lambdas, the type will be derived from the Type of the lambda's body. For all other expressions, the type is taken directly from the Type property of the expression itself. Properties | Improve this Doc View Source DeclaredType Gets the type of Expression or the type that all expressions returned by the ExpressionFactory are expected to be equal to. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source Expression Gets the static expression represented by this target - if null , then a factory is being used to produce the expression, which is available from the ExpressionFactory property. Declaration public Expression Expression { get; } Property Value Type Description Expression | Improve this Doc View Source ExpressionFactory Gets a factory which will be executed to obtain an expression given a particular ICompileContext . If null , then a static expression will be used instead and is available from the Expression property. Declaration public Func<ICompileContext, Expression> ExpressionFactory { get; } Property Value Type Description Func < ICompileContext , Expression > | Improve this Doc View Source ScopeBehaviour Gets the scoping behaviour for instances that will ultimately be produced by this target. Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour Methods | Improve this Doc View Source From<TResult>(Expression<Func<TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<TResult>(Expression<Func<TResult>> expression) Parameters Type Name Description Expression < Func <TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<TResult>(Expression<Func<ResolveContext, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<TResult>(Expression<Func<ResolveContext, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) T15 The type of the 15th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) T15 The type of the 15th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T, TResult>(Expression<Func<T, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T, TResult>(Expression<Func<T, TResult>> expression) Parameters Type Name Description Expression < Func <T, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T The type of the 1st lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T, TResult>(Expression<Func<ResolveContext, T, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T, TResult>(Expression<Func<ResolveContext, T, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T The type of the 2nd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T1, T2, TResult>(Expression<Func<T1, T2, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, TResult>(Expression<Func<T1, T2, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T2, T3, TResult>(Expression<Func<ResolveContext, T2, T3, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, TResult>(Expression<Func<ResolveContext, T2, T3, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T1, T2, T3, TResult>(Expression<Func<T1, T2, T3, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, TResult>(Expression<Func<T1, T2, T3, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T2, T3, T4, TResult>(Expression<Func<ResolveContext, T2, T3, T4, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, TResult>(Expression<Func<ResolveContext, T2, T3, T4, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T1, T2, T3, T4, TResult>(Expression<Func<T1, T2, T3, T4, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, TResult>(Expression<Func<T1, T2, T3, T4, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T2, T3, T4, T5, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T1, T2, T3, T4, T5, TResult>(Expression<Func<T1, T2, T3, T4, T5, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, TResult>(Expression<Func<T1, T2, T3, T4, T5, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T2, T3, T4, T5, T6, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T1, T2, T3, T4, T5, T6, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T2, T3, T4, T5, T6, T7, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T1, T2, T3, T4, T5, T6, T7, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T2, T3, T4, T5, T6, T7, T8, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, T8, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>> expression) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. | Improve this Doc View Source From<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>) Creates a target from the passed lambda expression. The numerous overloads exist to simplify the translation of expressions into targets. Declaration public static ExpressionTarget From<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression) Parameters Type Name Description Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression The lambda expression that is to be converted into an ExpressionTarget Returns Type Description ExpressionTarget Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks Whilst creating ExpressionTargets is simple enough; the nature of the C# and VB compilers is that you need a function to declare an expression parameter of the specific delegate type you need in order to be able to pass a whole lambda expression as if it were code. Hence the need for these static factory methods. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Compilation.CompileStackEntry.html": {
    "href": "api/Rezolver.Compilation.CompileStackEntry.html",
    "title": "Class CompileStackEntry",
    "keywords": "Class CompileStackEntry Represents an entry in the compilation stack of a ICompileContext , recording both a target that is being compiled, and the type for which it is being compiled. Inheritance Object CompileStackEntry Inherited Members Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation Assembly :Rezolver.dll Syntax public class CompileStackEntry : IEquatable<CompileStackEntry> Constructors | Improve this Doc View Source CompileStackEntry(ITarget, Type) Initializes a new instance of the CompileStackEntry class. Declaration public CompileStackEntry(ITarget target, Type targetType) Parameters Type Name Description ITarget target The target being compiled. Type targetType Type for which the target is being compiled. Properties | Improve this Doc View Source Target Gets the target being compiled. Declaration public ITarget Target { get; } Property Value Type Description ITarget | Improve this Doc View Source TargetType Gets the type for which the target is being compiled. Declaration public Type TargetType { get; } Property Value Type Description Type Methods | Improve this Doc View Source Equals(CompileStackEntry) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(CompileStackEntry other) Parameters Type Name Description CompileStackEntry other An object to compare with this object. Returns Type Description Boolean Implements IEquatable<T>.Equals(T) Remarks Equality is defined as both the Target and the TargetType being equal between this instance and the other instance. | Improve this Doc View Source Equals(Object) Determines whether the specified Object is equal to this instance. Declaration public override bool Equals(object obj) Parameters Type Name Description Object obj The object to compare with the current object. Returns Type Description Boolean Overrides Object.Equals(Object) | Improve this Doc View Source GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description Int32 Overrides Object.GetHashCode() Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionBuilderBase.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionBuilderBase.html",
    "title": "Class ExpressionBuilderBase",
    "keywords": "Class ExpressionBuilderBase Abstract starting point for implementing IExpressionBuilder . Note that the interface is implemented explicitly; but exposes protected abstract or virtual methods for inheritors to extend. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase <TTarget> Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public abstract class ExpressionBuilderBase : IExpressionBuilder Remarks This class takes care of checking the type requested in the IExpressionCompileContext is compatible with the target that's passed to the Build(ITarget, IExpressionCompileContext, IExpressionCompiler) method Properties | Improve this Doc View Source IContainerScope_Resolve_Method Gets a MethodInfo object for the Resolve(ResolveContext, Func<ResolveContext, Object>, ScopeBehaviour) method for help in generating scope-interfacing code. Declaration protected MethodInfo IContainerScope_Resolve_Method { get; } Property Value Type Description MethodInfo | Improve this Doc View Source ITarget_SelectScope_Method Gets a MethodInfo object for the SelectScope(ResolveContext) method for help in generating scope-interfacing code. Declaration protected MethodInfo ITarget_SelectScope_Method { get; } Property Value Type Description MethodInfo | Improve this Doc View Source ResolveContext_CreateNew_Method_Type Gets a MethodInfo object for the CreateNew(Type) method Declaration protected MethodInfo ResolveContext_CreateNew_Method_Type { get; } Property Value Type Description MethodInfo The type of the resolve context create new method. Methods | Improve this Doc View Source ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) Called by the BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) method. Applies the scoping behaviour to the builtExpression such that when it is executed it correctly interfaces with the active scope (from the ResolveContext ) if one is present for the given scopeBehaviour . Declaration protected virtual Expression ApplyScoping(ScopeBehaviour scopeBehaviour, Expression builtExpression, ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ScopeBehaviour scopeBehaviour The scoping behaviour for which the expression is to be adapted. If this is None , then the base class implementation will not generate any scoping code. Expression builtExpression The expression that was built for the target . ITarget target The target that is currently being compiled and from which the builtExpression was built. IExpressionCompileContext context The current active compilation context. IExpressionCompiler compiler The compiler. Returns Type Description Expression | Improve this Doc View Source Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Abstract method used as part implementation of the Build(ITarget, IExpressionCompileContext, IExpressionCompiler) It's called by BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) . Declaration protected abstract Expression Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context The context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression | Improve this Doc View Source BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) The core expression build function - takes care of handling mismatched types between the target and the requested type in the context - both checking compatibility and producing conversion expressions where necessary. Also performs cyclic dependency checking and rewriting expressions to take advantage of a target's ScopeBehaviour (which can be overriden with ScopeBehaviourOverride ) Declaration protected Expression BuildCore(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ITarget target The target to be compiled. IExpressionCompileContext context The context. IExpressionCompiler compiler The compiler. Returns Type Description Expression Remarks This class' implementation of Build(ITarget, IExpressionCompileContext, IExpressionCompiler) calls this, as does the derived abstract class ExpressionBuilderBase<TTarget> for its implementation of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) . It is this function that is responsible for calling the abstract Build(ITarget, IExpressionCompileContext, IExpressionCompiler) function, which deriving classes implement to actually produce their expression for the target . Exceptions Type Condition ArgumentException targetType doesn't support the context's TargetType InvalidOperationException The target is already being compiled. | Improve this Doc View Source CanBuild(ITarget, IExpressionCompileContext) Abstract method (implementation of CanBuild(ITarget, IExpressionCompileContext) ) which determines whether this instance can build an expression for the specified target. Declaration public abstract bool CanBuild(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context The compilation context. Returns Type Description Boolean Implements IExpressionBuilder.CanBuild(ITarget, IExpressionCompileContext) | Improve this Doc View Source GetContextCompiler(IExpressionCompileContext) Gets the IExpressionCompiler to be used to build the expression for the given target for the given context, if different from one passed to this class' implementation of Build(ITarget, IExpressionCompileContext, IExpressionCompiler) . This function is called by BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) which will throw an exception if it returns null and no compiler was provided to BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) (typically via the explicit implementation of IExpressionBuilder ). Declaration protected virtual IExpressionCompiler GetContextCompiler(IExpressionCompileContext context) Parameters Type Name Description IExpressionCompileContext context The current compile context. Returns Type Description IExpressionCompiler Remarks The base implementation simply attempts to resolve an instance of IExpressionCompiler from the Container which should, with the default configuration, resolve to the root ExpressionCompiler . In order for this to work, it is imperative that the underlying registered target implements the ICompiledTarget interface - so as to avoid needing a (or, more precisely, this) compiler needing to compile it. Explicit Interface Implementations | Improve this Doc View Source IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Explicit implementation of Build(ITarget, IExpressionCompileContext, IExpressionCompiler) - ultimately forwards the call to the BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) function. Declaration Expression IExpressionBuilder.Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ITarget target The target for which an expression is to be built IExpressionCompileContext context The compilation context. IExpressionCompiler compiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the implementation attempts to locate the context compiler using the GetContextCompiler(IExpressionCompileContext) method, and will throw an InvalidOperationException if it cannot do so. Returns Type Description Expression Implements IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Exceptions Type Condition ArgumentNullException target is null or context is null InvalidOperationException compiler is null and an IExpressionCompiler couldn't be resolved for the current context (via GetContextCompiler(IExpressionCompileContext) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also IExpressionBuilder"
  },
  "api/Rezolver.Compilation.Expressions.IExpressionBuilder-1.html": {
    "href": "api/Rezolver.Compilation.Expressions.IExpressionBuilder-1.html",
    "title": "Interface IExpressionBuilder<TTarget>",
    "keywords": "Interface IExpressionBuilder<TTarget> Interface for an object that produces expressions from instances of TTarget . This is a generic extension to the IExpressionBuilder interface. Inherited Members IExpressionBuilder.CanBuild(ITarget, IExpressionCompileContext) IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public interface IExpressionBuilder<in TTarget> : IExpressionBuilder where TTarget : ITarget Type Parameters Name Description TTarget The type of the target. Methods | Improve this Doc View Source Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target. Declaration Expression Build(TTarget target, IExpressionCompileContext context, IExpressionCompiler compiler = null) Parameters Type Name Description TTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the builder should attempt to fetch the compiler from the context; or throw an exception if it is required but not provided and cannot be resolved fromm the context. Returns Type Description Expression Remarks When invoked by the ExpressionCompiler class, the compiler parameter will always be provided. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also IExpressionBuilder"
  },
  "api/Rezolver.Compilation.Expressions.SharedExpressionKey.html": {
    "href": "api/Rezolver.Compilation.Expressions.SharedExpressionKey.html",
    "title": "Class SharedExpressionKey",
    "keywords": "Class SharedExpressionKey Key for a shared expression used during expression tree generation. As a consumer of this library, you are unlikely ever to need to use it. Inheritance Object SharedExpressionKey Inherited Members Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class SharedExpressionKey : IEquatable<SharedExpressionKey> Constructors | Improve this Doc View Source SharedExpressionKey(Type, String, Type) Initializes a new instance of the SharedExpressionKey class. Declaration public SharedExpressionKey(Type targetType, string name, Type requestingType = null) Parameters Type Name Description Type targetType Required. Eventual runtime type of the object produced by the expression that will be cached using this key. String name Required. The name used for storing and retrieving expressions cached with this key. Type requestingType The type (e.g. the runtime type of an ITarget implementation) whose compilation requires the cached expression. Properties | Improve this Doc View Source Name Gets the name used for expressions that are cached using this key. Declaration public string Name { get; } Property Value Type Description String The name. | Improve this Doc View Source RequestingType Gets the type that registered the shared expression Declaration public Type RequestingType { get; } Property Value Type Description Type | Improve this Doc View Source TargetType The intended type of the expression that is cached by this key. Declaration public Type TargetType { get; } Property Value Type Description Type Methods | Improve this Doc View Source Equals(SharedExpressionKey) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(SharedExpressionKey other) Parameters Type Name Description SharedExpressionKey other An object to compare with this object. Returns Type Description Boolean true if the current object is equal to the other parameter; otherwise, false. Implements IEquatable<T>.Equals(T) | Improve this Doc View Source Equals(Object) Determines whether the specified Object is equal to this instance. Declaration public override bool Equals(object obj) Parameters Type Name Description Object obj The object to compare with the current object. Returns Type Description Boolean true if the specified Object is equal to this instance; otherwise, false . Overrides Object.Equals(Object) | Improve this Doc View Source GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description Int32 A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. Overrides Object.GetHashCode() Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "docs/service-registration.html": {
    "href": "docs/service-registration.html",
    "title": "Registering services",
    "keywords": "Registering services Registering services ultimately means adding ITarget objects to an ITargetContainer . The different built-in implementations of ITarget provide us with the ability to resolve objects in different ways - and this section looks at those implementations in addition to how we actually perform registrations. Tip An ITarget is an object stored within an ITargetContainer which contains information about how an object is to be created or retrieved when a container's Resolve operation is called. This subject means delving into the ITargetContainer interface and our default implementation, TargetContainer - which contains the core registration API, as well as some extra functionality which might be useful to some. What is ITargetContainer ? The ITargetContainer interface supplies service registrations when using the default container types Container and ScopedContainer . All the target container does is to provide a means to register and look up ITarget instances which have been registered against specific types. Registering via extension methods The majority of your work with the Rezolver framework will use extension methods to create and add targets to an ITargetContainer which will ultimately drive the IContainer that you will use to create instances. These extension methods are more expressive than the core API (documented below), and greatly simplify your interaction with the Rezolver framework. The majority of the code samples shown on this site use these registration methods, which are documented in the API section of this site: AliasTargetContainerExtensions - for registering aliases of one type to another (useful for reusing singletons for multiple types) DecoratorTargetContainerExtensions - for registering decorators DelegateTargetContainerExtensions - for registering factory delegates ExpressionTargetContainerExtensions - for registering expression trees MultipleTargetContainerExtensions - for batch registering multiple targets ObjectTargetContainerExtensions - for registering object references/values RegisterTypeTargetContainerExtensions - for registering constructor-injected types (plain and open-generic) ScopedTargetContainerExtensions - for registering scoped constructor-injected types SingletonTargetContainerExtensions - for registering singleton constructor-injected types Note Some of these methods extend ITargetContainerOwner - an interface which extends ITargetContainer to supply advanced functionality to the framework - such as decoration. Registering via Register To add registrations to an ITargetContainer directly, i.e. without extension methods, we ultimately use the Register method, which accepts an ITarget object and an optional Type against which that target is to be registered. If the optional type is not provided, then the target's DeclaredType is used as the default registration type: Note In the next example, we're using the ObjectTarget . We have more in-depth documentation about ObjectTarget if you want to know more. var targets = new TargetContainer(); targets.Register(\"hello world\".AsObjectTarget()); var target = targets.Fetch(typeof(string)); Assert.IsType<ObjectTarget>(target); So, here, the target container defaults to using System.String as the registration type for the target because that's its DeclaredType . We can also provide any base or interface of the target's type as a valid type, too: Note This time we're creating a ConstructorTarget via one of its static factory functions. Again, this target is covered in more depth here . var targets = new TargetContainer(); targets.Register(ConstructorTarget.Auto<MyService>(), typeof(IMyService)); var target = targets.Fetch(typeof(IMyService)); Assert.IsType<ConstructorTarget>(target); The class MyService implements the interface IMyService in this example If you attempt to register a target against a type which the target does not support then an exception will occur: var targets = new TargetContainer(); //int is obviously not compatible with IMyService. Assert.Throws<ArgumentException>( () => targets.Register(50.AsObjectTarget(), typeof(IMyService))); How type compatiblity is verified The type(s) against which you can register a target is dependant upon the DeclaredType of the target, but, instead of performing the compatibility checks itself, the target container uses the SupportsType method of the target being registered. Here's just a few example types and the types against which we could register them, given the correct ITarget implementation: ITarget.DeclaredType Can be registered as With Targets int object Any int int? Any int IFormattable Any string IEnumerable<char> Any MyService : IService IService Any MyService<T> MyService<T> GenericConstructorTarget MyService<T> MyService<string> GenericConstructorTarget MyService<T> : IService<OtherService, T> IService<OtherService, int> GenericConstructorTarget Retrieving registrations As illustrated by earlier examples, you can interrogate the registrations in an ITargetContainer through two methods: Fetch - retrieves the last-registered target for the type FetchAll - retrieves all targets that have been registered for the type, in the order they were registered. These same methods are used by the standard container classes when determining how to resolve an instance (or instances) for a given type. Target types The different ways in which Rezolver can create/obtain objects for your application, then, are pretty much all handled through the ITarget interface, and the different implementations that we have for that. Whether you want to use constructor injection , an object you've built yourself , an expression tree or a factory delegate , or something else, there's lots of ways to get Rezolver to build the services you want to use in your application. Use the table of contents to the left (or above if on a small screen) to select the type of registration you want to learn more about. All the targets used by default in Rezolver to create objects can be found in the Rezolver.Targets namespace. Implementing targets You can also implement ITarget yourself if you're feeling adventurous - but you must provide a way for the container to compile your target into an ICompiledTarget that can be used at resolve-time. Documentation on how to do this will be added to this guide in the future. Short-circuited targets Rezolver containers also support short-circuited, 'direct' targets which bypass the compilation process when attempting to fulfil a Resolve operation, specifically: If the target also supports the ICompiledTarget interface, then its GetObject method will be used to get the object. If the target can be cast to the type originally requested through the Resolve method, then target will be returned as the object. The framework exploits both of these techniques to use the container as the source of its own services and configuration."
  },
  "docs/miscellaneous/how-this-website-is-built.html": {
    "href": "docs/miscellaneous/how-this-website-is-built.html",
    "title": "How this website is built",
    "keywords": "How this website is built We've used docfx to build this documentation site - a cool tool built by Microsoft which generates API documentation directly from source code. It also solves the typically knotty problem of mixing conceptual documentation such as the content in this developer guide with auto-generated API documentation. The website project itself is just a standard Asp.Net website - the source for which is available in our repo on github. The rest of content on this page refers to files in that project, so you might want to follow the 'Improve this Doc' link above to get to this file's location in the repo, and navigate up to the project root. We're using the recommended docfx.console nuget package to add docfx preprocessing to this website's build process. However, our usage of the package diverges from the documented process in order to customise the underlying bootstrap theme that the documentation pages use, as well as to add additional features such as browser-specific icons etc. As such, this project looks slightly different from a 'standard' docfx web project, and this document describes what we've done. Warning Feel free to use this site as a model for your own OSS project's documentation site, but please do not use it to publish an alternative version of the Rezolver documentation! If you have a suggestion for content to be added to the site, you can follow the 'Improve this Doc' link above and submit a pull request to the repo on github to have it included in the build. 1 - Template usage As mentioned before, the site is using a custom build of bootstrap as its backbone - replacing the version that the docfx team have included by default. This was not done by building bootstrap into the site's main.css , or otherwise using a theme as per the docfx documentation, but by breaking apart the default template and inserting our custom build of bootstrap into the build process of the default theme's own docfx.vendor js and css files. The reason for this is that we don't want to include all of docfx's bootstrap content only to overwrite it with another version. 1.1 - Default template Upon installing the docfx.console package (or upgrading it), the first thing we do is to extract the default theme into the ~/_docfx_themes/default folder. This can be done easily by opening a console to the install folder of the docfx package (or whichever folder you've downloaded the docfx binaries to if not using nuget) and running the command: docfx template export default (As per the docfx documentation ) Tip It's worth becoming familiar with how the default template is built, and how you can 'peek' into what's in the latest version by taking a look directly at the source at https://github.com/dotnet/docfx/tree/dev/src/docfx.website.themes (correct at the time of writing - Feb 2017). The contents of those folders there are similar to what you get when you export a template, except a docfx template is actually a combination which includes the common template folder which you will see in that source tree. The entire contents of the generated folder are then copied into this web project's local copy of the template. 1.2 - 'Rezolver' template The custom Rezolver template is found in ~/_docfx_themes/rezolver . This theme replaces the standard docfx.vendor.js and docfx.vendor.css files (containing jquery, bootstrap, lunr, highlightjs and more) so that the Rezolver bootstrap theme and the Rezolver highlightjs themes in ~/styles/ (built using LESS) are used instead of those which are baked into docfx. The versions of these files present in the default template are built by gulp (the gulpfile can be found in our project at ~/_docfx_themes/default/gulpfile.js ). We also use gulp to run our LESS compilation, so the docfx gulpfile is imported into ours so that we can replicate the ~/_docfx_themes/rezolver/docfx.vendor.* files, but replacing the core bootstrap with ours. If the gulpfile of the default docfx template changes, we can just mimic those changes in ours after updating and re-exporting the template. The most likely thing that will have changed will be the docfx.css file - which contains all the additional styles which the docfx team add in order to make the site look like a docfx site - and which we do not modify. Tip The docfx gulpfile relies on bower packages and npm packages - therefore the bower.json and package.json files which describe those dependencies (found, again, under the default theme's folder in the docfx repo at https://github.com/dotnet/docfx/tree/dev/src/docfx.website.themes ) need to be imported into this site's own bower and npm package files, so we have all the same build-time components to replicate their build. 2 - docfx content files (~/api/ ~/articles/ etc) We relocated all the docfx project content ( md , yml and image files in the ~/api , ~/articles and ~/images folders) into this single subfolder in the root of the project in order to keep it clean. The default folders might still be there because the docfx package adds them every time we upgrade the package, but the root docfx.json file has been customised not to use them. Also - all our MSBuild publish profiles import the Properties/PublishExclude.props file to ensure all the build-time docfx content which is typically marked as 'content' by the web project template is not included in the publish - including the xref zip files which balloon the release to over 20Mb. This file looks like this: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <!-- import this into the pubxml file to strip out all the guff that we don't want publishewd with the website --> <Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"> <PropertyGroup> <ExcludeFoldersFromDeployment>_docfx_themes;_docfx_proj;api;articles;images;styles/bootstrap</ExcludeFoldersFromDeployment> <ExcludeFilesFromDeployment>docfx*.json;*.md;*.yml;gruntfile.js;gulpfile.js;package.json;bower.json;**/*.less;**/*.zip</ExcludeFilesFromDeployment> </PropertyGroup> </Project>"
  },
  "docs/using-constructors/generics.html": {
    "href": "docs/using-constructors/generics.html",
    "title": "Markdown file",
    "keywords": "Markdown file"
  },
  "docs/using-constructors/index.html": {
    "href": "docs/using-constructors/index.html",
    "title": "Constructor Injection",
    "keywords": "Constructor Injection The most basic, fundamental feature of any IOC container is the ability to create instances of services through a constructor, automatically injecting arguments into that constructor from the services which have been registered in the container. Tip Constructor injection is achieved in Rezolver through the targets ConstructorTarget and GenericConstructorTarget (for open generic types). The examples here show how to create and register these directly and via some of the extension methods in RegisterTypeTargetContainerExtensions , SingletonTargetContainerExtensions and ScopedTargetContainerExtensions . You can see the tests from which these examples are taken, and run them yourself, if you grab the Rezolver source from Github , open the main solution and run the tests in the 'Rezolver.Tests.Examples' project. Some IOC containers restrict you to types with a single constructor. In some cases this is because of the design of the container itself - i.e. in order to achieve good performance - and in others it's to encourage good program design. Rezolver's constructor injection, implemented by the types ConstructorTarget and GenericConstructorTarget , supports binding to types which have multiple constructors. The ConstructorTarget actually has two modes: Find the best matching constructor Explicitly-supplied constructor (where you supply a ConstructorInfo on creation) Example - Injected class So, given these types: public class MyService : IMyService { } and public class RequiresMyService : IRequiresIMyService { public MyService Service { get; } public RequiresMyService(MyService service) { Service = service; } public RequiresMyService(IMyService service) { if (service.GetType() != typeof(MyService)) { throw new ArgumentException($\"{ service.GetType() } not supported\", nameof(service)); } Service = (MyService)service; } IMyService IRequiresIMyService.Service { get { return Service; } } } Note The rather silly explicit implementation and argument checking in the second constructor is purely for illustrative purposes! In order to build RequiresMyService we need an instance of MyService or IMyService , so let's try injecting a MyService , and resolve: var container = new Container(); container.RegisterType<MyService>(); container.RegisterType<RequiresMyService>(); var result = container.Resolve<RequiresMyService>(); Assert.NotNull(result.Service); Example - Injected interface Now, obviously a key facet of dependency injection is that we can depend upon an abstraction of a service instead of a concrete implementation - so most of the time your constructors will request an interface instead of a concrete type. To do this, we simply register MyService against the type IMyService : var container = new Container(); container.RegisterType<MyService, IMyService>(); container.RegisterType<RequiresMyService>(); var result = container.Resolve<RequiresMyService>(); Assert.NotNull(result.Service); 'So what?' you say, 'it's doing exactly what I want it to!' Yes, but there's more going on here than you'd think: the ConstructorTarget is selecting the best-matched constructor based on the service registrations present in the container when it's asked to Resolve the object. Best-match examples Let's take a bit of deep dive into how Rezolver determines a 'best-match' for the constructor to be called by the container. Example - Best-match (proof) First, to prove that it's the IMyService constructor we bound in the previous example, and not the other one - let's try registering a different implementation of IMyService - one which the class will not support because it'll fail that silly argument type-check in the second constructor of RequiresMyService : var container = new Container(); container.RegisterType<MyAlternateService, IMyService>(); container.RegisterType<RequiresMyService>(); // Proves that the ConstructorTarget is selecting the constructor // based on the available services. Assert.Throws<ArgumentException>(\"service\", () => container.Resolve<RequiresMyService>()); Example - Best-match (fewest params) The best-match algorithm is similar to how a compiler matches a method overload when writing code by hand. The rules aren't necessarily exactly the same as, say, the C# spec, but they're close. At the time the first Resolve call is made, the algorithm will first attempt to select the greediest constructor whose parameters are completely satisfied by services available to the container. Thus, if a class has two constructors - one with 1 parameter and one with 6 parameters - if the single parameter version can be successfully injected, but only 5 of the other constructor's parameters can be, then the single-parameter constructor wins. So, given this type: public class RequiresMyServices { #region Sentinel Instances public static readonly MyService2 Default2 = new MyService2(); public static readonly MyService3 Default3 = new MyService3(); public static readonly MyService4 Default4 = new MyService4(); public static readonly MyService5 Default5 = new MyService5(); public static readonly MyService6 Default6 = new MyService6(); #endregion #region Instance Properties public MyService1 Service1 { get; private set; } public MyService2 Service2 { get; private set; } public MyService3 Service3 { get; private set; } public MyService4 Service4 { get; private set; } public MyService5 Service5 { get; private set; } public MyService6 Service6 { get; private set; } #endregion public RequiresMyServices(MyService1 service1) : this(service1, Default2, Default3, Default4, Default5, Default6) { } public RequiresMyServices(MyService1 service1, MyService2 service2, MyService3 service3, MyService4 service4, MyService5 service5, MyService6 service6) { Service1 = service1; Service2 = service2; Service3 = service3; Service4 = service4; Service5 = service5; Service6 = service6; } } If we register Service1 , but not all of the other service types, the single-parameter constructor will be used: var container = new Container(); // Building ConstructorTargets directly here, // and using the batch-registration 'RegisterAll' method, // which registers against the target's DeclaredType container.RegisterAll( ConstructorTarget.Auto<RequiresMyServices>(), ConstructorTarget.Auto<MyService1>(), ConstructorTarget.Auto<MyService2>(), ConstructorTarget.Auto<MyService3>(), ConstructorTarget.Auto<MyService4>(), ConstructorTarget.Auto<MyService5>()); var result = container.Resolve<RequiresMyServices>(); // Because we didn't have MyService6 registered, the // container will bind the first constructor, which defaults // services 2-6: Assert.NotNull(result.Service1); Assert.Same(RequiresMyServices.Default2, result.Service2); Assert.Same(RequiresMyServices.Default3, result.Service3); Assert.Same(RequiresMyServices.Default4, result.Service4); Assert.Same(RequiresMyServices.Default5, result.Service5); Assert.Same(RequiresMyServices.Default6, result.Service6); Example - Best-match (with defaults) When a constructor's parameters have default values, the rules change slightly. The algorithm treats parameters which have defaults as always satisfied, even if a service is not registered of the correct type. So if we extend RequiresMyServices with a new class whose 6-parameter constructor specifies default values for parameters 2-6: public class RequiresMyServicesWithDefaults : RequiresMyServices { public RequiresMyServicesWithDefaults(MyService1 service1) : base(service1) { } public RequiresMyServicesWithDefaults(MyService1 service1, MyService2 service2 = null, MyService3 service3 = null, MyService4 service4 = null, MyService5 service5 = null, MyService6 service6 = null) : base(service1, service2 ?? Default2, service3 ?? Default3, service4 ?? Default4, service5 ?? Default5, service6 ?? Default6) { } } And then we swap RequiresMyServices for RequiresMyServicesWithDefaults , this time, the 6-parameter constructor will be executed, with parameters 1-5 receiving injected arguments, and parameter 6 receiving the default instance from the base: var container = new Container(); container.RegisterAll( // Note - using ChangeTypeTarget to make the container think // our ConstructorTarget is still RequiresMyService // Could also have done: // container.RegisterType<RequiresMyServicesWithDefaults, RequiresMyServices>() new ChangeTypeTarget( ConstructorTarget.Auto<RequiresMyServicesWithDefaults>(), typeof(RequiresMyServices) ), ConstructorTarget.Auto<MyService1>(), ConstructorTarget.Auto<MyService2>(), ConstructorTarget.Auto<MyService3>(), ConstructorTarget.Auto<MyService4>(), ConstructorTarget.Auto<MyService5>()); var result = container.Resolve<RequiresMyServices>(); //this time all but Service6 will have been injected Assert.NotNull(result.Service1); Assert.NotNull(result.Service2); Assert.NotNull(result.Service3); Assert.NotNull(result.Service4); Assert.NotNull(result.Service5); Assert.NotSame(RequiresMyServices.Default2, result.Service2); Assert.NotSame(RequiresMyServices.Default3, result.Service3); Assert.NotSame(RequiresMyServices.Default4, result.Service4); Assert.NotSame(RequiresMyServices.Default5, result.Service5); Assert.Same(RequiresMyServices.Default6, result.Service6); Tip The use of ChangeTypeTarget there might be a little confusing. In truth, we're only sneaking it in here to show some other parts of the framework :) Think of it as being the same as an explicit cast from one type to another - you put a target inside it and tell it what type you want it to be. In the example, we have to use this if we're determined to the use the RegisterAll method(s), because they don't allow us to override the registration type for the targets that we're registering. Example - Best partial match If, however, none of the constructors can be completely satisfied, then we look for the greediest constructor with the most number of successfully resolved arguments. If there's a clear winner, then we proceed with that constructor anyway even though one or more required services are missing. Note You might wonder why we would allow binding even though we can't actually satisfy all the parameters of the constructor, well we'll get to that in a moment. This time, we'll have a type which needs one or two services - either MyService1 or both MyService2 and MyService3 : // Slightly different to before properties are IMyService, but // constructors use concrete types. public class Requires2MyServices { public IMyService First { get; } public IMyService Second { get; } public Requires2MyServices(MyService1 first) { First = first; Second = null; } public Requires2MyServices(MyService2 first, MyService3 second) { First = first; Second = second; } } To force the selection of the second constructor for the test, we'll only register MyService2 in the container and, when we attempt to resolve the instance, we should get an InvalidOperationException explaining that MyService3 couldn't be resolved: var container = new Container(); container.RegisterType<MyService2>(); container.RegisterType<Requires2MyServices>(); var exception = Assert.Throws<InvalidOperationException>( () => container.Resolve<Requires2MyServices>()); //the InvalidOperationException contains the name of the type that //couldn't be resolved Assert.Contains(\"MyService3\", exception.Message); Why we allow partial matches As mentioned in the intro to the last example - it's probably not obvious why we would want to allow binding to a constructor in a container which can't actually fulfil that constructor's requirements! Well, it's clearly not normal , but it's a valid use-case when you consider that Rezolver supports a concept that is typically referred to as 'child containers', except Rezolver calls them 'overriding containers'. A more complete discussion of this functionality will be added to the documentation soon, but in the meantime, let's see two ways in which we could 'fix' the container in the previous test so that it successfully builds an instance of Requires2MyServices . Example - OverridingContainer This is the solution which most closely matches the child container functionality provided by other IOC libraries - take a container which is already 'established' and override it with another container that has its own registrations. The two will work together, sharing registrations when creating instances, so long as the overriding container's Resolve implementation is used: var container = new Container(); container.RegisterType<MyService2>(); container.RegisterType<Requires2MyServices>(); //create an overriding container var containerOverride = new OverridingContainer(container); containerOverride.RegisterType<MyService3>(); //resolve instance via containerOverride var result = containerOverride.Resolve<Requires2MyServices>(); Assert.NotNull(result.First); Assert.NotNull(result.Second); Note If we were to try to resolve from container after creating containerOverride , it would still fail, because it doesn't know anything about the overriding container. Hopefully this should all seem pretty logical. If so, and you're happy simply to accept it, you can skip the next bit. How it works If you're interested in the inner workings when using overriding containers, the process is this: The overridingContainer receives the Resolve call for Requires2MyServices It looks inside its Targets target container for a registration for Requires2MyServices and doesn't find one So the call is passed to the overidden container ... ... which finds its registration and binds to the 2-parameter constructor of Requires2MyServices as before The bound constructor is executed The MyService2 parameter is fulfiled by the container 's own registration But, for the MyService3 parameter, container sees that it was not the container whose Resolve method was originally called (i.e. overridingContainer ), so it forwards the call for MyService3 to overridingContainer . overridingContainer receives the Resolve call for MyService3 It finds its registration, and executes it to get the instance, passing it back to container - thus completing the constructor call for Requires2MyServices Example - ChildTargetContainer This solution is similar to the previous one, except this time we're not overriding the container, but overriding the target container used by a container. Note The choice of name 'ChildTargetContainer' is deliberate, despite the overriding behaviour shown here, because it is more a parent-child relationship than in the previous example. In order to do this, however, we have to change how we create our container. Until now, we've simply been creating a new Container instance and registering targets via its own implementation of ITargetContainer (which, as mentioned elsewhere, wraps its Targets property). This time, we're going to create a TargetContainer directly, register MyService2 and Requires2MyServices in it, then create a ChildTargetContainer on top of that with the other registration of MyService3 . This target container is then passed to the new container on construction. var targets = new TargetContainer(); targets.RegisterType<MyService2>(); targets.RegisterType<Requires2MyServices>(); var childTargets = new ChildTargetContainer(targets); childTargets.RegisterType<MyService3>(); //pass the childTargets ITargetContainer to //the container on construction var container = new Container(childTargets); var result = container.Resolve<Requires2MyServices>(); Assert.NotNull(result.First); Assert.NotNull(result.Second); Why do this? This might seem a little confusing - why would you split target containers like this? Firstly - it's quite an advanced concept, and truly understanding the difference between this and the last example requires a lot of understanding about the internals of Rezolver. Therefore it's more suited to developers who are extending the framework, rather than the average developer who's simply looking to use it to drive their application. The framework itself takes advantage of this functionality throughout in order to override behaviours, or to extend a user-configured container with additional transient targets. The DecoratorTarget wouldn't work without this functionality, for example. Also, if you delve into the compiler pipeline, you will be using this functionality all the time. Providing full examples of how you'd leverage this functionality is outside the scope of this topic, but we'll add them to the guide as soon as we've got the rest of the guide complete. Best-match (named args) When using best-match, you can also supply a dictionary of named argument bindings (as a dictionary of ITarget s) which can be used to provide a hint as to your preferred constructor and, more crucially, override the default behaviour of resolving every argument from container. You don't need to provide all named arguments, the binder will use as many as it can and auto-bind the rest. Example - Supplying a DateTime To demonstrate this, we'll have a new type which requires an IMyService and also accepts a DateTime . DateTime s and other primitive types ( string s etc) are typically not great for use in IOC containers, because you can only have one of them registered (or one collection) unless you start using overriding containers or child target containers, which means you typically can only allow one type to have them as dependencies. public class RequiresIMyServiceAndDateTime { public DateTime StartDate { get; } public IMyService Service { get; } public RequiresIMyServiceAndDateTime(IMyService service) : this(service, DateTime.UtcNow) { } public RequiresIMyServiceAndDateTime(IMyService service, DateTime startDate) { Service = service; StartDate = startDate; } } Note that the single parameter constructor defaults the StartDate to DateTime.UtcNow , but in our test, we'll explicitly provide a DateTime which is DateTime.UtcNow.AddDays(1) to create a date in the future: var container = new Container(); container.RegisterType<MyService, IMyService>(); //Currently a couple of different ways to do this - use the //ConstructorTarget's constructor directly with a dictionary, //or use this static method which creates a dictionary from an object //TODO: Will add object overload to the constructor in the future container.Register(ConstructorTarget.WithArgs<RequiresIMyServiceAndDateTime>( new { //each member of this object must be an ITarget startDate = DateTime.UtcNow.AddDays(1).AsObjectTarget() } )); var result = container.Resolve<RequiresIMyServiceAndDateTime>(); //if the datetime was used, then StartDate will be in the future Assert.True(result.StartDate > DateTime.UtcNow); What happens is that the named arguments contribute to the argument binding process - thus allowing us to 'cheat' and promote a constructor to being a better match than the one that would normally be. Warning Obviously - named argument binding is potentially very brittle - as if the parameter name changes, then the binding will no longer work. In the future, we will also add the ability to supply an ITargetContainer to a ConstructorTarget whose registrations will be used in preference to the main container - thus allowing us simply to register a DateTime in this example, removing the dependency on the parameter name. When you supply ITarget instances up-front to another target in this way, you can use any of the targets in the Rezolver.Targets namespace to supply a value, and they will work as if they were registered in the container. With a ConstructorInfo Instead of relying on the best match algorithm, you can also specify the constructor you want bound up-front, and you can supply parameter bindings too. To illustrate, we'll have a type with a default constructor and one which accepts a service: public class AcceptsOptionalIMyService { public IMyService Service { get; } public AcceptsOptionalIMyService() { } public AcceptsOptionalIMyService(IMyService service) { if (service == null) throw new ArgumentNullException(nameof(service)); Service = service; } } Example - No parameter bindings The first test ignores the registered services and forcibly targets the default constructor: var container = new Container(); container.RegisterType<MyService, IMyService>(); //under best-match, the container would select the greedy constructor, //but we're going to force it to use the default constructor container.Register(new ConstructorTarget( typeof(AcceptsOptionalIMyService).GetConstructor(Type.EmptyTypes) )); var result = container.Resolve<AcceptsOptionalIMyService>(); Assert.Null(result.Service); Example - Pre-bound parameters We can also explicitly bind the parameters of a particular constructor by providing an array of ParameterBinding objects along with a ConstructorInfo . var container = new Container(); //get the constructor: var ctor = typeof(AcceptsOptionalIMyService).GetConstructor(new[] { typeof(IMyService) }); //create parameter bindings var bindings = new[] { new ParameterBinding(ctor.GetParameters()[0], ConstructorTarget.Auto<MyService>() ) }; container.Register(new ConstructorTarget(ctor, parameterBindings: bindings)); var result = container.Resolve<AcceptsOptionalIMyService>(); Assert.NotNull(result.Service); As you can see - using explicitly bound parameters is a little verbose, given the need to find the constructor and then setup those ParameterBinding objects with the correct ParameterInfo s; but it's guaranteed to target the constructor you choose. Next steps"
  },
  "api/Rezolver.Compilation.CompileContext.html": {
    "href": "api/Rezolver.Compilation.CompileContext.html",
    "title": "Class CompileContext",
    "keywords": "Class CompileContext Core implementation of ICompileContext . A root context (i.e. where ParentContext is null ; created via the CompileContext(IContainer, ITargetContainer, Type) constructor) is the starting point for all shared state, such as the Container and the compilation stack. The ITargetContainer implementation is done by decorating a new ChildTargetContainer , so that new registrations can be added without interfering with upstream containers. Note that many of the interface members are implemented explicitly - therefore most of your interaction with this type is through its implementation of ICompileContext and ITargetContainer . Inheritance Object CompileContext ExpressionCompileContext Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation Assembly :Rezolver.dll Syntax public class CompileContext : ICompileContext, ITargetContainer Remarks Note that you can only create an instance of this either through inheritance, via the explicit implementation of NewContext(Type, Nullable<ScopeBehaviour>) , or (preferably) via an ICompileContextProvider resolved from an IContainer or ITargetContainer directly from a registered target. Constructors | Improve this Doc View Source CompileContext(ICompileContext, Type, Nullable<ScopeBehaviour>) Creates a new CompileContext as a child of another. Declaration protected CompileContext(ICompileContext parentContext, Type targetType = null, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description ICompileContext parentContext Used to seed the compilation stack, container, dependency container (which will still be wrapped in a new ChildTargetContainer for isolation) and, optionally, the target type (unless you pass a non-null type for targetType , which would override that). Type targetType The target type that is expected to be compiled, or null if the TargetType is to be inherited from the parentContext . Nullable < ScopeBehaviour > scopeBehaviourOverride Override the scope behaviour to be used for the target that is compiled with this context. | Improve this Doc View Source CompileContext(IContainer, ITargetContainer, Type) Creates a new CompileContext Declaration protected CompileContext(IContainer container, ITargetContainer dependencyTargetContainer, Type targetType = null) Parameters Type Name Description IContainer container Required. The container for which compilation is being performed. Will be set into the Container property. ITargetContainer dependencyTargetContainer Required - An ITargetContainer that contains the ITarget s that will be required to complete compilation. Note - this argument is passed to a new ChildTargetContainer that is created and proxied by this class' implementation of ITargetContainer . As a result, it's possible to register new targets directly into the context via its implementation of ITargetContainer , without modifying the underlying targets in the container you pass. Type targetType Optional. Will be set into the TargetType property. If null, then any ITarget that is compiled should be compiled for its own DeclaredType . Properties | Improve this Doc View Source CompileStack Gets the stack entries for all the targets that are being compiled. Declaration public IEnumerable<CompileStackEntry> CompileStack { get; } Property Value Type Description IEnumerable < CompileStackEntry > The compile stack. Implements ICompileContext.CompileStack | Improve this Doc View Source Container The container that is considered the current compilation 'scope' - i.e. the container for which the compilation is being performed and, usually, the one on which the Resolve(ResolveContext) method was originally called which triggered the compilation call. Declaration public IContainer Container { get; } Property Value Type Description IContainer The container. Implements ICompileContext.Container | Improve this Doc View Source DependencyTargetContainer This is the ITargetContainer through which dependencies are resolved by this context in its implementation of ITargetContainer . In essence, this class acts as a decorator for this inner target container. Declaration protected ITargetContainer DependencyTargetContainer { get; } Property Value Type Description ITargetContainer | Improve this Doc View Source ParentContext Gets the parent context from which this context was created, if applicable. Declaration public ICompileContext ParentContext { get; } Property Value Type Description ICompileContext The parent context. Implements ICompileContext.ParentContext | Improve this Doc View Source ScopeBehaviourOverride Implementation of ScopeBehaviourOverride Declaration public ScopeBehaviour? ScopeBehaviourOverride { get; } Property Value Type Description Nullable < ScopeBehaviour > Implements ICompileContext.ScopeBehaviourOverride | Improve this Doc View Source TargetType Any ICompiledTarget built for a ITarget with this context should target this type. If null, then the DeclaredType of the target being compiled should be used. Declaration public Type TargetType { get; } Property Value Type Description Type Implements ICompileContext.TargetType Remarks Note that when creating a child context with a null targetType argument, this property will be inherited from the ParentContext . Methods | Improve this Doc View Source NewContext(Type, Nullable<ScopeBehaviour>) Used by the explicit implementation of NewContext(Type, Nullable<ScopeBehaviour>) . Override this in your derived class to create the correct implementation of ICompileContext . Declaration protected virtual ICompileContext NewContext(Type targetType = null, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Nullable < ScopeBehaviour > scopeBehaviourOverride Override the scope behaviour to be used for the target that is compiled with the new context. Returns Type Description ICompileContext Explicit Interface Implementations | Improve this Doc View Source ICompileContext.NewContext(Type, Nullable<ScopeBehaviour>) Creates a new child context from this one, except the TargetType and ScopeBehaviour properties can be overriden if required, with the rest of the state inherited from this context. Declaration ICompileContext ICompileContext.NewContext(Type targetType, ScopeBehaviour? scopeBehaviourOverride) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Nullable < ScopeBehaviour > scopeBehaviourOverride Override the scope behaviour to be used for the target that is compiled with the new context. Returns Type Description ICompileContext Implements ICompileContext.NewContext(Type, Nullable<ScopeBehaviour>) | Improve this Doc View Source ICompileContext.PopCompileStack() Pops a target from the stack and returns it. Note that if there are no targets on the stack, an InvalidOperationException will occur. Declaration CompileStackEntry ICompileContext.PopCompileStack() Returns Type Description CompileStackEntry The CompileStackEntry that was popped off the compilation stack. Implements ICompileContext.PopCompileStack() Remarks If ParentContext is not null, then the call is redirected to that context, so that the compilation stack is always shared between all contexts spawned from the same root. | Improve this Doc View Source ICompileContext.PushCompileStack(ITarget, Type) Adds the target to the compilation stack if it doesn't already exist. Declaration bool ICompileContext.PushCompileStack(ITarget toCompile, Type targetType) Parameters Type Name Description ITarget toCompile The target to be pushed Type targetType The type for which the target is being compiled, if different from DeclaredType Returns Type Description Boolean Implements ICompileContext.PushCompileStack(ITarget, Type) Remarks Targets can appear on the compilation stack more than once for different types, since the ICompiledTarget produced for a target for one type can be different than it is for another. Ultimately, if a target does in fact have a cyclic dependency graph, then this method will detect that. | Improve this Doc View Source ITargetContainer.CombineWith(ITargetContainer, Type) Always throws a NotSupportedException Declaration ITargetContainer ITargetContainer.CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Ignored Type type Ignored Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) Exceptions Type Condition NotSupportedException Always thrown | Improve this Doc View Source ITargetContainer.Fetch(Type) Implements Fetch(Type) by wrapping around the child target container created by this context on construction. Declaration ITarget ITargetContainer.Fetch(Type type) Parameters Type Name Description Type type See Fetch(Type) for more. Returns Type Description ITarget Implements ITargetContainer.Fetch(Type) | Improve this Doc View Source ITargetContainer.FetchAll(Type) Implements FetchAll(Type) by wrapping around the child target container created by this context on construction. Declaration IEnumerable<ITarget> ITargetContainer.FetchAll(Type type) Parameters Type Name Description Type type See FetchAll(Type) for more Returns Type Description IEnumerable < ITarget > Implements ITargetContainer.FetchAll(Type) | Improve this Doc View Source ITargetContainer.Register(ITarget, Type) Implements Register(ITarget, Type) by wrapping around the child target container created by this context on construction. Declaration void ITargetContainer.Register(ITarget target, Type serviceType) Parameters Type Name Description ITarget target See Register(ITarget, Type) for more Type serviceType See Register(ITarget, Type) for more Implements ITargetContainer.Register(ITarget, Type) Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also ICompileContext ITargetContainer"
  },
  "api/Rezolver.Compilation.Expressions.DelegateTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.DelegateTargetBuilder.html",
    "title": "Class DelegateTargetBuilder",
    "keywords": "Class DelegateTargetBuilder Specialised builder for the DelegateTarget class and all its derivatives. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < DelegateTarget > DelegateTargetBuilder Inherited Members ExpressionBuilderBase<DelegateTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DelegateTarget>.IExpressionBuilder<DelegateTarget>.Build(DelegateTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DelegateTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class DelegateTargetBuilder : ExpressionBuilderBase<DelegateTarget>, IExpressionBuilder<DelegateTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(DelegateTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target for the given IExpressionCompileContext Declaration protected override Expression Build(DelegateTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description DelegateTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.DelegateTarget>.Build(Rezolver.Targets.DelegateTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Exceptions Type Condition NotImplementedException Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionTargetBuilder.html",
    "title": "Class ExpressionTargetBuilder",
    "keywords": "Class ExpressionTargetBuilder An IExpressionBuilder specialised for building the expression trees for the ExpressionTarget target type. This builder takes care of all expressions, including lambdas (where additional parameters beyond the standard ResolveContext are turned into local variables with injected values), producing an expression which can be compiled by an IExpressionCompiler after a Rezolver.Compilation.Expressions.TargetExpressionRewriter has been used to expand any targets embedded in the expression. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ExpressionTarget > ExpressionTargetBuilder Inherited Members ExpressionBuilderBase<ExpressionTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ExpressionTarget>.IExpressionBuilder<ExpressionTarget>.Build(ExpressionTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ExpressionTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class ExpressionTargetBuilder : ExpressionBuilderBase<ExpressionTarget>, IExpressionBuilder<ExpressionTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ExpressionTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(ExpressionTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ExpressionTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ExpressionTarget>.Build(Rezolver.Targets.ExpressionTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.ObjectTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ObjectTargetBuilder.html",
    "title": "Class ObjectTargetBuilder",
    "keywords": "Class ObjectTargetBuilder An IExpressionBuilder specialised to build expressions for the ObjectTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ObjectTarget > ObjectTargetBuilder Inherited Members ExpressionBuilderBase<ObjectTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ObjectTarget>.IExpressionBuilder<ObjectTarget>.Build(ObjectTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ObjectTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class ObjectTargetBuilder : ExpressionBuilderBase<ObjectTarget>, IExpressionBuilder<ObjectTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ObjectTarget, IExpressionCompileContext, IExpressionCompiler) returns a ConstantExpression wrapped around the Value reference. Declaration protected override Expression Build(ObjectTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ObjectTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ObjectTarget>.Build(Rezolver.Targets.ObjectTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Exceptions Type Condition NotImplementedException Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.UnscopedTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.UnscopedTargetBuilder.html",
    "title": "Class UnscopedTargetBuilder",
    "keywords": "Class UnscopedTargetBuilder Builder for the UnscopedTarget . Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < UnscopedTarget > UnscopedTargetBuilder Inherited Members ExpressionBuilderBase<UnscopedTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<UnscopedTarget>.IExpressionBuilder<UnscopedTarget>.Build(UnscopedTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<UnscopedTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Compilation.Expressions Assembly :Rezolver.dll Syntax public class UnscopedTargetBuilder : ExpressionBuilderBase<UnscopedTarget>, IExpressionBuilder<UnscopedTarget>, IExpressionBuilder Methods | Improve this Doc View Source ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) overrides the base method to block all automatic scoping code from the expression being built. Declaration protected override Expression ApplyScoping(ScopeBehaviour scopeBehaviour, Expression builtExpression, ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ScopeBehaviour scopeBehaviour Expression builtExpression ITarget target IExpressionCompileContext context IExpressionCompiler compiler Returns Type Description Expression Overrides ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) | Improve this Doc View Source Build(UnscopedTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(UnscopedTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description UnscopedTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.UnscopedTarget>.Build(Rezolver.Targets.UnscopedTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ConstructorBinding.html": {
    "href": "api/Rezolver.ConstructorBinding.html",
    "title": "Class ConstructorBinding",
    "keywords": "Class ConstructorBinding Represents a binding specifically to a class constructor, optionally with an additional set of MemberBindings to be used to initialise a new instance's properties or fields directly. Inheritance Object MethodBinding ConstructorBinding Inherited Members MethodBinding.Method MethodBinding.BoundArguments Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class ConstructorBinding : MethodBinding Constructors | Improve this Doc View Source ConstructorBinding(ConstructorInfo, ParameterBinding[], MemberBinding[]) Initializes a new instance of the ConstructorBinding class. Declaration public ConstructorBinding(ConstructorInfo constructor, ParameterBinding[] boundArgs = null, MemberBinding[] memberBindings = null) Parameters Type Name Description ConstructorInfo constructor The constructor to be used . ParameterBinding [] boundArgs Optional. The bound arguments. Can be null or empty. MemberBinding [] memberBindings Optional. The bindings for the members of the new instance created by the constructor. Fields | Improve this Doc View Source NoBoundMembers An empty array of MemberBinding objects used to represent a constructor binding with no bound members. The MemberBindings property will be set to this if the constructor is called with a null memberBindings argument. Declaration public static MemberBinding[] NoBoundMembers Field Value Type Description MemberBinding [] Properties | Improve this Doc View Source Constructor Gets the constructor to be invoked. Note that this simply returns the base Method property cast to ConstructorInfo . Declaration public ConstructorInfo Constructor { get; } Property Value Type Description ConstructorInfo The constructor. | Improve this Doc View Source MemberBindings Gets the member bindings to be applied to the new instance created by the Constructor Declaration public MemberBinding[] MemberBindings { get; } Property Value Type Description MemberBinding [] The member bindings. Remarks Member bindings represent the inline initialisation of writable properties or fields immediately after constructing a new instance of a type. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also MethodBinding"
  },
  "api/Rezolver.ContainerScopeExtensions.html": {
    "href": "api/Rezolver.ContainerScopeExtensions.html",
    "title": "Class ContainerScopeExtensions",
    "keywords": "Class ContainerScopeExtensions Standard extensions for the IContainerScope Inheritance Object ContainerScopeExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public static class ContainerScopeExtensions Methods | Improve this Doc View Source GetRootScope(IContainerScope) Gets the root-most scope for the scope on which this method is called. Note that the result is calculated by walking up the tree of Parent scopes until one is reached that does not have a parent. Declaration public static IContainerScope GetRootScope(this IContainerScope scope) Parameters Type Name Description IContainerScope scope The scope. Returns Type Description IContainerScope Exceptions Type Condition ArgumentNullException If scope is null"
  },
  "api/Rezolver.ExpressionTargetContainerExtensions.html": {
    "href": "api/Rezolver.ExpressionTargetContainerExtensions.html",
    "title": "Class ExpressionTargetContainerExtensions",
    "keywords": "Class ExpressionTargetContainerExtensions Extensions for to simplify registering expressions in an ITargetContainer . Inheritance Object ExpressionTargetContainerExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public static class ExpressionTargetContainerExtensions Methods | Improve this Doc View Source RegisterExpression(ITargetContainer, Expression, Type) Registers the expression. Declaration public static void RegisterExpression(this ITargetContainer targetContainer, Expression expression, Type type) Parameters Type Name Description ITargetContainer targetContainer The target container. Expression expression The expression. Type type The type. | Improve this Doc View Source RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<TResult>(this ITargetContainer targetContainer, Expression<Func<TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) T15 The type of the 15th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) T10 The type of the 10th lambda parameter (will be resolved automatically) T11 The type of the 11th lambda parameter (will be resolved automatically) T12 The type of the 12th lambda parameter (will be resolved automatically) T13 The type of the 13th lambda parameter (will be resolved automatically) T14 The type of the 14th lambda parameter (will be resolved automatically) T15 The type of the 15th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T, TResult>(this ITargetContainer targetContainer, Expression<Func<T, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T The type of the 1st lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T The type of the 2nd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(this ITargetContainer targetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func <T1, T2, T3, T4, T5, T6, T7, T8, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T1 The type of the 1st lambda parameter (will be resolved automatically) T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided. | Improve this Doc View Source RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) Creates a target from the lambda expression and registers it in the targetContainer , optionally against the given type . Declaration public static void RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(this ITargetContainer targetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression, Type type = null) Parameters Type Name Description ITargetContainer targetContainer The container which will receive the registration Expression < Func < ResolveContext , T2, T3, T4, T5, T6, T7, T8, T9, TResult>> expression The lambda expression that is to be converted into a target and registered Type type The type for which the registration will be made, if different from the expression's type Type Parameters Name Description T2 The type of the 2nd lambda parameter (will be resolved automatically) T3 The type of the 3rd lambda parameter (will be resolved automatically) T4 The type of the 4th lambda parameter (will be resolved automatically) T5 The type of the 5th lambda parameter (will be resolved automatically) T6 The type of the 6th lambda parameter (will be resolved automatically) T7 The type of the 7th lambda parameter (will be resolved automatically) T8 The type of the 8th lambda parameter (will be resolved automatically) T9 The type of the 9th lambda parameter (will be resolved automatically) TResult The type of object produced by the lambda expression. Remarks This function ultimately forwards the call through to the non generic extension method RegisterExpression(ITargetContainer, Expression, Type) , which simply wraps the expression into an ExpressionTarget and then registers it against either the passed type , or the created target's DeclaredType if not provided."
  },
  "api/Rezolver.Compilation.ITargetCompiler.html": {
    "href": "api/Rezolver.Compilation.ITargetCompiler.html",
    "title": "Interface ITargetCompiler",
    "keywords": "Interface ITargetCompiler An object that produces ICompiledTarget s from ITarget s given a particular ICompileContext . Namespace :Rezolver.Compilation Assembly :Rezolver.dll Syntax public interface ITargetCompiler Methods | Improve this Doc View Source CompileTarget(ITarget, ICompileContext) Create the ICompiledTarget for the given target using the context to inform the type of object that is to be built, and for compile-time dependency resolution. Declaration ICompiledTarget CompileTarget(ITarget target, ICompileContext context) Parameters Type Name Description ITarget target Required. The target to be compiled. ICompileContext context Required. The current compilation context. Returns Type Description ICompiledTarget A compiled target which can then be used to get produce objects represented by the target . Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ContainerResolveExtensions.html": {
    "href": "api/Rezolver.ContainerResolveExtensions.html",
    "title": "Class ContainerResolveExtensions",
    "keywords": "Class ContainerResolveExtensions Extension methods for IContainer which provide shortcuts for the Resolve(ResolveContext) operation. Inheritance Object ContainerResolveExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public static class ContainerResolveExtensions Methods | Improve this Doc View Source CanResolve(IContainer, Type) Determines whether this instance can resolve the specified type - wrapper for CanResolve(ResolveContext) Declaration public static bool CanResolve(this IContainer container, Type type) Parameters Type Name Description IContainer container The container. Type type The type. Returns Type Description Boolean | Improve this Doc View Source CanResolve<TObject>(IContainer) Determines whether this instance can resolve the specified container - wrapper for CanResolve(ResolveContext) Declaration public static bool CanResolve<TObject>(this IContainer container) Parameters Type Name Description IContainer container The container. Returns Type Description Boolean Type Parameters Name Description TObject The type to be checked.. | Improve this Doc View Source Resolve(IContainer, Type) Resolves an object of the given type Declaration public static object Resolve(this IContainer container, Type type) Parameters Type Name Description IContainer container The container. Type type The type to be resolved. Returns Type Description Object An instance of the type . | Improve this Doc View Source Resolve<TObject>(IContainer) Resolves an object of type TObject Declaration public static TObject Resolve<TObject>(this IContainer container) Parameters Type Name Description IContainer container The container. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject The type to be resolved. | Improve this Doc View Source TryResolve(IContainer, Type, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer container, Type type, out object result) Parameters Type Name Description IContainer container The container. Type type The type to be resolved. Object result Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type) overloads | Improve this Doc View Source TryResolve<TObject>(IContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer container, out TObject result) Parameters Type Name Description IContainer container The container. TObject result Receives the object that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved."
  },
  "api/Rezolver.DefaultMemberBindingBehaviour.html": {
    "href": "api/Rezolver.DefaultMemberBindingBehaviour.html",
    "title": "Class DefaultMemberBindingBehaviour",
    "keywords": "Class DefaultMemberBindingBehaviour The default implementation of IMemberBindingBehaviour when you are creating a ConstructorTarget or GenericConstructorTarget and you want publicly writable properties and public fields to be assigned values obtained from the container. If you do not require properties or fields to be bound from the container, then use a null IMemberBindingBehaviour . Inheritance Object DefaultMemberBindingBehaviour Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class DefaultMemberBindingBehaviour : IMemberBindingBehaviour Remarks This is a stateless singleton accessible through the Instance static property. The class also serves as a good starting point for any custom binding behaviours you might need - as there are numerous virtual methods which allow you to change which fields and/or properties are selected for binding, as well as how those bindings are created. The default behaviour is bind each member to a new ResolvedTarget whose DeclaredType is set to the member's type. Constructors | Improve this Doc View Source DefaultMemberBindingBehaviour() Constructs a new instance of the DefaultMemberBindingBehaviour class. Declaration protected DefaultMemberBindingBehaviour() Properties | Improve this Doc View Source Instance Gets the one and only instance of DefaultMemberBindingBehaviour Declaration public static DefaultMemberBindingBehaviour Instance { get; } Property Value Type Description DefaultMemberBindingBehaviour Methods | Improve this Doc View Source BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) Called by GetMemberBindings(ICompileContext, Type) - iterates through the fields , calling CreateBinding(ICompileContext, Type, FieldInfo) for each, and those which are non-null. Declaration protected virtual IEnumerable<MemberBinding> BindFields(ICompileContext context, Type type, IEnumerable<FieldInfo> fields) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. IEnumerable < FieldInfo > fields The fields for which bindings are to be created. This is fed by the function GetBindableFields(ICompileContext, Type) Returns Type Description IEnumerable < MemberBinding > | Improve this Doc View Source BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) Called by GetMemberBindings(ICompileContext, Type) - iterates through the properties , calling CreateBinding(ICompileContext, Type, PropertyInfo) for each, and those which are non-null. Declaration protected virtual IEnumerable<MemberBinding> BindProperties(ICompileContext context, Type type, IEnumerable<PropertyInfo> properties) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. IEnumerable < PropertyInfo > properties The properties for which bindings are to be created. This is fed by the function GetBindableProperties(ICompileContext, Type) Returns Type Description IEnumerable < MemberBinding > An enumerable of MemberBinding objects representing the bindings to be used for each bindable property in properties . | Improve this Doc View Source CreateBinding(ICompileContext, Type, FieldInfo) Creates a binding for the given field. Called by GetMemberBindings(ICompileContext, Type) Declaration protected virtual MemberBinding CreateBinding(ICompileContext context, Type type, FieldInfo field) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. FieldInfo field The field for which a binding is to be created. Returns Type Description MemberBinding Remarks Override this method to customise the binding that is create for the given field, or to prevent the binding from being created at all(return null if you want to abort binding the field). The base implementation simply creates a new MemberBinding whose Target is set to a new ResolvedTarget for the type FieldType - thus causing the field to be assigned a value resolved from the container when the instance is created. | Improve this Doc View Source CreateBinding(ICompileContext, Type, PropertyInfo) Creates a binding for the given property. Called by GetMemberBindings(ICompileContext, Type) Declaration protected virtual MemberBinding CreateBinding(ICompileContext context, Type type, PropertyInfo prop) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. PropertyInfo prop The property for which a binding is to be created. Returns Type Description MemberBinding Remarks Override this method to customise the binding that is create for the given property, or to prevent the binding from being created at all(return null if you want to abort binding the property). The base implementation simply creates a new MemberBinding whose Target is set to a new ResolvedTarget for the type PropertyType - thus causing the property to be assigned a value resolved from the container when the instance is created. | Improve this Doc View Source GetBindableFields(ICompileContext, Type) Gets the bindable fields on the type . Used by GetMemberBindings(ICompileContext, Type) and passed to the BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) method. Declaration protected virtual IEnumerable<FieldInfo> GetBindableFields(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. Returns Type Description IEnumerable < FieldInfo > Remarks Override this method to filter the fields which can be bound. The base implementation returns all public instance fields declared on the type . | Improve this Doc View Source GetBindableProperties(ICompileContext, Type) Gets the bindable properties on the type . Used by GetMemberBindings(ICompileContext, Type) and passed to the BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) method. Declaration protected virtual IEnumerable<PropertyInfo> GetBindableProperties(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. Returns Type Description IEnumerable < PropertyInfo > Remarks Override this method to filter the properties which can be bound. The base implementation returns all instance properties which have publicly accessible 'set' accessors. | Improve this Doc View Source GetMemberBindings(ICompileContext, Type) Implementation of GetMemberBindings(ICompileContext, Type) . Declaration public virtual MemberBinding[] GetMemberBindings(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. Returns Type Description MemberBinding [] Implements IMemberBindingBehaviour.GetMemberBindings(ICompileContext, Type) Remarks The base implementation calls GetBindableProperties(ICompileContext, Type) , passing the resultant enumerable to the BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) function; it also does the same thing with GetBindableFields(ICompileContext, Type) and BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) - concatenating the two enumerables together and returning the result as an array of MemberBinding objects. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also IMemberBindingBehaviour"
  },
  "api/Rezolver.Targets.DelegateTarget-4.html": {
    "href": "api/Rezolver.Targets.DelegateTarget-4.html",
    "title": "Class DelegateTarget<T1, T2, T3, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.FactoryMethod DelegateTarget.DeclaredType TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DelegateTarget<T1, T2, T3, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc View Source DelegateTarget(Func<T1, T2, T3, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, TResult> factory The factory. Type declaredType Type of the declared. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.DelegateTarget-5.html": {
    "href": "api/Rezolver.Targets.DelegateTarget-5.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.FactoryMethod DelegateTarget.DeclaredType TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DelegateTarget<T1, T2, T3, T4, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc View Source DelegateTarget(Func<T1, T2, T3, T4, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, TResult> factory The factory. Type declaredType Type of the declared. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.ScopedTarget.html": {
    "href": "api/Rezolver.Targets.ScopedTarget.html",
    "title": "Class ScopedTarget",
    "keywords": "Class ScopedTarget A target that produces or fetches a single instance of an object within a lifetime scope. Inheritance Object TargetBase ScopedTarget Inherited Members TargetBase.UseFallback TargetBase.SelectScope(ResolveContext) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class ScopedTarget : TargetBase, ITarget Remarks Scopes in Rezolver operate much the same as they do in any IOC framework, but use of them is always entirely optional. When a scope is active for a given Resolve(ResolveContext) operation, most objects which are returned from those operations will implicitly be scoped to whichever scope is active when the objects are resolved. Implicitly scoped objects are only disposed of when their containing scope is disposed, and you can have an unlimited number of instances of implicitly scoped objects per scope. This target is used to scope the object produced by a target explicitly to a scope, and to ensure that only one instance of that object is produced per scope. Such objects are also not inherited between parent scopes and child scopes. Constructors | Improve this Doc View Source ScopedTarget(ITarget) Initializes a new instance of the ScopedTarget class. Declaration public ScopedTarget(ITarget innerTarget) Parameters Type Name Description ITarget innerTarget Required. The inner target. Properties | Improve this Doc View Source DeclaredType Gets the declared type of object that is constructed by this target. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType Remarks Always forwards the call on to InnerTarget | Improve this Doc View Source InnerTarget Gets the inner target whose result (when compiled) will be scoped to the active scope. Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget The inner target. | Improve this Doc View Source ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour Methods | Improve this Doc View Source SupportsType(Type) Called to check whether a target can create an expression that builds an instance of the given type . Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type Required Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) Remarks Always forwards the call on the InnerTarget Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "docs/index.html": {
    "href": "docs/index.html",
    "title": "Rezolver Dev Guide",
    "keywords": "Rezolver Dev Guide Welcome to the Rezolver developer guide! This site is always under development, and right now we're doing everything we can to get all high-level documentation in place so that even novice users of DI containers can get up and running with Rezolver. Something missing? Please open an issue over on Github with your question. Getting started As with many open source .Net projects, there are two primary ways to get Rezolver integrated into your project. The easiest is via the Nuget packages By using the Nuget packages, you ensure that you're using the latest (hopefully stable!) releases. Pre-release packages will also be made available for in-development features. Fork or download the Rezolver source from Github Use this if you can't integrate nuget into your build pipeline, or if you'd like to customise or contribute to the project. If you're looking to customise, though, then there should be enough extensibility points in the framework to allow you to do so without having to change core types. If that's not the case, post an issue on the Github project so we can get it added in and make it better for everyone! Next Steps Asp.Net Core developers should read how to integrate Rezolver into the Asp.Net Core hosting pipeline . Learn how to create and use a container ."
  },
  "docs/object-lifetimes.html": {
    "href": "docs/object-lifetimes.html",
    "title": "Object lifetimes",
    "keywords": "Object lifetimes Tip Read Creating and using a container if you haven't already done so. As with any IOC container, Rezolver understands the concept of object lifetimes, which are implemented as different ITarget implementations that can be registered in an ITargetContainer . Before we take a look at how you actually use these lifetimes when working with Rezolver, we'll first take a look at exactly what these lifetimes are. Tip If you're already a seasoned IOC god - then you can skip this section and head straight to the Object lifetimes (in Rezolver) section for some examples from the Rezolver.Tests.Examples project. What is a lifetime? No, this is not a philosophical question ;) In a crude sense, an object lifetime describes when a new object is created and whether a previously created object is subsequently returned from a container's Resolve method. Note In practise, it's not that simple - because an IOC container's understanding of a lifetime does not strictly map to whether a new instance is actually created at all. It's more accurate to say that the lifetime determines when the action that's been associated with a given service type is actually executed . Rezolver understands three main lifetimes, which should be familiar to anyone who's used an IOC container before: Transient In general , a transient object is simply one which is created when needed; and thrown away when it's fulfilled its purpose. This typically translates to calling the new operator with the constructor of a particular type, when you want an object, and then allowing that object to go out of scope, as in this snippet: // Factory method always creates a new instance static MyObject CreateObject() { return new MyObject(); } static MyObject _transient = CreateObject(); void Test() { var transient1 = CreateObject(); var transient2 = CreateObject(); //note - using XUnit nomenclature here Assert.NotSame(transient1, transient2); Assert.NotSame(_transient, transient1); Assert.NotSame(_transient, transient2); } This idea of transience is encompassed by the following targets in the Rezolver.Targets namespace: ConstructorTarget DecoratorTarget DelegateTarget (see below) ExpressionTarget (see below) GenericConstructorTarget ListTarget Remember that a target in Rezolver is an instruction to perform an action when the associated service type is resolved by the container. In the case of the above list, for all but two we can definitely say that a new object will be created if that target is registered against a type that's requested. So, the ConstructorTarget will always result in a type's constructor being called; the ListTarget will always result in a new Array or List<T> being created, and so on. In the case of the DelegateTarget and ExpressionTarget targets, however, all we can say about those is that the action they represent will be executed every time the container resolves them. That's the same as if we were to change the definition of CreateObject in our earlier code example as follows: private static IMyObjectService _service = new MyObjectService(); static MyObject CreateObject() { return _service.GetObject(); } The point here being that we can no longer guarantee the transience of the object that is produced by the CreateObject method because we no longer know how the service is producing that object. All we can say is that we definitely execute the service's GetObject method every time we call CreateObject . We will go into more depth about using delegates and expressions (and indeed custom targets) as we delve deeper into the Rezolver framework - but for now it's important to know that some targets produce inherently transient results, whereas some might do, but they equally might not . Singleton Every developer should know what a singleton is. Okay - any reasonably experienced developer should know what a singleton is! In short, a singleton is exactly as the name suggests: a type for which there is guaranteed to be only one instance. Here's a simple implementation (note: please don't take this as the best, or only , way to implement one - it's just an example!): public class MySingleton { public MySingleton Instance { get; } = new MySingleton(); private MySingleton() { } } An application wishing to use the MySingleton object must do so through the Instance property, which is the only instance of that type for the entire AppDomain . Equally, if the singleton object implements an interface or base, then it can be passed to code which requires an instance of that interface or base without knowing that the underlying object itself is always the same reference. Note Different IOC containers have differing understandings of what a singleton really is. In some cases it's one instance per-AppDomain (as with the above code snippet) and in other cases it's one instance per-container. In yet more cases, it's configurable or, indeed, extensible. Rezolver currently supports one instance per-AppDomain, but in future it will also support one per-container and possibly more besides. Scoped Scoping has two flavours, and also often relates specifically to objects which implement the IDisposable interface from the .Net framework (although it doesn't have to). In order for the idea of a scoped object to make any sense, however, you need a scope within which the object will exist. A scope can be thought of as being a 'bag' for objects which the application wants to create and keep alive for a specific period of time and, when it no longer needs those objects, it throws the bag away - or, disposes of it. Scopes can also contain other, 'child' scopes. When a parent scope is disposed it also triggers the disposal of any child scopes it contains, and all their children, and so on. The reason why this pattern is usually applied to disposable objects is because you don't typically need to worry about telling the runtime that you're done with a non-disposable transient object - you simply allow it to go out of scope and, eventually, the garbage collector will reclaim the memory that object occupied. A disposable object, on the other hand, is disposable typically because it contains resources which the framework cannot free automatically when the object falls out of scope - e.g. database connections, or unmanaged memory - and so any container which takes charge of creating objects for us should also provide a way for us to dispose of them in those cases where that is needed. That said, there are scenarios why you might wish to explicitly restrict an otherwise transient object to one-per-scope, so that's why scoped objects do not have to be disposable. One feature which is consistent, however, is that the scope itself is disposable. Implicit scoping Implicit scoping applies only to IDisposable objects and affects when the object is disposed, not when it's created. A simple demonstration of this, if you were writing something like it by hand, would be as follows ( please note the implementation of IDisposable shown here is not recommended! ): public class Scope : IDisposable { private List<IDisposable> _scopeObjects = new List<IDisposable>(); public void Dispose() { //dispose all our tracked disposables foreach(var obj in _scopeObjects) { obj.Dispose(); } } public T CreateObject<T>() { //this bit is merely to take the place of a generic //factory/service/IOC container which knows how to build things. T result; if(typeof(T) == typeof(MyDisposable)) result = (T)(object)new MyDisposable(); else throw new InvalidOperationException($\"Don't know how to create { typeof(T) }\"); //if the object is disposable - track it if(result is IDisposable) _scopeObjects.Add((IDisposable)result); return result; } } public class MyDisposable : IDisposable { public bool Disposed { get; private set; } public void Dispose() { Disposed = true; } } public class XUnitTest { [Fact] public void ShouldDispose() { MyDisposable obj; using(var scope = new Scope()) { obj = scope.CreateObject<MyDisposable>(); } Assert.True(obj.Disposed); } } In the test, we create a new scope in a using block, create an object from it, and then check whether that object is disposed just after the using block is left. At this point, the scope should be disposed and, because the object we requested from the scope was IDisposable it, too, should be disposed. The scope only bothers with disposables - anything else that it might produce (ignoring the fact that our little factory function here only knows how to create an instance of MyDisposable !) would pass straight through. This is ultimately how implicitly scoped objects are handled in Rezolver. Explicit scoping Explicit scoping also does relate to IDisposable objects, inasmuch as disposable objects are expected to be disposed when the scope is disposed - but it's more targeted at controlling when a new object is created regardless of whether the object can be disposed. Explicit scoping can be thought of as a 'scoped singleton'. When the developer indicates he or she wants a scoped object, what they're actually saying is that they want one unique instance of that object per-scope. Note Child scopes also get their own instance of explicitly scoped objects - child scopes do not share instances with their parents. So imagine if we were to change the implementation of the Scope class we defined in the previous section to this: public class Scope : IDisposable { private Dictionary<Type, object> _scopeObjects = new Dictionary<Type, object>(); public void Dispose() { //dispose all our tracked disposables foreach(var obj in _scopeObjects.Values.OfType<IDisposable>()) { obj.Dispose(); } } public T CreateObject<T>() { // start with a look up to see if we have already created an instance of T // and, if so, return it. object cached; if(_scopeObjects.TryGetValue(typeof(T), out cached) return (T)cached; //this bit is merely to take the place of a generic //factory/service/IOC container which knows how to build things. T result; if(typeof(T) == typeof(MyDisposable)) result = (T)(object)new MyDisposable(); else throw new InvalidOperationException($\"Don't know how to create { typeof(T) }\"); _scopeObjects[typeof(T)] = result; return result; } } With a scope implemented like this (and, again, we have to imagine that CreateObject<T> is implemented properly), we will only ever get one instance of a given type from that scope. Explicitly scoped objects, then, treat their scopes as if they behave like this. Singletons in scopes To make things slightly more confusing - the singleton objects discussed earlier also have a special behaviour when materialised in a scope. The singleton is supposed to guarantee a single instance to the whole application, but at the same time, they are typically implicitly scoped , so what happens when you materalise that singleton via a scope, and the singleton is also disposable? Following the definitions of lifetimes we've talked about so far: when the first scope in which we resolve that singleton is disposed, the singleton will also be - rendering it useless. To get around this problem, singletons will actively seek out the root scope of the tree of scopes that it is being materialised within, and ensure that it is tracked for disposal only in that root scope - even if the current scope is a great great granchild - ensuring that it will only be disposed when the rootmost scope is disposed. Tip If your application requires a singleton which you also want to be automatically disposed, then you should ensure that your root container is the ScopedContainer - which contains its own scope that will be the ultimate root for any child scopes it creates. The next step is take a look at how you can work with lifetimes when registering targets in Rezolver ."
  },
  "docs/objects.html": {
    "href": "docs/objects.html",
    "title": "Registering objects",
    "keywords": "Registering objects Documentation coming soon!"
  },
  "api/Rezolver.Targets.SingletonTarget.html": {
    "href": "api/Rezolver.Targets.SingletonTarget.html",
    "title": "Class SingletonTarget",
    "keywords": "Class SingletonTarget A target which applies the singleton pattern to any ITarget . The inner target is available from the InnerTarget property. Inheritance Object TargetBase SingletonTarget Inherited Members TargetBase.UseFallback Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class SingletonTarget : TargetBase, ITarget Constructors | Improve this Doc View Source SingletonTarget(ITarget) Constructs a new instance of the SingletonTarget class. Declaration public SingletonTarget(ITarget innerTarget) Parameters Type Name Description ITarget innerTarget The target whose result (when compiled) is to be used as the singleton instance. Properties | Improve this Doc View Source DeclaredType Override of DeclaredType - always returns the DeclaredType of the InnerTarget Declaration public override Type DeclaredType { get; } Property Value Type Description Type The type of the declared. Overrides TargetBase.DeclaredType | Improve this Doc View Source InnerTarget Gets the inner target for this singleton. Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget | Improve this Doc View Source ScopeBehaviour Always returns Explicit . Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour Overrides TargetBase.ScopeBehaviour Methods | Improve this Doc View Source GetOrAddInitialiser(Type, Func<Type, ICompiledTarget>) Used to support compiled versions of this singleton Declaration public ICompiledTarget GetOrAddInitialiser(Type declaredType, Func<Type, ICompiledTarget> initialiserFactory) Parameters Type Name Description Type declaredType Type of object. Func < Type , ICompiledTarget > initialiserFactory The initialiser factory. Returns Type Description ICompiledTarget Remarks This concept is something that probably needs to move out of this type, into a more generic TargetState object or something like that. | Improve this Doc View Source SelectScope(ResolveContext) Always selects the root scope from the context ( GetRootScope(IContainerScope) , if the context has a non-null scope. Declaration public override IContainerScope SelectScope(ResolveContext context) Parameters Type Name Description ResolveContext context The context. Returns Type Description IContainerScope Overrides TargetBase.SelectScope(ResolveContext) | Improve this Doc View Source SupportsType(Type) Called to check whether a target can create an expression that builds an instance of the given type . The base implementation always passes the call on to the InnerTarget Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type Required Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "toc.html": {
    "href": "toc.html",
    "title": "Table of Content",
    "keywords": ""
  },
  "api/toc.html": {
    "href": "api/toc.html",
    "title": "Table of Content",
    "keywords": ""
  },
  "docs/toc.html": {
    "href": "docs/toc.html",
    "title": "Table of Content",
    "keywords": ""
  },
  "index.html": {
    "href": "index.html",
    "title": "Rezolver",
    "keywords": "Rezolver Welcome to the home of Rezolver - here you'll find guides, walkthroughs, deep-dives and reference for all of the APIs and functionality in the Rezolver library. What is Rezolver? Rezolver is an open source IOC container that, out of the box, supports all the standard features supported by most other popular IOC containers out there. It's also highly extensible - with practically the entire stack open to extension immediately after referencing the core library. It's been built specifically with the .Net Core framework in mind, supporting the NetStandard1.1 profile for (almost!) maximum portability Features Constructor injection Multiple constructors supported 'Intelligent' constructor discovery based on registered services Named argument binding Parameters with default arguments are supported Member injection (extensible) Open generics (with specific closed generics taking precedence) Decorators (non-generic and generic) Enumerables (empty enumerables returned by default) Child containers (overriding registrations in one container with those of another) Child registration containers (lower-level overriding of registrations for similar but sibling containers) Hierarchical lifetime scoping Delegates and Expressions as factories, with argument injection Explicit resolving supported inside factory/expression bodies Singletons Pre-built objects Scoped objects (i.e. 'singleton per scope') No 'prepare' phase - you can register targets in a container after you start using it Note - services which have already been used cannot yet be replaced Extensible compiler framework Expression tree compiler used by default Integration with Microsoft.Extensions.DependencyInjection and Microsoft.AspNetCore.Hosting via nuget packages Extensible configuration framework (still in development) Json configuration (still in development) Quick Links Developer Guide <!--- [Nuget Packages](docs/nuget-packages/index.md) --> API Reference"
  },
  "docs/nuget-packages/index.html": {
    "href": "docs/nuget-packages/index.html",
    "title": "Rezolver Nuget Packages",
    "keywords": "Rezolver Nuget Packages Rezolver is primarily distributed as a suite of Nuget packages whose functionality stacks one on top of another. Depending on the level of functionality you require, there should be a Nuget package which contains only the code you need, with the main package ( Rezolver ) being the root dependency for all. All the core nuget packages support the .NetStandard 1.1 profile (don't know what this is? Learn more ), .Net 4.5.1 and .Net 4.6. Note Where a package has a dependency on a third party package (such as Newtonsoft's Json.Net or .Net Core's Microsoft.Extensions.DependencyInjection packages), then we try to maintain full support for the same frameworks and profiles that those packages support. List of packages Rezolver Rezolver.Configuration (needs verifying) Rezolver.Microsoft.Extensions.DependencyInjection Rezolver.Microsoft.AspNetCore.Hosting Versioning Our versioning approach is the same as recommended by Nuget.org - semantic versioning - where: A major version bump ( x.y.z.w -> (++x).y.z.w ) indicates a breaking change A minor version bump ( x.y.z.w => x.(++y).z.w ) indicates new functionality that shouldn't be a breaking change A build version bump ( x.y.x.w => x.y.(++z).w ) indicates small new functionality or bugfixes A revision bump ( x.y.z.w => x.y.z.(++w) ) indicates a cock-up on our part that had to be corrected :) Obviously, we try to keep the latter to a minimum!"
  },
  "docs/nuget-packages/rezolver.configuration.html": {
    "href": "docs/nuget-packages/rezolver.configuration.html",
    "title": "Nuget Package: Rezolver.Configuration",
    "keywords": "Nuget Package: Rezolver.Configuration This package provides the Rezolver configuration object model, whose purpose is to describe how a Target Container should be constructed and configured based on a configuration file/script loaded at runtime. It doesn't define any specific code for parsing configuration files - but it does provide a standard implementation of the @Rezolver.Configuration.IConfigurationAdapter, whose job it is to create a ITargetContainer from a @Rezolver.Configuration.IConfiguration instance. You can implement your own configuration file formats with this simply by writing code to read your desired format and getting your parser to create an instance of @Rezolver.Configuration.IConfiguration"
  },
  "docs/nuget-packages/rezolver.microsoft.extensions.dependencyinjection.html": {
    "href": "docs/nuget-packages/rezolver.microsoft.extensions.dependencyinjection.html",
    "title": "Rezolver.Microsoft.Extensions.DependencyInjection Package",
    "keywords": "Rezolver.Microsoft.Extensions.DependencyInjection Package See package page on nuget . Tip It's recommended that you use the Asp.Net Core Hosting integration package on top of this one to enable integration of Rezolver into your Asp.Net core website at an earlier stage of its lifetime. This package provides Rezolver's implementation of the Microsoft DI Container which drives the new Asp.Net Core stack. After adding the package, configuring your Asp.Net website to use Rezolver as the DI container is simple: Replace the default ConfigureServices function in your application's Startup.cs file with this one: // This method gets called by the runtime. Use this method to add services to the container. public IServiceProvider ConfigureServices(IServiceCollection services) { // Add framework services. services.AddMvc(); //create the Rezolver container from the services, without making any additional //registrations var container = services.CreateRezolverContainer(); //use IContainer/ITargetContainer methods and extensions here to add extra registrations, e.g. //decorators or your own application's registrations. //IContainers implement the IServiceProvider interface natively - so can simply be returned. return container; } This returns a new service provider to the Asp.Net Core stack - thus replacing the default service provider that's already built. As the comment in the snippet suggests, you will likely want to perform additional registration operations on the IContainer object that's returned by the CreateRezolverContainer function called here, since the Rezolver container supports more functionality (e.g. expressions, decorators, custom targets, and more) than the MS DI container does through its ServiceRegistrations class."
  },
  "docs/nuget-packages/rezolver.html": {
    "href": "docs/nuget-packages/rezolver.html",
    "title": "Rezolver Nuget Package",
    "keywords": "Rezolver Nuget Package See package page on nuget . The core nuget package for using Rezolver in your class library or application, includes: All the core abstractions and classes required to create TargetContainer and Container objects. The core ITarget implementations which allow you to create/retrieve objects using all the standard techniques documented here (constructor injection, enumerables, delegates and expressions etc) from the get-go. The expression compiler which builds bespoke factories for each service you resolve in your container Simply add the package, add an using / import for the Rezolver namespace and you're all set."
  },
  "docs/nuget-packages/rezolver.microsoft.aspnetcore.hosting.html": {
    "href": "docs/nuget-packages/rezolver.microsoft.aspnetcore.hosting.html",
    "title": "Rezolver.Microsoft.AspNetCore.Hosting Package",
    "keywords": "Rezolver.Microsoft.AspNetCore.Hosting Package See package page on nuget . This builds on the Rezolver.Microsoft.Extensions.DependencyInjection package to enable the integration of Rezolver into your Asp.Net Core site somewhwat earlier in its startup phase. After adding the package, open your site's program.cs and add a call to the UseRezolver() extension method that's now available, as shown: public class Program { public static void Main(string[] args) { var host = new WebHostBuilder() .UseKestrel() //add the Rezolver container to the host builder .UseRezolver() .UseContentRoot(Directory.GetCurrentDirectory()) .UseIISIntegration() .UseStartup<Startup>() .Build(); host.Run(); } } Then we need to tell the Asp.Net Core stack that you want an ITargetContainer to be created in order to construct the IContainer that will be used as the DI container. We do this in your application's startup.cs - simply by declaring a single method: public void ConfigureContainer(ITargetContainer container) { //by declaring this method - even if empty - you trigger the //creation of the ITargetContainer which will ultimately //be used to create the IContainer that will be used //as the application's container. //Here you can perform additional registrations/configuration on the //ITargetContainer here. } And that's it - your application is configured."
  },
  "docs/using-constructors/member-binding.html": {
    "href": "docs/using-constructors/member-binding.html",
    "title": "Markdown file",
    "keywords": "Markdown file"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "Rezolver API reference",
    "keywords": "Rezolver API reference Looking for documentation on individual classes or methods in the Rezolver project? You've come to the right place! Crucial types to look at are: TargetContainer (implements ITargetContainer ): Stores ITarget instances, and is the main class you'll use for your 'registration' phase. Container (implements IContainer ): The standard, non-scoped, container you'll use in your composition root - you can create child scopes from this by calling its implementation of CreateScope() , which returns instances of IContainerScope . This class uses an ITargetContainer for its registrations, which you can supply construction if required. ScopedContainer - A container which also acts as a 'root' scope."
  },
  "docs/create-and-use-a-container.html": {
    "href": "docs/create-and-use-a-container.html",
    "title": "Creating and using a container",
    "keywords": "Creating and using a container Using Rezolver is the same as with all other IOC containers: Create and configure the root container Register the services which your application needs Resolve services from the container All of this setup is ultimately conducted through just a few primary types, which we'll take a brief look at now. Core types For all the built-in container types, Rezolver splits registration and resolving responsibilities between two primary interfaces: ITargetContainer This interface describes a registry of ITarget objects, keyed by type, describing the type of object that is to be created (and how) when a given type is requested. It is through this interface that you setup your container with registrations, which are then later used when resolving objects. You might also see ITargetContainerOwner - which is a special type required by some of the more complex registration mechanisms (decorators, for example). Tip The primary implementation of this interface that you will use in your application is TargetContainer . IContainer This is the interface through which we resolve objects. The interface does not expose any registration mechanisms at all (even if the 'standard' implementations of those classes all do) - only the ability to request objects from the container. This interface does not mandate that a container has an ITargetContainer , it's simply the case that all the provided implementations which we will discuss in the rest of this documentation do use that interface as the source of their service registrations. Tip The primary implementation of this interface is ContainerBase , an abstract class which also implements the ITargetContainer interface by wrapping around the Targets property that it exposes. As a consumer of Rezolver, however, you will be using the Container and ScopedContainer classes most of the time - which derive most of their functionality from this abstract class. Creating a container There are numerous ways to create an IContainer instance. The easiest, from the point of view registering services and then resolving them, is to create an instance of the Container type. Or, if you want your root container to act as a global lifetime scope for explicitly scoped objects (see ScopedTarget ) then you can also use ScopedContainer : void Foo() { //create a standard non-scoping container var container = new Container(); //or create a scoped container: var container = new ScopedContainer(); All code samples assume you have added a using statement ( imports in VB) for the Rezolver namespace. Once you have a local reference to either of these classes, you can start registering services in the container, and resolving objects from it. Registering services As mentioned above, with our default implementations of IContainer , registration of services ultimately means adding targets to a container's Targets target container, associating them with service types which we will later resolve. The core registration method for this is the Register method, which accepts an ITarget and an optional type against which the registration is to be made. There's too much to cover in a few sub headings here for this - the service registration topic has more detail, and links to the different types of registration you can perform. Resolving services Resolving objects from your container is done through the Resolve method which, you'll notice, accepts a ResolveContext as its single parameter, and returns an Object . Again, if you're familiar with IOC containers then you're probably wondering where your strongly-typed Resolve<TService>() method is! Well, fear not. As with the many extension methods available on ITargetContainer , the IContainer interface (through which all resolving of objects is done) has extension methods to provide a more traditional IOC API, and these are found on the ContainerResolveExtensions static class. The one you'll use most frequently, of course, is the Resolve<TObject>(IContainer) method, which provides the aforementioned Resolve<TService>() API. So, assuming we have the container that we've been using up till now, we would resolve an instance of MyService simply by doing one of the following: MyService service = container.Resolve<MyService>(); //or MyServiceBase service = container.Resolve<MyServiceBase>(); //or IMyService service = container.Resolve<IMyService>(); Note The ResolveContext class is used to capture the context of a call to the Resolve method, tracking the container on which the call is originally made, whether there is an IContainerScope active for the call, and other things besides. You will rarely use it directly in application code unless you are extending Rezolver. These Resolve extension methods create the ResolveContext for a given operation on your behalf, so you never have to worry about it. Assuming the container can locate the service registration for the type you request, it will fetch/produce an instance of the associated object type according to the behaviour described by the ITarget which we previously registered. If no registration is found, then an InvalidOperationException is raised by the container. Tip IContainer also implements the System.IServiceProvider interface from the .Net framework, which requires that missing services yield a null result instead of throwing an exception. CanResolve/TryResolve Sometimes you might want to attempt to resolve an object from the container, but not have an exception raised if it cannot be found. In this case you can use the TryResolve method, which returns the object via an out parameter and returns a bool indicating whether the operation succeeds. Naturally, as with the Resolve operation, this method has a generic overload ( TryResolve<TObject>(IContainer, out TObject) ) to avoid the need for a temporary Object reference: MyService result; bool success = container.TryResolve(out result); //success == true or false depending on registrations. Similarly we can also introspect a container to find out if it can resolve an instance of a given type by using the CanResolve method. This method also has friendly overloads via extension methods (e.g. CanResolve<TObject>(IContainer) )): bool canResolve = container.CanResolve<MyService>(); Next Steps Now read up on how to register services in the container . <!--Alternatively, you might be interested in Rezolver's understanding of [object lifetimes](object-lifetimes.md).-->"
  },
  "docs/decorators.html": {
    "href": "docs/decorators.html",
    "title": "Decorators",
    "keywords": "Decorators Documentation coming soon!"
  },
  "docs/delegates.html": {
    "href": "docs/delegates.html",
    "title": "Factory delegates",
    "keywords": "Factory delegates Documentation coming soon!"
  },
  "docs/details1.html": {
    "href": "docs/details1.html",
    "title": "Details 1",
    "keywords": "Details 1 This is the first details page."
  },
  "docs/details2.html": {
    "href": "docs/details2.html",
    "title": "Details 2",
    "keywords": "Details 2 This is the second details page. And the same image underneath:"
  },
  "docs/details3.html": {
    "href": "docs/details3.html",
    "title": "Details 3",
    "keywords": "Details 3 This is the third details page - getting a bit boring now huh?"
  },
  "docs/expressions.html": {
    "href": "docs/expressions.html",
    "title": "Factory expressions",
    "keywords": "Factory expressions Documentation coming soon!"
  },
  "api/Rezolver.ObjectTargetContainerExtensions.html": {
    "href": "api/Rezolver.ObjectTargetContainerExtensions.html",
    "title": "Class ObjectTargetContainerExtensions",
    "keywords": "Class ObjectTargetContainerExtensions Extensions for ITargetContainer relating to registering concrete instances via the ObjectTarget target. Inheritance Object ObjectTargetContainerExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public static class ObjectTargetContainerExtensions Methods | Improve this Doc View Source RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) Registers an instance to be used when resolving a particular service type via the ObjectTarget target. Declaration public static void RegisterObject<T>(this ITargetContainer targetContainer, T obj, Type serviceType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description ITargetContainer targetContainer The target container which will receive the registration. T obj The instance that will be resolved when the service type is requested. Type serviceType The service type against which this object is to be registered, if different from T . ScopeBehaviour scopeBehaviour Sets the ScopeBehaviour for the ObjectTarget that's created Type Parameters Name Description T Type of the object - will be used as the service type for registration if serviceType is not provied."
  },
  "api/Rezolver.OverridingContainer.html": {
    "href": "api/Rezolver.OverridingContainer.html",
    "title": "Class OverridingContainer",
    "keywords": "Class OverridingContainer An IContainer which can override the resolve operations of another. This is useful when you have a core application-wide container, with some objects being customised based on some ambient information, e.g. configuration, MVC Area/Controller, Brand (in a multi-tenant application for example) or more. Inheritance Object ContainerBase CachingContainerBase Container OverridingContainer Inherited Members CachingContainerBase.GetCompiledRezolveTarget(ResolveContext) ContainerBase.NoChangeCompilerConfiguration ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Targets ContainerBase.Resolve(ResolveContext) ContainerBase.TryResolve(ResolveContext, Object) ContainerBase.CreateScope() ContainerBase.FetchCompiled(ResolveContext) ContainerBase.IServiceProvider.GetService(Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) ContainerBase.ITargetContainer.Fetch(Type) ContainerBase.ITargetContainer.FetchAll(Type) ContainerBase.ITargetContainer.CombineWith(ITargetContainer, Type) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class OverridingContainer : Container, IContainer, IServiceProvider, ITargetContainer Remarks When overriding another IContainer , you are overriding the ICompiledTarget objects that will be returned when FetchCompiled(ResolveContext) is called on that container and, therefore, the compiled target which is executed when the Resolve(ResolveContext) method is called. This has the side effect of overriding automatically resolved arguments (bound to a ResolvedTarget ) compiled in the overridden container by virtue of the fact that the overriding container is a different reference, because the ResolvedTarget is typically compiled with a check, at resolve-time, that the Container is the same container as the one that was active when it was originally compiled. In essence, when resolving an instance as a dependency the ResolvedTarget does something like this: resolveContext.Container == compileContext.Container ? (execute compile-time target) : resolveContext.Container.Resolve(type) Constructors | Improve this Doc View Source OverridingContainer(IContainer, ITargetContainer, ICompilerConfigurationProvider) Creates a new instance of the OverridingContainer Declaration public OverridingContainer(IContainer inner, ITargetContainer targets = null, ICompilerConfigurationProvider compilerConfig = null) Parameters Type Name Description IContainer inner Required. The inner container that this one combines with. Any dependencies not served by the new combined container's own targets will be sought from this container. Equally, any targets in the base which are resolved when the overriding container is the root container for a resolve operation, will resolve their dependencies from this container. ITargetContainer targets Optional. A specific target container to be used for this container's own registrations. ICompilerConfigurationProvider compilerConfig Optional. An object which will be used to configure this container and its targets to use a specific compilation strategy. If null (recommended), then the inner container's configuration will be inherited. Methods | Improve this Doc View Source CanResolve(ResolveContext) Called to determine if this container is able to resolve the type specified in the passed context . Declaration public override bool CanResolve(ResolveContext context) Parameters Type Name Description ResolveContext context Required. The ResolveContext . Returns Type Description Boolean Overrides ContainerBase.CanResolve(ResolveContext) | Improve this Doc View Source GetFallbackCompiledRezolveTarget(ResolveContext) Overrides the base implementation to pass the lookup for an ITarget to the inner container - this is how dependency chaining from this container to the inner container is achieved. Declaration protected override ICompiledTarget GetFallbackCompiledRezolveTarget(ResolveContext context) Parameters Type Name Description ResolveContext context Required. The ResolveContext . Returns Type Description ICompiledTarget Overrides ContainerBase.GetFallbackCompiledRezolveTarget(ResolveContext) Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Targets.DecoratorTarget.html": {
    "href": "api/Rezolver.Targets.DecoratorTarget.html",
    "title": "Class DecoratorTarget",
    "keywords": "Class DecoratorTarget Represents the action of implementing a common DecoratedType by decorating one instance (produced by DecoratedTarget ) with another ( Target , which will create an instance of DecoratorType ). NOTE - You shouldn't register or otherwise create instances of this target unless you absolutely know what you're doing. Rather, decorators should be registered using the extension method RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) or its non-generic alternative because the target needs a DecoratingTargetContainer to work properly (the creation of which is automatically handled by these extension methods). Inheritance Object TargetBase DecoratorTarget Inherited Members TargetBase.UseFallback TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DecoratorTarget : TargetBase, ITarget Constructors | Improve this Doc View Source DecoratorTarget(Type, ITarget, Type) Creates a new instance of the DecoratorTarget type, initialising the Target to a just-in-time-bound ConstructorTarget for the decoratorType . Declaration public DecoratorTarget(Type decoratorType, ITarget decoratedTarget, Type decoratedType) Parameters Type Name Description Type decoratorType The type which is decorating the decoratedType ITarget decoratedTarget The target which is being decorated Type decoratedType The common type which is being decorated - e.g. IService when the decoratedTarget is bound to the type MyService : IService and the decoratorType is set to MyServiceDecorator : IService . Properties | Improve this Doc View Source DeclaredType Always returns DecoratorType Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source DecoratedTarget Gets the target whose instance will be wrapped (decorated) by the one produced by Target . Declaration public ITarget DecoratedTarget { get; } Property Value Type Description ITarget | Improve this Doc View Source DecoratedType Gets the underlying type (e.g. a common service interface or base) that is being implemented through decoration. Declaration public Type DecoratedType { get; } Property Value Type Description Type | Improve this Doc View Source DecoratorType Gets the type which is decorating the instance produced by the DecoratedTarget for the common service type DecoratedType Declaration public Type DecoratorType { get; } Property Value Type Description Type | Improve this Doc View Source Target Gets the target which will create an instance of the DecoratorType Declaration public ITarget Target { get; } Property Value Type Description ITarget Remarks The constructor currently auto-initialises this to a just-in-time-bound ConstructorTarget targetting the DecoratorType by using the Auto(Type, IMemberBindingBehaviour) method. Methods | Improve this Doc View Source SupportsType(Type) Overrides SupportsType(Type) to forward the call to Target . Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type The type which is to be checked. Returns Type Description Boolean true if the type is compatible with the object created by Target , false if not. Overrides TargetBase.SupportsType(Type) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget) See Also TargetBase"
  },
  "api/Rezolver.Compilation.ICompileContextProvider.html": {
    "href": "api/Rezolver.Compilation.ICompileContextProvider.html",
    "title": "Interface ICompileContextProvider",
    "keywords": "Interface ICompileContextProvider Interface for an object which creates ICompileContext instances for when the system needs to compile an ITarget into an ICompiledTarget . Namespace :Rezolver.Compilation Assembly :Rezolver.dll Syntax public interface ICompileContextProvider Remarks In normal operation, this interface is closely related to the ITargetCompiler interface because the core ContainerBase class (which provides most of the default implementation for IContainer ) obtains a new ICompileContext by resolving an instance of this interface, and calling the CreateContext(ResolveContext, ITargetContainer, IContainer) method, passing the result to the CompileTarget(ITarget, ICompileContext) method, along with the target to be compiled. Frequently, implementations of ITargetCompiler will also implement this interface to ensure that the compilation context contains everything the compiler needs to do its work. Methods | Improve this Doc View Source CreateContext(ResolveContext, ITargetContainer, IContainer) Creates a compilation context for the given resolveContext - which is used to determine the RequestedType that the eventual ICompiledTarget should return. Declaration ICompileContext CreateContext(ResolveContext resolveContext, ITargetContainer targets, IContainer containerOverride = null) Parameters Type Name Description ResolveContext resolveContext The resolve context - used to get the RequestedType and the Container (if containerOverride is not provided). ITargetContainer targets The target container that should be used to lookup other non-compiled targets. IContainer containerOverride The container requesting the new compilation context, if different from the Container on the resolveContext Returns Type Description ICompileContext Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ContainerBase.MissingCompiledTarget.html": {
    "href": "api/Rezolver.ContainerBase.MissingCompiledTarget.html",
    "title": "Class ContainerBase.MissingCompiledTarget",
    "keywords": "Class ContainerBase.MissingCompiledTarget Used as a sentinel type when a type cannot be resolved by a ContainerBase instance. Instead of returning a null ICompiledTarget instance, the container will construct an instance of this type (typically through GetMissingTarget(Type) , which caches singleton instances of this class on a per-type basis) which can then be used just as if the lookup succeeded. Inheritance Object ContainerBase.MissingCompiledTarget Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax protected class MissingCompiledTarget : ICompiledTarget Remarks The GetObject(ResolveContext) always throws an InvalidOperationException with the message 'Could resolve type [[type]]' Constructors | Improve this Doc View Source MissingCompiledTarget(Type) Constructs a new instance of the ContainerBase.MissingCompiledTarget class. Declaration public MissingCompiledTarget(Type type) Parameters Type Name Description Type type Methods | Improve this Doc View Source GetObject(ResolveContext) Implementation of GetObject(ResolveContext) . Always throws an InvalidOperationException . Declaration public object GetObject(ResolveContext context) Parameters Type Name Description ResolveContext context The current rezolve context. Returns Type Description Object Implements ICompiledTarget.GetObject(ResolveContext) Exceptions Type Condition InvalidOperationException Always thrown. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also ICompiledTarget"
  },
  "api/Rezolver.DecoratingTargetContainer.html": {
    "href": "api/Rezolver.DecoratingTargetContainer.html",
    "title": "Class DecoratingTargetContainer",
    "keywords": "Class DecoratingTargetContainer Implements service decoration in an ITargetContainer , producing instances of the DecoratorTarget when Fetch(Type) or FetchAll(Type) are called. The best way to add a decorator to your target container is to use the extension method RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) or its non-generic equivalent. Inheritance Object DecoratingTargetContainer Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class DecoratingTargetContainer : ITargetContainerOwner, ITargetContainer Remarks This class does not implement ITarget , rather it's an ITargetContainerOwner into which other targets can be added, and when Fetch(Type) or FetchAll(Type) are called, a temporary DecoratorTarget is created which wraps around the targets that have been registered within and which will ultimately create instances of DecoratorType Constructors | Improve this Doc View Source DecoratingTargetContainer(Type, Type) Initializes a new instance of the DecoratingTargetContainer class. Declaration public DecoratingTargetContainer(Type decoratorType, Type decoratedType) Parameters Type Name Description Type decoratorType Type of the decorator. Type decoratedType Type being decorated. Properties | Improve this Doc View Source DecoratedType Gets the type that's being decorated - in essence, this is the type that this decorator target Declaration public Type DecoratedType { get; } Property Value Type Description Type | Improve this Doc View Source DecoratorType Gets the type which will be used to decorate the instances produced by targets in this decorator target. Declaration public Type DecoratorType { get; } Property Value Type Description Type Methods | Improve this Doc View Source CombineWith(ITargetContainer, Type) Implements CombineWith(ITargetContainer, Type) by wrapping the existing container and returning itself. This allows decorators to be applied on top of decorators; and decorators to be added after types have begun to be registered in another target container. Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing The existing ITargetContainer instance that this instance is to be combined with Type type The type that the combined container owner will be registered under. Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) Exceptions Type Condition InvalidOperationException If this target container is already decorating another container | Improve this Doc View Source Fetch(Type) Implementation of Fetch(Type) - wraps a special target around the target returned by the target container that's decorated by this one. Declaration public ITarget Fetch(Type type) Parameters Type Name Description Type type Required. The type for which an ITarget is to be retrieved. Returns Type Description ITarget Implements ITargetContainer.Fetch(Type) Remarks If the inner container returns null, then so does this one. | Improve this Doc View Source FetchAll(Type) Implementation of FetchAll(Type) - passes the call on to the inner container that's decorated by this one, and then wraps each of those targets in a DecoratorTarget which represents the decoration logic for each instance. Declaration public IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type Required. The type for which the ITarget instances are to be retrieved. Returns Type Description IEnumerable < ITarget > Implements ITargetContainer.FetchAll(Type) | Improve this Doc View Source FetchContainer(Type) Retrieves an existing container registered against the given type , or null if not found. Declaration public ITargetContainer FetchContainer(Type type) Parameters Type Name Description Type type The type. Returns Type Description ITargetContainer Implements ITargetContainerOwner.FetchContainer(Type) Remarks This is an implementation of FetchContainer(Type) which wraps around the inner target container and passes the call on to that. Exceptions Type Condition InvalidOperationException If this decorator's inner container isn't an instance of ITargetContainerOwner | Improve this Doc View Source Register(ITarget, Type) Registers a target, either for the serviceType specified or, if null, the DeclaredType of the target . Implementation of Register(ITarget, Type) . Declaration public void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target Required. The target to be registered Type serviceType Optional. The type the target is to be registered against, if different from the DeclaredType of the target . If provided, then the target must be compatible with this type. Implements ITargetContainer.Register(ITarget, Type) Remarks The decorator target does not accept registrations directly; rather it passes the call on to its inner container which could be a TargetListContainer , or GenericTargetContainer in the most basic cases; or it could be another DecoratingTargetContainer in situations where a type has had multiple decorators registered against it. | Improve this Doc View Source RegisterContainer(Type, ITargetContainer) Implementation of RegisterContainer(Type, ITargetContainer) - the call is automatically forwarded on to the inner target container that's being decorated, since decorator targets don't support direct registration of targets or containers. Declaration public void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type The type. ITargetContainer container The container. Implements ITargetContainerOwner.RegisterContainer(Type, ITargetContainer) Exceptions Type Condition InvalidOperationException This decorator must be decorating another ITargetContainerOwner , or be decorating a generic type Extension Methods EnumerableTargetBuilderExtensions.EnableEnumerableResolving(ITargetContainerOwner) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) DecoratorTargetContainerExtensions.RegisterDecorator(ITargetContainerOwner, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.GenericTargetContainer.html": {
    "href": "api/Rezolver.GenericTargetContainer.html",
    "title": "Class GenericTargetContainer",
    "keywords": "Class GenericTargetContainer A special type of ITargetContainerOwner which stores targets (and potentially other containers) which are specifically keyed either to a particular open generic type or a closed generic built from it. Inheritance Object TargetDictionaryContainer GenericTargetContainer Inherited Members TargetDictionaryContainer.FetchContainer(Type) TargetDictionaryContainer.RegisterContainer(Type, ITargetContainer) TargetDictionaryContainer.CreateContainer(Type, ITarget) TargetDictionaryContainer.CombineWith(ITargetContainer, Type) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class GenericTargetContainer : TargetDictionaryContainer, ITargetContainerOwner, ITargetContainer Remarks You don't typically use this container directly - it is implicitly added to an ITargetContainer when generic types are registered. Indeed the TargetContainer and DecoratingTargetContainer booth create instances of this; and the Rezolver.EnumerableTargetContainer (understandably) inherits from it. Constructors | Improve this Doc View Source GenericTargetContainer(Type) Initializes a new instance of the GenericTargetContainer class. Declaration public GenericTargetContainer(Type genericType) Parameters Type Name Description Type genericType Required. The generic type definition that all targets and subcontainers will be grouped under. Properties | Improve this Doc View Source GenericType Gets the open generic type definition which is common to all targets and containers within this container. Declaration public Type GenericType { get; } Property Value Type Description Type Methods | Improve this Doc View Source Fetch(Type) Gets the target which can be used to build an instance of type . Declaration public override ITarget Fetch(Type type) Parameters Type Name Description Type type Required. The type for which a target is to be obtained. Because of the restrictions placed on the DeclaredType of the targets that can actually be registered into this container, the function will only ever return anything if type is a closed generic type whose definition equals GenericType . Returns Type Description ITarget Overrides TargetDictionaryContainer.Fetch(Type) Remarks Targets which have been registered specifically against the exact closed generic type represented by type take precedence over any targets which have been registered against the open generic type GenericType . | Improve this Doc View Source FetchAll(Type) Implementation of FetchAll(Type) Declaration public override IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type The type whose targets are to be retrieved. Returns Type Description IEnumerable < ITarget > Overrides TargetDictionaryContainer.FetchAll(Type) | Improve this Doc View Source Register(ITarget, Type) Overrides the Register(ITarget, Type) method to support registering both targets against the open generic type GenericType and against specific closed versions of that open generic type. Declaration public override void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target The target to be registered Type serviceType Service type against which the registration will be made. If null, then it will be assumed to be equal to GenericType . Only types equal to GenericType or generic types whose generic type definition is equal to GenericType are supported. Overrides TargetDictionaryContainer.Register(ITarget, Type) Remarks Notes to overriders: When serviceType is a closed generic type, this function creates an ITargetContainer for that serviceType by calling the protected method CreateContainer(Type, ITarget) if one doesn't exist (it calls FetchContainer(Type) to check for existence), and then chains to its Register(ITarget, Type) method. Exceptions Type Condition ArgumentException If serviceType is not equal to GenericType or is not a closed generic type whose generic type definition is GenericType . Extension Methods EnumerableTargetBuilderExtensions.EnableEnumerableResolving(ITargetContainerOwner) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) DecoratorTargetContainerExtensions.RegisterDecorator(ITargetContainerOwner, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also TargetDictionaryContainer"
  },
  "api/Rezolver.IMemberBindingBehaviour.html": {
    "href": "api/Rezolver.IMemberBindingBehaviour.html",
    "title": "Interface IMemberBindingBehaviour",
    "keywords": "Interface IMemberBindingBehaviour Describes a type which discovers and creates property/field bindings, typically for use when creating a new instance. Namespace :Rezolver Assembly :Rezolver.dll Syntax public interface IMemberBindingBehaviour Remarks The default implementation of this is DefaultMemberBindingBehaviour , which always binds all publicly writable instance properties and publicly accessible instance fields to auto-generated ResolvedTarget targets. Methods | Improve this Doc View Source GetMemberBindings(ICompileContext, Type) Retrieves the property and/or field bindings for the given type based on the given context . Declaration MemberBinding[] GetMemberBindings(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The current compilation context (will be used to look up ITarget references from its implementation of ITargetContainer Type type The type whose writable members are to be probed. Returns Type Description MemberBinding [] Zero or more bindings for the members of the type . Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.IScopedContainer.html": {
    "href": "api/Rezolver.IScopedContainer.html",
    "title": "Interface IScopedContainer",
    "keywords": "Interface IScopedContainer An IContainer that also has a Scope attached to it. Many applications will use such a container as the root container to use as anchors for things like scoped singletons. Inherited Members IContainer.CanResolve(ResolveContext) IContainer.Resolve(ResolveContext) IContainer.TryResolve(ResolveContext, Object) IContainer.CreateScope() IContainer.FetchCompiled(ResolveContext) IServiceProvider.GetService(Type) IDisposable.Dispose() Namespace :Rezolver Assembly :Rezolver.dll Syntax public interface IScopedContainer : IContainer, IServiceProvider, IDisposable Properties | Improve this Doc View Source Scope Gets the scope for this scoped container. Note that this is used automatically by the container for Resolve(ResolveContext) operations where the Scope property is not already set. Declaration IContainerScope Scope { get; } Property Value Type Description IContainerScope Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also IContainer IDisposable"
  },
  "api/Rezolver.SingletonTargetContainerExtensions.html": {
    "href": "api/Rezolver.SingletonTargetContainerExtensions.html",
    "title": "Class SingletonTargetContainerExtensions",
    "keywords": "Class SingletonTargetContainerExtensions Extension methods for the ITargetContainer interface which simplify the registration of singletons. Inheritance Object SingletonTargetContainerExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public static class SingletonTargetContainerExtensions Methods | Improve this Doc View Source RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) Registers the type objectType as a singleton ( SingletonTarget ) in the target container using either objectType as the service type, or serviceType instead - if it's provided. The instance will be built automatically with constructor injection (and, optionally, property injection if a propertyBindingBehaviour is passed) by leveraging the ConstructorTarget or GenericConstructorTarget targets. Declaration public static void RegisterSingleton(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registrations will be made. Type objectType Required. The type of object to be created. Type serviceType Optional. The type against which the target will be registered in the targetContainer IMemberBindingBehaviour propertyBindingBehaviour Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. | Improve this Doc View Source RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) Registers the type TObject as a singleton ( SingletonTarget ) in the target container. The instance will be built automatically with constructor injection (and, optionally, property injection if a propertyBindingBehaviour is passed) by leveraging the ConstructorTarget or GenericConstructorTarget targets. Declaration public static void RegisterSingleton<TObject>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registrations will be made. IMemberBindingBehaviour propertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type to be created, and the type against which the registration will be made | Improve this Doc View Source RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) Registers the type TObject as a singleton ( SingletonTarget ) in the target container for the service type TService . The instance will be built automatically with constructor injection (and, optionally, property injection if a propertyBindingBehaviour is passed) by leveraging the ConstructorTarget or GenericConstructorTarget targets. Declaration public static void RegisterSingleton<TObject, TService>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registrations will be made. IMemberBindingBehaviour propertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of object to be created. TService The type against which the target will be registered in the targetContainer"
  },
  "api/Rezolver.SingletonTargetDictionaryExtensions.html": {
    "href": "api/Rezolver.SingletonTargetDictionaryExtensions.html",
    "title": "Class SingletonTargetDictionaryExtensions",
    "keywords": "Class SingletonTargetDictionaryExtensions Extension methods for the ITargetContainer interface which simplify the registration of singletons. Inheritance Object SingletonTargetDictionaryExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public static class SingletonTargetDictionaryExtensions Methods | Improve this Doc View Source RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) Registers the type objectType as a singleton ( SingletonTarget ) in the target container using either objectType as the service type, or serviceType instead - if it's provided. The instance will be built automatically with constructor injection (and, optionally, property injection if a propertyBindingBehaviour is passed) by leveraging the ConstructorTarget or GenericConstructorTarget targets. Declaration public static void RegisterSingleton(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registrations will be made. Type objectType Required. The type of object to be created. Type serviceType Optional. The type against which the target will be registered in the targetContainer IMemberBindingBehaviour propertyBindingBehaviour Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. | Improve this Doc View Source RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) Registers the type TObject as a singleton ( SingletonTarget ) in the target container. The instance will be built automatically with constructor injection (and, optionally, property injection if a propertyBindingBehaviour is passed) by leveraging the ConstructorTarget or GenericConstructorTarget targets. Declaration public static void RegisterSingleton<TObject>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registrations will be made. IMemberBindingBehaviour propertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type to be created, and the type against which the registration will be made | Improve this Doc View Source RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) Registers the type TObject as a singleton ( SingletonTarget ) in the target container for the service type TService . The instance will be built automatically with constructor injection (and, optionally, property injection if a propertyBindingBehaviour is passed) by leveraging the ConstructorTarget or GenericConstructorTarget targets. Declaration public static void RegisterSingleton<TObject, TService>(this ITargetContainer targetContainer, IMemberBindingBehaviour propertyBindingBehaviour = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registrations will be made. IMemberBindingBehaviour propertyBindingBehaviour Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of object to be created. TService The type against which the target will be registered in the targetContainer"
  },
  "api/Rezolver.Targets.DelegateTarget-2.html": {
    "href": "api/Rezolver.Targets.DelegateTarget-2.html",
    "title": "Class DelegateTarget<T, TResult>",
    "keywords": "Class DelegateTarget<T, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.FactoryMethod DelegateTarget.DeclaredType TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DelegateTarget<T, TResult> : DelegateTarget, ITarget Type Parameters Name Description T The type of the 1st delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc View Source DelegateTarget(Func<T, TResult>, Type) Initializes a new instance of the DelegateTarget<T, TResult> class. Declaration public DelegateTarget(Func<T, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T, TResult> factory The factory. Type declaredType Type of the declared. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.DelegateTarget-3.html": {
    "href": "api/Rezolver.Targets.DelegateTarget-3.html",
    "title": "Class DelegateTarget<T1, T2, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.FactoryMethod DelegateTarget.DeclaredType TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DelegateTarget<T1, T2, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc View Source DelegateTarget(Func<T1, T2, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, TResult> class. Declaration public DelegateTarget(Func<T1, T2, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, TResult> factory The factory. Type declaredType Type of the declared. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.Targets.TargetBase.html": {
    "href": "api/Rezolver.Targets.TargetBase.html",
    "title": "Class TargetBase",
    "keywords": "Class TargetBase Abstract base class, suggested as a starting point for implementations of ITarget . Inheritance Object TargetBase ChangeTypeTarget ConstructorTarget DecoratorTarget DefaultTarget DelegateTarget ExpressionTarget GenericConstructorTarget ListTarget ObjectTarget OptionalParameterTarget ResolvedTarget ScopedTarget SingletonTarget UnscopedTarget Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public abstract class TargetBase : ITarget Properties | Improve this Doc View Source DeclaredType Gets the declared type of object that is constructed by this target. Declaration public abstract Type DeclaredType { get; } Property Value Type Description Type Implements ITarget.DeclaredType | Improve this Doc View Source ScopeBehaviour Gets the scoping behaviour for instances that will ultimately be produced by this target. Declaration public virtual ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Implements ITarget.ScopeBehaviour Remarks Base implementation always returns Implicit . | Improve this Doc View Source UseFallback Implementation of UseFallback Base version always returns false . Declaration public virtual bool UseFallback { get; } Property Value Type Description Boolean Implements ITarget.UseFallback Methods | Improve this Doc View Source SelectScope(ResolveContext) Selects the scope. Declaration public virtual IContainerScope SelectScope(ResolveContext context) Parameters Type Name Description ResolveContext context The context. Returns Type Description IContainerScope Implements ITarget.SelectScope(ResolveContext) | Improve this Doc View Source SupportsType(Type) Implementation of SupportsType(Type) . Returns a boolean indicating whether the target is able to produce an instance of, or an instance that is compatible with, the passed type . Declaration public virtual bool SupportsType(Type type) Parameters Type Name Description Type type The type. Returns Type Description Boolean Implements ITarget.SupportsType(Type) Remarks It is strongly suggested that you use this method to check whether the target can construct an instance of a given type rather than performing any type checking yourself on the DeclaredType , because an ITarget might be able to support a much wider range of types other than just those which are directly compatible with its DeclaredType . For example, the GenericConstructorTarget is statically bound to an open generic, so therefore traditional type checks on the DeclaredType do not work. That class' implementation of this method, however, contains the complex logic necessary to determine if the open generic can be closed into a generic type which is compatible with the given type . Implementations of ITargetCompiler should always consult this function in their implementation of CompileTarget(ITarget, ICompileContext) to determine if the target is compatible with the TargetType of the CompileContext Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  },
  "api/Rezolver.TargetContainer.html": {
    "href": "api/Rezolver.TargetContainer.html",
    "title": "Class TargetContainer",
    "keywords": "Class TargetContainer Root container for ITarget s that can be used as the backing for the standard IContainer classes - Container and ScopedContainer . Stores and retrieves registrations of ITarget s, is also Generic type aware, unlike its base class - TargetDictionaryContainer . Inheritance Object TargetDictionaryContainer TargetContainer ChildTargetContainer Inherited Members TargetDictionaryContainer.Fetch(Type) TargetDictionaryContainer.FetchAll(Type) TargetDictionaryContainer.CombineWith(ITargetContainer, Type) Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public class TargetContainer : TargetDictionaryContainer, ITargetContainerOwner, ITargetContainer Remarks This is the type used by default for the Targets of all the standard containers in the core framework, e.g. Container , ScopedContainer etc, when you don't supply an instance of an ITargetContainer explicitly on construction. Constructors | Improve this Doc View Source TargetContainer(Boolean) Constructs a new instance of the TargetContainer class Declaration public TargetContainer(bool autoRezolveIEnumerable = true) Parameters Type Name Description Boolean autoRezolveIEnumerable If true, then IEnumerable<T> will be automatically resolved as a concatenation of all the ITarget s that are registered against a particular type. Note - this parameter might be removed in a future version - you can achieve the same thing by using the extension method EnableEnumerableResolving(ITargetContainerOwner) Methods | Improve this Doc View Source CreateContainer(Type, ITarget) Called to create and register a container for the given serviceType and target . This class overrides the base version ( CreateContainer(Type, ITarget) ) to create a specialised container for generic types ( GenericTargetContainer ) if serviceType if a generic type or generic type definition. Declaration protected override ITargetContainer CreateContainer(Type serviceType, ITarget target) Parameters Type Name Description Type serviceType The type for which a container is to be created and registered. ITarget target Optional. The target that will be added to the container that is returned. Returns Type Description ITargetContainer An ITargetContainer in which the passed target will be registered. Overrides TargetDictionaryContainer.CreateContainer(Type, ITarget) Remarks The main caller for this method will be the base Register method, which will create a new container for a target that's being registered against a new type. It is, however, also called by this class' implementation of RegisterContainer(Type, ITargetContainer) when the type is a generic type - as all generics must have a container registered against their generic type definitions as a starting point. | Improve this Doc View Source CreateGenericTypeDefContainer(Type, ITarget) Called by CreateContainer(Type, ITarget) to create a container suitable for handling targets that are registered against generic types. Declaration protected virtual ITargetContainer CreateGenericTypeDefContainer(Type genericTypeDefinition, ITarget target) Parameters Type Name Description Type genericTypeDefinition Will be an open generic type (generic type definition) ITarget target Optional. The initial target for which the container is being constructed Returns Type Description ITargetContainer The base implementation always creates an instance of CreateGenericTypeDefContainer(Type, ITarget) | Improve this Doc View Source FetchContainer(Type) Retrieves Declaration public override ITargetContainer FetchContainer(Type type) Parameters Type Name Description Type type Returns Type Description ITargetContainer Overrides TargetDictionaryContainer.FetchContainer(Type) | Improve this Doc View Source Register(ITarget, Type) Overrides the base method to block registration if the target does not support the serviceType (checked by calling the target's SupportsType(Type) method). Declaration public override void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target The target to be registered. Type serviceType Optional - the type against which the target is to be registered, if different from the target's DeclaredType . Overrides TargetDictionaryContainer.Register(ITarget, Type) | Improve this Doc View Source RegisterContainer(Type, ITargetContainer) Overrides the base method so that if type is a generic type, then the container will be registered inside another which will be registered for the generic type definition first. Declaration public override void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container Overrides TargetDictionaryContainer.RegisterContainer(Type, ITargetContainer) | Improve this Doc View Source RegisterContainerDirect(Type, ITargetContainer) Version of RegisterContainer(Type, ITargetContainer) which does not interrogate the type to see if it's generic - simply registers the passed container directly against the passed type (it just chains through directly to the RegisterContainer(Type, ITargetContainer) method non-virtually. Declaration protected virtual void RegisterContainerDirect(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container Extension Methods EnumerableTargetBuilderExtensions.EnableEnumerableResolving(ITargetContainerOwner) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) DecoratorTargetContainerExtensions.RegisterDecorator(ITargetContainerOwner, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T, TResult>(ITargetContainer, Func<T, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>, Type) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T, TResult>(ITargetContainer, Expression<Func<ResolveContext, T, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<ResolveContext, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>, Type) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.TargetCreationExtensions.html": {
    "href": "api/Rezolver.TargetCreationExtensions.html",
    "title": "Class TargetCreationExtensions",
    "keywords": "Class TargetCreationExtensions Extensions which provide shortcuts for creating some of the targets in the Rezolver.Targets namespace. Inheritance Object TargetCreationExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver Assembly :Rezolver.dll Syntax public static class TargetCreationExtensions Methods | Improve this Doc View Source AsDelegateTarget(Delegate, Type) Creates a DelegateTarget from the factory which can be registered in an ITargetContainer to resolve an instance of a type compatible with the delegate's return type and, optionally, with the declaredType Declaration public static DelegateTarget AsDelegateTarget(this Delegate factory, Type declaredType = null) Parameters Type Name Description Delegate factory The delegate to be used as a factory. Type declaredType Optional type to set as the DeclaredType of the target, if not passed, then the return type of the delegate will be used. Returns Type Description DelegateTarget | Improve this Doc View Source AsObjectTarget<T>(T, Type, ScopeBehaviour) Wraps the instance on which this is invoked as an ObjectTarget that can be registered into an ITargetContainer . The parameters are direct analogues of the parameters on the type's constructor (see ObjectTarget(Object, Type, ScopeBehaviour) ). Declaration public static ObjectTarget AsObjectTarget<T>(this T obj, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description T obj the object being wrapped Type declaredType Optional. The type which is to be set as the DeclaredType of the created target. ScopeBehaviour scopeBehaviour Controls how the object will interact the the scope. By default, object targets must be disposed by you. Returns Type Description ObjectTarget A new object target that wraps the object obj . Type Parameters Name Description T The type of object being wrapped | Improve this Doc View Source Scoped(ITarget) Creates a ScopedTarget from the target on which this method is invoked. Declaration public static ScopedTarget Scoped(this ITarget target) Parameters Type Name Description ITarget target Returns Type Description ScopedTarget | Improve this Doc View Source Singleton(ITarget) Constructs a SingletonTarget that wraps the target on which the method is invoked. Declaration public static SingletonTarget Singleton(this ITarget target) Parameters Type Name Description ITarget target Returns Type Description SingletonTarget | Improve this Doc View Source Unscoped(ITarget) Creates an UnscopedTarget from the target on which this method is invoked. Declaration public static UnscopedTarget Unscoped(this ITarget target) Parameters Type Name Description ITarget target The target. Returns Type Description UnscopedTarget"
  },
  "api/Rezolver.Targets.DelegateTarget-15.html": {
    "href": "api/Rezolver.Targets.DelegateTarget-15.html",
    "title": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>",
    "keywords": "Class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Extension of the DelegateTarget class which provides strong typing for the generic Func delegate type. Inheritance Object TargetBase DelegateTarget DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> Inherited Members DelegateTarget.Factory DelegateTarget.FactoryMethod DelegateTarget.DeclaredType TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace :Rezolver.Targets Assembly :Rezolver.dll Syntax public class DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> : DelegateTarget, ITarget Type Parameters Name Description T1 The type of the 1st delegate parameter (will be resolved automatically) T2 The type of the 2nd delegate parameter (will be resolved automatically) T3 The type of the 3rd delegate parameter (will be resolved automatically) T4 The type of the 4th delegate parameter (will be resolved automatically) T5 The type of the 5th delegate parameter (will be resolved automatically) T6 The type of the 6th delegate parameter (will be resolved automatically) T7 The type of the 7th delegate parameter (will be resolved automatically) T8 The type of the 8th delegate parameter (will be resolved automatically) T9 The type of the 9th delegate parameter (will be resolved automatically) T10 The type of the 10th delegate parameter (will be resolved automatically) T11 The type of the 11th delegate parameter (will be resolved automatically) T12 The type of the 12th delegate parameter (will be resolved automatically) T13 The type of the 13th delegate parameter (will be resolved automatically) T14 The type of the 14th delegate parameter (will be resolved automatically) TResult The type of object produced by the delegate. Remarks This class and its other generic cousins exist purely to simplify the creation of a DelegateTarget with a delegate expressed as a lambda expression. e.g. new DelegateTarget<IMyservice>(() => new MyService()); With the DelegateTarget it is not possible to do this - you need a delegate variable. Ultimately, however, all functionality beyond construction is provided by the base class. Constructors | Improve this Doc View Source DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>, Type) Initializes a new instance of the DelegateTarget<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> class. Declaration public DelegateTarget(Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> factory The factory. Type declaredType Type of the declared. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) TargetCreationExtensions.Scoped(ITarget) TargetCreationExtensions.Unscoped(ITarget) TargetCreationExtensions.Singleton(ITarget)"
  }
}