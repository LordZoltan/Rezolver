{
  "api/Rezolver.IMemberBindingBehaviour.html": {
    "href": "api/Rezolver.IMemberBindingBehaviour.html",
    "title": "Interface IMemberBindingBehaviour | Rezolver IOC Framework",
    "keywords": "Interface IMemberBindingBehaviour Describes a type which discovers and creates property/field bindings, typically for use when creating a new instance. Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public interface IMemberBindingBehaviour Remarks The default implementation of this is DefaultMemberBindingBehaviour , which always binds all publicly writable instance properties and publicly accessible instance fields to auto-generated ResolvedTarget targets. Methods | Improve this Doc View Source GetMemberBindings(ICompileContext, Type) Retrieves the property and/or field bindings for the given type based on the given context . Declaration MemberBinding[] GetMemberBindings(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The current compilation context (will be used to look up ITarget references from its implementation of ITargetContainer Type type The type whose writable members are to be probed. Returns Type Description MemberBinding [] Zero or more bindings for the members of the type . Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ResolveContext.html": {
    "href": "api/Rezolver.ResolveContext.html",
    "title": "Class ResolveContext | Rezolver IOC Framework",
    "keywords": "Class ResolveContext Captures the state for a call to Resolve(ResolveContext) (or TryResolve(ResolveContext, out Object) ), including the container on which the operation is invoked, any IScopedContainer that might be active for the call (if different), and the type that is being resolved from the IContainer . Inheritance Object ResolveContext Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class ResolveContext : IScopeFactory Remarks The context implements IScopeFactory because the a new child scope might be created either from the Scope or the Container , in that order. So, rather than Constructors | Improve this Doc View Source ResolveContext(IContainer, Type) Initializes a new instance of the ResolveContext class. Declaration public ResolveContext(IContainer container, Type requestedType) Parameters Type Name Description IContainer container The container. Type requestedType The type of object to be resolved from the container. | Improve this Doc View Source ResolveContext(IContainer, Type, IContainerScope) Initializes a new instance of the ResolveContext class. Declaration public ResolveContext(IContainer container, Type requestedType, IContainerScope scope) Parameters Type Name Description IContainer container The container. Type requestedType The type of object to be resolved from the container. IContainerScope scope The scope for this context. | Improve this Doc View Source ResolveContext(IContainerScope, Type) Initializes a new instance of the ResolveContext class from the given scope. The Container is inherited from the scope's Container . Declaration public ResolveContext(IContainerScope scope, Type requestedType) Parameters Type Name Description IContainerScope scope The scope. Type requestedType The of object to be resolved from the container. Properties | Improve this Doc View Source Container The container for this context. Declaration public IContainer Container { get; } Property Value Type Description IContainer Remarks This is the container which received the original call to Resolve(ResolveContext) , but is not necessarily the same container that will eventually end up resolving the object. | Improve this Doc View Source RequestedType Gets the type being requested from the container Declaration public Type RequestedType { get; } Property Value Type Description Type The type of the requested. | Improve this Doc View Source RequestedTypeComparer Gets a comparer for ResolveContext which treats two contexts as being equal if they're both the same reference (including null) or, if both have the same RequestedType Declaration public static IEqualityComparer<ResolveContext> RequestedTypeComparer { get; } Property Value Type Description IEqualityComparer < ResolveContext > | Improve this Doc View Source Scope Gets the scope that's active for all calls for this context. Declaration public IContainerScope Scope { get; } Property Value Type Description IContainerScope The scope. Methods | Improve this Doc View Source CreateScope() Creates a new scope either through the Scope or, if that's null, then the Container . Declaration public IContainerScope CreateScope() Returns Type Description IContainerScope Implements IScopeFactory.CreateScope() Remarks This interface implementation is present for when an object wants to be able to inject a scope factory in order to create child scopes which are correctly parented either to another active scope or the container. | Improve this Doc View Source Resolve(Type) Resolves a new instance of a different type from the same scope/container that originally received the current Resolve operation. Declaration public object Resolve(Type newRequestedType) Parameters Type Name Description Type newRequestedType New type to be resolved. Returns Type Description Object Remarks Use this method, or the generic equivalent, to resolve dependency services in a factory or expression. If a scope is active then it will be honoured. | Improve this Doc View Source Resolve<TResult>() Resolves a new instance of a different type from the same scope/container that originally received the current Resolve operation. Declaration public TResult Resolve<TResult>() Returns Type Description TResult Type Parameters Name Description TResult New type to be resolved. Remarks Use this method, or the non-generic equivalent, to resolve dependency services in a factory or expression. If a scope is active then it will be honoured. | Improve this Doc View Source ToString() Returns a String that represents this instance. Declaration public override string ToString() Returns Type Description String Overrides Object.ToString() Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ScopeBehaviour.html": {
    "href": "api/Rezolver.ScopeBehaviour.html",
    "title": "Enum ScopeBehaviour | Rezolver IOC Framework",
    "keywords": "Enum ScopeBehaviour Describes different ways in which objeects interact with scopes. Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public enum ScopeBehaviour Remarks Note: this enum might be replaced with an abstraction in the future. If so, it will not alter how regatrations are performed, but it will affect any low-level code which uses this enum directly. Fields Name Description Explicit Explicitly scoped objects act like singletons in the current scope, regardless of whether they are disposable or not. Implicit Implicitly scoped objects are only added to the scope for the purposes of disposing when the scope is disposed None The object will not be tracked in any scope, regardless of whether there is one active, or whether the object is disposable. Extension Methods TargetCreationExtensions.AsObjectTarget<ScopeBehaviour>(Type, ScopeBehaviour)"
  },
  "api/Rezolver.Targets.GenericConstructorTarget.GenericTypeMapping.html": {
    "href": "api/Rezolver.Targets.GenericConstructorTarget.GenericTypeMapping.html",
    "title": "Class GenericConstructorTarget.GenericTypeMapping | Rezolver IOC Framework",
    "keywords": "Class GenericConstructorTarget.GenericTypeMapping Result returned from the MapType(Type) function. Represents various levels of success - from a completely incompatible mapping ( Success = false ), or a successful mapping from an open generic type to a closed generic type which can then be constructed ( Success = true and IsFullyBound = true ) or, a successful mapping from an open generic type to another open generic type ( Success = true but IsFullyBound = false ). This mapping is then used by both the SupportsType(Type) and Bind(ICompileContext) functions. Only fully bound mappings are supported by Bind(ICompileContext) , whereas SupportsType(Type) will return true so long as the Success is true. The caller, therefore, must ensure it is aware of the difference between open and closed generics. Inheritance Object GenericConstructorTarget.GenericTypeMapping Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Targets Assembly :rezolver-docfx.dll Syntax public class GenericTypeMapping Properties | Improve this Doc View Source BindErrorMessage Gets a string describing the reason why the type could not be mapped. Can be used for exceptions, etc. Note that this can be set even if Success is true - because mappings exist between open generic types so that a target's SupportsType(Type) returns true , but the Bind(ICompileContext) function throws an exception for the same type, since you can't create an instance of an open generic. Declaration public string BindErrorMessage { get; } Property Value Type Description String The binding error message. | Improve this Doc View Source IsFullyBound If true, then the Type is a fully closed generic type that can be constructed (and therefore would be successfully bound by the Bind(ICompileContext) method, which uses the MapType(Type) method). If this is false but Success is true , then while the target is technically compatible with the requested type, you can't create an instance. The target will, however, be able to mapped to a closed generic type based on the same Type . Declaration public bool IsFullyBound { get; } Property Value Type Description Boolean | Improve this Doc View Source RequestedType The type requested for mapping. If this is an open generic, then the best result for this mapping will be that Success is true and IsFullyBound is false . Declaration public Type RequestedType { get; } Property Value Type Description Type | Improve this Doc View Source Success Gets a value indicating whether the DeclaredType of the GenericConstructorTarget was successfully mapped to the requested type. If so, and IsFullyBound is true , then an instance of Type will be compatible with the type that was requested. If IsFullyBound is false , then you can't create an instance of Type because it's an open generic - but you will be able to bind the same target to a closed generic of the same Type . Declaration public bool Success { get; } Property Value Type Description Boolean true if success; otherwise, false . | Improve this Doc View Source Type If Success = true , gets the generic type to be used for the RequestedType . Note that this could be either an open or closed generic - the IsFullyBound offers a quick means by which to determine this. If IsFullyBound is true , then the mapping will succeed when encountered by the Bind(ICompileContext) method. Declaration public Type Type { get; } Property Value Type Description Type The type. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Targets.GenericConstructorTarget.html": {
    "href": "api/Rezolver.Targets.GenericConstructorTarget.html",
    "title": "Class GenericConstructorTarget | Rezolver IOC Framework",
    "keywords": "Class GenericConstructorTarget Equivalent of ConstructorTarget but for open generic types. So, this will handle the open generic MyType<,>, for example, whereas ConstructorTarget would handle the closed type MyType<int, string>. Inheritance Object TargetBase GenericConstructorTarget Inherited Members TargetBase.UseFallback TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Targets Assembly :rezolver-docfx.dll Syntax public class GenericConstructorTarget : TargetBase, ITarget Constructors | Improve this Doc View Source GenericConstructorTarget(Type, IMemberBindingBehaviour) Constructs a new instance of the GenericConstructorTarget for the given open generic type, which will utilise the optional memberBindingBehaviour when it constructs its ConstructorTarget when Bind(ICompileContext) is called. Declaration public GenericConstructorTarget(Type genericType, IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description Type genericType The type of the object that is to be built (open generic of course) IMemberBindingBehaviour memberBindingBehaviour Optional. The IMemberBindingBehaviour to be used for binding properties and/or fields on the ConstructorTarget that is generated. If null, then no property or fields will be bound on construction. Properties | Improve this Doc View Source DeclaredType Implementation of the abstract base property. Will return the unbound generic type passed to this object on construction. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source GenericType Gets the generic type definition from which generic types are to be built and instances of which will be constructed. Declaration public Type GenericType { get; } Property Value Type Description Type | Improve this Doc View Source MemberBindingBehaviour Gets the member binding behaviour to be used when creating an instance. Declaration public IMemberBindingBehaviour MemberBindingBehaviour { get; } Property Value Type Description IMemberBindingBehaviour The member binding behaviour. Methods | Improve this Doc View Source Auto(Type, IMemberBindingBehaviour) This method has been replaced by the Target.ForType method and will be removed in 1.2. Equivalent of Auto(Type, IMemberBindingBehaviour) but for open generic types. Note - there is no generic version because that could only be invoked by reflection. Declaration [Obsolete(\"This method has been replaced by the Target.ForType method and will be removed in 1.2.\")] public static ITarget Auto(Type type, IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description Type type The type. IMemberBindingBehaviour memberBindingBehaviour Optional behaviour controlling which properties and fields, if any, will receive injected values. Returns Type Description ITarget Exceptions Type Condition ArgumentException This is raised from the GenericConstructorTarget(Type, IMemberBindingBehaviour) constructor when the passed type is either not an open generic type or is an abstract class or interface. | Improve this Doc View Source Bind(ICompileContext) Obtains an ITarget (usually a ConstructorTarget ) which will create an instance of a generic type (whose definition is equal to GenericType ) with generic arguments set correctly according to the TargetType of the context . Declaration public ITarget Bind(ICompileContext context) Parameters Type Name Description ICompileContext context The context. Returns Type Description ITarget Remarks The process of binding a requested type to the concrete type can be very complex, when inheritance chains and interface implementation maps are taken into account. At the simplest end of the spectrum, if GenericType is MyGeneric<> and the context 's TargetType is MyGeneric<int> , then this function merely has to insert the int type as the generic parameter to the MyGeneric<> type definition, bake a new type and create an auto-bound ConstructorTarget . Consider what happens, however, when the inheritance chain is more complex: interface IMyInterfaceCore<T, U> { } class MyBaseClass<T, U> : IMyInterfaceCore<U, T> { } class MyDerivedClass<T, U> : MyBaseClass<U, T> { } A GenericConstructorTarget bound to the generic type definition MyDerivedClass<,> can create instances not only of any generic type based on that definition, but also any generic type based on the definitions of either it's immediate base, or that base's interface. In order to do so, however, the parameters must be mapped between the generic type definitions so that if an instance of MyBaseClass<string, int> is requested, then an instance of MyDerivedClass<int, string> (note the arguments are reversed) is actually created. Similarly, if an instance of IMyInterface<string, int> is requested, we actually need to create an instance of MyDerivedClass<string, int> - because the generic arguments are reversed first through the base class inheritance, and then again by the base class' implementation of the interface. Note that a GenericConstructorTarget can only bind to the context's target type if there is enough information in order to deduce the generic type arguments for GenericType . This means, in general, that the requested type will almost always need to be a generic type with at least as many type arguments as the GenericType . | Improve this Doc View Source MapType(Type) Maps the DeclaredType open generic type to the targetType . Examine the Success of the result to check whether the result was successful. Declaration public GenericConstructorTarget.GenericTypeMapping MapType(Type targetType) Parameters Type Name Description Type targetType Type of the target. Returns Type Description GenericConstructorTarget.GenericTypeMapping | Improve this Doc View Source SupportsType(Type) Override - introduces additional logic to cope with generic types not generally supported by the majority of other targets. This uses the MapType(Type) function to determine success, but only checks the Success flag. As a result, this method will return true if an open generic base or interface of DeclaredType Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also TargetBase"
  },
  "api/Rezolver.Compilation.CompileContext.html": {
    "href": "api/Rezolver.Compilation.CompileContext.html",
    "title": "Class CompileContext | Rezolver IOC Framework",
    "keywords": "Class CompileContext Core implementation of ICompileContext . A root context (i.e. where ParentContext is null ; created via the CompileContext(IContainer, ITargetContainer, Type) constructor) is the starting point for all shared state, such as the Container and the compilation stack. The ITargetContainer implementation is done by decorating a new ChildTargetContainer , so that new registrations can be added without interfering with upstream containers. Note that many of the interface members are implemented explicitly - therefore most of your interaction with this type is through its implementation of ICompileContext and ITargetContainer . Inheritance Object CompileContext ExpressionCompileContext Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation Assembly :rezolver-docfx.dll Syntax public class CompileContext : ICompileContext, ITargetContainer Remarks Note that you can only create an instance of this either through inheritance, via the explicit implementation of NewContext(Type, Nullable<ScopeBehaviour>) , or (preferably) via an ICompileContextProvider resolved from an IContainer or ITargetContainer directly from a registered target. Constructors | Improve this Doc View Source CompileContext(ICompileContext, Type, Nullable<ScopeBehaviour>) Creates a new CompileContext as a child of another. Declaration protected CompileContext(ICompileContext parentContext, Type targetType = null, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description ICompileContext parentContext Used to seed the compilation stack, container, dependency container (which will still be wrapped in a new ChildTargetContainer for isolation) and, optionally, the target type (unless you pass a non-null type for targetType , which would override that). Type targetType The target type that is expected to be compiled, or null if the TargetType is to be inherited from the parentContext . Nullable < ScopeBehaviour > scopeBehaviourOverride Override the scope behaviour to be used for the target that is compiled with this context. | Improve this Doc View Source CompileContext(IContainer, ITargetContainer, Type) Creates a new CompileContext Declaration protected CompileContext(IContainer container, ITargetContainer dependencyTargetContainer, Type targetType = null) Parameters Type Name Description IContainer container Required. The container for which compilation is being performed. Will be set into the Container property. ITargetContainer dependencyTargetContainer Required - An ITargetContainer that contains the ITarget s that will be required to complete compilation. Note - this argument is passed to a new ChildTargetContainer that is created and proxied by this class' implementation of ITargetContainer . As a result, it's possible to register new targets directly into the context via its implementation of ITargetContainer , without modifying the underlying targets in the container you pass. Type targetType Optional. Will be set into the TargetType property. If null, then any ITarget that is compiled should be compiled for its own DeclaredType . Properties | Improve this Doc View Source CompileStack Gets the stack entries for all the targets that are being compiled for all contexts related to this one - both up and down the hierarchy. Declaration public IEnumerable<CompileStackEntry> CompileStack { get; } Property Value Type Description IEnumerable < CompileStackEntry > The compile stack. Implements ICompileContext.CompileStack | Improve this Doc View Source Container The container that is considered the current compilation 'scope' - i.e. the container for which the compilation is being performed and, usually, the one on which the Resolve(ResolveContext) method was originally called which triggered the compilation call. Declaration public IContainer Container { get; } Property Value Type Description IContainer The container. Implements ICompileContext.Container | Improve this Doc View Source DependencyTargetContainer This is the ITargetContainer through which dependencies are resolved by this context in its implementation of ITargetContainer . In essence, this class acts as a decorator for this inner target container. Declaration protected ITargetContainer DependencyTargetContainer { get; } Property Value Type Description ITargetContainer | Improve this Doc View Source ParentContext Gets the parent context from which this context was created, if applicable. Declaration public ICompileContext ParentContext { get; } Property Value Type Description ICompileContext The parent context. Implements ICompileContext.ParentContext | Improve this Doc View Source ScopeBehaviourOverride Implementation of ScopeBehaviourOverride Declaration public ScopeBehaviour? ScopeBehaviourOverride { get; } Property Value Type Description Nullable < ScopeBehaviour > Implements ICompileContext.ScopeBehaviourOverride | Improve this Doc View Source TargetType Any ICompiledTarget built for a ITarget with this context should target this type. If null, then the DeclaredType of the target being compiled should be used. Declaration public Type TargetType { get; } Property Value Type Description Type Implements ICompileContext.TargetType Remarks Note that when creating a child context with a null targetType argument, this property will be inherited from the ParentContext . Methods | Improve this Doc View Source NewContext(Type, Nullable<ScopeBehaviour>) Used by the explicit implementation of NewContext(Type, Nullable<ScopeBehaviour>) . Override this in your derived class to create the correct implementation of ICompileContext . Declaration protected virtual ICompileContext NewContext(Type targetType = null, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Nullable < ScopeBehaviour > scopeBehaviourOverride Override the scope behaviour to be used for the target that is compiled with the new context. Returns Type Description ICompileContext Explicit Interface Implementations | Improve this Doc View Source ICompileContext.NewContext(Type, Nullable<ScopeBehaviour>) Creates a new child context from this one, except the TargetType and ScopeBehaviour properties can be overriden if required, with the rest of the state inherited from this context. Declaration ICompileContext ICompileContext.NewContext(Type targetType, ScopeBehaviour? scopeBehaviourOverride) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Nullable < ScopeBehaviour > scopeBehaviourOverride Override the scope behaviour to be used for the target that is compiled with the new context. Returns Type Description ICompileContext Implements ICompileContext.NewContext(Type, Nullable<ScopeBehaviour>) | Improve this Doc View Source ICompileContext.PopCompileStack() Pops a target from the stack and returns it. Note that if there are no targets on the stack, an InvalidOperationException will occur. Declaration CompileStackEntry ICompileContext.PopCompileStack() Returns Type Description CompileStackEntry The CompileStackEntry that was popped off the compilation stack. Implements ICompileContext.PopCompileStack() Remarks If ParentContext is not null, then the call is redirected to that context, so that the compilation stack is always shared between all contexts spawned from the same root. | Improve this Doc View Source ICompileContext.PushCompileStack(ITarget, Type) Adds the target to the compilation stack if it doesn't already exist. Declaration bool ICompileContext.PushCompileStack(ITarget toCompile, Type targetType) Parameters Type Name Description ITarget toCompile The target to be pushed Type targetType The type for which the target is being compiled, if different from DeclaredType Returns Type Description Boolean Implements ICompileContext.PushCompileStack(ITarget, Type) Remarks Targets can appear on the compilation stack more than once for different types, since the ICompiledTarget produced for a target for one type can be different than it is for another. Ultimately, if a target does in fact have a cyclic dependency graph, then this method will detect that. | Improve this Doc View Source ITargetContainer.CombineWith(ITargetContainer, Type) Always throws a NotSupportedException Declaration ITargetContainer ITargetContainer.CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Ignored Type type Ignored Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) Exceptions Type Condition NotSupportedException Always thrown | Improve this Doc View Source ITargetContainer.Fetch(Type) Implements Fetch(Type) by wrapping around the child target container created by this context on construction. Declaration ITarget ITargetContainer.Fetch(Type type) Parameters Type Name Description Type type See Fetch(Type) for more. Returns Type Description ITarget Implements ITargetContainer.Fetch(Type) | Improve this Doc View Source ITargetContainer.FetchAll(Type) Implements FetchAll(Type) by wrapping around the child target container created by this context on construction. Declaration IEnumerable<ITarget> ITargetContainer.FetchAll(Type type) Parameters Type Name Description Type type See FetchAll(Type) for more Returns Type Description IEnumerable < ITarget > Implements ITargetContainer.FetchAll(Type) | Improve this Doc View Source ITargetContainer.Register(ITarget, Type) Implements Register(ITarget, Type) by wrapping around the child target container created by this context on construction. Declaration void ITargetContainer.Register(ITarget target, Type serviceType) Parameters Type Name Description ITarget target See Register(ITarget, Type) for more Type serviceType See Register(ITarget, Type) for more Implements ITargetContainer.Register(ITarget, Type) Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also ICompileContext ITargetContainer"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionBuilderBase.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionBuilderBase.html",
    "title": "Class ExpressionBuilderBase | Rezolver IOC Framework",
    "keywords": "Class ExpressionBuilderBase Abstract starting point for implementing IExpressionBuilder . Note that the interface is implemented explicitly; but exposes protected abstract or virtual methods for inheritors to extend. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase <TTarget> Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public abstract class ExpressionBuilderBase : IExpressionBuilder Remarks This class takes care of checking the type requested in the IExpressionCompileContext is compatible with the target that's passed to the Build(ITarget, IExpressionCompileContext, IExpressionCompiler) method Properties | Improve this Doc View Source IContainerScope_Resolve_Method Gets a MethodInfo object for the Resolve(ResolveContext, Func<ResolveContext, Object>, ScopeBehaviour) method for help in generating scope-interfacing code. Declaration protected MethodInfo IContainerScope_Resolve_Method { get; } Property Value Type Description MethodInfo | Improve this Doc View Source ITarget_SelectScope_Method Gets a MethodInfo object for the SelectScope(ResolveContext) method for help in generating scope-interfacing code. Declaration protected MethodInfo ITarget_SelectScope_Method { get; } Property Value Type Description MethodInfo | Improve this Doc View Source ResolveContext_CreateNew_Method_Type Gets a MethodInfo object for the Rezolver.ResolveContext.CreateNew(System.Type) method Declaration protected MethodInfo ResolveContext_CreateNew_Method_Type { get; } Property Value Type Description MethodInfo The type of the resolve context create new method. Methods | Improve this Doc View Source ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) Called by the BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) method. Applies the scoping behaviour to the builtExpression such that when it is executed it correctly interfaces with the active scope (from the ResolveContext ) if one is present for the given scopeBehaviour . Declaration protected virtual Expression ApplyScoping(ScopeBehaviour scopeBehaviour, Expression builtExpression, ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ScopeBehaviour scopeBehaviour The scoping behaviour for which the expression is to be adapted. If this is None , then the base class implementation will not generate any scoping code. Expression builtExpression The expression that was built for the target . ITarget target The target that is currently being compiled and from which the builtExpression was built. IExpressionCompileContext context The current active compilation context. IExpressionCompiler compiler The compiler. Returns Type Description Expression | Improve this Doc View Source Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Abstract method used as part implementation of the Build(ITarget, IExpressionCompileContext, IExpressionCompiler) It's called by BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) . Declaration protected abstract Expression Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context The context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression | Improve this Doc View Source BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) The core expression build function - takes care of handling mismatched types between the target and the requested type in the context - both checking compatibility and producing conversion expressions where necessary. Also performs cyclic dependency checking and rewriting expressions to take advantage of a target's ScopeBehaviour (which can be overriden with ScopeBehaviourOverride ) Declaration protected Expression BuildCore(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ITarget target The target to be compiled. IExpressionCompileContext context The context. IExpressionCompiler compiler The compiler. Returns Type Description Expression Remarks This class' implementation of Build(ITarget, IExpressionCompileContext, IExpressionCompiler) calls this, as does the derived abstract class ExpressionBuilderBase<TTarget> for its implementation of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) . It is this function that is responsible for calling the abstract Build(ITarget, IExpressionCompileContext, IExpressionCompiler) function, which deriving classes implement to actually produce their expression for the target . Exceptions Type Condition ArgumentException targetType doesn't support the context's TargetType InvalidOperationException The target is already being compiled. | Improve this Doc View Source CanBuild(ITarget, IExpressionCompileContext) Abstract method (implementation of CanBuild(ITarget, IExpressionCompileContext) ) which determines whether this instance can build an expression for the specified target. Declaration public abstract bool CanBuild(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context The compilation context. Returns Type Description Boolean Implements IExpressionBuilder.CanBuild(ITarget, IExpressionCompileContext) | Improve this Doc View Source GetContextCompiler(IExpressionCompileContext) Gets the IExpressionCompiler to be used to build the expression for the given target for the given context, if different from one passed to this class' implementation of Build(ITarget, IExpressionCompileContext, IExpressionCompiler) . This function is called by BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) which will throw an exception if it returns null and no compiler was provided to BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) (typically via the explicit implementation of IExpressionBuilder ). Declaration protected virtual IExpressionCompiler GetContextCompiler(IExpressionCompileContext context) Parameters Type Name Description IExpressionCompileContext context The current compile context. Returns Type Description IExpressionCompiler Remarks The base implementation simply attempts to resolve an instance of IExpressionCompiler from the Container which should, with the default configuration, resolve to the root ExpressionCompiler . In order for this to work, it is imperative that the underlying registered target implements the ICompiledTarget interface - so as to avoid needing a (or, more precisely, this) compiler needing to compile it. Explicit Interface Implementations | Improve this Doc View Source IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Explicit implementation of Build(ITarget, IExpressionCompileContext, IExpressionCompiler) - ultimately forwards the call to the BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) function. Declaration Expression IExpressionBuilder.Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ITarget target The target for which an expression is to be built IExpressionCompileContext context The compilation context. IExpressionCompiler compiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the implementation attempts to locate the context compiler using the GetContextCompiler(IExpressionCompileContext) method, and will throw an InvalidOperationException if it cannot do so. Returns Type Description Expression Implements IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Exceptions Type Condition ArgumentNullException target is null or context is null InvalidOperationException compiler is null and an IExpressionCompiler couldn't be resolved for the current context (via GetContextCompiler(IExpressionCompileContext) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also IExpressionBuilder"
  },
  "api/Rezolver.Compilation.Expressions.GenericConstructorTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.GenericConstructorTargetBuilder.html",
    "title": "Class GenericConstructorTargetBuilder | Rezolver IOC Framework",
    "keywords": "Class GenericConstructorTargetBuilder An IExpressionBuilder specialised for building expressions for GenericConstructorTarget targets. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < GenericConstructorTarget > GenericConstructorTargetBuilder Inherited Members ExpressionBuilderBase<GenericConstructorTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<GenericConstructorTarget>.IExpressionBuilder<GenericConstructorTarget>.Build(GenericConstructorTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<GenericConstructorTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class GenericConstructorTargetBuilder : ExpressionBuilderBase<GenericConstructorTarget>, IExpressionBuilder<GenericConstructorTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(GenericConstructorTarget, IExpressionCompileContext, IExpressionCompiler) Obtains the bound target for the target passed (by calling Bind(ICompileContext) , and passes it to the compiler to have an expression built for it. Declaration protected override Expression Build(GenericConstructorTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description GenericConstructorTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.GenericConstructorTarget>.Build(Rezolver.Targets.GenericConstructorTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.AliasTargetContainerExtensions.html": {
    "href": "api/Rezolver.AliasTargetContainerExtensions.html",
    "title": "Class AliasTargetContainerExtensions | Rezolver IOC Framework",
    "keywords": "Class AliasTargetContainerExtensions Contains extension methods for ITargetContainer to create targets which alias others by different types. Inheritance Object AliasTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public static class AliasTargetContainerExtensions Methods | Improve this Doc View Source RegisterAlias(ITargetContainer, Type, Type) Registers an alias for one type to another type. The created entry will effectively represent a second Resolve call into the container for the aliased type. Declaration public static void RegisterAlias(this ITargetContainer targetContainer, Type aliasType, Type originalType) Parameters Type Name Description ITargetContainer targetContainer The builder in which the alias is to be registered Type aliasType The type to be registered as an alias Type originalType The type being aliased. Remarks Use this when it's important that a given target type is always served through the same compiled target, even when the consumer expects it to be of a different type. A very common scenario is when you have a singleton instance of the originalType , and need to serve that same instance for aliasType . If you register the same singleton for both types, you get two separate singletons for each type, whereas if you create an alias, both will be served by the same alias. | Improve this Doc View Source RegisterAlias<TAlias, TOriginal>(ITargetContainer) Generic version of RegisterAlias(ITargetContainer, Type, Type) , see that method for more. Declaration public static void RegisterAlias<TAlias, TOriginal>(this ITargetContainer targetContainer) Parameters Type Name Description ITargetContainer targetContainer The target container in which the alias is to be registered Type Parameters Name Description TAlias Type being registered as an alias to another type TOriginal The target type of the alias."
  },
  "api/Rezolver.Compilation.Expressions.DefaultTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.DefaultTargetBuilder.html",
    "title": "Class DefaultTargetBuilder | Rezolver IOC Framework",
    "keywords": "Class DefaultTargetBuilder An IExpressionBuilder specialised for building the expression for the DefaultTarget target. Essentially, it just calls for the DeclaredType . Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < DefaultTarget > DefaultTargetBuilder Inherited Members ExpressionBuilderBase<DefaultTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DefaultTarget>.IExpressionBuilder<DefaultTarget>.Build(DefaultTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DefaultTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class DefaultTargetBuilder : ExpressionBuilderBase<DefaultTarget>, IExpressionBuilder<DefaultTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(DefaultTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target for the given ICompileContext Declaration protected override Expression Build(DefaultTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description DefaultTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.DefaultTarget>.Build(Rezolver.Targets.DefaultTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.IExpressionCompiler.html": {
    "href": "api/Rezolver.Compilation.Expressions.IExpressionCompiler.html",
    "title": "Interface IExpressionCompiler | Rezolver IOC Framework",
    "keywords": "Interface IExpressionCompiler Interface for an object which is responsible for coordinating the production of expressions for targets during the compilation phase. Objects implementing this are expected to be implementations of ITargetCompiler ; this library provides the one implementation, too: ExpressionCompiler . Inherited Members ITargetCompiler.CompileTarget(ITarget, ICompileContext) Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public interface IExpressionCompiler : ITargetCompiler Remarks All expressions are built to be called from the GetObject(ResolveContext) function which, in turn, is typically called in response to a container's Resolve(ResolveContext) function being called. Note that the Build(ITarget, IExpressionCompileContext) method declared here is effectively an analogue to the Build(ITarget, IExpressionCompileContext, IExpressionCompiler) . Indeed, the default implementation resolves IExpressionBuilder instances to delegate the building of expressions. Methods | Improve this Doc View Source Build(ITarget, IExpressionCompileContext) Gets an unoptimised expression containing the logic required to create or fetch an instance of the target 's DeclaredType when invoked for a particular ResolveContext . Use this method if you want the raw expression for a target (possibly when integrating it into your own expressions during custom compilation). Declaration Expression Build(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context Contains the supporting expressions (shared locals, shared expressions, ResolveContext expression etc) that have been used in the generation of the expression. Returns Type Description Expression Remarks If you want to build the optimised code for the passed target, you should use the BuildResolveLambda(IExpressionCompiler, ITarget, IExpressionCompileContext) extension method, which uses this method and then passes the result to the BuildResolveLambda(Expression, IExpressionCompileContext) function also defined on this interface. | Improve this Doc View Source BuildResolveLambda(Expression, IExpressionCompileContext) This function optimises and prepares an expression that's (most likely) previously been produced by the Build(ITarget, IExpressionCompileContext) function into a lambda expression which can be compiled into a delegate and executed; or quoted inside another expression as a callback. The ResolveContextExpression of the context will be used to define the single parameter for the lambda that is created. Declaration Expression<Func<ResolveContext, object>> BuildResolveLambda(Expression targetExpression, IExpressionCompileContext context) Parameters Type Name Description Expression targetExpression Expression to be optimised and used as the body of the lambda. Any expression produced by the Build(ITarget, IExpressionCompileContext) method must be compatible with this. IExpressionCompileContext context Contains the supporting expressions (shared locals, shared expressions, ResolveContext expression etc) that have been used in the generation of the expression. Returns Type Description Expression < Func < ResolveContext , Object >> A lambda expression which, when compiled and executed, will produce an object consistent with the ITarget from which the code was produced. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) ExpressionCompilerBuildExtensions.BuildResolveLambda(IExpressionCompiler, ITarget, IExpressionCompileContext)"
  },
  "api/Rezolver.Compilation.Expressions.ScopedTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ScopedTargetBuilder.html",
    "title": "Class ScopedTargetBuilder | Rezolver IOC Framework",
    "keywords": "Class ScopedTargetBuilder An IExpressionBuilder specialised for building expressions for ScopedTarget targets. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ScopedTarget > ScopedTargetBuilder Inherited Members ExpressionBuilderBase<ScopedTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ScopedTarget>.IExpressionBuilder<ScopedTarget>.Build(ScopedTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ScopedTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class ScopedTargetBuilder : ExpressionBuilderBase<ScopedTarget>, IExpressionBuilder<ScopedTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ScopedTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(ScopedTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ScopedTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ScopedTarget>.Build(Rezolver.Targets.ScopedTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.ICompilerConfigurationProvider.html": {
    "href": "api/Rezolver.Compilation.ICompilerConfigurationProvider.html",
    "title": "Interface ICompilerConfigurationProvider | Rezolver IOC Framework",
    "keywords": "Interface ICompilerConfigurationProvider Interface for an object which configures the compiler for the given container and/or targets object to use a specific ITargetCompiler and ICompileContextProvider . Used by all the standard container types in the Rezolver framework. You can provide a specific provider to most containers on creation, and you can configure the default system-wide provider via the DefaultProvider static property. Namespace :Rezolver.Compilation Assembly :rezolver-docfx.dll Syntax public interface ICompilerConfigurationProvider Methods | Improve this Doc View Source Configure(IContainer, ITargetContainer) Called to configure the compiler and context provider for the given container and/or targets. When using the standard container types (based on ContainerBase ), the method should register directly-resolvable targets in the targets target container for the types ITargetCompiler and ICompileContextProvider so that the container can resolve the compiler and context provider. Declaration void Configure(IContainer container, ITargetContainer targets) Parameters Type Name Description IContainer container The container. ITargetContainer targets The targets. Remarks The built-in container classes (all those which inherit from ContainerBase ) rely on their ITargetContainer to directly resolve the compiler and context provider that is used to compile ITarget objects into ICompiledTarget instances. Therefore, in order to use a specific compilation strategy, the framework needs some way of knowing how the underlying ITargetContainer should be configured to use that strategy. Since this requires adding registrations to the container, the most flexible way to do that is via a callback, which is what this method technically represents. Note that the registered targets must NOT require compilation - i.e. - the target must either directly implement ITargetCompiler / ICompileContextProvider or also implement ICompiledTarget such that when GetObject(ResolveContext) is called, the actual compiler or context provider are returned. The simplest way to achieve this is to build the compiler/context provider conventionally, and then use the ObjectTarget target to store them directly in the target container against the types for which they should be used. This is how the default expression compiler does it - in addition to registering additional targets to support the different compilation strategies required for the different target types. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ContainerBase.MissingCompiledTarget.html": {
    "href": "api/Rezolver.ContainerBase.MissingCompiledTarget.html",
    "title": "Class ContainerBase.MissingCompiledTarget | Rezolver IOC Framework",
    "keywords": "Class ContainerBase.MissingCompiledTarget Used as a sentinel type when a type cannot be resolved by a ContainerBase instance. Instead of returning a null ICompiledTarget instance, the container will construct an instance of this type (typically through GetMissingTarget(Type) , which caches singleton instances of this class on a per-type basis) which can then be used just as if the lookup succeeded. Inheritance Object ContainerBase.MissingCompiledTarget Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax protected class MissingCompiledTarget : ICompiledTarget Remarks The GetObject(ResolveContext) always throws an InvalidOperationException with the message 'Could resolve type [[type]]' Constructors | Improve this Doc View Source MissingCompiledTarget(Type) Constructs a new instance of the ContainerBase.MissingCompiledTarget class. Declaration public MissingCompiledTarget(Type type) Parameters Type Name Description Type type Methods | Improve this Doc View Source GetObject(ResolveContext) Implementation of GetObject(ResolveContext) . Always throws an InvalidOperationException . Declaration public object GetObject(ResolveContext context) Parameters Type Name Description ResolveContext context The current rezolve context. Returns Type Description Object Implements ICompiledTarget.GetObject(ResolveContext) Exceptions Type Condition InvalidOperationException Always thrown. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also ICompiledTarget"
  },
  "api/Rezolver.DelegateTargetContainerExtensions.html": {
    "href": "api/Rezolver.DelegateTargetContainerExtensions.html",
    "title": "Class DelegateTargetContainerExtensions | Rezolver IOC Framework",
    "keywords": "Class DelegateTargetContainerExtensions Extension methods for ITargetContainer designed to simplify the registration of DelegateTarget and its numerous generic variants. Inheritance Object DelegateTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public static class DelegateTargetContainerExtensions Methods | Improve this Doc View Source RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) Constructs a DelegateTarget from the passed factory delegate (optionally with the given declaredType ) and registers it in the target container. Declaration public static void RegisterDelegate(this ITargetContainer targetContainer, Delegate factory, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targetContainer The target container in which the new target is to registered Delegate factory The factory delegate that is to be executed by the DelegateTarget that is created. Type declaredType Optional - if provided, then it overrides the DeclaredType of the DelegateTarget that is created which, in turn, will change the type against which the target will be registered in the target container. If null, then the return type of the factory will be used. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the factory delegate will be tracked if the target is executed within an IContainerScope . The default is Implicit . | Improve this Doc View Source RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) Registers a DelegateTarget built from a parameterless factory delegate which returns an instance of TResult Declaration public static void RegisterDelegate<TResult>(this ITargetContainer targets, Func<TResult> factory, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered Func <TResult> factory Required. The factory delegate which is to be executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the factory delegate will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description TResult The type of the object produced by the factory delegate. | Improve this Doc View Source RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) Registers a DelegateTarget built from a factory delegate which takes a ResolveContext and which returns an instance of TResult Declaration public static void RegisterDelegate<TResult>(this ITargetContainer targets, Func<ResolveContext, TResult> factory, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered Func < ResolveContext , TResult> factory Required. The factory delegate which is to be executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the factory delegate will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description TResult The type of the object produced by the factory delegate. | Improve this Doc View Source RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) Registers a DelegateTarget built from a factory delegate which takes 1 argument and which returns an instance of TResult Declaration public static void RegisterDelegate<T1, TResult>(this ITargetContainer targets, Func<T1, TResult> factory, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered Func <T1, TResult> factory Required. The factory delegate which is to be executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the factory delegate will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st delegate parameter TResult The type of the object produced by the factory delegate. | Improve this Doc View Source RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) Registers a DelegateTarget built from a factory delegate which takes 2 arguments and which returns an instance of TResult Declaration public static void RegisterDelegate<T1, T2, TResult>(this ITargetContainer targets, Func<T1, T2, TResult> factory, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered Func <T1, T2, TResult> factory Required. The factory delegate which is to be executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the factory delegate will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st delegate parameter T2 Type of the 2nd delegate parameter TResult The type of the object produced by the factory delegate. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) Registers a DelegateTarget built from a factory delegate which takes 3 arguments and which returns an instance of TResult Declaration public static void RegisterDelegate<T1, T2, T3, TResult>(this ITargetContainer targets, Func<T1, T2, T3, TResult> factory, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered Func <T1, T2, T3, TResult> factory Required. The factory delegate which is to be executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the factory delegate will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st delegate parameter T2 Type of the 2nd delegate parameter T3 Type of the 3rd delegate parameter TResult The type of the object produced by the factory delegate. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) Registers a DelegateTarget built from a factory delegate which takes 4 arguments and which returns an instance of TResult Declaration public static void RegisterDelegate<T1, T2, T3, T4, TResult>(this ITargetContainer targets, Func<T1, T2, T3, T4, TResult> factory, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered Func <T1, T2, T3, T4, TResult> factory Required. The factory delegate which is to be executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the factory delegate will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st delegate parameter T2 Type of the 2nd delegate parameter T3 Type of the 3rd delegate parameter T4 Type of the 4th delegate parameter TResult The type of the object produced by the factory delegate. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) Registers a DelegateTarget built from a factory delegate which takes 5 arguments and which returns an instance of TResult Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, TResult>(this ITargetContainer targets, Func<T1, T2, T3, T4, T5, TResult> factory, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered Func <T1, T2, T3, T4, T5, TResult> factory Required. The factory delegate which is to be executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the factory delegate will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st delegate parameter T2 Type of the 2nd delegate parameter T3 Type of the 3rd delegate parameter T4 Type of the 4th delegate parameter T5 Type of the 5th delegate parameter TResult The type of the object produced by the factory delegate."
  },
  "api/Rezolver.Compilation.Expressions.RedundantConvertRewriter.html": {
    "href": "api/Rezolver.Compilation.Expressions.RedundantConvertRewriter.html",
    "title": "Class RedundantConvertRewriter | Rezolver IOC Framework",
    "keywords": "Class RedundantConvertRewriter Removes unnecessary convert expressions from an expression. An unnecessary conversion is one where the target type is equal to, or a base of, the source type. Only boxing/unboxing conversions or upcasts are left intact. Inheritance Object RedundantConvertRewriter Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class RedundantConvertRewriter : ExpressionVisitor Methods | Improve this Doc View Source VisitUnary(UnaryExpression) Visits the children of the UnaryExpression . Declaration protected override Expression VisitUnary(UnaryExpression node) Parameters Type Name Description UnaryExpression node The expression to visit. Returns Type Description Expression Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.ICompileContext.html": {
    "href": "api/Rezolver.Compilation.ICompileContext.html",
    "title": "Interface ICompileContext | Rezolver IOC Framework",
    "keywords": "Interface ICompileContext Tracks state and provides services during the compilation phase in which ITarget targets are compiled into ICompiledTarget targets, which produce actual instances of objects. Inherited Members ITargetContainer.Register(ITarget, Type) ITargetContainer.Fetch(Type) ITargetContainer.FetchAll(Type) ITargetContainer.CombineWith(ITargetContainer, Type) Namespace :Rezolver.Compilation Assembly :rezolver-docfx.dll Syntax public interface ICompileContext : ITargetContainer Remarks Implementations must also implement the ITargetContainer so the compile context can be used for dependency lookups during compilation time. Indeed, if you are developing your own compilation component (possibly for a custom ITarget implementation) and need to resolve any dependencies from an ITargetContainer during compilation, it should be done through the context's implementation of ITargetContainer. Properties | Improve this Doc View Source CompileStack Gets the stack entries for all the targets that are being compiled. Declaration IEnumerable<CompileStackEntry> CompileStack { get; } Property Value Type Description IEnumerable < CompileStackEntry > The compile stack. | Improve this Doc View Source Container The container that is considered the current compilation 'scope' - i.e. the container for which the compilation is being performed and, usually, the one on which the Resolve(ResolveContext) method was originally called which triggered the compilation call. Declaration IContainer Container { get; } Property Value Type Description IContainer | Improve this Doc View Source ParentContext Gets the parent context from which this context was created, if applicable. Declaration ICompileContext ParentContext { get; } Property Value Type Description ICompileContext The parent context. | Improve this Doc View Source ScopeBehaviourOverride If not null then this overrides the ScopeBehaviour of the ITarget that's currently being compiled. Declaration ScopeBehaviour? ScopeBehaviourOverride { get; } Property Value Type Description Nullable < ScopeBehaviour > | Improve this Doc View Source TargetType Any ICompiledTarget built for a ITarget with this context should target this type. If null, then the DeclaredType of the target being compiled should be used. Declaration Type TargetType { get; } Property Value Type Description Type Methods | Improve this Doc View Source NewContext(Type, Nullable<ScopeBehaviour>) Creates a new child context from this one, except the TargetType and ScopeBehaviourOverride properties can be overriden if required. Implementations must make sure that the ScopeBehaviourOverride is never inherited. Declaration ICompileContext NewContext(Type targetType = null, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Nullable < ScopeBehaviour > scopeBehaviourOverride Override the ScopeBehaviourOverride to be used for the target that is compiled with the new context. This is never inherited automatically from one context to another. Returns Type Description ICompileContext A new ICompileContext . | Improve this Doc View Source PopCompileStack() Pops the compile stack, returning the entry that was popped. Declaration CompileStackEntry PopCompileStack() Returns Type Description CompileStackEntry | Improve this Doc View Source PushCompileStack(ITarget, Type) Pushes the passed target on to the compile stack if it's not already on it for the same TargetType Compilers should consult the return value and abort compilation if it's true - since that implies a cyclic dependency graph. Declaration bool PushCompileStack(ITarget toCompile, Type targetType = null) Parameters Type Name Description ITarget toCompile To compile. Type targetType The type for which the target is being compiled, if different from DeclaredType Returns Type Description Boolean Remarks Targets can appear on the compilation stack more than once for different types, since the ICompiledTarget produced for a target for one type can be different than it is for another. Ultimately, if a target does in fact have a cyclic dependency graph, then this method will detect that. Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also ITargetContainer"
  },
  "api/Rezolver.Container.html": {
    "href": "api/Rezolver.Container.html",
    "title": "Class Container | Rezolver IOC Framework",
    "keywords": "Class Container The standard IOC container class in Rezolver. Inheritance Object ContainerBase CachingContainerBase Container OverridingContainer ScopedContainer Inherited Members CachingContainerBase.GetCompiledRezolveTarget(ResolveContext) ContainerBase.NoChangeCompilerConfiguration ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Targets ContainerBase.Resolve(ResolveContext) ContainerBase.TryResolve(ResolveContext, Object) ContainerBase.CreateScope() ContainerBase.FetchCompiled(ResolveContext) ContainerBase.CanResolve(ResolveContext) ContainerBase.GetFallbackCompiledRezolveTarget(ResolveContext) ContainerBase.IServiceProvider.GetService(Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) ContainerBase.ITargetContainer.Fetch(Type) ContainerBase.ITargetContainer.FetchAll(Type) ContainerBase.ITargetContainer.CombineWith(ITargetContainer, Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class Container : CachingContainerBase, IContainer, IServiceProvider, IScopeFactory, ITargetContainer Remarks All of this class' functionality is inherited through CachingContainerBase and its base classes. Note that it doesn't implement lifetime scoping (although you can create a lifetime scope from it by calling its CreateScope() method). Also note that the class implements ITargetContainer through its ContainerBase base (which merely wraps around the Targets property. The reason for this is simplicity: in many applications, you'll want to simply create a new container, register services into it, and then start using it. Constructors | Improve this Doc View Source Container(ICompilerConfigurationProvider) Constructs a new instance of the Container class using a default empty ITargetContainer Declaration public Container(ICompilerConfigurationProvider compilerConfig) Parameters Type Name Description ICompilerConfigurationProvider compilerConfig An object which will be used to configure this container and its targets to use a specific compilation strategy. If null , then the DefaultProvider provider will be used. | Improve this Doc View Source Container(ITargetContainer) Constructs a new instance of the Container class using the given target container and the default compiler configuration ( DefaultProvider ). Declaration public Container(ITargetContainer targets) Parameters Type Name Description ITargetContainer targets The targets that will be used to resolve objects. If left null, then a new, empty, target container will be constructed. | Improve this Doc View Source Container(ITargetContainer, ICompilerConfigurationProvider) Constructs a new instance of the Container class. Declaration public Container(ITargetContainer targets = null, ICompilerConfigurationProvider compilerConfig = null) Parameters Type Name Description ITargetContainer targets Optional. The targets that will be used to resolve objects. If left null, then a new, empty, target container will be constructed. ICompilerConfigurationProvider compilerConfig Optional. An object which will be used to configure this container and its targets to use a specific compilation strategy. If null , then the DefaultProvider provider will be used. Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.DecoratingTargetContainer.html": {
    "href": "api/Rezolver.DecoratingTargetContainer.html",
    "title": "Class DecoratingTargetContainer | Rezolver IOC Framework",
    "keywords": "Class DecoratingTargetContainer Implements service decoration in an ITargetContainer , producing instances of the DecoratorTarget when Fetch(Type) or FetchAll(Type) are called. The best way to add a decorator to your target container is to use the extension method RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) or its non-generic equivalent. Inheritance Object DecoratingTargetContainer Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class DecoratingTargetContainer : ITargetContainerOwner, ITargetContainer Remarks This class does not implement ITarget , rather it's an ITargetContainerOwner into which other targets can be added, and when Fetch(Type) or FetchAll(Type) are called, a temporary DecoratorTarget is created which wraps around the targets that have been registered within and which will ultimately create instances of DecoratorType Constructors | Improve this Doc View Source DecoratingTargetContainer(Type, Type) Initializes a new instance of the DecoratingTargetContainer class. Declaration public DecoratingTargetContainer(Type decoratorType, Type decoratedType) Parameters Type Name Description Type decoratorType Type of the decorator. Type decoratedType Type being decorated. Properties | Improve this Doc View Source DecoratedType Gets the type that's being decorated - in essence, this is the type that this decorator target Declaration public Type DecoratedType { get; } Property Value Type Description Type | Improve this Doc View Source DecoratorType Gets the type which will be used to decorate the instances produced by targets in this decorator target. Declaration public Type DecoratorType { get; } Property Value Type Description Type Methods | Improve this Doc View Source CombineWith(ITargetContainer, Type) Implements CombineWith(ITargetContainer, Type) by wrapping the existing container and returning itself. This allows decorators to be applied on top of decorators; and decorators to be added after types have begun to be registered in another target container. Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing The existing ITargetContainer instance that this instance is to be combined with Type type The type that the combined container owner will be registered under. Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) Exceptions Type Condition InvalidOperationException If this target container is already decorating another container | Improve this Doc View Source Fetch(Type) Implementation of Fetch(Type) - wraps a special target around the target returned by the target container that's decorated by this one. Declaration public ITarget Fetch(Type type) Parameters Type Name Description Type type Required. The type for which an ITarget is to be retrieved. Returns Type Description ITarget Implements ITargetContainer.Fetch(Type) Remarks If the inner container returns null, then so does this one. | Improve this Doc View Source FetchAll(Type) Implementation of FetchAll(Type) - passes the call on to the inner container that's decorated by this one, and then wraps each of those targets in a DecoratorTarget which represents the decoration logic for each instance. Declaration public IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type Required. The type for which the ITarget instances are to be retrieved. Returns Type Description IEnumerable < ITarget > Implements ITargetContainer.FetchAll(Type) | Improve this Doc View Source FetchContainer(Type) Retrieves an existing container registered against the given type , or null if not found. Declaration public ITargetContainer FetchContainer(Type type) Parameters Type Name Description Type type The type. Returns Type Description ITargetContainer Implements ITargetContainerOwner.FetchContainer(Type) Remarks This is an implementation of FetchContainer(Type) which wraps around the inner target container and passes the call on to that. Exceptions Type Condition InvalidOperationException If this decorator's inner container isn't an instance of ITargetContainerOwner | Improve this Doc View Source Register(ITarget, Type) Registers a target, either for the serviceType specified or, if null, the DeclaredType of the target . Implementation of Register(ITarget, Type) . Declaration public void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target Required. The target to be registered Type serviceType Optional. The type the target is to be registered against, if different from the DeclaredType of the target . If provided, then the target must be compatible with this type. Implements ITargetContainer.Register(ITarget, Type) Remarks The decorator target does not accept registrations directly; rather it passes the call on to its inner container which could be a TargetListContainer , or GenericTargetContainer in the most basic cases; or it could be another DecoratingTargetContainer in situations where a type has had multiple decorators registered against it. | Improve this Doc View Source RegisterContainer(Type, ITargetContainer) Implementation of RegisterContainer(Type, ITargetContainer) - the call is automatically forwarded on to the inner target container that's being decorated, since decorator targets don't support direct registration of targets or containers. Declaration public void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type The type. ITargetContainer container The container. Implements ITargetContainerOwner.RegisterContainer(Type, ITargetContainer) Exceptions Type Condition InvalidOperationException This decorator must be decorating another ITargetContainerOwner , or be decorating a generic type Extension Methods EnumerableTargetBuilderExtensions.EnableEnumerableResolving(ITargetContainerOwner) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) DecoratorTargetContainerExtensions.RegisterDecorator(ITargetContainerOwner, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.GenericTargetContainer.html": {
    "href": "api/Rezolver.GenericTargetContainer.html",
    "title": "Class GenericTargetContainer | Rezolver IOC Framework",
    "keywords": "Class GenericTargetContainer A special type of ITargetContainerOwner which stores targets (and potentially other containers) which are specifically keyed either to a particular open generic type or a closed generic built from it. Inheritance Object TargetDictionaryContainer GenericTargetContainer Inherited Members TargetDictionaryContainer.FetchContainer(Type) TargetDictionaryContainer.RegisterContainer(Type, ITargetContainer) TargetDictionaryContainer.CreateContainer(Type, ITarget) TargetDictionaryContainer.CombineWith(ITargetContainer, Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class GenericTargetContainer : TargetDictionaryContainer, ITargetContainerOwner, ITargetContainer Remarks You don't typically use this container directly - it is implicitly added to an ITargetContainer when generic types are registered. Indeed the TargetContainer and DecoratingTargetContainer booth create instances of this; and the Rezolver.EnumerableTargetContainer (understandably) inherits from it. Constructors | Improve this Doc View Source GenericTargetContainer(Type) Initializes a new instance of the GenericTargetContainer class. Declaration public GenericTargetContainer(Type genericType) Parameters Type Name Description Type genericType Required. The generic type definition that all targets and subcontainers will be grouped under. Properties | Improve this Doc View Source GenericType Gets the open generic type definition which is common to all targets and containers within this container. Declaration public Type GenericType { get; } Property Value Type Description Type Methods | Improve this Doc View Source Fetch(Type) Gets the target which can be used to build an instance of type . Declaration public override ITarget Fetch(Type type) Parameters Type Name Description Type type Required. The type for which a target is to be obtained. Because of the restrictions placed on the DeclaredType of the targets that can actually be registered into this container, the function will only ever return anything if type is a closed generic type whose definition equals GenericType . Returns Type Description ITarget Overrides TargetDictionaryContainer.Fetch(Type) Remarks Targets which have been registered specifically against the exact closed generic type represented by type take precedence over any targets which have been registered against the open generic type GenericType . | Improve this Doc View Source FetchAll(Type) Implementation of FetchAll(Type) Declaration public override IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type The type whose targets are to be retrieved. Returns Type Description IEnumerable < ITarget > Overrides TargetDictionaryContainer.FetchAll(Type) | Improve this Doc View Source Register(ITarget, Type) Overrides the Register(ITarget, Type) method to support registering both targets against the open generic type GenericType and against specific closed versions of that open generic type. Declaration public override void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target The target to be registered Type serviceType Service type against which the registration will be made. If null, then it will be assumed to be equal to GenericType . Only types equal to GenericType or generic types whose generic type definition is equal to GenericType are supported. Overrides TargetDictionaryContainer.Register(ITarget, Type) Remarks Notes to overriders: When serviceType is a closed generic type, this function creates an ITargetContainer for that serviceType by calling the protected method CreateContainer(Type, ITarget) if one doesn't exist (it calls FetchContainer(Type) to check for existence), and then chains to its Register(ITarget, Type) method. Exceptions Type Condition ArgumentException If serviceType is not equal to GenericType or is not a closed generic type whose generic type definition is GenericType . Extension Methods EnumerableTargetBuilderExtensions.EnableEnumerableResolving(ITargetContainerOwner) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) DecoratorTargetContainerExtensions.RegisterDecorator(ITargetContainerOwner, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also TargetDictionaryContainer"
  },
  "api/Rezolver.IScopeFactory.html": {
    "href": "api/Rezolver.IScopeFactory.html",
    "title": "Interface IScopeFactory | Rezolver IOC Framework",
    "keywords": "Interface IScopeFactory Represents an object from which a scope can be created Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public interface IScopeFactory Methods | Improve this Doc View Source CreateScope() Creates a new scope. If the implementing object is also a scope, then the new scope must be created as a child scope of that scope. Declaration IContainerScope CreateScope() Returns Type Description IContainerScope Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ITarget.html": {
    "href": "api/Rezolver.ITarget.html",
    "title": "Interface ITarget | Rezolver IOC Framework",
    "keywords": "Interface ITarget Represents an action to be performed in order to obtain an object to satisfy a call to Resolve(ResolveContext) , when the standard implementations of IContainer are used (e.g. Container ). Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public interface ITarget Remarks As mentioned in the summary, the role of this interface is largely determined by the framework's own standard implementations of the IContainer interface - all of which use an ITargetContainer to store service registrations which, when Resolve(ResolveContext) is called, is queried to obtain one or more targets which will have been registered for the requested type. After obtaining a target, an ITargetCompiler is then used to compile the target(s) into an ICompiledTarget whose GetObject(ResolveContext) method will ultimately then be called to 'resolve' the instance. The role of the target, then, is to act as a description of the action that is to be performed by that compiled target that is built from it. The interface doesn't describe the type of target in hand - it only provides the core data required to query the static type of the target (the type of object that the target will produce) and to determine compatibility with a request for a particular type. The framework's many implementations of this interface - e.g. ConstructorTarget , SingletonTarget , ResolvedTarget plus many others - then define the behaviour and any additional data required in order for a compiler to produce an ICompiledTarget which matches the target's intent. E.g, the ConstructorTarget , which represents creating a new instance via a constructor, provides all the necessary information to bind to the correct constructor (including parameter bindings etc) - and the compiler's job is to translate that into an ICompiledTarget which executes that constructor, returning the result. Properties | Improve this Doc View Source DeclaredType Gets the static type of the object produced from this target. For example, if this target represents executing a constructor on a type, then this property should equal the type to which that constructor belongs. Declaration Type DeclaredType { get; } Property Value Type Description Type | Improve this Doc View Source ScopeBehaviour Gets the scoping behaviour for instances that will ultimately be produced by this target. Declaration ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. | Improve this Doc View Source UseFallback If true , then the consumer should consider falling back to a more suitable target if available, as the object produced from this target is most likely a default of some kind - e.g. empty enumerable, default parameter value. Declaration bool UseFallback { get; } Property Value Type Description Boolean Methods | Improve this Doc View Source SelectScope(ResolveContext) Selects the scope in which instances produced from this target should be tracked. This should be executed only during a resolve operation when a scope is detected. Declaration IContainerScope SelectScope(ResolveContext context) Parameters Type Name Description ResolveContext context The context passed to a container's Resolve(ResolveContext) method. Returns Type Description IContainerScope | Improve this Doc View Source SupportsType(Type) Returns a boolean indicating whether the target is able to produce an instance of, or an instance that is compatible with, the passed type . Declaration bool SupportsType(Type type) Parameters Type Name Description Type type The type. Returns Type Description Boolean true if type is supported, false otherwise. Remarks It is strongly suggested that you use this method to check whether the target can construct an instance of a given type rather than performing any type checking yourself on the DeclaredType , because an ITarget might be able to support a much wider range of types other than just those which are directly compatible with its DeclaredType . For example, the GenericConstructorTarget is statically bound to an open generic, so therefore traditional type checks on the DeclaredType do not work. That class' implementation of this method, however, contains the complex logic necessary to determine if the open generic can be closed into a generic type which is compatible with the given type . Implementations of ITargetCompiler should always consult this function in their implementation of CompileTarget(ITarget, ICompileContext) to determine if the target is compatible with the TargetType of the CompileContext Please note that any type that's a generic type definition will always yield a false result, because it's impossible to build an instance of an open generic type. Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.SingletonTargetContainerExtensions.html": {
    "href": "api/Rezolver.SingletonTargetContainerExtensions.html",
    "title": "Class SingletonTargetContainerExtensions | Rezolver IOC Framework",
    "keywords": "Class SingletonTargetContainerExtensions Extension methods for the ITargetContainer interface which simplify the registration of singletons. Inheritance Object SingletonTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public static class SingletonTargetContainerExtensions Methods | Improve this Doc View Source RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) Registers the type objectType as a singleton ( SingletonTarget ) in the target container using either objectType as the service type, or serviceType instead - if it's provided. The instance will be built automatically with constructor injection (and, optionally, property injection if a memberBinding is passed) by leveraging the ConstructorTarget or GenericConstructorTarget targets. Declaration public static void RegisterSingleton(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registrations will be made. Type objectType Required. The type of object to be created. Type serviceType Optional. The type against which the target will be registered in the targetContainer IMemberBindingBehaviour memberBinding Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. | Improve this Doc View Source RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) Registers the type TObject as a singleton ( SingletonTarget ) in the target container. The instance will be built automatically with constructor injection (and, optionally, property injection if a memberBinding is passed) by leveraging the ConstructorTarget or GenericConstructorTarget targets. Declaration public static void RegisterSingleton<TObject>(this ITargetContainer targetContainer, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registrations will be made. IMemberBindingBehaviour memberBinding Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type to be created, and the type against which the registration will be made | Improve this Doc View Source RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) Registers the type TObject as a singleton ( SingletonTarget ) in the target container for the service type TService . The instance will be built automatically with constructor injection (and, optionally, property injection if a memberBinding is passed) by leveraging the ConstructorTarget or GenericConstructorTarget targets. Declaration public static void RegisterSingleton<TObject, TService>(this ITargetContainer targetContainer, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registrations will be made. IMemberBindingBehaviour memberBinding Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of object to be created. TService The type against which the target will be registered in the targetContainer"
  },
  "api/Rezolver.TargetContainer.html": {
    "href": "api/Rezolver.TargetContainer.html",
    "title": "Class TargetContainer | Rezolver IOC Framework",
    "keywords": "Class TargetContainer Root container for ITarget s that can be used as the backing for the standard IContainer classes - Container and ScopedContainer . Stores and retrieves registrations of ITarget s, is also Generic type aware, unlike its base class - TargetDictionaryContainer . Inheritance Object TargetDictionaryContainer TargetContainer ChildTargetContainer Inherited Members TargetDictionaryContainer.Fetch(Type) TargetDictionaryContainer.FetchAll(Type) TargetDictionaryContainer.CombineWith(ITargetContainer, Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class TargetContainer : TargetDictionaryContainer, ITargetContainerOwner, ITargetContainer Remarks This is the type used by default for the Targets of all the standard containers in the core framework, e.g. Container , ScopedContainer etc, when you don't supply an instance of an ITargetContainer explicitly on construction. Constructors | Improve this Doc View Source TargetContainer(Boolean) Constructs a new instance of the TargetContainer class Declaration public TargetContainer(bool autoRezolveIEnumerable = true) Parameters Type Name Description Boolean autoRezolveIEnumerable If true, then IEnumerable<T> will be automatically resolved as a concatenation of all the ITarget s that are registered against a particular type. Note - this parameter might be removed in a future version - you can achieve the same thing by using the extension method EnableEnumerableResolving(ITargetContainerOwner) Methods | Improve this Doc View Source CreateContainer(Type, ITarget) Called to create and register a container for the given serviceType and target . This class overrides the base version ( CreateContainer(Type, ITarget) ) to create a specialised container for generic types ( GenericTargetContainer ) if serviceType if a generic type or generic type definition. Declaration protected override ITargetContainer CreateContainer(Type serviceType, ITarget target) Parameters Type Name Description Type serviceType The type for which a container is to be created and registered. ITarget target Optional. The target that will be added to the container that is returned. Returns Type Description ITargetContainer An ITargetContainer in which the passed target will be registered. Overrides TargetDictionaryContainer.CreateContainer(Type, ITarget) Remarks The main caller for this method will be the base Register method, which will create a new container for a target that's being registered against a new type. It is, however, also called by this class' implementation of RegisterContainer(Type, ITargetContainer) when the type is a generic type - as all generics must have a container registered against their generic type definitions as a starting point. | Improve this Doc View Source CreateGenericTypeDefContainer(Type, ITarget) Called by CreateContainer(Type, ITarget) to create a container suitable for handling targets that are registered against generic types. Declaration protected virtual ITargetContainer CreateGenericTypeDefContainer(Type genericTypeDefinition, ITarget target) Parameters Type Name Description Type genericTypeDefinition Will be an open generic type (generic type definition) ITarget target Optional. The initial target for which the container is being constructed Returns Type Description ITargetContainer The base implementation always creates an instance of CreateGenericTypeDefContainer(Type, ITarget) | Improve this Doc View Source FetchContainer(Type) Retrieves Declaration public override ITargetContainer FetchContainer(Type type) Parameters Type Name Description Type type Returns Type Description ITargetContainer Overrides TargetDictionaryContainer.FetchContainer(Type) | Improve this Doc View Source Register(ITarget, Type) Overrides the base method to block registration if the target does not support the serviceType (checked by calling the target's SupportsType(Type) method). Declaration public override void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target The target to be registered. Type serviceType Optional - the type against which the target is to be registered, if different from the target's DeclaredType . Overrides TargetDictionaryContainer.Register(ITarget, Type) | Improve this Doc View Source RegisterContainer(Type, ITargetContainer) Overrides the base method so that if type is a generic type, then the container will be registered inside another which will be registered for the generic type definition first. Declaration public override void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container Overrides TargetDictionaryContainer.RegisterContainer(Type, ITargetContainer) | Improve this Doc View Source RegisterContainerDirect(Type, ITargetContainer) Version of RegisterContainer(Type, ITargetContainer) which does not interrogate the type to see if it's generic - simply registers the passed container directly against the passed type (it just chains through directly to the RegisterContainer(Type, ITargetContainer) method non-virtually. Declaration protected virtual void RegisterContainerDirect(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container Extension Methods EnumerableTargetBuilderExtensions.EnableEnumerableResolving(ITargetContainerOwner) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) DecoratorTargetContainerExtensions.RegisterDecorator(ITargetContainerOwner, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.TargetCreationExtensions.html": {
    "href": "api/Rezolver.TargetCreationExtensions.html",
    "title": "Class TargetCreationExtensions | Rezolver IOC Framework",
    "keywords": "Class TargetCreationExtensions Has been replaced by the Target static class, and will be removed in 1.2 Inheritance Object TargetCreationExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax [Obsolete(\"This static class has been replaced by the Target static class and will be obsoleted in 1.2, please remove all references to it\")] public static class TargetCreationExtensions Methods | Improve this Doc View Source AsDelegateTarget(Delegate, Type) This method will be removed in 1.2 in favour of the Target.ForDelegate static methods Creates a DelegateTarget from the factory which can be registered in an ITargetContainer to resolve an instance of a type compatible with the delegate's return type and, optionally, with the declaredType Declaration [Obsolete(\"This method will be removed in 1.2 in favour of the Target.ForDelegate static methods\")] public static DelegateTarget AsDelegateTarget(this Delegate factory, Type declaredType = null) Parameters Type Name Description Delegate factory The delegate to be used as a factory. Type declaredType Optional type to set as the DeclaredType of the target, if not passed, then the return type of the delegate will be used. Returns Type Description DelegateTarget | Improve this Doc View Source AsObjectTarget<T>(T, Type, ScopeBehaviour) This method will be removed in 1.2 in favour of Target.ForObject<T>(T)\" Wraps the instance on which this is invoked as an ObjectTarget that can be registered into an ITargetContainer . The parameters are direct analogues of the parameters on the type's constructor (see ObjectTarget(Object, Type, ScopeBehaviour) ). Declaration [Obsolete(\"This method will be removed in 1.2 in favour of Target.ForObject<T>(T)\")] public static ObjectTarget AsObjectTarget<T>(this T obj, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description T obj the object being wrapped Type declaredType Optional. The type which is to be set as the DeclaredType of the created target. ScopeBehaviour scopeBehaviour Controls how the object will interact the the scope. By default, object targets must be disposed by you. Returns Type Description ObjectTarget A new object target that wraps the object obj . Type Parameters Name Description T The type of object being wrapped"
  },
  "api/Rezolver.Compilation.Expressions.ChangeTypeTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ChangeTypeTargetBuilder.html",
    "title": "Class ChangeTypeTargetBuilder | Rezolver IOC Framework",
    "keywords": "Class ChangeTypeTargetBuilder Implementation of IExpressionBuilder specialised to build expressions for the ChangeTypeTarget This always produces a conversion expression (i.e. cast or box/unbox) Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ChangeTypeTarget > ChangeTypeTargetBuilder Inherited Members ExpressionBuilderBase<ChangeTypeTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ChangeTypeTarget>.IExpressionBuilder<ChangeTypeTarget>.Build(ChangeTypeTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ChangeTypeTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class ChangeTypeTargetBuilder : ExpressionBuilderBase<ChangeTypeTarget>, IExpressionBuilder<ChangeTypeTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ChangeTypeTarget, IExpressionCompileContext, IExpressionCompiler) Builds the conversion expression represented by the target Declaration protected override Expression Build(ChangeTypeTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ChangeTypeTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ChangeTypeTarget>.Build(Rezolver.Targets.ChangeTypeTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionCompilerBuildExtensions.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionCompilerBuildExtensions.html",
    "title": "Class ExpressionCompilerBuildExtensions | Rezolver IOC Framework",
    "keywords": "Class ExpressionCompilerBuildExtensions Extensions for IExpressionCompiler . Inheritance Object ExpressionCompilerBuildExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public static class ExpressionCompilerBuildExtensions Methods | Improve this Doc View Source BuildResolveLambda(IExpressionCompiler, ITarget, IExpressionCompileContext) This method is a shortcut for building a lambda expression directly from an ITarget . It calls Build(ITarget, IExpressionCompileContext) and passes the result to BuildResolveLambda(Expression, IExpressionCompileContext) , which should yield an optimised lambda expression for the expression produced from the target which can then be compiled and used as the factory for that target. Declaration public static Expression<Func<ResolveContext, object>> BuildResolveLambda(this IExpressionCompiler compiler, ITarget target, IExpressionCompileContext context) Parameters Type Name Description IExpressionCompiler compiler The compiler. ITarget target The target. IExpressionCompileContext context The current compilation context. Returns Type Description Expression < Func < ResolveContext , Object >>"
  },
  "api/Rezolver.Compilation.Expressions.ListTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ListTargetBuilder.html",
    "title": "Class ListTargetBuilder | Rezolver IOC Framework",
    "keywords": "Class ListTargetBuilder An IExpressionBuilder specialised for building expressions for the ListTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ListTarget > ListTargetBuilder Inherited Members ExpressionBuilderBase<ListTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ListTarget>.IExpressionBuilder<ListTarget>.Build(ListTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ListTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class ListTargetBuilder : ExpressionBuilderBase<ListTarget>, IExpressionBuilder<ListTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ListTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression which either represents creating an array or a list of objects using an enumerable of targets from the target 's Items . The target's AsArray flag is used to determine which expression to build. Declaration protected override Expression Build(ListTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ListTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ListTarget>.Build(Rezolver.Targets.ListTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.TargetExpression.html": {
    "href": "api/Rezolver.Compilation.Expressions.TargetExpression.html",
    "title": "Class TargetExpression | Rezolver IOC Framework",
    "keywords": "Class TargetExpression An expression which represents an ITarget , allowing a target with a particular DeclaredType to be used in place of a traditional expression. Inheritance Object TargetExpression Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class TargetExpression : Expression Remarks The ExpressionTargetBuilder uses this class extensively when translating expressions into targets and back again. It's highly unlikely you'll need to use it in your code. It acts as a placeholder for targets until the point at which the expression compiler wants to build a complete expression tree for a target. Constructors | Improve this Doc View Source TargetExpression(ITarget) Initializes a new instance of the TargetExpression class. Declaration public TargetExpression(ITarget target) Parameters Type Name Description ITarget target The target. Properties | Improve this Doc View Source CanReduce Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form. Declaration public override bool CanReduce { get; } Property Value Type Description Boolean true if this instance can reduce; otherwise, false . Remarks The implementation always returns true ; although the Reduce() methodd is not implemented. | Improve this Doc View Source NodeType Gets the node type of this . Declaration public override ExpressionType NodeType { get; } Property Value Type Description ExpressionType Always returns . | Improve this Doc View Source Target Gets the target whose expression will be subsituted for this TargetExpression in the final expression tree. Declaration public ITarget Target { get; } Property Value Type Description ITarget | Improve this Doc View Source Type Gets the static type of the expression that this represents. Declaration public override Type Type { get; } Property Value Type Description Type Remarks Always returns the type referenced by the DeclaredType property of Target . Methods | Improve this Doc View Source Reduce() Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced. Declaration public override Expression Reduce() Returns Type Description Expression Exceptions Type Condition NotSupportedException RezolveTargetExpression must be rewritten as a bona-fide expression before walking the expression tree for any other purpose Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.TargetCompiler.html": {
    "href": "api/Rezolver.Compilation.TargetCompiler.html",
    "title": "Class TargetCompiler | Rezolver IOC Framework",
    "keywords": "Class TargetCompiler Holds a reference to the default compiler for this application. Inheritance Object TargetCompiler Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation Assembly :rezolver-docfx.dll Syntax public static class TargetCompiler Properties | Improve this Doc View Source Default The default compiler to be used by rezolvers when they are not explicitly provided one. Declaration public static ITargetCompiler Default { get; set; } Property Value Type Description ITargetCompiler"
  },
  "api/Rezolver.ContainerScope.html": {
    "href": "api/Rezolver.ContainerScope.html",
    "title": "Class ContainerScope | Rezolver IOC Framework",
    "keywords": "Class ContainerScope Standard implementation of the IContainerScope interface. Inheritance Object ContainerScope Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class ContainerScope : IContainerScope, IDisposable, IServiceProvider, IScopeFactory Constructors | Improve this Doc View Source ContainerScope(IContainer) Creates a new root scope tied to the given container Declaration public ContainerScope(IContainer container) Parameters Type Name Description IContainer container | Improve this Doc View Source ContainerScope(IContainerScope, IContainer) Creates a new container that is a child of another. The Container will be inherited from the parentScope by default, unless it's overriden by containerOverride . Declaration public ContainerScope(IContainerScope parentScope, IContainer containerOverride = null) Parameters Type Name Description IContainerScope parentScope Required - the parent scope IContainer containerOverride Optional - the container which should be used for resolve operations executed against this scope (note - all the resolve methods are declared as extension methods which mirror those present on IContainer . Properties | Improve this Doc View Source Container The container that this scope is tied to. All standard resolve operations should be made against this container. Declaration public IContainer Container { get; } Property Value Type Description IContainer The container. Implements IContainerScope.Container | Improve this Doc View Source Disposed Gets a value indicating whether this ContainerScope is disposed. Declaration public bool Disposed { get; } Property Value Type Description Boolean true if disposed; otherwise, false . | Improve this Doc View Source Parent If this scope has a parent scope, this is it. Declaration public IContainerScope Parent { get; } Property Value Type Description IContainerScope The parent. Implements IContainerScope.Parent Methods | Improve this Doc View Source ChildScopeDisposed(IContainerScope) Called by child scopes when they are disposed to notify the parent that they will no longer need to be disposed of when the parent is disposed. Declaration public void ChildScopeDisposed(IContainerScope child) Parameters Type Name Description IContainerScope child The child. Implements IContainerScope.ChildScopeDisposed(IContainerScope) Remarks This is an infrastructure method and not something you would usually need to call. It's exposed for developers who are extending the container scoping functionality only. | Improve this Doc View Source CreateScope() Called to create a child scope from this scope. The implementation adds the new scope to a private collection so that it can dispose of the new child if it is not already disposed. Declaration public IContainerScope CreateScope() Returns Type Description IContainerScope Implements IScopeFactory.CreateScope() | Improve this Doc View Source Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() Implements IDisposable.Dispose() | Improve this Doc View Source Dispose(Boolean) Releases unmanaged and - optionally - managed resources. Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description Boolean disposing true to release both managed and unmanaged resources; false to release only unmanaged resources. Explicit Interface Implementations | Improve this Doc View Source IContainerScope.Resolve(ResolveContext, Func<ResolveContext, Object>, ScopeBehaviour) Declaration object IContainerScope.Resolve(ResolveContext context, Func<ResolveContext, object> factory, ScopeBehaviour behaviour) Parameters Type Name Description ResolveContext context Func < ResolveContext , Object > factory ScopeBehaviour behaviour Returns Type Description Object Implements IContainerScope.Resolve(ResolveContext, Func<ResolveContext, Object>, ScopeBehaviour) | Improve this Doc View Source IServiceProvider.GetService(Type) Declaration object IServiceProvider.GetService(Type serviceType) Parameters Type Name Description Type serviceType Returns Type Description Object Implements IServiceProvider.GetService(Type) Extension Methods ContainerScopeExtensions.GetRootScope(IContainerScope) ContainerScopeResolveExtensions.Resolve<TResult>(IContainerScope) ContainerScopeResolveExtensions.Resolve(IContainerScope, Type) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also IContainerScope"
  },
  "api/Rezolver.EnumerableTargetBuilderExtensions.html": {
    "href": "api/Rezolver.EnumerableTargetBuilderExtensions.html",
    "title": "Class EnumerableTargetBuilderExtensions | Rezolver IOC Framework",
    "keywords": "Class EnumerableTargetBuilderExtensions Houses an extension method which enables native resolving of IEnumerables of services on ITargetContainer containers which, in turn, enables it for any ContainerBase containers which use that target container. Inheritance Object EnumerableTargetBuilderExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public static class EnumerableTargetBuilderExtensions Methods | Improve this Doc View Source EnableEnumerableResolving(ITargetContainerOwner) Enables resolving of enumerables of services on the target container. Declaration public static void EnableEnumerableResolving(this ITargetContainerOwner targetContainer) Parameters Type Name Description ITargetContainerOwner targetContainer The target container. Remarks After calling this, you can immediately request a target for IEnumerable<T> of any type and you will receive a ListTarget (with AsArray set to true) which contains all the targets which have previously been registered for the type T , in the order they were registered. If a service has not been registered, then the returned ListTarget will be empty and its UseFallback property will be true ."
  },
  "api/Rezolver.IContainerScope.html": {
    "href": "api/Rezolver.IContainerScope.html",
    "title": "Interface IContainerScope | Rezolver IOC Framework",
    "keywords": "Interface IContainerScope This is an IContainer -like object (resolving functionality is provided through the extension methods in the ContainerScopeResolveExtensions class) which provides lifetime scoping for disposable objects, and scoped singleton functionality for any object. Implementations of this interface must, in their implementation of IScopeFactory , create a child scope of this scope. Inherited Members IDisposable.Dispose() IServiceProvider.GetService(Type) IScopeFactory.CreateScope() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public interface IContainerScope : IDisposable, IServiceProvider, IScopeFactory Properties | Improve this Doc View Source Container The container that this scope is tied to. All standard resolve operations should be made against this container to begin with. Declaration IContainer Container { get; } Property Value Type Description IContainer | Improve this Doc View Source Parent If this scope has a parent scope, this is it. Declaration IContainerScope Parent { get; } Property Value Type Description IContainerScope Methods | Improve this Doc View Source ChildScopeDisposed(IContainerScope) Called by child scopes when they are disposed to notify the parent that they will no longer need to be disposed of when the parent is disposed. Declaration void ChildScopeDisposed(IContainerScope child) Parameters Type Name Description IContainerScope child Remarks This is an infrastructure method and not something you would usually need to call. It's exposed for developers who are extending the container scoping functionality only. | Improve this Doc View Source Resolve(ResolveContext, Func<ResolveContext, Object>, ScopeBehaviour) Not intended for direct use. Use the Resolve extension methods on this interface to perform 'normal' resolve operations. Execute the given object factory within this scope. Depending on the scoping behaviour passed, the object will either be resolved directly from the scope (i.e. existing objects contained within it) or obtained by executing the factory and optionally tracking the object if it's IDisposable . Declaration object Resolve(ResolveContext context, Func<ResolveContext, object> factory, ScopeBehaviour behaviour) Parameters Type Name Description ResolveContext context The resolve context - please note that the container that's present on this is the actual container that should be used to resolve objects. Func < ResolveContext , Object > factory The factory to be executed ScopeBehaviour behaviour The scope behaviour that the factory should be executed with. Returns Type Description Object Remarks This function is the primary workhorse of all scopes. Most importantly, the object produced from the factory DOES NOT have to come from this scope's Container - the implementing type simply has to ensure that it tracks whatever object is ultimately returned; potentially returning a previously tracked object if behaviour is Explicit Extension Methods ContainerScopeExtensions.GetRootScope(IContainerScope) ContainerScopeResolveExtensions.Resolve<TResult>(IContainerScope) ContainerScopeResolveExtensions.Resolve(IContainerScope, Type) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also IScopeFactory IDisposable IServiceProvider"
  },
  "api/Rezolver.ParameterBinding.html": {
    "href": "api/Rezolver.ParameterBinding.html",
    "title": "Class ParameterBinding | Rezolver IOC Framework",
    "keywords": "Class ParameterBinding Represents a binding between a method parameter and an ITarget Inheritance Object ParameterBinding Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class ParameterBinding Constructors | Improve this Doc View Source ParameterBinding(ParameterInfo, ITarget) Constructs a new instance of the ParameterBinding class. Declaration public ParameterBinding(ParameterInfo parameter, ITarget target = null) Parameters Type Name Description ParameterInfo parameter Required - the parameter being bound ITarget target Optional - the argument supplied for the parameter. Fields | Improve this Doc View Source None Represents an empty parameter bindings array. Declaration public static readonly ParameterBinding[] None Field Value Type Description ParameterBinding [] Properties | Improve this Doc View Source IsValid Gets a boolean indicating whether the parameter binding is valid Ultimately, this returns true if Target is non-null. Declaration public bool IsValid { get; } Property Value Type Description Boolean | Improve this Doc View Source Parameter The parameter to be bound Declaration public ParameterInfo Parameter { get; } Property Value Type Description ParameterInfo | Improve this Doc View Source Target The initial target that was bound to this parameter. Declaration public ITarget Target { get; } Property Value Type Description ITarget Methods | Improve this Doc View Source BindMethod(MethodBase, ParameterBinding[]) Binds the method using explicit bindings for each parameter supplied in the suppliedBindings array, or defaults (which will be resolved from the compile or run-time container) if not present. Declaration public static ParameterBinding[] BindMethod(MethodBase method, ParameterBinding[] suppliedBindings) Parameters Type Name Description MethodBase method The method to be bound ParameterBinding [] suppliedBindings Optional. The supplied bindings for the parameters of the method. Any parameters not matched from this array will be automatically bound with default (resolved from the container). Returns Type Description ParameterBinding [] | Improve this Doc View Source BindMethod(MethodBase, IDictionary<String, ITarget>) Matches named targets in args to parameters on the passed method , creating default ParameterBinding s (which will be resolved from the compile or run-time container), for any parameters for which named targets cannot be found. Declaration public static ParameterBinding[] BindMethod(MethodBase method, IDictionary<string, ITarget> args) Parameters Type Name Description MethodBase method IDictionary < String , ITarget > args Returns Type Description ParameterBinding [] | Improve this Doc View Source BindOverload(MethodBase[], IDictionary<String, ITarget>, out MethodBase) Searches for a method in the methods collection whose parameters can be filled by the targets provided in the args dictionary, returning the parameter bindings, and passing out the resolved target method in resolvedMethod if found. Note - if no match can be found, or if more than one method could be bound, then an InvalidOperationException will occur. Declaration public static ParameterBinding[] BindOverload(MethodBase[] methods, IDictionary<string, ITarget> args, out MethodBase resolvedMethod) Parameters Type Name Description MethodBase [] methods The methods. IDictionary < String , ITarget > args The arguments. MethodBase resolvedMethod The resolved method. Returns Type Description ParameterBinding [] ParameterBinding[]. | Improve this Doc View Source BindWithRezolvedArguments(MethodBase) Creates parameter bindings for each parameter in the passed method where each value will be resolved. For any optional parameters - their default values will be used as a fallback if the ResolvedTarget cannot either resolve a target at compile time or from the IContainer at resolve-time. Declaration public static ParameterBinding[] BindWithRezolvedArguments(MethodBase method) Parameters Type Name Description MethodBase method Returns Type Description ParameterBinding [] | Improve this Doc View Source Resolve(ICompileContext) Fetch the target that would be bound to this parameter given the passed ICompileContext Declaration public virtual ITarget Resolve(ICompileContext context) Parameters Type Name Description ICompileContext context The current compile context - a new one is created for the Parameter type Returns Type Description ITarget The target that should be used for the parameter, or null if no target could be found. Note that if the returned target's UseFallback property is set to true , then it means either the parameter's default value is being used, or that the target fetched from the target container in the context is a stub (e.g. empty enumerable) Remarks During compilation - you should not use the target returned by this function as a direct part of your expression tree - you should Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.RegisterTypeTargetContainerExtensions.html": {
    "href": "api/Rezolver.RegisterTypeTargetContainerExtensions.html",
    "title": "Class RegisterTypeTargetContainerExtensions | Rezolver IOC Framework",
    "keywords": "Class RegisterTypeTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for the simplest cases of registering ConstructorTarget and GenericConstructorTarget targets. Inheritance Object RegisterTypeTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public static class RegisterTypeTargetContainerExtensions Methods | Improve this Doc View Source RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) Registers an instance of objectType (optionally for the service type serviceType ) to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter memberBinding . Declaration public static void RegisterType(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. Type objectType The type of the object that is to be constructed when resolved. Type serviceType Optional. The type against which the registration will be performed, if different from objectType . objectType must be compatible with this type, if it's provided. IMemberBindingBehaviour memberBinding Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto(Type, IMemberBindingBehaviour) or Auto(Type, IMemberBindingBehaviour) static methods and then registering it against the type serviceType or objectType . | Improve this Doc View Source RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) Registers an instance of TObject to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter memberBinding . Declaration public static void RegisterType<TObject>(this ITargetContainer targetContainer, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IMemberBindingBehaviour memberBinding Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto<T>(IMemberBindingBehaviour) or Auto(Type, IMemberBindingBehaviour) static methods and then registering it. | Improve this Doc View Source RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) Registers an instance of TObject for the service type TService to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter memberBinding . Declaration public static void RegisterType<TObject, TService>(this ITargetContainer targetContainer, IMemberBindingBehaviour memberBinding = null)where TObject : TService Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IMemberBindingBehaviour memberBinding Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. TService The type against which the registration will be performed. TObject must be compatible with this type. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto<T>(IMemberBindingBehaviour) or Auto(Type, IMemberBindingBehaviour) static methods and then registering it against the type TService ."
  },
  "api/Rezolver.Targets.DelegateTarget.html": {
    "href": "api/Rezolver.Targets.DelegateTarget.html",
    "title": "Class DelegateTarget | Rezolver IOC Framework",
    "keywords": "Class DelegateTarget An ITarget which resolve objects by executing a delegate with argument injection. Inheritance Object TargetBase DelegateTarget Inherited Members TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Targets Assembly :rezolver-docfx.dll Syntax public class DelegateTarget : TargetBase, ITarget Remarks The delegate must be non-void and can have any number of parameters. A compiler must ensure that any parameters for the Factory are automatically resolved from the container, and that a parameter of the type ResolveContext will receive the context passed to the Resolve(ResolveContext) method call for which this target is being compiled and/or executed. Constructors | Improve this Doc View Source DelegateTarget(Delegate, Type) Initializes a new instance of the DelegateTarget class. Declaration public DelegateTarget(Delegate factory, Type declaredType = null) Parameters Type Name Description Delegate factory Required - the factory delegate. Must have a return type and can take 0 or more parameters. Type declaredType Optional - type that will be set into the DeclaredType for the target; if not provided, then it will be derived from the factory 's return type Exceptions Type Condition ArgumentException If the factory represents a void delegate or if declaredType is passed but the type is not compatible with the return type of factory . ArgumentNullException If factory is null Properties | Improve this Doc View Source DeclaredType Gets the declared type of object that is constructed by this target, either set on construction or derived from the return type of the Factory Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source Factory Gets the factory delegate that will be invoked when this target is compiled and executed Declaration public Delegate Factory { get; } Property Value Type Description Delegate The factory. | Improve this Doc View Source FactoryMethod Gets the MethodInfo for the Factory delegate. Declaration public MethodInfo FactoryMethod { get; } Property Value Type Description MethodInfo Remarks Whilst this can be easily obtained from the delegate yourself (by using the GetMethodInfo(Delegate) extension method) however, this class also uses it to determine the DeclaredType of the target or whether the delegate is actually compatible with the one supplied on construction, therefore if you need to introspect the delegate, you might as well use this. Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Targets.ExpressionTarget.html": {
    "href": "api/Rezolver.Targets.ExpressionTarget.html",
    "title": "Class ExpressionTarget | Rezolver IOC Framework",
    "keywords": "Class ExpressionTarget A generic target for all expressions not explicitly supported by a particular target. Enables more complex behaviours to be registered and used with the more formal ITarget implementations. Inheritance Object TargetBase ExpressionTarget Inherited Members TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Targets Assembly :rezolver-docfx.dll Syntax public class ExpressionTarget : TargetBase, ITarget Remarks Note to compiler implementers: This class can be used to represent simple expressions such as constants, constructor calls and so on; but can also contain whole lambda expressions with parameters. In the latter case, expression parameters are expected to receive injected arguments and, therefore, some rewriting of the expression is likely to be required. Constructors | Improve this Doc View Source ExpressionTarget(Expression, Type) Initializes a new instance of the ExpressionTarget class. Declaration public ExpressionTarget(Expression expression, Type declaredType = null) Parameters Type Name Description Expression expression Required. The static expression which should be used by compilers. Type declaredType Declared type of the target to be created (used when registering without an explicit type or when this target is used as a value inside another target). Remarks declaredType will automatically be determined if not provided by examining the type of the expression . For lambdas, the type will be derived from the Type of the lambda's body. For all other expressions, the type is taken directly from the Type property of the expression itself. | Improve this Doc View Source ExpressionTarget(Func<ICompileContext, Expression>, Type) Initializes a new instance of the ExpressionTarget class. Declaration public ExpressionTarget(Func<ICompileContext, Expression> expressionFactory, Type declaredType) Parameters Type Name Description Func < ICompileContext , Expression > expressionFactory Required. The factory delegate that a compiler should call to get the expression to use when compiling this target. Type declaredType Required. Static type of all expressions that will be returned by expressionFactory . Properties | Improve this Doc View Source DeclaredType Gets the type of Expression or the type that all expressions returned by the ExpressionFactory are expected to be equal to. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source Expression Gets the static expression represented by this target - if null , then a factory is being used to produce the expression, which is available from the ExpressionFactory property. Declaration public Expression Expression { get; } Property Value Type Description Expression | Improve this Doc View Source ExpressionFactory Gets a factory which will be executed to obtain an expression given a particular ICompileContext . If null , then a static expression will be used instead and is available from the Expression property. Declaration public Func<ICompileContext, Expression> ExpressionFactory { get; } Property Value Type Description Func < ICompileContext , Expression > Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ExpressionTargetContainerExtensions.html": {
    "href": "api/Rezolver.ExpressionTargetContainerExtensions.html",
    "title": "Class ExpressionTargetContainerExtensions | Rezolver IOC Framework",
    "keywords": "Class ExpressionTargetContainerExtensions Extensions for to simplify registering expressions in an ITargetContainer . Inheritance Object ExpressionTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public static class ExpressionTargetContainerExtensions Methods | Improve this Doc View Source RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) Registers the expression in the target container Declaration public static void RegisterExpression(this ITargetContainer targetContainer, Expression expression, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targetContainer The target container in which the registration will be made. Expression expression The expression to be registered. Type declaredType Optional. The DeclaredType of the target to be created, if different from the of the expression (or its if the expression is a ). Will also override the type against which the expression will be registered if provided. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the compiled expression will be tracked if the target is executed within an IContainerScope . The default is Implicit . | Improve this Doc View Source RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) Registers an ExpressionTarget built from a parameterless lambda expression which returns an instance of TResult Declaration public static void RegisterExpression<TResult>(this ITargetContainer targets, Expression<Func<TResult>> lambda, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered Expression < Func <TResult>> lambda Required. The lambda expression which is to be compiled and executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the compiled expression will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description TResult The return type of the lambda expression. | Improve this Doc View Source RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) Registers an ExpressionTarget built from a lambda expression which takes a ResolveContext and which returns an instance of TResult Declaration public static void RegisterExpression<TResult>(this ITargetContainer targets, Expression<Func<ResolveContext, TResult>> lambda, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered Expression < Func < ResolveContext , TResult>> lambda Required. The lambda expression which is to be compiled and executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the compiled expression will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) Registers an ExpressionTarget built from a lambda expression which takes 1 argument and which returns an instance of TResult Declaration public static void RegisterExpression<T1, TResult>(this ITargetContainer targets, Expression<Func<T1, TResult>> lambda, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered Expression < Func <T1, TResult>> lambda Required. The lambda expression which is to be compiled and executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the compiled expression will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) Registers an ExpressionTarget built from a lambda expression which takes 2 arguments and which returns an instance of TResult Declaration public static void RegisterExpression<T1, T2, TResult>(this ITargetContainer targets, Expression<Func<T1, T2, TResult>> lambda, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered Expression < Func <T1, T2, TResult>> lambda Required. The lambda expression which is to be compiled and executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the compiled expression will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. T2 Type of the 2nd parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) Registers an ExpressionTarget built from a lambda expression which takes 3 arguments and which returns an instance of TResult Declaration public static void RegisterExpression<T1, T2, T3, TResult>(this ITargetContainer targets, Expression<Func<T1, T2, T3, TResult>> lambda, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered Expression < Func <T1, T2, T3, TResult>> lambda Required. The lambda expression which is to be compiled and executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the compiled expression will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. T2 Type of the 2nd parameter of the lambda expression. T3 Type of the 3rd parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) Registers an ExpressionTarget built from a lambda expression which takes 4 arguments and which returns an instance of TResult Declaration public static void RegisterExpression<T1, T2, T3, T4, TResult>(this ITargetContainer targets, Expression<Func<T1, T2, T3, T4, TResult>> lambda, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered Expression < Func <T1, T2, T3, T4, TResult>> lambda Required. The lambda expression which is to be compiled and executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the compiled expression will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. T2 Type of the 2nd parameter of the lambda expression. T3 Type of the 3rd parameter of the lambda expression. T4 Type of the 4th parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) Registers an ExpressionTarget built from a lambda expression which takes 5 arguments and which returns an instance of TResult Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, TResult>(this ITargetContainer targets, Expression<Func<T1, T2, T3, T4, T5, TResult>> lambda, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered Expression < Func <T1, T2, T3, T4, T5, TResult>> lambda Required. The lambda expression which is to be compiled and executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the compiled expression will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. T2 Type of the 2nd parameter of the lambda expression. T3 Type of the 3rd parameter of the lambda expression. T4 Type of the 4th parameter of the lambda expression. T5 Type of the 5th parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed"
  },
  "api/Rezolver.ITargetContainer.html": {
    "href": "api/Rezolver.ITargetContainer.html",
    "title": "Interface ITargetContainer | Rezolver IOC Framework",
    "keywords": "Interface ITargetContainer Stores and retrieves ITarget instances, keyed by the type of service that the targets are registered against. This is where all your service registrations will ultimately go. Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public interface ITargetContainer Remarks You do not resolve objects from a target container, instead, it holds the ITarget s which will later be compiled to produce the objects. A target container is considered mutable for its entire lifetime, because it's only a glorified dictionary of targets from which multiple IContainer objects can be built (when using the types provided in the framework). As an example, the Container class uses this as the source of the registrations that it uses to resolve objects in its Resolve(ResolveContext) implementation. Note that there are multiple implementations of this interface in the framework, however the two you will use most commonly are TargetContainer and ChildTargetContainer . Methods | Improve this Doc View Source CombineWith(ITargetContainer, Type) If supported by the implementation, this gets the container built from combining this container with an existing container as part of a registration inside another ITargetContainerOwner . Declaration ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing The existing ITargetContainer instance that this instance is to be combined with Type type The type that the combined container owner will be registered under. Returns Type Description ITargetContainer Remarks Used most frequently in implementations of RegisterContainer(Type, ITargetContainer) when a container owner is already registered against the type, and a new container owner is then registered against the same type. This behaviour is used to implement open generics and decorators, and can be used to implement more besides. Exceptions Type Condition NotSupportedException If this container doesn't support being combined with another. | Improve this Doc View Source Fetch(Type) Retrieves a target for a particular type, or null if no target is registered against that type. Declaration ITarget Fetch(Type type) Parameters Type Name Description Type type Required. The type for which an ITarget is to be retrieved. Returns Type Description ITarget The target for the given type , or null if no target is found. Remarks The target you receive from this method depends entirely on the implementation. It could be the last target to be registered against the type or the first, or another target entirely. As mentioned in the documentation for the Register(ITarget, Type) method - the only guarantee is that if at least one target has been registered for the same type, then this method should return a valid target. | Improve this Doc View Source FetchAll(Type) Retrieves an enumerable of all targets that have been registered for a particular type . Declaration IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type Required. The type for which the ITarget s are to be retrieved. Returns Type Description IEnumerable < ITarget > An enumerable containing all the targets that have been registered against the given type , or, an empty enumerable if no targets have been registered. Remarks As with Fetch(Type) , the only guarantee is that if a target has been registered for the type through a call to Register(ITarget, Type) , then the returned enumerable will contain at least one valid target. | Improve this Doc View Source Register(ITarget, Type) Registers a target, either for the serviceType specified or, if null, the DeclaredType of the target . Declaration void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target Required. The target to be registered Type serviceType Optional. The type the target is to be registered against, if different from the DeclaredType of the target . If provided, then the target must be compatible with this type. Remarks The interface does not define the behaviour for when multiple targets are registered against the same type - although the default behaviour of the framework (via the TargetContainer class) is to allow this, with the last registered target being treated as the 'default' for that type. The only guarantee expected by the framework from implementations of this interface is that if a target is registered against a given type with this method, then a Fetch(Type) operation with the same type should return a valid target, and a FetchAll(Type) operation should return a non-empty enumerable of targets. Exceptions Type Condition ArgumentException If serviceType is non-null and the target 's SupportsType(Type) method returns false for that type. Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ITargetContainerOwner.html": {
    "href": "api/Rezolver.ITargetContainerOwner.html",
    "title": "Interface ITargetContainerOwner | Rezolver IOC Framework",
    "keywords": "Interface ITargetContainerOwner Interface for an ITargetContainer which also contains other target containers. It is not typically used by your application code since it's primarily an infrastructure interface - if you are extending the API, however, then you might need to work with it. Inherited Members ITargetContainer.Register(ITarget, Type) ITargetContainer.Fetch(Type) ITargetContainer.FetchAll(Type) ITargetContainer.CombineWith(ITargetContainer, Type) Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public interface ITargetContainerOwner : ITargetContainer Remarks This interface, its implementations and everything else associated with it, is at the heart of functionality such as open generics, automatic enumerables and decorators. Methods | Improve this Doc View Source FetchContainer(Type) Retrieves an existing container registered against the given type , or null if not found. Declaration ITargetContainer FetchContainer(Type type) Parameters Type Name Description Type type Returns Type Description ITargetContainer | Improve this Doc View Source RegisterContainer(Type, ITargetContainer) Registers a container against a given type . If a container already exists against this type, then the existing container's CombineWith(ITargetContainer, Type) method is called with the container as the argument, and the resulting container will replace the existing one. Declaration void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container Extension Methods EnumerableTargetBuilderExtensions.EnableEnumerableResolving(ITargetContainerOwner) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) DecoratorTargetContainerExtensions.RegisterDecorator(ITargetContainerOwner, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.html": {
    "href": "api/Rezolver.Compilation.html",
    "title": "Namespace Rezolver.Compilation | Rezolver IOC Framework",
    "keywords": "Namespace Rezolver.Compilation Classes CompileContext Core implementation of ICompileContext . A root context (i.e. where ParentContext is null ; created via the CompileContext(IContainer, ITargetContainer, Type) constructor) is the starting point for all shared state, such as the Container and the compilation stack. The ITargetContainer implementation is done by decorating a new ChildTargetContainer , so that new registrations can be added without interfering with upstream containers. Note that many of the interface members are implemented explicitly - therefore most of your interaction with this type is through its implementation of ICompileContext and ITargetContainer . CompilerConfiguration Controls the system-wide compiler configuration used by default by all standard Rezolver containers. CompileStackEntry Represents an entry in the compilation stack of a ICompileContext , recording both a target that is being compiled, and the type for which it is being compiled. TargetCompiler Holds a reference to the default compiler for this application. Interfaces ICompileContext Tracks state and provides services during the compilation phase in which ITarget targets are compiled into ICompiledTarget targets, which produce actual instances of objects. ICompileContextProvider Interface for an object which creates ICompileContext instances for when the system needs to compile an ITarget into an ICompiledTarget . ICompilerConfigurationProvider Interface for an object which configures the compiler for the given container and/or targets object to use a specific ITargetCompiler and ICompileContextProvider . Used by all the standard container types in the Rezolver framework. You can provide a specific provider to most containers on creation, and you can configure the default system-wide provider via the DefaultProvider static property. ITargetCompiler An object that produces ICompiledTarget s from ITarget s given a particular ICompileContext ."
  },
  "api/Rezolver.ContainerScopeExtensions.html": {
    "href": "api/Rezolver.ContainerScopeExtensions.html",
    "title": "Class ContainerScopeExtensions | Rezolver IOC Framework",
    "keywords": "Class ContainerScopeExtensions Standard extensions for the IContainerScope Inheritance Object ContainerScopeExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public static class ContainerScopeExtensions Methods | Improve this Doc View Source GetRootScope(IContainerScope) Gets the root-most scope for the scope on which this method is called. Note that the result is calculated by walking up the tree of Parent scopes until one is reached that does not have a parent. Declaration public static IContainerScope GetRootScope(this IContainerScope scope) Parameters Type Name Description IContainerScope scope The scope. Returns Type Description IContainerScope Exceptions Type Condition ArgumentNullException If scope is null"
  },
  "api/Rezolver.ExpressionFunctions.html": {
    "href": "api/Rezolver.ExpressionFunctions.html",
    "title": "Class ExpressionFunctions | Rezolver IOC Framework",
    "keywords": "Class ExpressionFunctions This type is only used when using expressions as targets(via the ExpressionTarget type) - it's functions serve no actual purpose other than to act as hooks to create specific ITarget objects in place of static code. All the functions will throw a NotImplementedException if called at runtime. Inheritance Object ExpressionFunctions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public static class ExpressionFunctions Methods | Improve this Doc View Source Resolve(Type) Provides a way to emit a Resolve(Type) call to the ResolveContext which is active when an expression is compiled and executed when resolving an object. Declaration public static object Resolve(Type t) Parameters Type Name Description Type t The type to be resolved. Returns Type Description Object Exceptions Type Condition NotImplementedException Always. The method is not intended to be used outside of an expression, instead it should be rewritten either to a ResolvedTarget or another bound to the Resolve(Type) method of a ResolveContext . | Improve this Doc View Source Resolve<T>() Provides a way to emit a Resolve<TResult>() call to the ResolveContext which is active when an expression is compiled and executed when resolving an object. Declaration public static T Resolve<T>() Returns Type Description T Type Parameters Name Description T The type to be resolved. Remarks Use of this function in a Lambda expression is not required if you can add a ResolveContext parameter to the Lambda - since you can simply call its Resolve<TResult>() method in your lambda body. This is primarily provided instead for non-lambda expressions which require services from the container (e.g. if manually building a or and you want to explicitly inject one or more constructor/method arguments). Exceptions Type Condition NotImplementedException Always. The method is not intended to be used outside of an expression, instead it should be rewritten either to a ResolvedTarget or another bound to the Resolve<TResult>() method of a ResolveContext ."
  },
  "api/Rezolver.IScopedContainer.html": {
    "href": "api/Rezolver.IScopedContainer.html",
    "title": "Interface IScopedContainer | Rezolver IOC Framework",
    "keywords": "Interface IScopedContainer An IContainer that also has a Scope attached to it. Many applications will use such a container as the root container to use as anchors for things like scoped singletons. Inherited Members IContainer.CanResolve(ResolveContext) IContainer.Resolve(ResolveContext) IContainer.TryResolve(ResolveContext, Object) IContainer.FetchCompiled(ResolveContext) IServiceProvider.GetService(Type) IScopeFactory.CreateScope() IDisposable.Dispose() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public interface IScopedContainer : IContainer, IServiceProvider, IScopeFactory, IDisposable Properties | Improve this Doc View Source Scope Gets the root scope for this scoped container. Note that this is used automatically by the container for Resolve(ResolveContext) operations where the Scope property is not already set. Declaration IContainerScope Scope { get; } Property Value Type Description IContainerScope Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also IContainer IDisposable"
  },
  "api/Rezolver.ScopedContainer.html": {
    "href": "api/Rezolver.ScopedContainer.html",
    "title": "Class ScopedContainer | Rezolver IOC Framework",
    "keywords": "Class ScopedContainer Extends the Container to implement lifetime implicit scoping through the Scope that's created along with it. Implementation of the IScopedContainer interface. Inheritance Object ContainerBase CachingContainerBase Container ScopedContainer Inherited Members CachingContainerBase.GetCompiledRezolveTarget(ResolveContext) ContainerBase.NoChangeCompilerConfiguration ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Targets ContainerBase.FetchCompiled(ResolveContext) ContainerBase.GetFallbackCompiledRezolveTarget(ResolveContext) ContainerBase.IServiceProvider.GetService(Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) ContainerBase.ITargetContainer.Fetch(Type) ContainerBase.ITargetContainer.FetchAll(Type) ContainerBase.ITargetContainer.CombineWith(ITargetContainer, Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class ScopedContainer : Container, ITargetContainer, IScopedContainer, IContainer, IServiceProvider, IScopeFactory, IDisposable Remarks Both the Resolve(ResolveContext) and TryResolve(ResolveContext, out Object) methods will inject the Scope into ResolveContext that's passed if the context doesn't already have a scope. If you want your root container to act as a lifetime scope, then you should use this class instead of using Container . Note that this class does NOT implement the IContainerScope interface because the two interfaces are not actually compatible with each other, thanks to identical sets of extension methods. Constructors | Improve this Doc View Source ScopedContainer(ITargetContainer, ICompilerConfigurationProvider) Initializes a new instance of the ScopedContainer class. Declaration public ScopedContainer(ITargetContainer targets = null, ICompilerConfigurationProvider compilerConfig = null) Parameters Type Name Description ITargetContainer targets Optional. The underlying target container to be used to resolve objects. ICompilerConfigurationProvider compilerConfig Optional. The compiler configuration. Properties | Improve this Doc View Source Scope Gets the scope for this scoped container. Note that this is used automatically by the container for Resolve(ResolveContext) operations where the Scope property is not already set. Declaration public IContainerScope Scope { get; } Property Value Type Description IContainerScope Implements IScopedContainer.Scope Methods | Improve this Doc View Source CanResolve(ResolveContext) Overrides the base implementation to ensure that the context has the Scope assigned. Declaration public override bool CanResolve(ResolveContext context) Parameters Type Name Description ResolveContext context The resolve context containing the requested type. Returns Type Description Boolean Overrides ContainerBase.CanResolve(ResolveContext) Implements IContainer.CanResolve(ResolveContext) | Improve this Doc View Source CreateScope() Overrides the base method's implementation of CreateScope() to pass the call to the Scope . Declaration public override IContainerScope CreateScope() Returns Type Description IContainerScope Overrides ContainerBase.CreateScope() Implements IScopeFactory.CreateScope() | Improve this Doc View Source Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() Implements IDisposable.Dispose() | Improve this Doc View Source Dispose(Boolean) Releases unmanaged and - optionally - managed resources. Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description Boolean disposing true to release both managed and unmanaged resources; false to release only unmanaged resources. | Improve this Doc View Source Resolve(ResolveContext) Overrides the base implementation to ensure that the context has the Scope assigned. Declaration public override object Resolve(ResolveContext context) Parameters Type Name Description ResolveContext context The context containing the type that's requested, any active scope and so on. Returns Type Description Object Overrides ContainerBase.Resolve(ResolveContext) Implements IContainer.Resolve(ResolveContext) | Improve this Doc View Source TryResolve(ResolveContext, out Object) Overrides the base implementation to ensure that the context has the Scope assigned. Declaration public override bool TryResolve(ResolveContext context, out object result) Parameters Type Name Description ResolveContext context The context containing the type that's requested, any active scope and so on. Object result Receives a reference to the object that was resolved, if successful, or null if not. Returns Type Description Boolean Overrides ContainerBase.TryResolve(ResolveContext, out Object) Implements IContainer.TryResolve(ResolveContext, out Object) Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ScopedTargetContainerExtensions.html": {
    "href": "api/Rezolver.ScopedTargetContainerExtensions.html",
    "title": "Class ScopedTargetContainerExtensions | Rezolver IOC Framework",
    "keywords": "Class ScopedTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for registering constructor-injected types whose lifetimes are slaved to that of a parent IScopedContainer . All of the extension methods ultimately create a ScopedTarget Inheritance Object ScopedTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public static class ScopedTargetContainerExtensions Methods | Improve this Doc View Source RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) Registers an explicitly instance of objectType (optionally for the service type serviceType ) to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter memberBinding . Declaration public static void RegisterScoped(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. Type objectType The type of the object that is to be constructed when resolved. Type serviceType Optional. The type against which the registration will be performed, if different from objectType . objectType must be compatible with this type, if it's provided. IMemberBindingBehaviour memberBinding Optional. Can be used to enable and control property injection in addition to constructor injection on the instance of objectType that is created. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto(Type, IMemberBindingBehaviour) or Auto(Type, IMemberBindingBehaviour) static methods, wrapping it with a ScopedTarget and then registering it against the type serviceType or objectType . | Improve this Doc View Source RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) Registers an explicitly scoped instance of TObject to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter memberBinding . Declaration public static void RegisterScoped<TObject>(this ITargetContainer targetContainer, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IMemberBindingBehaviour memberBinding Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto<T>(IMemberBindingBehaviour) or Auto(Type, IMemberBindingBehaviour) static methods, wrapping it with a ScopedTarget and registering it. | Improve this Doc View Source RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) Registers an explicitly scoped instance of TObject for the service type TService to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(ResolveContext) is first called. Optionally, property injection can be configured for the new object, depending on the IMemberBindingBehaviour object passed for the optional parameter memberBinding . Declaration public static void RegisterScoped<TObject, TService>(this ITargetContainer targetContainer, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IMemberBindingBehaviour memberBinding Can be used to enable and control property injection in addition to constructor injection on the instance of TObject that is created. Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. TService The type against which the registration will be performed. TObject must be compatible with this type. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the Auto<T>(IMemberBindingBehaviour) or Auto(Type, IMemberBindingBehaviour) static methods, wrapping it with a ScopedTarget and then registering it against the type TService ."
  },
  "api/Rezolver.Targets.ListTarget.html": {
    "href": "api/Rezolver.Targets.ListTarget.html",
    "title": "Class ListTarget | Rezolver IOC Framework",
    "keywords": "Class ListTarget This target produces arrays ( AsArray = true ) or lists ( AsArray = false ) whose individual items are built by ITarget instances. Primarily used by the Rezolver.EnumerableTargetContainer and the configuration framework, but can also be used by your code. Inheritance Object TargetBase ListTarget Inherited Members TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Targets Assembly :rezolver-docfx.dll Syntax public class ListTarget : TargetBase, ITarget Remarks The element type you feed on construction determines the type of array or the generic argument to List<T>. Each of the rezolve targets that you then pass must support that type. Constructors | Improve this Doc View Source ListTarget(Type, IEnumerable<ITarget>, Boolean) Initializes a new instance of the ListTarget class. Declaration public ListTarget(Type elementType, IEnumerable<ITarget> items, bool asArray = false) Parameters Type Name Description Type elementType Required. Type of the elements in the array or list. IEnumerable < ITarget > items Required. The targets that will create each the individual items. Boolean asArray A boolean indicating whether the target will build an array ( true ) or a list ( false ). Exceptions Type Condition ArgumentNullException elementType or items ArgumentException All targets in the items enumerable must be non-null;items or All targets in the items enumerable must support the element type elementType Properties | Improve this Doc View Source AsArray Gets a value indicating whether the target will build an array ( true ) or a list ( false ). Declaration public bool AsArray { get; } Property Value Type Description Boolean | Improve this Doc View Source DeclaredType Implementation of the abstract property from the base. This will always return either a type equal to an array of ElementType , or List<T> with ElementType as the generic parameter. This is controlled by the AsArray property. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source ElementType Gets the declared type of each element in the array or list that will be constructed. The DeclaredType returned by this instance will either be ElementType[] or List<ElementType> depending on the value of AsArray . Declaration public Type ElementType { get; } Property Value Type Description Type The declared type of each element. | Improve this Doc View Source Items Gets the rezolve targets that will build each individual item in the resulting list or array. Declaration public IEnumerable<ITarget> Items { get; } Property Value Type Description IEnumerable < ITarget > The items. | Improve this Doc View Source ListConstructor Gets the list constructor to be invoked when AsArray is false. Declaration public ConstructorInfo ListConstructor { get; } Property Value Type Description ConstructorInfo The list constructor. Exceptions Type Condition InvalidOperationException Since this target is configured to build an array, getting the ListConstructor is not a valid operation. | Improve this Doc View Source UseFallback Returns true if the Items enumerable is empty. Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides TargetBase.UseFallback Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Target.html": {
    "href": "api/Rezolver.Target.html",
    "title": "Class Target | Rezolver IOC Framework",
    "keywords": "Class Target Provides static factory methods (including extension methods) for creating numerous types of targets from the Rezolver.Targets namespace. Inheritance Object Target Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public static class Target Remarks Although most of these methods create targets of a known type (e.g. Scoped(ITarget) returns a ScopedTarget ), the methods all return ITarget to allow for changes in implementation in the future. Methods | Improve this Doc View Source As(ITarget, Type) Extension method which creates a new ChangeTypeTarget that wraps the target , changing its DeclaredType to the targetType passed. Declaration public static ITarget As(this ITarget target, Type targetType) Parameters Type Name Description ITarget target Required. The target. Type targetType Required. The new type for the target . Returns Type Description ITarget | Improve this Doc View Source As<T>(ITarget) Extension method which creates a new ChangeTypeTarget that wraps the target , changing its DeclaredType to T . Declaration public static ITarget As<T>(this ITarget target) Parameters Type Name Description ITarget target Required. The target. Returns Type Description ITarget Type Parameters Name Description T | Improve this Doc View Source ForConstructor(ConstructorInfo, IMemberBindingBehaviour) Creates a ConstructorTarget for the given constructor. Declaration public static ITarget ForConstructor(ConstructorInfo constructor, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ConstructorInfo constructor Required. The constructor to be bound by the target. IMemberBindingBehaviour memberBinding The member binding behaviour. Returns Type Description ITarget | Improve this Doc View Source ForConstructor(ConstructorInfo, ParameterBinding[], IMemberBindingBehaviour) Creates a ConstructorTarget for the given constructor. Declaration public static ITarget ForConstructor(ConstructorInfo constructor, ParameterBinding[] parameterBindings, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ConstructorInfo constructor Required. The constructor to be bound by the target. ParameterBinding [] parameterBindings Can be null/empty. An array of ParameterBinding objects containing targets to be bound to somme or all of the constructor parameters. IMemberBindingBehaviour memberBinding The member binding behaviour. Returns Type Description ITarget | Improve this Doc View Source ForConstructor(ConstructorInfo, IDictionary<String, ITarget>, IMemberBindingBehaviour) Creates a ConstructorTarget for the given constructor. Declaration public static ITarget ForConstructor(ConstructorInfo constructor, IDictionary<string, ITarget> namedArgs, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ConstructorInfo constructor Required. The constructor to be bound by the target. IDictionary < String , ITarget > namedArgs Can be null. A dictionary of targets that are to be bound to the constructor by name and DeclaredType . IMemberBindingBehaviour memberBinding The member binding behaviour. Returns Type Description ITarget | Improve this Doc View Source ForConstructor(ConstructorInfo, Object, IMemberBindingBehaviour) Creates a ConstructorTarget for the given constructor. Declaration public static ITarget ForConstructor(ConstructorInfo constructor, object namedArgs, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ConstructorInfo constructor Required. The constructor to be bound by the target. Object namedArgs Optional. An object whose publicly readable members which are of the type ITarget (or a type which implements it) are to be bound to the constructor by name and DeclaredType . IMemberBindingBehaviour memberBinding The member binding behaviour. Returns Type Description ITarget | Improve this Doc View Source ForDelegate<TResult>(Func<TResult>, Type) Creates a DelegateTarget for a parameterless factory delegate which returns an instance of TResult Declaration public static ITarget ForDelegate<TResult>(Func<TResult> factory, Type declaredType = null) Parameters Type Name Description Func <TResult> factory Required. The factory delegate that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description TResult The type of the object produced by the factory delegate. | Improve this Doc View Source ForDelegate<TResult>(Func<ResolveContext, TResult>, Type) Creates a DelegateTarget for a factory delegate which takes a ResolveContext and which returns an instance of TResult Declaration public static ITarget ForDelegate<TResult>(Func<ResolveContext, TResult> factory, Type declaredType = null) Parameters Type Name Description Func < ResolveContext , TResult> factory Required. The factory delegate that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description TResult The type of the object produced by the factory delegate. Remarks All arguments to the delegate are injected from the container when executed | Improve this Doc View Source ForDelegate<T1, TResult>(Func<T1, TResult>, Type) Creates a DelegateTarget for a factory delegate which takes 1 argument and which returns an instance of TResult Declaration public static ITarget ForDelegate<T1, TResult>(Func<T1, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, TResult> factory Required. The factory delegate that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st delegate parameter TResult The type of the object produced by the factory delegate. Remarks All arguments to the delegate are injected from the container when executed | Improve this Doc View Source ForDelegate<T1, T2, TResult>(Func<T1, T2, TResult>, Type) Creates a DelegateTarget for a factory delegate which takes 2 arguments and which returns an instance of TResult Declaration public static ITarget ForDelegate<T1, T2, TResult>(Func<T1, T2, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, TResult> factory Required. The factory delegate that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st delegate parameter T2 Type of the 2nd delegate parameter TResult The type of the object produced by the factory delegate. Remarks All arguments to the delegate are injected from the container when executed | Improve this Doc View Source ForDelegate<T1, T2, T3, TResult>(Func<T1, T2, T3, TResult>, Type) Creates a DelegateTarget for a factory delegate which takes 3 arguments and which returns an instance of TResult Declaration public static ITarget ForDelegate<T1, T2, T3, TResult>(Func<T1, T2, T3, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, TResult> factory Required. The factory delegate that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st delegate parameter T2 Type of the 2nd delegate parameter T3 Type of the 3rd delegate parameter TResult The type of the object produced by the factory delegate. Remarks All arguments to the delegate are injected from the container when executed | Improve this Doc View Source ForDelegate<T1, T2, T3, T4, TResult>(Func<T1, T2, T3, T4, TResult>, Type) Creates a DelegateTarget for a factory delegate which takes 4 arguments and which returns an instance of TResult Declaration public static ITarget ForDelegate<T1, T2, T3, T4, TResult>(Func<T1, T2, T3, T4, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, TResult> factory Required. The factory delegate that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st delegate parameter T2 Type of the 2nd delegate parameter T3 Type of the 3rd delegate parameter T4 Type of the 4th delegate parameter TResult The type of the object produced by the factory delegate. Remarks All arguments to the delegate are injected from the container when executed | Improve this Doc View Source ForDelegate<T1, T2, T3, T4, T5, TResult>(Func<T1, T2, T3, T4, T5, TResult>, Type) Creates a DelegateTarget for a factory delegate which takes 5 arguments and which returns an instance of TResult Declaration public static ITarget ForDelegate<T1, T2, T3, T4, T5, TResult>(Func<T1, T2, T3, T4, T5, TResult> factory, Type declaredType = null) Parameters Type Name Description Func <T1, T2, T3, T4, T5, TResult> factory Required. The factory delegate that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st delegate parameter T2 Type of the 2nd delegate parameter T3 Type of the 3rd delegate parameter T4 Type of the 4th delegate parameter T5 Type of the 5th delegate parameter TResult The type of the object produced by the factory delegate. Remarks All arguments to the delegate are injected from the container when executed | Improve this Doc View Source ForExpression<TResult>(Expression<Func<TResult>>, Type) Creates an ExpressionTarget for a parameterless lambda expression which returns an instance of TResult Declaration public static ITarget ForExpression<TResult>(Expression<Func<TResult>> lambda, Type declaredType = null) Parameters Type Name Description Expression < Func <TResult>> lambda Required. The lambda expression that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description TResult The return type of the lambda expression. | Improve this Doc View Source ForExpression<TResult>(Expression<Func<ResolveContext, TResult>>, Type) Creates an ExpressionTarget for a lambda expression which takes a ResolveContext and which returns an instance of TResult Declaration public static ITarget ForExpression<TResult>(Expression<Func<ResolveContext, TResult>> lambda, Type declaredType = null) Parameters Type Name Description Expression < Func < ResolveContext , TResult>> lambda Required. The lambda expression that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source ForExpression<T1, TResult>(Expression<Func<T1, TResult>>, Type) Creates an ExpressionTarget for a lambda expression which takes 1 argument and which returns an instance of TResult Declaration public static ITarget ForExpression<T1, TResult>(Expression<Func<T1, TResult>> lambda, Type declaredType = null) Parameters Type Name Description Expression < Func <T1, TResult>> lambda Required. The lambda expression that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source ForExpression<T1, T2, TResult>(Expression<Func<T1, T2, TResult>>, Type) Creates an ExpressionTarget for a lambda expression which takes 2 arguments and which returns an instance of TResult Declaration public static ITarget ForExpression<T1, T2, TResult>(Expression<Func<T1, T2, TResult>> lambda, Type declaredType = null) Parameters Type Name Description Expression < Func <T1, T2, TResult>> lambda Required. The lambda expression that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. T2 Type of the 2nd parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source ForExpression<T1, T2, T3, TResult>(Expression<Func<T1, T2, T3, TResult>>, Type) Creates an ExpressionTarget for a lambda expression which takes 3 arguments and which returns an instance of TResult Declaration public static ITarget ForExpression<T1, T2, T3, TResult>(Expression<Func<T1, T2, T3, TResult>> lambda, Type declaredType = null) Parameters Type Name Description Expression < Func <T1, T2, T3, TResult>> lambda Required. The lambda expression that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. T2 Type of the 2nd parameter of the lambda expression. T3 Type of the 3rd parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source ForExpression<T1, T2, T3, T4, TResult>(Expression<Func<T1, T2, T3, T4, TResult>>, Type) Creates an ExpressionTarget for a lambda expression which takes 4 arguments and which returns an instance of TResult Declaration public static ITarget ForExpression<T1, T2, T3, T4, TResult>(Expression<Func<T1, T2, T3, T4, TResult>> lambda, Type declaredType = null) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, TResult>> lambda Required. The lambda expression that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. T2 Type of the 2nd parameter of the lambda expression. T3 Type of the 3rd parameter of the lambda expression. T4 Type of the 4th parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source ForExpression<T1, T2, T3, T4, T5, TResult>(Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) Creates an ExpressionTarget for a lambda expression which takes 5 arguments and which returns an instance of TResult Declaration public static ITarget ForExpression<T1, T2, T3, T4, T5, TResult>(Expression<Func<T1, T2, T3, T4, T5, TResult>> lambda, Type declaredType = null) Parameters Type Name Description Expression < Func <T1, T2, T3, T4, T5, TResult>> lambda Required. The lambda expression that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. T2 Type of the 2nd parameter of the lambda expression. T3 Type of the 3rd parameter of the lambda expression. T4 Type of the 4th parameter of the lambda expression. T5 Type of the 5th parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source ForObject(Object, Type, ScopeBehaviour) Creates a new ObjectTarget for the passed object whose DeclaredType will either be set to object's type (obtained by calling GetType() or declaredType , if it is passed non-null. Declaration public static ITarget ForObject(object object, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description Object object The @object to be wrapped by the new ObjectTarget Type declaredType Optional - will be used to set the DeclaredType of the target that is created. ScopeBehaviour scopeBehaviour The scope behaviour of the target if resolved inside an IContainerScope . Returns Type Description ITarget | Improve this Doc View Source ForObject<T>(T, Type, ScopeBehaviour) Creates a new ObjectTarget for the passed object whose DeclaredType will either be set to T or declaredType , if it is passed non-null. Declaration public static ITarget ForObject<T>(T object, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description T object The @object to be wrapped by the new ObjectTarget Type declaredType Optional - will be used to set the DeclaredType of the target that is created. ScopeBehaviour scopeBehaviour The scope behaviour of the target if resolved inside an IContainerScope . Returns Type Description ITarget Type Parameters Name Description T Type of the object | Improve this Doc View Source ForType(Type, IMemberBindingBehaviour) Creates a ConstructorTarget or GenericConstructorTarget for the type type . Declaration public static ITarget ForType(Type type, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description Type type The type whose constructor is to be bound by the target. IMemberBindingBehaviour memberBinding The member binding behaviour. Returns Type Description ITarget Remarks If the type is a generic type definition, then a GenericConstructorTarget is created; otherwise a ConstructorTarget is created. | Improve this Doc View Source ForType(Type, IDictionary<String, ITarget>, IMemberBindingBehaviour) Creates a ConstructorTarget or GenericConstructorTarget for the type type . Declaration public static ITarget ForType(Type type, IDictionary<string, ITarget> namedArgs, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description Type type The type whose constructor is to be bound by the target. IDictionary < String , ITarget > namedArgs Optional. A dictionary of targets that are to be bound to the type's constructor by name and type. If type is a generic type definition, then this parameter must be null, or an ArgumentException will be thrown. IMemberBindingBehaviour memberBinding The member binding behaviour. Returns Type Description ITarget Remarks If the type is a generic type definition, then a GenericConstructorTarget is created; otherwise a ConstructorTarget is created. | Improve this Doc View Source ForType(Type, Object, IMemberBindingBehaviour) Creates a ConstructorTarget or GenericConstructorTarget for the type type . Declaration public static ITarget ForType(Type type, object namedArgs, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description Type type The type whose constructor is to be bound by the target. Object namedArgs Optional. An object whose publicly readable members which are of the type ITarget (or a type which implements it) are to be bound to the type's constructor by name and DeclaredType . If type is a generic type definition, then this parameter must be null, or an ArgumentException will be thrown. IMemberBindingBehaviour memberBinding The member binding behaviour. Returns Type Description ITarget Remarks If the type is a generic type definition, then a GenericConstructorTarget is created; otherwise a ConstructorTarget is created. Examples This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a ConstructorTarget for the type 'MyType': Target.ForType(typeof(MyType), namedArguments: new { param1 = new ObjectTarget(\" Hello World\") }); | Improve this Doc View Source ForType<T>(IMemberBindingBehaviour) Creates a ConstructorTarget or GenericConstructorTarget for the type T . Declaration public static ITarget ForType<T>(IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description IMemberBindingBehaviour memberBinding The member binding behaviour. Returns Type Description ITarget Type Parameters Name Description T The type whose constructor is to be bound by the target. Remarks If the type is a generic type definition, then a GenericConstructorTarget is created; otherwise a ConstructorTarget is created. | Improve this Doc View Source ForType<T>(IDictionary<String, ITarget>, IMemberBindingBehaviour) Creates a ConstructorTarget or GenericConstructorTarget for the type T . Declaration public static ITarget ForType<T>(IDictionary<string, ITarget> namedArgs, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description IDictionary < String , ITarget > namedArgs Can be null. A dictionary of targets that are to be bound to the type's constructor by name and DeclaredType . If T is a generic type definition, then this parameter must be null, or an ArgumentException will be thrown. IMemberBindingBehaviour memberBinding Optional. The member binding behaviour to be used - controls whether and which properties and/or fields also receive values injected from the container when an instance is created. Returns Type Description ITarget Type Parameters Name Description T The type whose constructor is to be bound by the target. Remarks If the type is a generic type definition, then a GenericConstructorTarget is created; otherwise a ConstructorTarget is created. | Improve this Doc View Source ForType<T>(Object, IMemberBindingBehaviour) Creates a ConstructorTarget or GenericConstructorTarget for the type T . Declaration public static ITarget ForType<T>(object namedArgs, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description Object namedArgs Optional. An object whose publicly readable members which are of the type ITarget (or a type which implements it) are to be bound to the type's constructor by name and DeclaredType . If T is a generic type definition, then this parameter must be null, or an ArgumentException will be thrown. IMemberBindingBehaviour memberBinding The member binding behaviour. Returns Type Description ITarget Type Parameters Name Description T The type whose constructor is to be bound by the target. Remarks If the type is a generic type definition, then a GenericConstructorTarget is created; otherwise a ConstructorTarget is created. Examples This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a ConstructorTarget for the type 'MyType': Target.ForType<MyType>(namedArguments: new { param1 = new ObjectTarget(\"Hello World\") }); | Improve this Doc View Source Resolved(Type, ITarget) Creates a ResolvedTarget for the given type, providing a way to call back into the container during the execution of another target. Declaration public static ITarget Resolved(Type type, ITarget fallbackTarget = null) Parameters Type Name Description Type type Required. The type to be resolved from the container. ITarget fallbackTarget Optional. If provided and the container is unable to resolve the type , then this target is used instead. Returns Type Description ITarget | Improve this Doc View Source Scoped(ITarget) Extension method which creates a ScopedTarget from the target on which this method is invoked. Declaration public static ITarget Scoped(this ITarget target) Parameters Type Name Description ITarget target Returns Type Description ITarget | Improve this Doc View Source Singleton(ITarget) Extension method which constructs a SingletonTarget that wraps the target on which the method is invoked. Declaration public static ITarget Singleton(this ITarget target) Parameters Type Name Description ITarget target Returns Type Description ITarget | Improve this Doc View Source Unscoped(ITarget) Extension method which creates an UnscopedTarget from the target on which this method is invoked. Declaration public static ITarget Unscoped(this ITarget target) Parameters Type Name Description ITarget target The target. Returns Type Description ITarget"
  },
  "api/Rezolver.Targets.OptionalParameterTarget.html": {
    "href": "api/Rezolver.Targets.OptionalParameterTarget.html",
    "title": "Class OptionalParameterTarget | Rezolver IOC Framework",
    "keywords": "Class OptionalParameterTarget Used specifically when binding arguments to method parameters when a parameter is optional and its default value is to be used when binding to it. It is highly unlikely you'll ever create one of these directly. Inheritance Object TargetBase OptionalParameterTarget Inherited Members TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Targets Assembly :rezolver-docfx.dll Syntax public class OptionalParameterTarget : TargetBase, ITarget Constructors | Improve this Doc View Source OptionalParameterTarget(ParameterInfo) Constructs a new instance of the OptionalParameterTarget class. Declaration public OptionalParameterTarget(ParameterInfo methodParameter) Parameters Type Name Description ParameterInfo methodParameter Required - parameter to which this target will be bound. Its IsOptional property must be true otherwise an ArgumentException is thrown. Properties | Improve this Doc View Source DeclaredType Always returns the ParameterType of the MethodParameter Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source MethodParameter The parameter to which this target is bound. Declaration public ParameterInfo MethodParameter { get; } Property Value Type Description ParameterInfo | Improve this Doc View Source ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour | Improve this Doc View Source UseFallback Always returns true, since using a default argument of a parameter is always considered to be a last-resort. Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides TargetBase.UseFallback | Improve this Doc View Source Value Gets the value represented by this target. This is either the default value of the MethodParameter , if applicable, or the default for the parameter type. Declaration public object Value { get; } Property Value Type Description Object The value. Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Targets.ResolvedTarget.html": {
    "href": "api/Rezolver.Targets.ResolvedTarget.html",
    "title": "Class ResolvedTarget | Rezolver IOC Framework",
    "keywords": "Class ResolvedTarget Represents a target that is rezolved statically at compile time via the ICompileContext , or dynamically (at 'resolve time') from the IContainer that is attached to the current ResolveContext when Resolve(ResolveContext) is called. This is the most common way that we bind constructor parameters, for example - i.e. 'I want an IService instance - go get it'. Inheritance Object TargetBase ResolvedTarget Inherited Members TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Targets Assembly :rezolver-docfx.dll Syntax public class ResolvedTarget : TargetBase, ITarget Remarks Represents an object that will be resolved from the container when its ICompiledTarget is executed, or when the target is used perhaps by another ITarget (e.g. - a ConstructorTarget with a constructor parameter bound to one of these). So, in essence, a ResolvedTarget represents an automatic call to a container's Resolve(ResolveContext) method, for the DeclaredType . In practise - an ITargetCompiler might take advantage of the fact that, during compilation, targets can be discovered directly from the ICompileContext that is passed to CompileTarget(ITarget, ICompileContext) by leveraging its ITargetContainer implementation. Indeed - the expressions compiler uses this to avoid repeated recursion into the Resolve method of the container, instead choosing to compile all the expressions for all targets required for an operation into one dynamically built method - which results in very fast execution times for all resolve operations. Not only this, but the behaviour can be extended still further by realising that a Container on which a resolve operation is invoked might not be the same container for which this ResolvedTarget was first compiled. In this case - it's possible that the other container has alternative registrations for a given service type which the application expects to take precedence over those which were originally resolved when compilation took place. The expressions compiler, again, detects this - allowing compiled code from a root container to detect an 'overriding' container and to dynamically resolve a different dependency in this situation. It's this behaviour which is almost unique to the Rezolver framework out of the box. Constructors | Improve this Doc View Source ResolvedTarget(Type, ITarget) Creates a new ResolvedTarget for the given type which will attempt to resolve a value at compile time and/or resolve-time and, if it can't, will either use the fallbackTarget or will throw an exception. Declaration public ResolvedTarget(Type type, ITarget fallbackTarget = null) Parameters Type Name Description Type type Required. The type to be resolved ITarget fallbackTarget Optional. The target to be used if the value cannot be resolved at either compile time or resolve-time. An ArgumentException is thrown if this target's SupportsType(Type) function returns false when called with the type . Properties | Improve this Doc View Source DeclaredType The type that is to be resolved from the container at resolve-time. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source FallbackTarget Gets the target that this ResolvedTarget will fallback to if a satisfactory target cannot be found at compile time or resolve-time. Declaration public ITarget FallbackTarget { get; } Property Value Type Description ITarget Remarks The UseFallback property is also used to determine whether this will be used. If the target resolved from the ICompileContext has its UseFallback property set to true, and this property is non-null for this target, then this target will be used. Note also that extension containers such as OverridingContainer also have the ability to override the use of this fallback if they successfully resolve the type. | Improve this Doc View Source ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour Methods | Improve this Doc View Source Bind(ICompileContext) Attempts to obtain the target that this ResolvedTarget resolves to for the given ICompileContext . This function should be used by ITargetCompiler implementations when producing the ICompiledTarget for this instance, who wish to perform some form of up-front optimisations. Declaration public virtual ITarget Bind(ICompileContext context) Parameters Type Name Description ICompileContext context The context from which a target is to be resolved. Returns Type Description ITarget The target resolved by this target - could be the FallbackTarget , could be null. Remarks The target that is returned depends both on the context passed and also whether a FallbackTarget has been provided to this target. Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.DefaultMemberBindingBehaviour.html": {
    "href": "api/Rezolver.DefaultMemberBindingBehaviour.html",
    "title": "Class DefaultMemberBindingBehaviour | Rezolver IOC Framework",
    "keywords": "Class DefaultMemberBindingBehaviour WILL BE RENAMED TO AllMembersBindingBehaviour IN 1.2 - SEE https://github.com/ZolutionSoftware/Rezolver/issues/7 FOR MORE The default implementation of IMemberBindingBehaviour when you are creating a ConstructorTarget or GenericConstructorTarget and you want publicly writable properties and public fields to be assigned values obtained from the container. If you do not require properties or fields to be bound from the container, then use a null IMemberBindingBehaviour . Inheritance Object DefaultMemberBindingBehaviour Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax [Obsolete(\"This type will be renamed to AllMembersBindingBehaviour in 1.2 - see https://github.com/ZolutionSoftware/Rezolver/issues/7\")] public class DefaultMemberBindingBehaviour : IMemberBindingBehaviour Remarks This is a stateless singleton accessible through the Instance static property. The class also serves as a good starting point for any custom binding behaviours you might need - as there are numerous virtual methods which allow you to change which fields and/or properties are selected for binding, as well as how those bindings are created. The default behaviour is bind each member to a new ResolvedTarget whose DeclaredType is set to the member's type. Constructors | Improve this Doc View Source DefaultMemberBindingBehaviour() Constructs a new instance of the DefaultMemberBindingBehaviour class. Declaration protected DefaultMemberBindingBehaviour() Properties | Improve this Doc View Source Instance Gets the one and only instance of DefaultMemberBindingBehaviour Declaration public static DefaultMemberBindingBehaviour Instance { get; } Property Value Type Description DefaultMemberBindingBehaviour Methods | Improve this Doc View Source BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) Called by GetMemberBindings(ICompileContext, Type) - iterates through the fields , calling CreateBinding(ICompileContext, Type, FieldInfo) for each, and those which are non-null. Declaration protected virtual IEnumerable<MemberBinding> BindFields(ICompileContext context, Type type, IEnumerable<FieldInfo> fields) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. IEnumerable < FieldInfo > fields The fields for which bindings are to be created. This is fed by the function GetBindableFields(ICompileContext, Type) Returns Type Description IEnumerable < MemberBinding > | Improve this Doc View Source BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) Called by GetMemberBindings(ICompileContext, Type) - iterates through the properties , calling CreateBinding(ICompileContext, Type, PropertyInfo) for each, and those which are non-null. Declaration protected virtual IEnumerable<MemberBinding> BindProperties(ICompileContext context, Type type, IEnumerable<PropertyInfo> properties) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. IEnumerable < PropertyInfo > properties The properties for which bindings are to be created. This is fed by the function GetBindableProperties(ICompileContext, Type) Returns Type Description IEnumerable < MemberBinding > An enumerable of MemberBinding objects representing the bindings to be used for each bindable property in properties . | Improve this Doc View Source CreateBinding(ICompileContext, Type, FieldInfo) Creates a binding for the given field. Called by GetMemberBindings(ICompileContext, Type) Declaration protected virtual MemberBinding CreateBinding(ICompileContext context, Type type, FieldInfo field) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. FieldInfo field The field for which a binding is to be created. Returns Type Description MemberBinding Remarks Override this method to customise the binding that is create for the given field, or to prevent the binding from being created at all(return null if you want to abort binding the field). The base implementation simply creates a new MemberBinding whose Target is set to a new ResolvedTarget for the type FieldType - thus causing the field to be assigned a value resolved from the container when the instance is created. | Improve this Doc View Source CreateBinding(ICompileContext, Type, PropertyInfo) Creates a binding for the given property. Called by GetMemberBindings(ICompileContext, Type) Declaration protected virtual MemberBinding CreateBinding(ICompileContext context, Type type, PropertyInfo prop) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. PropertyInfo prop The property for which a binding is to be created. Returns Type Description MemberBinding Remarks Override this method to customise the binding that is create for the given property, or to prevent the binding from being created at all(return null if you want to abort binding the property). The base implementation simply creates a new MemberBinding whose Target is set to a new ResolvedTarget for the type PropertyType - thus causing the property to be assigned a value resolved from the container when the instance is created. | Improve this Doc View Source GetBindableFields(ICompileContext, Type) Gets the bindable fields on the type . Used by GetMemberBindings(ICompileContext, Type) and passed to the BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) method. Declaration protected virtual IEnumerable<FieldInfo> GetBindableFields(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. Returns Type Description IEnumerable < FieldInfo > Remarks Override this method to filter the fields which can be bound. The base implementation returns all public instance fields declared on the type . | Improve this Doc View Source GetBindableProperties(ICompileContext, Type) Gets the bindable properties on the type . Used by GetMemberBindings(ICompileContext, Type) and passed to the BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) method. Declaration protected virtual IEnumerable<PropertyInfo> GetBindableProperties(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. Returns Type Description IEnumerable < PropertyInfo > Remarks Override this method to filter the properties which can be bound. The base implementation returns all instance properties which have publicly accessible 'set' accessors. | Improve this Doc View Source GetMemberBindings(ICompileContext, Type) Implementation of GetMemberBindings(ICompileContext, Type) . Declaration public virtual MemberBinding[] GetMemberBindings(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. Returns Type Description MemberBinding [] Implements IMemberBindingBehaviour.GetMemberBindings(ICompileContext, Type) Remarks The base implementation calls GetBindableProperties(ICompileContext, Type) , passing the resultant enumerable to the BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) function; it also does the same thing with GetBindableFields(ICompileContext, Type) and BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) - concatenating the two enumerables together and returning the result as an array of MemberBinding objects. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also IMemberBindingBehaviour"
  },
  "api/Rezolver.ICompiledTarget.html": {
    "href": "api/Rezolver.ICompiledTarget.html",
    "title": "Interface ICompiledTarget | Rezolver IOC Framework",
    "keywords": "Interface ICompiledTarget Provides an abstraction for creating objects based on a given ResolveContext - this is the ultimate target of all Resolve(ResolveContext) calls in the standard container implementations within the Rezolver framework. Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public interface ICompiledTarget Remarks In the standard implementations of IContainer (e.g. Container ), a ITargetCompiler creates instances of this from ITarget s which are registered in an ITargetContainer . When the container is then called upon to resolve an instance of a particular type, the ICompiledTarget is first obtained, and then the responsibility for creating the object is delegated to its GetObject(ResolveContext) method. Methods | Improve this Doc View Source GetObject(ResolveContext) Called to get/create an object, potentially using the passed context to resolve additional dependencies (via its Container ), or interact with any lifetime scope which is 'active' for that request (through Scope ). Declaration object GetObject(ResolveContext context) Parameters Type Name Description ResolveContext context The current rezolve context. Returns Type Description Object The object that is constructed. The return value can legitimately be null. Exceptions Type Condition InvalidOperationException If the target fails to create the object Exception Any other application-level exception could be raised by this operation Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.MethodCallExtractor.html": {
    "href": "api/Rezolver.MethodCallExtractor.html",
    "title": "Class MethodCallExtractor | Rezolver IOC Framework",
    "keywords": "Class MethodCallExtractor Used to help grab method and constructor info from expressions (which is easier than writing long strings of reflection code). For example: MethodCallExtractor.ExtractCalledMethod(() => Console.WriteLine(\"foo\")) Will return the MethodInfo for the WriteLine method of the Console class. Inheritance Object MethodCallExtractor Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public sealed class MethodCallExtractor : ExpressionVisitor Methods | Improve this Doc View Source ExtractCalledMethod(Expression<Action>) Extracts the MethodInfo of the first method call found in the expression. Declaration public static MethodInfo ExtractCalledMethod(Expression<Action> expr) Parameters Type Name Description Expression < System.Action > expr The expression to be read Returns Type Description MethodInfo A MethodInfo representing the method - if the expression contains a method call; otherwise null | Improve this Doc View Source ExtractCalledMethod<T>(Expression<Action<T>>) Extracts the MethodInfo of the first method call found in the expression. Declaration public static MethodInfo ExtractCalledMethod<T>(Expression<Action<T>> expr) Parameters Type Name Description Expression < System.Action <T>> expr The expression to be read Returns Type Description MethodInfo A MethodInfo representing the method - if the expression contains a method call; otherwise null Type Parameters Name Description T Allows the expression to declare a parameter to aid overload resolution, but doesn't actually have any material influence on the expression analysis. | Improve this Doc View Source ExtractCalledMethod<TResult>(Expression<Func<TResult>>) Extracts the MethodInfo of the first method call found in the expression. Declaration public static MethodInfo ExtractCalledMethod<TResult>(Expression<Func<TResult>> expr) Parameters Type Name Description Expression < Func <TResult>> expr The expression to be read Returns Type Description MethodInfo A MethodInfo representing the method - if the expression contains a method call; otherwise null Type Parameters Name Description TResult Return type of the expression. Not actually used in any way, it's just here to allow overload resolution when an expression represents a non-void function call | Improve this Doc View Source ExtractCalledMethod<TInstance, TResult>(Expression<Func<TInstance, TResult>>) Extracts the MethodInfo of the first method call found in the expression. Declaration public static MethodInfo ExtractCalledMethod<TInstance, TResult>(Expression<Func<TInstance, TResult>> expr) Parameters Type Name Description Expression < Func <TInstance, TResult>> expr The expression to be read Returns Type Description MethodInfo A MethodInfo representing the method - if the expression contains a method call; otherwise null Type Parameters Name Description TInstance Allows the expression to declare a parameter to aid overload resolution, but doesn't actually have any material influence on the expression analysis. TResult Return type of the expression. Not actually used in any way, it's just here to allow overload resolution when an expression represents a non-void function call | Improve this Doc View Source ExtractConstructorCall(Expression<Action>) Extracts the ConstructorInfo of the first 'new' statement found in the expression Declaration public static ConstructorInfo ExtractConstructorCall(Expression<Action> expr) Parameters Type Name Description Expression < System.Action > expr The expression to be analysed. Returns Type Description ConstructorInfo A ConstructorInfo representing the constructor being called in the expression; otherwise null if not found. | Improve this Doc View Source ExtractConstructorCall<T>(Expression<Action<T>>) Extracts the ConstructorInfo of the first 'new' statement found in the expression Declaration public static ConstructorInfo ExtractConstructorCall<T>(Expression<Action<T>> expr) Parameters Type Name Description Expression < System.Action <T>> expr The expression to be analysed. Returns Type Description ConstructorInfo A ConstructorInfo representing the constructor being called in the expression; otherwise null if not found. Type Parameters Name Description T Allows the expression to declare a parameter to aid overload resolution, but doesn't actually have any material influence on the expression analysis. | Improve this Doc View Source ExtractConstructorCall<TResult>(Expression<Func<TResult>>) Extracts the ConstructorInfo of the first 'new' statement found in the expression Declaration public static ConstructorInfo ExtractConstructorCall<TResult>(Expression<Func<TResult>> expr) Parameters Type Name Description Expression < Func <TResult>> expr The expression to be analysed. Returns Type Description ConstructorInfo A ConstructorInfo representing the constructor being called in the expression; otherwise null if not found. Type Parameters Name Description TResult Return type of the expression. Not actually used in any way, it's just here to allow overload resolution when an expression represents a non-void function call | Improve this Doc View Source ExtractConstructorCall<TInstance, TResult>(Expression<Func<TInstance, TResult>>) Extracts the ConstructorInfo of the first 'new' statement found in the expression Declaration public static ConstructorInfo ExtractConstructorCall<TInstance, TResult>(Expression<Func<TInstance, TResult>> expr) Parameters Type Name Description Expression < Func <TInstance, TResult>> expr The expression to be analysed. Returns Type Description ConstructorInfo A ConstructorInfo representing the constructor being called in the expression; otherwise null if not found. Type Parameters Name Description TInstance Allows the expression to declare a parameter to aid overload resolution, but doesn't actually have any material influence on the expression analysis. TResult Return type of the expression. Not actually used in any way, it's just here to allow overload resolution when an expression represents a non-void function call | Improve this Doc View Source VisitMethodCall(MethodCallExpression) Visits the children of the MethodCallExpression . Declaration protected override Expression VisitMethodCall(MethodCallExpression node) Parameters Type Name Description MethodCallExpression node The expression to visit. Returns Type Description Expression | Improve this Doc View Source VisitNew(NewExpression) Visits the children of the NewExpression . Declaration protected override Expression VisitNew(NewExpression node) Parameters Type Name Description NewExpression node The expression to visit. Returns Type Description Expression Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.MultipleTargetContainerExtensions.html": {
    "href": "api/Rezolver.MultipleTargetContainerExtensions.html",
    "title": "Class MultipleTargetContainerExtensions | Rezolver IOC Framework",
    "keywords": "Class MultipleTargetContainerExtensions Extensions for registering multiple targets individually and against the same type Inheritance Object MultipleTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public static class MultipleTargetContainerExtensions Methods | Improve this Doc View Source RegisterAll(ITargetContainer, ITarget[]) Performs the same operations as RegisterAll(ITargetContainer, IEnumerable<ITarget>) except via a variable number of ITarget arguments. Declaration public static void RegisterAll(this ITargetContainer targetContainer, params ITarget[] targets) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registrations are to be performed. ITarget [] targets The targets to be registered. | Improve this Doc View Source RegisterAll(ITargetContainer, IEnumerable<ITarget>) Batch-registers multiple targets against their DeclaredType . This is the same as calling Register(ITarget, Type) for each of the targets , except the type cannot be overriden from the target's DeclaredType. Declaration public static void RegisterAll(this ITargetContainer targetContainer, IEnumerable<ITarget> targets) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registrations are to be performed. IEnumerable < ITarget > targets The targets to be registered | Improve this Doc View Source RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) Called to register multiple targets against the same type. It is the same as calling Register(ITarget, Type) multiple times with the different targets. Declaration public static void RegisterMultiple(this ITargetContainer targetContainer, IEnumerable<ITarget> targets, Type commonServiceType = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registration is to be performed. IEnumerable < ITarget > targets The targets to be registered - all must support a common service type (potentially passed in the commonServiceType argument. Type commonServiceType Optional - if provided, then this will be used as the common service type for registration. If not provided, then the DeclaredType of the first target will be used. Remarks If the container has the capability to handle enumerables, then each target will be returned when an IEnumerable of the common service type is requested. This is an opt-in behaviour in Rezolver - implemented by the Rezolver.EnumerableTargetContainer and can be added to a target container with the extension method EnableEnumerableResolving(ITargetContainerOwner) . Note that default behaviour of TargetContainer is for this to be enabled."
  },
  "api/Rezolver.Targets.ChangeTypeTarget.html": {
    "href": "api/Rezolver.Targets.ChangeTypeTarget.html",
    "title": "Class ChangeTypeTarget | Rezolver IOC Framework",
    "keywords": "Class ChangeTypeTarget This target is specifically used for explicitly casting the result of one target to another type. Its use is rare, since the framework already caters for downcasting the result of targets to base types. Inheritance Object TargetBase ChangeTypeTarget Inherited Members TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Targets Assembly :rezolver-docfx.dll Syntax public class ChangeTypeTarget : TargetBase, ITarget Remarks A valid use of this target is when you have a SingletonTarget registered against one type, and you want the same singleton (backed by the same instance) to server another type. In this case, instead of registering the same singleton target multiple times, you can register it once for its primary type, then register one of these for the other type, with a ResolvedTarget as its inner target. When creating this target, the DeclaredType of the InnerTarget must be able to cast up or down to the DeclaredType of this target. Constructors | Improve this Doc View Source ChangeTypeTarget(ITarget, Type) Creates a new instance of the ChangeTypeTarget class. Declaration public ChangeTypeTarget(ITarget innerTarget, Type targetType) Parameters Type Name Description ITarget innerTarget Required. See InnerTarget Type targetType Required. See DeclaredType Properties | Improve this Doc View Source DeclaredType Always returns the target type that was passed in the ChangeTypeTarget(ITarget, Type) constructor. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source InnerTarget The target whose type will be changed to DeclaredType . Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget | Improve this Doc View Source ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Targets.ConstructorTarget.html": {
    "href": "api/Rezolver.Targets.ConstructorTarget.html",
    "title": "Class ConstructorTarget | Rezolver IOC Framework",
    "keywords": "Class ConstructorTarget A target that binds to a type's constructor with zero or more arguments supplied by other ITarget s and, optionally binding to the new instance's writeable properties. The target supports en explicitly supplied constructor, as well as just-in-time lookups for the best available constructor based on the available services and/or any named arguments which might been provided up front. Inheritance Object TargetBase ConstructorTarget Inherited Members TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Targets Assembly :rezolver-docfx.dll Syntax public class ConstructorTarget : TargetBase, ITarget Remarks Although you can create this target directly through the Rezolver.Targets.ConstructorTarget.#ctor(System.Type,System.Reflection.ConstructorInfo,Rezolver.IMemberBindingBehaviour,Rezolver.ParameterBinding[],System.Collections.Generic.IDictionary{System.String,Rezolver.ITarget}) constructor, you're more likely to create it through factory methods such as Auto<T>(IMemberBindingBehaviour) or, more likely still, extension methods such as RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) during your application's container setup phase. To compile this target, an ITargetCompiler must call the Bind(ICompileContext) method Constructors | Improve this Doc View Source ConstructorTarget(ConstructorInfo, ParameterBinding[], IMemberBindingBehaviour) Initializes a new instance of the ConstructorTarget class bound in advance to a specific constructor. Declaration public ConstructorTarget(ConstructorInfo ctor, ParameterBinding[] parameterBindings = null, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ConstructorInfo ctor Required - the constructor that is to be bound. The DeclaredType of the new instance will be set to the DeclaringType of this object. ParameterBinding [] parameterBindings Optional. Specific bindings for the parameters of the given ctor which should be used during code generation. Note that this array can contain fewer or more entries than there are parameters on the ctor . Any missing bindings will be automatically generated when Bind(ICompileContext) is called. IMemberBindingBehaviour memberBinding Optional. If provided, can be used to select properties which are to be initialised before the new instance is returned. | Improve this Doc View Source ConstructorTarget(Type, IDictionary<String, ITarget>, IMemberBindingBehaviour) Initializes a just-in-time-bound instance of the ConstructorTarget class which must be bound to the best constructor at compile-time by calling the Bind(ICompileContext) method. Declaration public ConstructorTarget(Type type, IDictionary<string, ITarget> namedArgs = null, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description Type type Required. The type whose constructor is to bound. IDictionary < String , ITarget > namedArgs Optional. The named arguments which will be passed to, and used to find, the best-matched constructor. These are taken into account when the constructor is sought - with the constructor containing the most matched parameters matched being selected. IMemberBindingBehaviour memberBinding Optional. If provided, can be used to select properties which are to be initialised before the new instance is returned. Remarks To compile this target, a ITargetCompiler first calls the Bind(ICompileContext) method to discover the constructor to be executed, along with the final set of arguments to be provided to it (see ConstructorBinding ). The best available constructor is defined as the constructor with the most parameters for which arguments can be resolved from the ICompileContext at compile-time to the fewest number of ITarget objects whose UseFallback is false. Properties | Improve this Doc View Source Ctor Can be null. Gets the constructor that this target is bound to, if it was known when the target was created. Declaration public ConstructorInfo Ctor { get; } Property Value Type Description ConstructorInfo Remarks ConstructorTargets can be bound to a particular constructor in advance, or they can search for a best-match constructor at the point where Bind(ICompileContext) is called. This property will only be set ultimately if it was passed to the ConstructorTarget(ConstructorInfo, ParameterBinding[], IMemberBindingBehaviour) constructor, possibly by a factory method like WithArgs(ConstructorInfo, IDictionary<String, ITarget>) is captured within the expression. | Improve this Doc View Source DeclaredType Implementation of DeclaredType . Always equal to the type whose constructor will be bound by this target. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source MemberBindingBehaviour Gets the member binding behaviour to be used when Bind(ICompileContext) is called. Declaration public IMemberBindingBehaviour MemberBindingBehaviour { get; } Property Value Type Description IMemberBindingBehaviour | Improve this Doc View Source NamedArgs Named arguments (as ITarget objects) to be supplied to the object on construction, also aiding the search for a constructor. This equivalent to the way that languages such as C# can bind to overloaded functions based solely on named arguments. Declaration public IReadOnlyDictionary<string, ITarget> NamedArgs { get; } Property Value Type Description IReadOnlyDictionary < String , ITarget > Remarks Note the difference between this and ParameterBindings - this property might be used when the constructor is not known in advance, whereas ParameterBindings is used when it is. | Improve this Doc View Source ParameterBindings If this target was created with a specific constructor then this might contain argument bindings for that constructor's parameters. Declaration public IReadOnlyList<ParameterBinding> ParameterBindings { get; } Property Value Type Description IReadOnlyList < ParameterBinding > Remarks This is not the same as NamedArgs - as is noted by the documentation on that property. This property is for when the constructor is known in advance and when certain parameters are to be bound with specific arguments; whereas NamedArgs is for when the constructor is not known. Methods | Improve this Doc View Source Auto(Type, IMemberBindingBehaviour) This method has been replaced by the Target.ForType method and will be removed in 1.2. Creates a late bound ConstructorTarget or GenericConstructorTarget for the given type . Declaration [Obsolete(\"This method has been replaced by the Target.ForType overloaded method and will be removed in 1.2\")] public static ITarget Auto(Type type, IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description Type type The type that is to be constructed when this target is compiled and executed. IMemberBindingBehaviour memberBindingBehaviour Optional. An object which selects properties on the new instance which are to be bound from the container. Returns Type Description ITarget Either a ConstructorTarget or GenericConstructorTarget , depending on whether the type is a generic type definition. Remarks This factory is merely a shortcut for calling the ConstructorTarget(Type, IDictionary<String, ITarget>, IMemberBindingBehaviour) with only the type and memberBindingBehaviour arguments supplied. When creating a GenericConstructorTarget , the function uses the GenericConstructorTarget(Type, IMemberBindingBehaviour) constructor. | Improve this Doc View Source Auto<T>(IMemberBindingBehaviour) This method has been replaced by the Target.ForType method and will be removed in 1.2. Generic version of the Auto(Type, IMemberBindingBehaviour) method. Declaration [Obsolete(\"This method has been replaced by the Target.ForType overloaded method and will be removed in 1.2\")] public static ITarget Auto<T>(IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description IMemberBindingBehaviour memberBindingBehaviour See the documentation for the memberBindingBehaviour parameter on the non-generic version of this method. Returns Type Description ITarget Either a ConstructorTarget or GenericConstructorTarget , depending on whether T is a generic type definition. Type Parameters Name Description T The type that is to be constructed when the new target is compiled and executed. | Improve this Doc View Source Bind(ICompileContext) Gets the ConstructorBinding for the DeclaredType using the targets available in the context for dependency lookup. The constructor is either resolved by checking available targets for the best match, or is pre-selected on construction ( Ctor will be non-null in this case). Declaration public ConstructorBinding Bind(ICompileContext context) Parameters Type Name Description ICompileContext context The current compilation context. Returns Type Description ConstructorBinding Exceptions Type Condition AmbiguousMatchException If more than one constructor can be bound with an equal amount of all-resolved arguments or default arguments. InvalidOperationException If no sutiable constructors can be found. | Improve this Doc View Source WithArgs(ConstructorInfo, IDictionary<String, ITarget>) This method has been replaced by the Target.ForType method and will be removed in 1.2. Similar to WithArgs(Type, IDictionary<String, ITarget>) except this one creates a ConstructorTarget that is specifically bound to a particular constructor on a given type, using any matched argument bindings from the provided namedArgs dictionary, and using ResolvedTarget targets for any that are not matched. Declaration [Obsolete(\"This method has been replaced by the Target.ForType overloaded method and will be removed in 1.2\")] public static ITarget WithArgs(ConstructorInfo ctor, IDictionary<string, ITarget> namedArgs) Parameters Type Name Description ConstructorInfo ctor Required. The constructor to be bound. IDictionary < String , ITarget > namedArgs Optional. Any arguments to be supplied to parameters on the ctor by name. Any parameters for which matches are not found in this dictionary will be automatically bound either from compile-time defaults or by resolving those types dynamically. Returns Type Description ITarget Remarks Although this overload accepts a dictionary of arguments, note that it will not result in the NamedArgs property being set on the target that is created - it's just an alternative for deriving the ParameterBindings with which the target will be created. Also, this function will not fail if the args dictionary contains named arguments that cannot be matched to parameters on the ctor . | Improve this Doc View Source WithArgs(ConstructorInfo, Object) This method has been replaced by the Target.ForType method and will be removed in 1.2. Performs the same operation as WithArgs(ConstructorInfo, IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration [Obsolete(\"This method has been replaced by the Target.ForType overloaded method and will be removed in 1.2\")] public static ITarget WithArgs(ConstructorInfo ctor, object namedArgs) Parameters Type Name Description ConstructorInfo ctor Required. The constructor to be bound. Object namedArgs An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Remarks Although this overload accepts a dictionary of arguments, note that it will not result in the NamedArgs property being set on the target that is created - it's just an alternative for deriving the ParameterBindings with which the target will be created. Also, this function will not fail if the args dictionary contains named arguments that cannot be matched to parameters on the ctor . | Improve this Doc View Source WithArgs(Type, IDictionary<String, ITarget>) This method has been replaced by the Target.ForType method and will be removed in 1.2. Non-generic version of WithArgs<T>(IDictionary<String, ITarget>) . Creates a ConstructorTarget with a set of named targets which will be used like named arguments to late-bind the constructor when code-generation occurs. Declaration [Obsolete(\"This method has been replaced by the Target.ForType overloaded method and will be removed in 1.2\")] public static ITarget WithArgs(Type declaredType, IDictionary<string, ITarget> namedArgs) Parameters Type Name Description Type declaredType The type whose constructor is to be bound. IDictionary < String , ITarget > namedArgs The named arguments to be used when building the expression. Returns Type Description ITarget Remarks Both versions of this method will create a target which will try to find the best-matching constructor where all of the named arguments match, and with the fewest number of auto-resolved arguments. So, a class with a constructor such as Foo(IService1 s1, IService2 s2) Can happily be bound if you only provide a named argument for 's1'; the target will simply attempt to auto-resolve the argument for the IService2 s2 parameter when constructing the object - and will fail only if it can't be resolved at that point. | Improve this Doc View Source WithArgs(Type, Object) This method has been replaced by the Target.ForType method and will be removed in 1.2. Performs the same operation as WithArgs(Type, IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration [Obsolete(\"This method has been replaced by the Target.ForType overloaded method and will be removed in 1.2\")] public static ITarget WithArgs(Type declaredType, object namedArgs) Parameters Type Name Description Type declaredType The type whose constructor is to be bound. Object namedArgs An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Remarks This overload exists to simplify the process of creating a ConstructorTarget with argument bindings by removing the need to create an argument dictionary in advance. An anonymous type can instead be used to supply the arguments. Examples This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a ConstructorTarget for the type 'MyType': ConstructorTarget.WithArgs(typeof(MyType), new { param1 = new ObjectTarget(\"Hello World\") }); | Improve this Doc View Source WithArgs<T>(IDictionary<String, ITarget>) This method has been replaced by the Target.ForType method and will be removed in 1.2. Creates a ConstructorTarget with a set of named targets which will be used like named arguments to late-bind the constructor when code-generation occurs. Declaration [Obsolete(\"This method has been replaced by the Target.ForType overloaded method and will be removed in 1.2\")] public static ITarget WithArgs<T>(IDictionary<string, ITarget> namedArgs) Parameters Type Name Description IDictionary < String , ITarget > namedArgs The named arguments to be used when building the expression. Returns Type Description ITarget Type Parameters Name Description T The type whose constructor is to be bound Remarks Both versions of this method will create a target which will try to find the best-matching constructor where all of the named arguments match, and with the fewest number of auto-resolved arguments. So, a class with a constructor such as Foo(IService1 s1, IService2 s2) Can happily be bound if you only provide a named argument for 's1'; the target will simply attempt to auto-resolve the argument for the IService2 s2 parameter when constructing the object - and will fail only if it can't be resolved at that point. | Improve this Doc View Source WithArgs<T>(Object) This method has been replaced by the Target.ForType method and will be removed in 1.2. Performs the same operation as WithArgs<T>(IDictionary<String, ITarget>) except the arguments are pulled from the publicly readable properties and fields of the passed namedArgs object. Declaration [Obsolete(\"This method has been replaced by the Target.ForType overloaded method and will be removed in 1.2\")] public static ITarget WithArgs<T>(object namedArgs) Parameters Type Name Description Object namedArgs An object whose properties/fields provide the names and values for the argument which are to be used when binding the type's constructor. Only properties and fields whose value is ITarget are considered. Returns Type Description ITarget Type Parameters Name Description T Remarks This overload exists to simplify the process of creating a ConstructorTarget with argument bindings by removing the need to create an argument dictionary in advance. An anonymous type can instead be used to supply the arguments. Examples This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a ConstructorTarget for the type 'MyType': ConstructorTarget.WithArgs<MyType>(new { param1 = new ObjectTarget(\"Hello World\") }); Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Targets.TargetBase.html": {
    "href": "api/Rezolver.Targets.TargetBase.html",
    "title": "Class TargetBase | Rezolver IOC Framework",
    "keywords": "Class TargetBase Abstract base class, suggested as a starting point for implementations of ITarget . Inheritance Object TargetBase ChangeTypeTarget ConstructorTarget DecoratorTarget DefaultTarget DelegateTarget ExpressionTarget GenericConstructorTarget ListTarget ObjectTarget OptionalParameterTarget ResolvedTarget ScopedTarget SingletonTarget UnscopedTarget Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Targets Assembly :rezolver-docfx.dll Syntax public abstract class TargetBase : ITarget Properties | Improve this Doc View Source DeclaredType Gets the declared type of object that is constructed by this target. Declaration public abstract Type DeclaredType { get; } Property Value Type Description Type Implements ITarget.DeclaredType | Improve this Doc View Source ScopeBehaviour Gets the scoping behaviour for instances that will ultimately be produced by this target. Declaration public virtual ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Implements ITarget.ScopeBehaviour Remarks Base implementation always returns Implicit . | Improve this Doc View Source UseFallback Implementation of UseFallback Base version always returns false . Declaration public virtual bool UseFallback { get; } Property Value Type Description Boolean Implements ITarget.UseFallback Methods | Improve this Doc View Source SelectScope(ResolveContext) Selects the scope. Declaration public virtual IContainerScope SelectScope(ResolveContext context) Parameters Type Name Description ResolveContext context The context. Returns Type Description IContainerScope Implements ITarget.SelectScope(ResolveContext) | Improve this Doc View Source SupportsType(Type) Implementation of SupportsType(Type) . Returns a boolean indicating whether the target is able to produce an instance of, or an instance that is compatible with, the passed type . Declaration public virtual bool SupportsType(Type type) Parameters Type Name Description Type type The type. Returns Type Description Boolean Implements ITarget.SupportsType(Type) Remarks It is strongly suggested that you use this method to check whether the target can construct an instance of a given type rather than performing any type checking yourself on the DeclaredType , because an ITarget might be able to support a much wider range of types other than just those which are directly compatible with its DeclaredType . For example, the GenericConstructorTarget is statically bound to an open generic, so therefore traditional type checks on the DeclaredType do not work. That class' implementation of this method, however, contains the complex logic necessary to determine if the open generic can be closed into a generic type which is compatible with the given type . Implementations of ITargetCompiler should always consult this function in their implementation of CompileTarget(ITarget, ICompileContext) to determine if the target is compatible with the TargetType of the CompileContext Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.CompilerConfiguration.html": {
    "href": "api/Rezolver.Compilation.CompilerConfiguration.html",
    "title": "Class CompilerConfiguration | Rezolver IOC Framework",
    "keywords": "Class CompilerConfiguration Controls the system-wide compiler configuration used by default by all standard Rezolver containers. Inheritance Object CompilerConfiguration Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation Assembly :rezolver-docfx.dll Syntax public static class CompilerConfiguration Properties | Improve this Doc View Source DefaultProvider Gets or sets the default ICompilerConfigurationProvider used by classes derived from ContainerBase to self-configure for target compilation. Declaration public static ICompilerConfigurationProvider DefaultProvider { get; set; } Property Value Type Description ICompilerConfigurationProvider Remarks The default implementation will throw an InvalidOperationException as soon as its Configure(IContainer, ITargetContainer) method is called - therefore it's imperative either that you change this provider for one which actually configures the container to support compilation, or that you explicitly pass a provider to the container when you create it. The standard expression compiler defined in the Rezolver.Compilation.Expressions library defines a provider in Rezolver.Compilation.Expressions.ConfigProvider , and a static configuration method UseAsDefaultCompiler which automatically sets it into this property for you."
  },
  "api/Rezolver.Compilation.Expressions.DelegateTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.DelegateTargetBuilder.html",
    "title": "Class DelegateTargetBuilder | Rezolver IOC Framework",
    "keywords": "Class DelegateTargetBuilder Specialised builder for the DelegateTarget class and all its derivatives. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < DelegateTarget > DelegateTargetBuilder Inherited Members ExpressionBuilderBase<DelegateTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DelegateTarget>.IExpressionBuilder<DelegateTarget>.Build(DelegateTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DelegateTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class DelegateTargetBuilder : ExpressionBuilderBase<DelegateTarget>, IExpressionBuilder<DelegateTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(DelegateTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target for the given IExpressionCompileContext Declaration protected override Expression Build(DelegateTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description DelegateTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.DelegateTarget>.Build(Rezolver.Targets.DelegateTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Exceptions Type Condition NotImplementedException Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionTargetBuilder.html",
    "title": "Class ExpressionTargetBuilder | Rezolver IOC Framework",
    "keywords": "Class ExpressionTargetBuilder An IExpressionBuilder specialised for building the expression trees for the ExpressionTarget target type. This builder takes care of all expressions, including lambdas (where additional parameters beyond the standard ResolveContext are turned into local variables with injected values), producing an expression which can be compiled by an IExpressionCompiler after a Rezolver.Compilation.Expressions.TargetExpressionRewriter has been used to expand any targets embedded in the expression. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ExpressionTarget > ExpressionTargetBuilder Inherited Members ExpressionBuilderBase<ExpressionTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ExpressionTarget>.IExpressionBuilder<ExpressionTarget>.Build(ExpressionTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ExpressionTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class ExpressionTargetBuilder : ExpressionBuilderBase<ExpressionTarget>, IExpressionBuilder<ExpressionTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ExpressionTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(ExpressionTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ExpressionTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ExpressionTarget>.Build(Rezolver.Targets.ExpressionTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.ObjectTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ObjectTargetBuilder.html",
    "title": "Class ObjectTargetBuilder | Rezolver IOC Framework",
    "keywords": "Class ObjectTargetBuilder An IExpressionBuilder specialised to build expressions for the ObjectTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ObjectTarget > ObjectTargetBuilder Inherited Members ExpressionBuilderBase<ObjectTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ObjectTarget>.IExpressionBuilder<ObjectTarget>.Build(ObjectTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ObjectTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class ObjectTargetBuilder : ExpressionBuilderBase<ObjectTarget>, IExpressionBuilder<ObjectTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ObjectTarget, IExpressionCompileContext, IExpressionCompiler) returns a ConstantExpression wrapped around the Value reference. Declaration protected override Expression Build(ObjectTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ObjectTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ObjectTarget>.Build(Rezolver.Targets.ObjectTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Exceptions Type Condition NotImplementedException Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.UnscopedTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.UnscopedTargetBuilder.html",
    "title": "Class UnscopedTargetBuilder | Rezolver IOC Framework",
    "keywords": "Class UnscopedTargetBuilder Builder for the UnscopedTarget . Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < UnscopedTarget > UnscopedTargetBuilder Inherited Members ExpressionBuilderBase<UnscopedTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<UnscopedTarget>.IExpressionBuilder<UnscopedTarget>.Build(UnscopedTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<UnscopedTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class UnscopedTargetBuilder : ExpressionBuilderBase<UnscopedTarget>, IExpressionBuilder<UnscopedTarget>, IExpressionBuilder Methods | Improve this Doc View Source ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) overrides the base method to block all automatic scoping code from the expression being built. Declaration protected override Expression ApplyScoping(ScopeBehaviour scopeBehaviour, Expression builtExpression, ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ScopeBehaviour scopeBehaviour Expression builtExpression ITarget target IExpressionCompileContext context IExpressionCompiler compiler Returns Type Description Expression Overrides ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) | Improve this Doc View Source Build(UnscopedTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(UnscopedTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description UnscopedTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.UnscopedTarget>.Build(Rezolver.Targets.UnscopedTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ContainerResolveExtensions.html": {
    "href": "api/Rezolver.ContainerResolveExtensions.html",
    "title": "Class ContainerResolveExtensions | Rezolver IOC Framework",
    "keywords": "Class ContainerResolveExtensions Extension methods for IContainer which provide shortcuts for the Resolve(ResolveContext) operation. Inheritance Object ContainerResolveExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public static class ContainerResolveExtensions Methods | Improve this Doc View Source CanResolve(IContainer, Type) Determines whether this instance can resolve the specified type - wrapper for CanResolve(ResolveContext) Declaration public static bool CanResolve(this IContainer container, Type type) Parameters Type Name Description IContainer container The container. Type type The type. Returns Type Description Boolean | Improve this Doc View Source CanResolve<TObject>(IContainer) Determines whether this instance can resolve the specified container - wrapper for CanResolve(ResolveContext) Declaration public static bool CanResolve<TObject>(this IContainer container) Parameters Type Name Description IContainer container The container. Returns Type Description Boolean Type Parameters Name Description TObject The type to be checked.. | Improve this Doc View Source Resolve(IContainer, Type) Resolves an object of the given type Declaration public static object Resolve(this IContainer container, Type type) Parameters Type Name Description IContainer container The container. Type type The type to be resolved. Returns Type Description Object An instance of the type . | Improve this Doc View Source Resolve<TObject>(IContainer) Resolves an object of type TObject Declaration public static TObject Resolve<TObject>(this IContainer container) Parameters Type Name Description IContainer container The container. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject The type to be resolved. | Improve this Doc View Source TryResolve(IContainer, Type, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer container, Type type, out object result) Parameters Type Name Description IContainer container The container. Type type The type to be resolved. Object result Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type) overloads | Improve this Doc View Source TryResolve<TObject>(IContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer container, out TObject result) Parameters Type Name Description IContainer container The container. TObject result Receives the object that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved."
  },
  "api/Rezolver.ExceptionResources.html": {
    "href": "api/Rezolver.ExceptionResources.html",
    "title": "Class ExceptionResources | Rezolver IOC Framework",
    "keywords": "Class ExceptionResources A strongly-typed resource class, for looking up localized strings, etc. Inheritance Object ExceptionResources Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class ExceptionResources Properties | Improve this Doc View Source _MOVETOSHAREDPROJECT Looks up a localized string similar to REMINDER TO MOVE THIS TO THE SHARED PROJECT AND MARK AS INTERNAL WHEN YOU FINALY CAN. Declaration public static string _MOVETOSHAREDPROJECT { get; } Property Value Type Description String | Improve this Doc View Source Culture Overrides the current thread's CurrentUICulture property for all resource lookups using this strongly typed resource class. Declaration public static CultureInfo Culture { get; set; } Property Value Type Description CultureInfo | Improve this Doc View Source CyclicDependencyDetectedInTargetFormat Looks up a localized string similar to Cyclic dependency detected in targets - current target of type {0} with DeclaredType of {1} has tried to include itself in its expression.. Declaration public static string CyclicDependencyDetectedInTargetFormat { get; } Property Value Type Description String | Improve this Doc View Source DeclaredTypeIsNotCompatible_Format Looks up a localized string similar to The declared type {0} is not compatible with the type {1}. Declaration public static string DeclaredTypeIsNotCompatible_Format { get; } Property Value Type Description String | Improve this Doc View Source LambdaBodyIsNotNewExpressionFormat Looks up a localized string similar to The body of the lambda \"{0}\" is not a NewExpression. Declaration public static string LambdaBodyIsNotNewExpressionFormat { get; } Property Value Type Description String | Improve this Doc View Source LambdaBodyNewExpressionIsWrongTypeFormat Looks up a localized string similar to The expression {0} does not represent calling a constructor of the type {1}. Declaration public static string LambdaBodyNewExpressionIsWrongTypeFormat { get; } Property Value Type Description String | Improve this Doc View Source MoreThanOneBestConstructorFormat Looks up a localized string similar to More than one constructor for {0} found that could be bound from the current context. Possible candidates: {1}. Declaration public static string MoreThanOneBestConstructorFormat { get; } Property Value Type Description String | Improve this Doc View Source MoreThanOneConstructorFormat Looks up a localized string similar to More than one constructor for {0} qualifies as a target for Auto construction. Declaration public static string MoreThanOneConstructorFormat { get; } Property Value Type Description String | Improve this Doc View Source MoreThanOneObjectFoundInScope Looks up a localized string similar to More than one matching object was found in the scope. Declaration public static string MoreThanOneObjectFoundInScope { get; } Property Value Type Description String | Improve this Doc View Source NoApplicableConstructorForContextFormat Looks up a localized string similar to No constructor found on the type {0} which can be satisfied by the CompileContext. Declaration public static string NoApplicableConstructorForContextFormat { get; } Property Value Type Description String | Improve this Doc View Source NoConstructorSetOnNewExpression Looks up a localized string similar to No constructor has been set on the NewExpression - this is not allowed.. Declaration public static string NoConstructorSetOnNewExpression { get; } Property Value Type Description String | Improve this Doc View Source NoDefaultOrAllOptionalConstructorFormat Looks up a localized string similar to The type {0} has no default constructor, nor any constructors where all the parameters are optional.. Declaration public static string NoDefaultOrAllOptionalConstructorFormat { get; } Property Value Type Description String | Improve this Doc View Source NoPublicConstructorsDefinedFormat Looks up a localized string similar to No public constructors declared on the type {0}. Declaration public static string NoPublicConstructorsDefinedFormat { get; } Property Value Type Description String | Improve this Doc View Source NotRuntimeMethod Looks up a localized string similar to This method is not to be called at run-time - it is only used for static expression analysis in creating IRezolveTargets for an IRezolveBuilder. Declaration public static string NotRuntimeMethod { get; } Property Value Type Description String | Improve this Doc View Source PathIsAtEnd Looks up a localized string similar to path's Next must not be null - pass path as null once it's reached the last item. Declaration public static string PathIsAtEnd { get; } Property Value Type Description String | Improve this Doc View Source PathIsInvalid Looks up a localized string similar to The path {0} is invalid. All path steps must contain non-whitespace characters and be at least one character in length. Declaration public static string PathIsInvalid { get; } Property Value Type Description String | Improve this Doc View Source ResourceManager Returns the cached ResourceManager instance used by this class. Declaration public static ResourceManager ResourceManager { get; } Property Value Type Description ResourceManager | Improve this Doc View Source RezolverTargetEntryHasBeenRealised Looks up a localized string similar to No more targets can be added to this entry. Declaration public static string RezolverTargetEntryHasBeenRealised { get; } Property Value Type Description String | Improve this Doc View Source ScopedSingletonRequiresAScope Looks up a localized string similar to A lifetime scope is required for a scoped singleton. Declaration public static string ScopedSingletonRequiresAScope { get; } Property Value Type Description String | Improve this Doc View Source TargetDoesntSupportType_Format Looks up a localized string similar to The target does not support the type {0}. Declaration public static string TargetDoesntSupportType_Format { get; } Property Value Type Description String | Improve this Doc View Source TargetIsNullButTypeIsNotNullable_Format Looks up a localized string similar to The type {0} is not a nullable type. Declaration public static string TargetIsNullButTypeIsNotNullable_Format { get; } Property Value Type Description String | Improve this Doc View Source TargetReturnedNullExpressionFormat Looks up a localized string similar to Target of type {0} returned a null expression for context {1} - implementation is invalid, targets must never return a null expression.. Declaration public static string TargetReturnedNullExpressionFormat { get; } Property Value Type Description String | Improve this Doc View Source TypeIsAlreadyRegistered Looks up a localized string similar to The type {0} has already been registered. Declaration public static string TypeIsAlreadyRegistered { get; } Property Value Type Description String | Improve this Doc View Source UnableToResolveTypeFromBuilderFormat Looks up a localized string similar to Unable to resolve type {0} from builder. Declaration public static string UnableToResolveTypeFromBuilderFormat { get; } Property Value Type Description String Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.SharedExpressionKey.html": {
    "href": "api/Rezolver.Compilation.Expressions.SharedExpressionKey.html",
    "title": "Class SharedExpressionKey | Rezolver IOC Framework",
    "keywords": "Class SharedExpressionKey Key for a shared expression used during expression tree generation. As a consumer of this library, you are unlikely ever to need to use it. Inheritance Object SharedExpressionKey Inherited Members Object.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class SharedExpressionKey : IEquatable<SharedExpressionKey> Constructors | Improve this Doc View Source SharedExpressionKey(Type, String, Type) Initializes a new instance of the SharedExpressionKey class. Declaration public SharedExpressionKey(Type targetType, string name, Type requestingType = null) Parameters Type Name Description Type targetType Required. Eventual runtime type of the object produced by the expression that will be cached using this key. String name Required. The name used for storing and retrieving expressions cached with this key. Type requestingType The type (e.g. the runtime type of an ITarget implementation) whose compilation requires the cached expression. Properties | Improve this Doc View Source Name Gets the name used for expressions that are cached using this key. Declaration public string Name { get; } Property Value Type Description String The name. | Improve this Doc View Source RequestingType Gets the type that registered the shared expression Declaration public Type RequestingType { get; } Property Value Type Description Type | Improve this Doc View Source TargetType The intended type of the expression that is cached by this key. Declaration public Type TargetType { get; } Property Value Type Description Type Methods | Improve this Doc View Source Equals(SharedExpressionKey) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(SharedExpressionKey other) Parameters Type Name Description SharedExpressionKey other An object to compare with this object. Returns Type Description Boolean true if the current object is equal to the other parameter; otherwise, false. Implements IEquatable<T>.Equals(T) | Improve this Doc View Source Equals(Object) Determines whether the specified Object is equal to this instance. Declaration public override bool Equals(object obj) Parameters Type Name Description Object obj The object to compare with the current object. Returns Type Description Boolean true if the specified Object is equal to this instance; otherwise, false . Overrides Object.Equals(Object) | Improve this Doc View Source GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description Int32 A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. Overrides Object.GetHashCode() Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.ITargetCompiler.html": {
    "href": "api/Rezolver.Compilation.ITargetCompiler.html",
    "title": "Interface ITargetCompiler | Rezolver IOC Framework",
    "keywords": "Interface ITargetCompiler An object that produces ICompiledTarget s from ITarget s given a particular ICompileContext . Namespace :Rezolver.Compilation Assembly :rezolver-docfx.dll Syntax public interface ITargetCompiler Methods | Improve this Doc View Source CompileTarget(ITarget, ICompileContext) Create the ICompiledTarget for the given target using the context to inform the type of object that is to be built, and for compile-time dependency resolution. Declaration ICompiledTarget CompileTarget(ITarget target, ICompileContext context) Parameters Type Name Description ITarget target Required. The target to be compiled. ICompileContext context Required. The current compilation context. Returns Type Description ICompiledTarget A compiled target which can then be used to get produce objects represented by the target . Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ContainerBase.html": {
    "href": "api/Rezolver.ContainerBase.html",
    "title": "Class ContainerBase | Rezolver IOC Framework",
    "keywords": "Class ContainerBase Starting point for implementations of IContainer - only creatable through inheritance. Inheritance Object ContainerBase CachingContainerBase Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class ContainerBase : IContainer, IServiceProvider, IScopeFactory, ITargetContainer Remarks This class also implements ITargetContainer by proxying the Targets that are provided to it on construction (or created anew if not supplied). All of those interface methods are implemented explicitly except the Register(ITarget, Type) method, which is available through the class' public API. Note: IContainer s are generally not expected to implement ITargetContainer , and the framework will never assume they do. The reason this class does is to make it easier to create a new container and to register targets into it without having to worry about managing a separate ITargetContainer instance in your application root - because all the registration extension methods defined in classes like RegisterTypeTargetContainerExtensions , SingletonTargetContainerExtensions plus many more will be available to developers in code which has a reference to this class, or one derived from it. Note also that calling CombineWith(ITargetContainer, Type) on an instance of this type will always cause a NotSupportedException to be thrown. Constructors | Improve this Doc View Source ContainerBase(ITargetContainer, ICompilerConfigurationProvider) Constructs a new instance of the ContainerBase , optionally initialising it with the given targets and compilerConfig Declaration protected ContainerBase(ITargetContainer targets = null, ICompilerConfigurationProvider compilerConfig = null) Parameters Type Name Description ITargetContainer targets Optional. The target container whose registrations will be used for dependency lookup when Resolve(ResolveContext) (and other operations) is called. If not provided, a new TargetContainer instance is constructed. This will ultimately be available to inherited types, after construction, through the Targets property. ICompilerConfigurationProvider compilerConfig Optional. An object which will be used to configure this container and its targets to use a specific compilation strategy. If null , then the DefaultProvider provider will be used. Properties | Improve this Doc View Source NoChangeCompilerConfiguration Gets the compiler configuration provider to be passed when a derived container does not want the DefaultProvider provider to be used if one is not passed on construction. This provider is guaranteed not to add/modify any registrations in the underlying target container which are connected with compilation. Declaration protected static ICompilerConfigurationProvider NoChangeCompilerConfiguration { get; } Property Value Type Description ICompilerConfigurationProvider | Improve this Doc View Source Targets Provides the ITarget instances that will be compiled into ICompiledTarget instances. Declaration protected ITargetContainer Targets { get; } Property Value Type Description ITargetContainer Remarks Notes to implementers: This property must NEVER be null. This class implements the ITargetContainer interface by wrapping around this instance so that an application can create an instance of ContainerBase and directly register targets into it; rather than having to create and setup the target container first. You can add registrations to this target container at any point in the lifetime of any ContainerBase instances which are attached to it. In reality, however, if any Resolve(ResolveContext) operations have been performed prior to adding more registrations, then there's no guarantee that new dependencies will be picked up - especially if the CachingContainerBase is being used as your application's container (which it nearly always will be). Methods | Improve this Doc View Source CanResolve(ResolveContext) Implementation of the CanResolve(ResolveContext) method. Returns true if, and only if, the Targets ITargetContainer returns a non-null ITarget when the RequestedType is passed to its Fetch(Type) method. Declaration public virtual bool CanResolve(ResolveContext context) Parameters Type Name Description ResolveContext context The resolve context containing the requested type. Returns Type Description Boolean Implements IContainer.CanResolve(ResolveContext) | Improve this Doc View Source CreateScope() Implementation of the CreateScope() method. The base definition creates a ContainerScope with this container passed as the scope's container. Thus, the new scope is a 'root' scope. Declaration public virtual IContainerScope CreateScope() Returns Type Description IContainerScope Implements IScopeFactory.CreateScope() | Improve this Doc View Source FetchCompiled(ResolveContext) Base implementation of FetchCompiled(ResolveContext) . Note that any container already defined in the Container is ignored in favour of this container. Declaration public virtual ICompiledTarget FetchCompiled(ResolveContext context) Parameters Type Name Description ResolveContext context The context containing the requested type and any scope which is currently in force. Returns Type Description ICompiledTarget Always returns a reference to a compiled target - but note that if CanResolve(ResolveContext) returns false for the same context, then the target's GetObject(ResolveContext) method will likely throw an exception - in line with the behaviour of the ContainerBase.MissingCompiledTarget class' behaviour. Implements IContainer.FetchCompiled(ResolveContext) | Improve this Doc View Source GetCompiledRezolveTarget(ResolveContext) The main workhorse of the resolve process - obtains an ICompiledTarget for the given context by looking up an ITarget from the Targets target container, then compiling it. Declaration protected virtual ICompiledTarget GetCompiledRezolveTarget(ResolveContext context) Parameters Type Name Description ResolveContext context The current resolve context Returns Type Description ICompiledTarget Remarks The specifics of how this process works are not important if you simply want to use the container, but if you are looking to extend it, then it's essential you understand the different steps that the process goes through. If the Fetch(Type) method of the Targets target container returns a null ITarget , or one which has its UseFallback set to true , then the method gets an alternative compiled target by calling the GetFallbackCompiledRezolveTarget(ResolveContext) method. This fallback compiled target will be used instead of compiling the target unless the target was not null and its UseFallback is true AND the compiled target returned by the fallback method is a ContainerBase.MissingCompiledTarget - in which case the fallback target will be compiled as normal. Before proceeding with compilation, the container checks whether the target can resolve the required object directly. This means that the target either implements the ICompiledTarget interface (in which case it is immediately returned) or the RequestedType is not Object and the target's type is compatible with it (in which case the target is simply embedded in a new ContainerBase.DirectResolveCompiledTarget , which will later just return the target when its GetObject(ResolveContext) is called). The ObjectTarget supports the ICompiledTarget interface, therefore any objects which are directly registered through this target will always use that class' implementation of ICompiledTarget if requested through the Resolve(ResolveContext) method. Once the decision has been taken to compile the target, the container first needs a compiler ( ITargetCompiler ) and a compile context provider ( ICompileContextProvider ). Note that classes which implement the ITargetCompiler interface also frequently implement the ICompileContextProvider interface so that any additional state they require is correctly attached to the ICompileContext which will be fed to their CompileTarget(ITarget, ICompileContext) implementation. These are both obtained by resolving them directly from the Container of the context (since a container can be delegated to from another container which originally received the Resolve(ResolveContext) call). Attentive readers will realise at this point that this could lead to an infinite recursion - i.e. since compiling a target means resolving a compiler, which in turn must mean compiling that target. The class sidesteps this potential pitfall by requiring that the targets registered for these types support direct resolving, as per the description a couple of paragraphs back. Therefore, compilers and context providers are typically registered as objects via the ObjectTarget target. Finally, a new ICompileContext is created via the CreateContext(ResolveContext, ITargetContainer, IContainer) method of the resolved context provider, and then passed to the CompileTarget(ITarget, ICompileContext) method of the resolved compiler. The result of that operation is then returned to the caller. | Improve this Doc View Source GetFallbackCompiledRezolveTarget(ResolveContext) Called by GetCompiledRezolveTarget(ResolveContext) if no valid ITarget can be found for the context or if the one found has its UseFallback property set to true . Declaration protected virtual ICompiledTarget GetFallbackCompiledRezolveTarget(ResolveContext context) Parameters Type Name Description ResolveContext context Returns Type Description ICompiledTarget An ICompiledTarget to be used as the result of a Resolve(ResolveContext) operation where the search for a valid target either fails or is inconclusive (e.g. - empty enumerables). Remarks The base implementation always returns an instance of the ContainerBase.MissingCompiledTarget via the GetMissingTarget(Type) static method. | Improve this Doc View Source GetMissingTarget(Type) Gets an ICompiledTarget for the given type which will always throw an InvalidOperationException whenever its GetObject(ResolveContext) method is called. Use this when you can't resolve a target for a type. Declaration protected static ICompiledTarget GetMissingTarget(Type type) Parameters Type Name Description Type type The type for which you wish to create a missing target. Returns Type Description ICompiledTarget | Improve this Doc View Source GetService(Type) Protected virtual implementation of GetService(Type) . Uses the TryResolve(ResolveContext, out Object) method to resolve the service, returning null if the operation fails. Declaration protected virtual object GetService(Type serviceType) Parameters Type Name Description Type serviceType Type of service to be resolved. Returns Type Description Object | Improve this Doc View Source IsMissingTarget(ICompiledTarget) Determines whether the given target is an instance of ContainerBase.MissingCompiledTarget . Declaration protected static bool IsMissingTarget(ICompiledTarget target) Parameters Type Name Description ICompiledTarget target The target. Returns Type Description Boolean | Improve this Doc View Source Register(ITarget, Type) Implementation of Register(ITarget, Type) - simply proxies the call to the target container referenced by the Targets property. Declaration public void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target Type serviceType Implements ITargetContainer.Register(ITarget, Type) Remarks Remember: registering new targets into an ITargetContainer after an IContainer has started compiling targets within it can yield unpredictable results. If you create a new container and perform all your registrations before you use it, however, then everything will work as expected. Note also the other ITargetContainer interface methods are implemented explicitly so as to hide them from the list of class members. | Improve this Doc View Source Resolve(ResolveContext) Implementation of the Resolve(ResolveContext) method. Obtains an ICompiledTarget by calling the GetCompiledRezolveTarget(ResolveContext) method, and then immediately calls its GetObject(ResolveContext) method, returning the result. Declaration public virtual object Resolve(ResolveContext context) Parameters Type Name Description ResolveContext context The context containing the type that's requested, any active scope and so on. Returns Type Description Object Implements IContainer.Resolve(ResolveContext) | Improve this Doc View Source TryResolve(ResolveContext, out Object) Implementation of the TryResolve(ResolveContext, out Object) method. Attempts to resolve the requested type (given on the context , returning a boolean indicating whether the operation was successful. If successful, then result receives a reference to the resolved object. Declaration public virtual bool TryResolve(ResolveContext context, out object result) Parameters Type Name Description ResolveContext context The context containing the type that's requested, any active scope and so on. Object result Receives a reference to the object that was resolved, if successful, or null if not. Returns Type Description Boolean A boolean indicating whether the operation completed successfully. Implements IContainer.TryResolve(ResolveContext, out Object) Explicit Interface Implementations | Improve this Doc View Source ITargetContainer.CombineWith(ITargetContainer, Type) Declaration ITargetContainer ITargetContainer.CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Type type Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) | Improve this Doc View Source ITargetContainer.Fetch(Type) Declaration ITarget ITargetContainer.Fetch(Type type) Parameters Type Name Description Type type Returns Type Description ITarget Implements ITargetContainer.Fetch(Type) | Improve this Doc View Source ITargetContainer.FetchAll(Type) Declaration IEnumerable<ITarget> ITargetContainer.FetchAll(Type type) Parameters Type Name Description Type type Returns Type Description IEnumerable < ITarget > Implements ITargetContainer.FetchAll(Type) | Improve this Doc View Source IServiceProvider.GetService(Type) Declaration object IServiceProvider.GetService(Type serviceType) Parameters Type Name Description Type serviceType Returns Type Description Object Implements IServiceProvider.GetService(Type) Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.TargetDictionaryContainer.html": {
    "href": "api/Rezolver.TargetDictionaryContainer.html",
    "title": "Class TargetDictionaryContainer | Rezolver IOC Framework",
    "keywords": "Class TargetDictionaryContainer An ITargetContainerOwner implementation that stores and retrieves ITarget and ITargetContainer by type. Inheritance Object TargetDictionaryContainer GenericTargetContainer TargetContainer Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class TargetDictionaryContainer : ITargetContainerOwner, ITargetContainer Remarks This type is not thread-safe Note that for generic type, a special container is registered first against the open generic version of the type, with concrete (closed) generics being registered within that. Methods | Improve this Doc View Source CombineWith(ITargetContainer, Type) Always adds this container into the existing container as a child. Declaration public virtual ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Type type Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) | Improve this Doc View Source CreateContainer(Type, ITarget) Called by Register(ITarget, Type) to create and register the container instance most suited for the passed target. The base implementation always creates a TargetListContainer , capable of storing multiple targets against a single type. Declaration protected virtual ITargetContainer CreateContainer(Type serviceType, ITarget target) Parameters Type Name Description Type serviceType ITarget target The initial target for which the container is being created. Can be null. Note - the function is not expected to add this target to the new container. Returns Type Description ITargetContainer | Improve this Doc View Source Fetch(Type) Implementation of Fetch(Type) . Declaration public virtual ITarget Fetch(Type type) Parameters Type Name Description Type type The type whose default target is to be retrieved. Returns Type Description ITarget A single target representing the last target registered against the type , or, null if no target is found. Implements ITargetContainer.Fetch(Type) Remarks Note - in scenarios where you are chaining multiple containers, then you should consult the return value's UseFallback property if the method returns non-null because, if true, then it's an instruction to use a parent container's result for the same type. | Improve this Doc View Source FetchAll(Type) Implementation of FetchAll(Type) Declaration public virtual IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type The type whose targets are to be retrieved. Returns Type Description IEnumerable < ITarget > A non-null enumerable containing the targets that match the type, or an empty enumerable if the type is not registered. Implements ITargetContainer.FetchAll(Type) | Improve this Doc View Source FetchContainer(Type) Obtains a child container that was previously registered by the passed type . Returns null if no entry is found. Declaration public virtual ITargetContainer FetchContainer(Type type) Parameters Type Name Description Type type Returns Type Description ITargetContainer Implements ITargetContainerOwner.FetchContainer(Type) | Improve this Doc View Source Register(ITarget, Type) Implementation of Register(ITarget, Type) . Declaration public virtual void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target The target to be registered Type serviceType Implements ITargetContainer.Register(ITarget, Type) Remarks This implementation creates an ITargetContainer for the serviceType with a call to the protected method CreateContainer(Type, ITarget) if one doesn't exist (it calls FetchContainer(Type) to check for existence), and then chains to its Register(ITarget, Type) method. | Improve this Doc View Source RegisterContainer(Type, ITargetContainer) Implementation of RegisterContainer(Type, ITargetContainer) Declaration public virtual void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container Implements ITargetContainerOwner.RegisterContainer(Type, ITargetContainer) Remarks This container implementation actually stores containers against the types that targets are registered against, rather than simply storing a dictionary of targets. This method allows you to add your own containers against type (instead of the default, which is TargetListContainer ) so you can plug in some advanced behaviour into this container. For example, decorators are not actually ITarget implementations but specialised ITargetContainer instances into which the 'standard' targets are registered. Extension Methods EnumerableTargetBuilderExtensions.EnableEnumerableResolving(ITargetContainerOwner) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) DecoratorTargetContainerExtensions.RegisterDecorator(ITargetContainerOwner, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.TargetListContainer.html": {
    "href": "api/Rezolver.TargetListContainer.html",
    "title": "Class TargetListContainer | Rezolver IOC Framework",
    "keywords": "Class TargetListContainer An ITargetContainer that stores multiple targets in a list. This is not a type that you would typically use directly in your code, unless you are writing custom logic/behaviour for ITarget registration. Inheritance Object TargetListContainer Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class TargetListContainer : ITargetContainer Remarks This type is not thread-safe, nor does it perform any type checking on the targets that are added to it. Constructors | Improve this Doc View Source TargetListContainer(Type, ITarget[]) Initializes a new instance of the TargetListContainer class. Declaration public TargetListContainer(Type registeredType, params ITarget[] targets) Parameters Type Name Description Type registeredType Required - the type against which this list will be registered. ITarget [] targets Optional array of targets with which to initialise the list. Properties | Improve this Doc View Source Count Gets the number of targets which have been added to the list. Declaration public int Count { get; } Property Value Type Description Int32 The count. | Improve this Doc View Source DefaultTarget Gets the default target for this list - which will always be the last target added to the list, or null if no targets have been added yet. Declaration public ITarget DefaultTarget { get; } Property Value Type Description ITarget | Improve this Doc View Source Item[Int32] Gets the ITarget at the specified index. Declaration public ITarget this[int index] { get; } Parameters Type Name Description Int32 index The index. Property Value Type Description ITarget ITarget. Exceptions Type Condition IndexOutOfRangeException If index is less than zero, or if Count is zero, or if index represents an index greater than last item's index | Improve this Doc View Source RegisteredType Gets the type against which this list container is registered in its ITargetContainerOwner . Declaration public Type RegisteredType { get; } Property Value Type Description Type | Improve this Doc View Source Targets Gets the targets stored in this list container. Declaration public IEnumerable<ITarget> Targets { get; } Property Value Type Description IEnumerable < ITarget > | Improve this Doc View Source TargetsList Provides deriving classes a means to manipulate the underlying list. Declaration protected List<ITarget> TargetsList { get; } Property Value Type Description List < ITarget > Methods | Improve this Doc View Source CombineWith(ITargetContainer, Type) Not supported. Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Ignored Type type Ignored. Returns Type Description ITargetContainer Implements ITargetContainer.CombineWith(ITargetContainer, Type) Exceptions Type Condition NotSupportedException Always | Improve this Doc View Source Fetch(Type) Always returns the DefaultTarget Declaration public virtual ITarget Fetch(Type type) Parameters Type Name Description Type type Ignored. Returns Type Description ITarget Implements ITargetContainer.Fetch(Type) | Improve this Doc View Source FetchAll(Type) Retrieves an enumerable of all targets that have been registered to this list. Declaration public virtual IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type Ignored. Returns Type Description IEnumerable < ITarget > Implements ITargetContainer.FetchAll(Type) | Improve this Doc View Source Register(ITarget, Type) Registers the specified target into the list. Note - the target is not checked to see if it supports this list's RegisteredType . Declaration public virtual void Register(ITarget target, Type registeredType = null) Parameters Type Name Description ITarget target The target. Type registeredType Ignored. Implements ITargetContainer.Register(ITarget, Type) Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Targets.ScopedTarget.html": {
    "href": "api/Rezolver.Targets.ScopedTarget.html",
    "title": "Class ScopedTarget | Rezolver IOC Framework",
    "keywords": "Class ScopedTarget A target that produces or fetches a single instance of an object within a lifetime scope. Inheritance Object TargetBase ScopedTarget Inherited Members TargetBase.UseFallback TargetBase.SelectScope(ResolveContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Targets Assembly :rezolver-docfx.dll Syntax public class ScopedTarget : TargetBase, ITarget Remarks Scopes in Rezolver operate much the same as they do in any IOC framework, but use of them is always entirely optional. When a scope is active for a given Resolve(ResolveContext) operation, most objects which are returned from those operations will implicitly be scoped to whichever scope is active when the objects are resolved. Implicitly scoped objects are only disposed of when their containing scope is disposed, and you can have an unlimited number of instances of implicitly scoped objects per scope. This target is used to scope the object produced by a target explicitly to a scope, and to ensure that only one instance of that object is produced per scope. Such objects are also not inherited between parent scopes and child scopes. Constructors | Improve this Doc View Source ScopedTarget(ITarget) Initializes a new instance of the ScopedTarget class. Declaration public ScopedTarget(ITarget innerTarget) Parameters Type Name Description ITarget innerTarget Required. The inner target. Properties | Improve this Doc View Source DeclaredType Gets the declared type of object that is constructed by this target. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType Remarks Always forwards the call on to InnerTarget | Improve this Doc View Source InnerTarget Gets the inner target whose result (when compiled) will be scoped to the active scope. Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget The inner target. | Improve this Doc View Source ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour Methods | Improve this Doc View Source SupportsType(Type) Called to check whether a target can create an expression that builds an instance of the given type . Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type Required Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) Remarks Always forwards the call on the InnerTarget Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Targets.SingletonTarget.html": {
    "href": "api/Rezolver.Targets.SingletonTarget.html",
    "title": "Class SingletonTarget | Rezolver IOC Framework",
    "keywords": "Class SingletonTarget A target which applies the singleton pattern to any ITarget . The inner target is available from the InnerTarget property. Inheritance Object TargetBase SingletonTarget Inherited Members TargetBase.UseFallback Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Targets Assembly :rezolver-docfx.dll Syntax public class SingletonTarget : TargetBase, ITarget Constructors | Improve this Doc View Source SingletonTarget(ITarget) Constructs a new instance of the SingletonTarget class. Declaration public SingletonTarget(ITarget innerTarget) Parameters Type Name Description ITarget innerTarget The target whose result (when compiled) is to be used as the singleton instance. Properties | Improve this Doc View Source DeclaredType Override of DeclaredType - always returns the DeclaredType of the InnerTarget Declaration public override Type DeclaredType { get; } Property Value Type Description Type The type of the declared. Overrides TargetBase.DeclaredType | Improve this Doc View Source InnerTarget Gets the inner target for this singleton. Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget | Improve this Doc View Source ScopeBehaviour Always returns Explicit . Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour Overrides TargetBase.ScopeBehaviour Methods | Improve this Doc View Source GetOrAddInitialiser(Type, Func<Type, ICompiledTarget>) Used to support compiled versions of this singleton Declaration public ICompiledTarget GetOrAddInitialiser(Type declaredType, Func<Type, ICompiledTarget> initialiserFactory) Parameters Type Name Description Type declaredType Type of object. Func < Type , ICompiledTarget > initialiserFactory The initialiser factory. Returns Type Description ICompiledTarget Remarks This concept is something that probably needs to move out of this type, into a more generic TargetState object or something like that. | Improve this Doc View Source SelectScope(ResolveContext) Always selects the root scope from the context ( GetRootScope(IContainerScope) , if the context has a non-null scope. Declaration public override IContainerScope SelectScope(ResolveContext context) Parameters Type Name Description ResolveContext context The context. Returns Type Description IContainerScope Overrides TargetBase.SelectScope(ResolveContext) | Improve this Doc View Source SupportsType(Type) Called to check whether a target can create an expression that builds an instance of the given type . The base implementation always passes the call on to the InnerTarget Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type Required Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.CompileStackEntry.html": {
    "href": "api/Rezolver.Compilation.CompileStackEntry.html",
    "title": "Class CompileStackEntry | Rezolver IOC Framework",
    "keywords": "Class CompileStackEntry Represents an entry in the compilation stack of a ICompileContext , recording both a target that is being compiled, and the type for which it is being compiled. Inheritance Object CompileStackEntry Inherited Members Object.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation Assembly :rezolver-docfx.dll Syntax public class CompileStackEntry : IEquatable<CompileStackEntry> Constructors | Improve this Doc View Source CompileStackEntry(ITarget, Type) Initializes a new instance of the CompileStackEntry class. Declaration public CompileStackEntry(ITarget target, Type targetType) Parameters Type Name Description ITarget target The target being compiled. Type targetType Type for which the target is being compiled. Properties | Improve this Doc View Source Target Gets the target being compiled. Declaration public ITarget Target { get; } Property Value Type Description ITarget | Improve this Doc View Source TargetType Gets the type for which the target is being compiled. Declaration public Type TargetType { get; } Property Value Type Description Type Methods | Improve this Doc View Source Equals(CompileStackEntry) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(CompileStackEntry other) Parameters Type Name Description CompileStackEntry other An object to compare with this object. Returns Type Description Boolean Implements IEquatable<T>.Equals(T) Remarks Equality is defined as both the Target and the TargetType being equal between this instance and the other instance. | Improve this Doc View Source Equals(Object) Determines whether the specified Object is equal to this instance. Declaration public override bool Equals(object obj) Parameters Type Name Description Object obj The object to compare with the current object. Returns Type Description Boolean Overrides Object.Equals(Object) | Improve this Doc View Source GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description Int32 Overrides Object.GetHashCode() Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionBuilderBase-1.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionBuilderBase-1.html",
    "title": "Class ExpressionBuilderBase<TTarget> | Rezolver IOC Framework",
    "keywords": "Class ExpressionBuilderBase<TTarget> Abstract base class for implementations of IExpressionBuilder<TTarget> . Provide an implementation of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) and then register an instance in an ObjectTarget in the active container. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase<TTarget> ChangeTypeTargetBuilder ConstructorTargetBuilder DecoratorTargetBuilder DefaultTargetBuilder DelegateTargetBuilder ExpressionTargetBuilder GenericConstructorTargetBuilder ListTargetBuilder ObjectTargetBuilder OptionalParameterTargetBuilder RezolvedTargetBuilder ScopedTargetBuilder SingletonTargetBuilder UnscopedTargetBuilder Inherited Members ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public abstract class ExpressionBuilderBase<TTarget> : ExpressionBuilderBase, IExpressionBuilder<TTarget>, IExpressionBuilder where TTarget : ITarget Type Parameters Name Description TTarget The type of target for which this builder can build an expression. Remarks This is a generic extension of the ExpressionBuilderBase class, designed to simplify the process of implementating the IExpressionBuilder<TTarget> (and, by extension, IExpressionBuilder ) interface. This is the class from which most of the built-in expression builders derive, because the ExpressionCompiler , when asked to compile an expression, attempts to resolve an IExpressionBuilder<TTarget> whose TTarget is the same type as the target that needs compiling. Inheriting from ExpressionBuilderBase is more appropriate if your builder is capable of handling multiple types of ITarget - a scenario that's much less common. Note that this class' implementation of IExpressionBuilder<TTarget> is entirely explicit and non-virtual, the same as with its base class, hence the only way to build an expression via an instance of this class without exposing the behaviour to external callers yourself is via the interface. Methods | Improve this Doc View Source Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target for the given ICompileContext OVerride this to implement the compilation for your target type. Declaration protected abstract Expression Build(TTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description TTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression | Improve this Doc View Source Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Overrides the abstract Build(ITarget, IExpressionCompileContext, IExpressionCompiler) (and seals it from further overrides); checks that target is an instance of TTarget (throwing an ArgumentException if not) and then calls this class' Build(TTarget, IExpressionCompileContext, IExpressionCompiler) abstract function. Declaration protected override sealed Expression Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ITarget target The target for which an expression is to be built. Must be an instance of TTarget . IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides ExpressionBuilderBase.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Exceptions Type Condition ArgumentException target must be an instance of { typeof(TTarget) } ArgumentException If the passed target is not an instance of TTarget | Improve this Doc View Source CanBuild(ITarget, IExpressionCompileContext) Determines whether this instance can build an expression from the specified target. This base implementation simply checks that the type of target is compatible with the type TTarget . Declaration public override bool CanBuild(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context The compilation context. Returns Type Description Boolean Overrides ExpressionBuilderBase.CanBuild(ITarget, IExpressionCompileContext) Implements IExpressionBuilder.CanBuild(ITarget, IExpressionCompileContext) Explicit Interface Implementations | Improve this Doc View Source IExpressionBuilder<TTarget>.Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Builds the specified target. Declaration Expression IExpressionBuilder<TTarget>.Build(TTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description TTarget target The target. IExpressionCompileContext context The context. IExpressionCompiler compiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the implementation attempts to locate the context compiler using the GetContextCompiler(IExpressionCompileContext) method, and will throw an InvalidOperationException if it cannot do so. Returns Type Description Expression Implements IExpressionBuilder<TTarget>.Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Exceptions Type Condition ArgumentNullException target is null or context is null InvalidOperationException compiler is null and an IExpressionCompiler couldn't be resolved for the current context (via GetContextCompiler(IExpressionCompileContext) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also IExpressionBuilder <TTarget> ExpressionBuilderBase"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionCompilerConfigurationProvider.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionCompilerConfigurationProvider.html",
    "title": "Class ExpressionCompilerConfigurationProvider | Rezolver IOC Framework",
    "keywords": "Class ExpressionCompilerConfigurationProvider Implements the ICompilerConfigurationProvider to configure expression-based compilation for targets in containers. The implementation registers all the targets necessary to use the expression tree-based compilation provided by the Rezolver.Compilation.Expressions library. This configuration provider is automatically configured as the default for all containers when the Rezolver library is referenced. Inheritance Object ExpressionCompilerConfigurationProvider Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class ExpressionCompilerConfigurationProvider : ICompilerConfigurationProvider Methods | Improve this Doc View Source Configure(IContainer, ITargetContainer) Implements the Configure(IContainer, ITargetContainer) method, registering all the targets necessary to use expression-based compilation for all the standard targets defined in the Rezolver core library. Declaration public virtual void Configure(IContainer container, ITargetContainer targets) Parameters Type Name Description IContainer container The container - ignored. ITargetContainer targets Required - the target container into which the various targets will be registered. Implements ICompilerConfigurationProvider.Configure(IContainer, ITargetContainer) Remarks All targets registered by this function are ObjectTarget targets backed by concrete instances of the various components (compiler etc). Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Targets.UnscopedTarget.html": {
    "href": "api/Rezolver.Targets.UnscopedTarget.html",
    "title": "Class UnscopedTarget | Rezolver IOC Framework",
    "keywords": "Class UnscopedTarget Wraps another target to force scoping to be ignored for the object that it produces, regardless of whether that object is IDisposable or otherwise has its own scoping behaviour. Inheritance Object TargetBase UnscopedTarget Inherited Members TargetBase.SelectScope(ResolveContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Targets Assembly :rezolver-docfx.dll Syntax public class UnscopedTarget : TargetBase, ITarget Constructors | Improve this Doc View Source UnscopedTarget(ITarget) Initializes a new instance of the UnscopedTarget class. Declaration public UnscopedTarget(ITarget inner) Parameters Type Name Description ITarget inner Required - the inner target. Properties | Improve this Doc View Source DeclaredType Gets the declared type of object that is constructed by this target - always forwards the call to the Inner target. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source Inner Gets the inner target whose scoping rules are to be stripped by this target. Declaration public ITarget Inner { get; } Property Value Type Description ITarget | Improve this Doc View Source ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour Overrides TargetBase.ScopeBehaviour | Improve this Doc View Source UseFallback Implementation of UseFallback Always forwards the call to Inner target. Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides TargetBase.UseFallback Methods | Improve this Doc View Source SupportsType(Type) Always forward the call to the Inner target's implementation. Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type The type. Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ChildTargetContainer.html": {
    "href": "api/Rezolver.ChildTargetContainer.html",
    "title": "Class ChildTargetContainer | Rezolver IOC Framework",
    "keywords": "Class ChildTargetContainer A version of TargetContainer which overrides the registrations of another (the Parent ). Inheritance Object TargetDictionaryContainer TargetContainer ChildTargetContainer Inherited Members TargetContainer.CreateContainer(Type, ITarget) TargetContainer.CreateGenericTypeDefContainer(Type, ITarget) TargetContainer.FetchContainer(Type) TargetContainer.Register(ITarget, Type) TargetContainer.RegisterContainer(Type, ITargetContainer) TargetContainer.RegisterContainerDirect(Type, ITargetContainer) TargetDictionaryContainer.CombineWith(ITargetContainer, Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class ChildTargetContainer : TargetContainer, ITargetContainerOwner, IChildTargetContainer, ITargetContainer Remarks When it's looking to find an entry for a type, if it cannot find one within its own registrations, it will forward the call on to its ancestors (starting with its Parent ). As a result, any dependencies required by registrations in this container can be provided by any ancestor. Fallback logic in the Fetch(Type) is triggered by the UseFallback property. Constructors | Improve this Doc View Source ChildTargetContainer(ITargetContainer) Initializes a new instance of the ChildTargetContainer class. Declaration public ChildTargetContainer(ITargetContainer parent) Parameters Type Name Description ITargetContainer parent Required. The parent target container Properties | Improve this Doc View Source Parent Gets the parent. Declaration public ITargetContainer Parent { get; } Property Value Type Description ITargetContainer The parent. Implements IChildTargetContainer.Parent Methods | Improve this Doc View Source Fetch(Type) Fetches the registered target for the given type , if found, or forwards the call to the Parent container. Declaration public override ITarget Fetch(Type type) Parameters Type Name Description Type type The type whose registration is sought. Returns Type Description ITarget The target which is registered for the given type, or null if no registration can be found. Overrides TargetDictionaryContainer.Fetch(Type) Implements ITargetContainer.Fetch(Type) | Improve this Doc View Source FetchAll(Type) Implementation of FetchAll(Type) Declaration public override IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type The type whose targets are to be retrieved. Returns Type Description IEnumerable < ITarget > A non-null enumerable containing the targets that match the type, or an empty enumerable if the type is not registered. Overrides TargetDictionaryContainer.FetchAll(Type) Implements ITargetContainer.FetchAll(Type) Extension Methods EnumerableTargetBuilderExtensions.EnableEnumerableResolving(ITargetContainerOwner) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) DecoratorTargetContainerExtensions.RegisterDecorator(ITargetContainerOwner, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also TargetContainer IChildTargetContainer"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionCompileContext.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionCompileContext.html",
    "title": "Class ExpressionCompileContext | Rezolver IOC Framework",
    "keywords": "Class ExpressionCompileContext An implementation of ICompileContext which is specialised for use by an IExpressionCompiler . Inheritance Object CompileContext ExpressionCompileContext Inherited Members CompileContext.Container CompileContext.TargetType CompileContext.ScopeBehaviourOverride CompileContext.DependencyTargetContainer CompileContext.CompileStack CompileContext.ICompileContext.NewContext(Type, Nullable<ScopeBehaviour>) CompileContext.ICompileContext.PushCompileStack(ITarget, Type) CompileContext.ICompileContext.PopCompileStack() CompileContext.ITargetContainer.Register(ITarget, Type) CompileContext.ITargetContainer.Fetch(Type) CompileContext.ITargetContainer.FetchAll(Type) CompileContext.ITargetContainer.CombineWith(ITargetContainer, Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class ExpressionCompileContext : CompileContext, IExpressionCompileContext, ICompileContext, ITargetContainer Constructors | Improve this Doc View Source ExpressionCompileContext(IExpressionCompileContext, Type, Boolean, Nullable<ScopeBehaviour>) Initializes a new instance of the ExpressionCompileContext class as a child of another. Note that all the expression properties ( ResolveContextExpression , ContextContainerPropertyExpression and ContextScopePropertyExpression ) are always inherited from the source context to ensure consistency across all expressions being built during a particular compilation chain. Declaration protected ExpressionCompileContext(IExpressionCompileContext sourceContext, Type targetType = null, bool useParentSharedExpressions = true, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description IExpressionCompileContext sourceContext The source context. Type targetType If not null, the type for which expressions are to be compiled. If null, then the sourceContext 's TargetType will be inherited. Boolean useParentSharedExpressions If true then the SharedExpressions of the sourceContext will be reused by this new context. If false , then this context will start with a new empty set of shared expressions. Nullable < ScopeBehaviour > scopeBehaviourOverride Override the scope behaviour to be used for the target that is compiled with this context. | Improve this Doc View Source ExpressionCompileContext(IContainer, ITargetContainer, Type, ParameterExpression) Initializes a new instance of the ExpressionCompileContext class. Declaration protected ExpressionCompileContext(IContainer container, ITargetContainer dependencyTargetContainer, Type targetType = null, ParameterExpression resolveContextExpression = null) Parameters Type Name Description IContainer container Required. The container for which the compilation is being performed. When compiling in response to a call to Resolve(ResolveContext) , the container which first receives the call should be the one passed here. ITargetContainer dependencyTargetContainer Required - target container used for dependency lookups. As with the base class this is actually wrapped in a new ChildTargetContainer and used as this class' implementation of ITargetContainer . Type targetType Optional. Will be set into the TargetType property. If null, then any ITarget that is compiled should be compiled for its own DeclaredType . ParameterExpression resolveContextExpression Optional, mapped to ResolveContextExpression - the default for this (i.e. when you leave it as null) is to use the static DefaultResolveContextParameterExpression and generally it should always be left as that. The ExpressionCompiler , when building expressions to turn into compiled lambdas, uses this as the main parameter on the lambda itself. See Also CompileContext(IContainer, ITargetContainer, Type) Properties | Improve this Doc View Source ContainerExpression Gets an expression which gives a reference to the IContainer for this context - i.e. the same reference as given by the Container property. Declaration public Expression ContainerExpression { get; } Property Value Type Description Expression The container expression. Implements IExpressionCompileContext.ContainerExpression Remarks Note that this is not the same as ContextContainerPropertyExpression - but is provided to allow expressions to be compiled which compare the container supplied at compile time to the one from the Container at resolve-time. | Improve this Doc View Source ContextContainerPropertyExpression Gets an expression for reading the Container property of the ResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration public MemberExpression ContextContainerPropertyExpression { get; } Property Value Type Description MemberExpression The context container property expression. Implements IExpressionCompileContext.ContextContainerPropertyExpression | Improve this Doc View Source ContextScopePropertyExpression Gets an expression for reading the Scope property of the ResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration public MemberExpression ContextScopePropertyExpression { get; } Property Value Type Description MemberExpression The context scope property expression. Implements IExpressionCompileContext.ContextScopePropertyExpression | Improve this Doc View Source DefaultResolveContextParameterExpression The default ResolveContext parameter expression used by the expression-based code generators defined in this library, although it's not used directly for that purpose - instead, the ResolveContextExpression of new contexts is initialised to this if not explicitly provided on construction and when not being inherited from another context. Declaration public static ParameterExpression DefaultResolveContextParameterExpression { get; } Property Value Type Description ParameterExpression | Improve this Doc View Source ParentContext Gets the parent context. Declaration public IExpressionCompileContext ParentContext { get; } Property Value Type Description IExpressionCompileContext Implements IExpressionCompileContext.ParentContext Remarks Note that this property hides the inherited ParentContext property, since an IExpressionCompileContext can only be a child of another IExpressionCompileContext . | Improve this Doc View Source ResolveContextExpression This is the parameter expression which represents the ResolveContext that is passed to the ICompiledTarget at resolve-time. The other expressions - ContextContainerPropertyExpression and ContextScopePropertyExpression are both built from this too. Declaration public ParameterExpression ResolveContextExpression { get; } Property Value Type Description ParameterExpression The resolve context expression. Implements IExpressionCompileContext.ResolveContextExpression Remarks If the code produced by the IExpressionBuilder for a given target needs to read or use the ResolveContext that was originally passed to the Resolve(ResolveContext) method, then it does it by using this expression, which will be set as the only parameter on the lambda expression which is eventually compiled (in the case of the default expression compiler, ExpressionCompiler . | Improve this Doc View Source SharedExpressions Gets a read-only enumerable of all the shared expressions that have been inherited from any parent context and/or added via calls to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) or GetOrAddSharedLocal(Type, String, Type) . Declaration public IEnumerable<Expression> SharedExpressions { get; } Property Value Type Description IEnumerable < Expression > Implements IExpressionCompileContext.SharedExpressions Methods | Improve this Doc View Source GetOrAddSharedExpression(Type, String, Func<Expression>, Type) Gets or adds a shared expression (created by the expressionFactory if it's not already cached) with the given name, type, optionally for the given requestingType . Declaration public Expression GetOrAddSharedExpression(Type type, string name, Func<Expression> expressionFactory, Type requestingType = null) Parameters Type Name Description Type type The runtime type of the Expression. String name The runtime name of the Expression - and also the name used to retrieve it later. Func < Expression > expressionFactory The factory method to use to construct the shared expression from scratch, if it's not already cached. Type requestingType Optional - to avoid naming clashes with shared expressions created by other targets, you can pass a type here (usually the runtime type of your ITarget implementation). Returns Type Description Expression Expression. Implements IExpressionCompileContext.GetOrAddSharedExpression(Type, String, Func<Expression>, Type) | Improve this Doc View Source GetOrAddSharedLocal(Type, String, Type) Similar to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) , except this is used when expression builders want to use local variables in block expressions to store the result of some operation in the expression tree built for a particular target. Reusing one local variable is more efficient than declaring the same local multiple times. Declaration public ParameterExpression GetOrAddSharedLocal(Type type, string name, Type requestingType = null) Parameters Type Name Description Type type The type. String name The name. Type requestingType Optional - the type of the object requesting this shared expression. If this is provided, then the search for an existing shared expression will only work if the same requesting type was passed previously. Returns Type Description ParameterExpression Implements IExpressionCompileContext.GetOrAddSharedLocal(Type, String, Type) Remarks When multiple expression trees from multiple targets are brought together into one lambda, there will often be many duplicate variables which could be shared. So, if an IExpressionBuilder needs a local variable for a block, instead of simply declaring it directly through the function, it can use this function instead, which will return a previously created one if available. Exceptions Type Condition InvalidOperationException Cannot add ParameterExpression: A shared expression of a different type has already been added with the same type and name. | Improve this Doc View Source NewContext(Type, Nullable<ScopeBehaviour>) Used by the explicit implementation of NewContext(Type, Nullable<ScopeBehaviour>) . This is overriden to ensure that the correct type of context is created when created directly through the ICompileContext interface. Declaration protected override ICompileContext NewContext(Type targetType = null, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Nullable < ScopeBehaviour > scopeBehaviourOverride Override the ScopeBehaviourOverride to be used for the target that is compiled with the new context. This is never inherited automatically from one context to another. Returns Type Description ICompileContext Overrides CompileContext.NewContext(Type, Nullable<ScopeBehaviour>) Remarks Note all child contexts created through this virtual method will always inherit the parent context's shared expressions. | Improve this Doc View Source RegisterExpressionTargets() Registers some additional targets into the compile context to support compilation. Declaration protected void RegisterExpressionTargets() Explicit Interface Implementations | Improve this Doc View Source IExpressionCompileContext.NewContext(Type, Boolean, Nullable<ScopeBehaviour>) Creates a new IExpressionCompileContext using this one as a seed. This function is identical to NewContext(Type, Nullable<ScopeBehaviour>) but allows you to control whether the SharedExpressions are inherited (the default); and is more convenient because it returns another IExpressionCompileContext . Declaration IExpressionCompileContext IExpressionCompileContext.NewContext(Type targetType, bool useParentSharedExpressions, ScopeBehaviour? scopeBehaviourOverride) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Boolean useParentSharedExpressions If true then the shared expressions in this context will be inherited by the new context by reference. That is, when the new context goes out of scope, any new shared expressions it created will still be available. If false, then the new context will get a brand new, empty, set of shared expressions. Nullable < ScopeBehaviour > scopeBehaviourOverride Override the ScopeBehaviourOverride to be used for the target that is compiled with the new context. This is never inherited automatically from one context to another. Returns Type Description IExpressionCompileContext Implements IExpressionCompileContext.NewContext(Type, Boolean, Nullable<ScopeBehaviour>) Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also CompileContext"
  },
  "api/Rezolver.Compilation.Expressions.IExpressionCompileContext.html": {
    "href": "api/Rezolver.Compilation.Expressions.IExpressionCompileContext.html",
    "title": "Interface IExpressionCompileContext | Rezolver IOC Framework",
    "keywords": "Interface IExpressionCompileContext Extension to the ICompileContext interface which provides additional state and functionality for the IExpressionCompiler and the IExpressionBuilder implementations which are used by the default expression compiler, the ExpressionCompiler class. Inherited Members ICompileContext.Container ICompileContext.ScopeBehaviourOverride ICompileContext.TargetType ICompileContext.CompileStack ICompileContext.NewContext(Type, Nullable<ScopeBehaviour>) ICompileContext.PopCompileStack() ICompileContext.PushCompileStack(ITarget, Type) ITargetContainer.Register(ITarget, Type) ITargetContainer.Fetch(Type) ITargetContainer.FetchAll(Type) ITargetContainer.CombineWith(ITargetContainer, Type) Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public interface IExpressionCompileContext : ICompileContext, ITargetContainer Properties | Improve this Doc View Source ContainerExpression Gets an expression which gives a reference to the IContainer for this context - i.e. the same reference as given by the Container property. Declaration Expression ContainerExpression { get; } Property Value Type Description Expression Remarks Note that this is not the same as ContextContainerPropertyExpression - but is provided to allow expressions to be compiled which compare the container supplied at compile time to the one from the Container at resolve-time. | Improve this Doc View Source ContextContainerPropertyExpression Gets an expression for reading the Container property of the ResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration MemberExpression ContextContainerPropertyExpression { get; } Property Value Type Description MemberExpression | Improve this Doc View Source ContextScopePropertyExpression Gets an expression for reading the Scope property of the ResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration MemberExpression ContextScopePropertyExpression { get; } Property Value Type Description MemberExpression | Improve this Doc View Source ParentContext Gets the parent context. Declaration IExpressionCompileContext ParentContext { get; } Property Value Type Description IExpressionCompileContext Remarks Note that this property hides the inherited ParentContext property, since an IExpressionCompileContext can only be a child of another IExpressionCompileContext . | Improve this Doc View Source ResolveContextExpression This is the parameter expression which represents the ResolveContext that is passed to the ICompiledTarget at resolve-time. The other expressions - ContextContainerPropertyExpression and ContextScopePropertyExpression are both built from this too. Declaration ParameterExpression ResolveContextExpression { get; } Property Value Type Description ParameterExpression Remarks If the code produced by the IExpressionBuilder for a given target needs to read or use the ResolveContext that was originally passed to the Resolve(ResolveContext) method, then it does it by using this expression, which will be set as the only parameter on the lambda expression which is eventually compiled (in the case of the default expression compiler, ExpressionCompiler . | Improve this Doc View Source SharedExpressions Gets a read-only enumerable of all the shared expressions that have been inherited from any parent context or added via calls to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) or GetOrAddSharedLocal(Type, String, Type) . Declaration IEnumerable<Expression> SharedExpressions { get; } Property Value Type Description IEnumerable < Expression > The shared expressions. Methods | Improve this Doc View Source GetOrAddSharedExpression(Type, String, Func<Expression>, Type) Gets or adds an expression which is potentially shared between multiple targets' expression trees. Declaration Expression GetOrAddSharedExpression(Type type, string name, Func<Expression> expressionFactory, Type requestingType = null) Parameters Type Name Description Type type Required - the type of the expression. String name Required - the caller-defined name for this expression. Func < Expression > expressionFactory Required - Delegate to call to create the expression if it does not already exist. Type requestingType Optional - the type of the object requesting this shared expression. If this is provided, then the search for an existing shared expression will only work if the same requesting type was passed previously. Returns Type Description Expression Remarks Using shared expressions opens the door to potentially multiple optimisations, depending on the type of expression in question. For example, conditional expressions which share the same operand and comparand can all be merged into one with all the 'true' and 'false' branches being combined into one of each, thus saving multiple identical comparisons. | Improve this Doc View Source GetOrAddSharedLocal(Type, String, Type) Similar to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) , except this is used when expression builders want to use local variables in block expressions to store the result of some operation in the expression tree built for a particular target. Reusing one local variable is more efficient than declaring the same local multiple times. Declaration ParameterExpression GetOrAddSharedLocal(Type type, string name, Type requestingType = null) Parameters Type Name Description Type type The type. String name The name. Type requestingType Optional - the type of the object requesting this shared expression. If this is provided, then the search for an existing shared expression will only work if the same requesting type was passed previously. Returns Type Description ParameterExpression Remarks When multiple expression trees from multiple targets are brought together into one lambda, there will often be many duplicate variables which could be shared. So, if an IExpressionBuilder needs a local variable for a block, instead of simply declaring it directly through the function, it can use this function instead, which will return a previously created one if available. | Improve this Doc View Source NewContext(Type, Boolean, Nullable<ScopeBehaviour>) Creates a new IExpressionCompileContext using this one as a seed. This function is identical to NewContext(Type, Nullable<ScopeBehaviour>) but allows you to control whether the SharedExpressions are inherited (the default); and is more convenient because it returns another IExpressionCompileContext . Declaration IExpressionCompileContext NewContext(Type targetType = null, bool inheritSharedExpressions = true, ScopeBehaviour? scopeBehaviourOverride = null) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Boolean inheritSharedExpressions If true then the shared expressions in this context will be inherited by the new context by reference. That is, when the new context goes out of scope, any new shared expressions it created will still be available. If false, then the new context will get a brand new, empty, set of shared expressions. Nullable < ScopeBehaviour > scopeBehaviourOverride Override the ScopeBehaviourOverride to be used for the target that is compiled with the new context. This is never inherited automatically from one context to another. Returns Type Description IExpressionCompileContext Remarks When you have a reference to an IExpressionCompileContext the compiler will favour this method to the one defined on the ICompileContext interface because it is 'closer', even if you do not explicitly provide an argument for the inheritSharedExpressions parameter. Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also ICompileContext"
  },
  "api/Rezolver.Compilation.Expressions.RezolvedTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.RezolvedTargetBuilder.html",
    "title": "Class RezolvedTargetBuilder | Rezolver IOC Framework",
    "keywords": "Class RezolvedTargetBuilder An IExpressionBuilder specialised for building the expression for the ResolvedTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ResolvedTarget > RezolvedTargetBuilder Inherited Members ExpressionBuilderBase<ResolvedTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ResolvedTarget>.IExpressionBuilder<ResolvedTarget>.Build(ResolvedTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ResolvedTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class RezolvedTargetBuilder : ExpressionBuilderBase<ResolvedTarget>, IExpressionBuilder<ResolvedTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ResolvedTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(ResolvedTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ResolvedTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ResolvedTarget>.Build(Rezolver.Targets.ResolvedTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Exceptions Type Condition InvalidOperationException Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.html": {
    "href": "api/Rezolver.Compilation.Expressions.html",
    "title": "Namespace Rezolver.Compilation.Expressions | Rezolver IOC Framework",
    "keywords": "Namespace Rezolver.Compilation.Expressions Classes ChangeTypeTargetBuilder Implementation of IExpressionBuilder specialised to build expressions for the ChangeTypeTarget This always produces a conversion expression (i.e. cast or box/unbox) ConstructorTargetBuilder An IExpressionBuilder specialised for building the target ConstructorTarget DecoratorTargetBuilder Specialised builder for DecoratorTarget targets. DefaultTargetBuilder An IExpressionBuilder specialised for building the expression for the DefaultTarget target. Essentially, it just calls for the DeclaredType . DelegateTargetBuilder Specialised builder for the DelegateTarget class and all its derivatives. ExpressionBuilderBase Abstract starting point for implementing IExpressionBuilder . Note that the interface is implemented explicitly; but exposes protected abstract or virtual methods for inheritors to extend. ExpressionBuilderBase<TTarget> Abstract base class for implementations of IExpressionBuilder<TTarget> . Provide an implementation of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) and then register an instance in an ObjectTarget in the active container. ExpressionCompileContext An implementation of ICompileContext which is specialised for use by an IExpressionCompiler . ExpressionCompiler Implementation of the ITargetCompiler interface which produces ICompiledTarget objects by building and compiling expression trees from the ITarget objects which are registered. ExpressionCompilerBuildExtensions Extensions for IExpressionCompiler . ExpressionCompilerConfigurationProvider Implements the ICompilerConfigurationProvider to configure expression-based compilation for targets in containers. The implementation registers all the targets necessary to use the expression tree-based compilation provided by the Rezolver.Compilation.Expressions library. This configuration provider is automatically configured as the default for all containers when the Rezolver library is referenced. ExpressionTargetBuilder An IExpressionBuilder specialised for building the expression trees for the ExpressionTarget target type. This builder takes care of all expressions, including lambdas (where additional parameters beyond the standard ResolveContext are turned into local variables with injected values), producing an expression which can be compiled by an IExpressionCompiler after a Rezolver.Compilation.Expressions.TargetExpressionRewriter has been used to expand any targets embedded in the expression. GenericConstructorTargetBuilder An IExpressionBuilder specialised for building expressions for GenericConstructorTarget targets. ListTargetBuilder An IExpressionBuilder specialised for building expressions for the ListTarget target. ObjectTargetBuilder An IExpressionBuilder specialised to build expressions for the ObjectTarget target. OptionalParameterTargetBuilder An IExpressionBuilder specialised for building an expression for the OptionalParameterTarget target. RedundantConvertRewriter Removes unnecessary convert expressions from an expression. An unnecessary conversion is one where the target type is equal to, or a base of, the source type. Only boxing/unboxing conversions or upcasts are left intact. RezolvedTargetBuilder An IExpressionBuilder specialised for building the expression for the ResolvedTarget target. ScopedTargetBuilder An IExpressionBuilder specialised for building expressions for ScopedTarget targets. SharedExpressionKey Key for a shared expression used during expression tree generation. As a consumer of this library, you are unlikely ever to need to use it. SingletonTargetBuilder An IExpressionBuilder specialised for the building the expression for a SingletonTarget target. TargetExpression An expression which represents an ITarget , allowing a target with a particular DeclaredType to be used in place of a traditional expression. UnscopedTargetBuilder Builder for the UnscopedTarget . Interfaces IExpressionBuilder The interface for an object that produces expressions (which can be compiled to delegates) from ITarget instances. IExpressionBuilder<TTarget> Interface for an object that produces expressions from instances of TTarget . This is a generic extension to the IExpressionBuilder interface. IExpressionCompileContext Extension to the ICompileContext interface which provides additional state and functionality for the IExpressionCompiler and the IExpressionBuilder implementations which are used by the default expression compiler, the ExpressionCompiler class. IExpressionCompiler Interface for an object which is responsible for coordinating the production of expressions for targets during the compilation phase. Objects implementing this are expected to be implementations of ITargetCompiler ; this library provides the one implementation, too: ExpressionCompiler ."
  },
  "api/Rezolver.ConstructorBinding.html": {
    "href": "api/Rezolver.ConstructorBinding.html",
    "title": "Class ConstructorBinding | Rezolver IOC Framework",
    "keywords": "Class ConstructorBinding Represents a binding specifically to a class constructor, optionally with an additional set of MemberBindings to be used to initialise a new instance's properties or fields directly. Inheritance Object MethodBinding ConstructorBinding Inherited Members MethodBinding.Method MethodBinding.BoundArguments Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class ConstructorBinding : MethodBinding Constructors | Improve this Doc View Source ConstructorBinding(ConstructorInfo, ParameterBinding[], MemberBinding[]) Initializes a new instance of the ConstructorBinding class. Declaration public ConstructorBinding(ConstructorInfo constructor, ParameterBinding[] boundArgs = null, MemberBinding[] memberBindings = null) Parameters Type Name Description ConstructorInfo constructor The constructor to be used . ParameterBinding [] boundArgs Optional. The bound arguments. Can be null or empty. MemberBinding [] memberBindings Optional. The bindings for the members of the new instance created by the constructor. Fields | Improve this Doc View Source NoBoundMembers An empty array of MemberBinding objects used to represent a constructor binding with no bound members. The MemberBindings property will be set to this if the constructor is called with a null memberBindings argument. Declaration public static MemberBinding[] NoBoundMembers Field Value Type Description MemberBinding [] Properties | Improve this Doc View Source Constructor Gets the constructor to be invoked. Note that this simply returns the base Method property cast to ConstructorInfo . Declaration public ConstructorInfo Constructor { get; } Property Value Type Description ConstructorInfo The constructor. | Improve this Doc View Source MemberBindings Gets the member bindings to be applied to the new instance created by the Constructor Declaration public MemberBinding[] MemberBindings { get; } Property Value Type Description MemberBinding [] The member bindings. Remarks Member bindings represent the inline initialisation of writable properties or fields immediately after constructing a new instance of a type. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also MethodBinding"
  },
  "api/Rezolver.ContainerScopeResolveExtensions.html": {
    "href": "api/Rezolver.ContainerScopeResolveExtensions.html",
    "title": "Class ContainerScopeResolveExtensions | Rezolver IOC Framework",
    "keywords": "Class ContainerScopeResolveExtensions Extensions for IContainerScope so that instances of that interface present a similar set of functionality to IContainer . Inheritance Object ContainerScopeResolveExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public static class ContainerScopeResolveExtensions Methods | Improve this Doc View Source Resolve(IContainerScope, Type) Non-generic variant of the Resolve<TResult>(IContainerScope) extension method. Declaration public static object Resolve(this IContainerScope scope, Type requestedType) Parameters Type Name Description IContainerScope scope The scope. Type requestedType Type of object required. Returns Type Description Object Exceptions Type Condition ArgumentNullException | Improve this Doc View Source Resolve<TResult>(IContainerScope) Resolves an object through the scope's Container Declaration public static TResult Resolve<TResult>(this IContainerScope scope) Parameters Type Name Description IContainerScope scope The active scope within which the call is to be made. Returns Type Description TResult Type Parameters Name Description TResult The type of object required. Remarks Resolving an object via a scope does not guarantee that it will be tracked. Ultimately, it's up to the behaviour of the individual underlying targets to determine whether they should interact with the scope. Indeed, all this extension method does is to forward the method call on to the Container of the given scope, ensuring that the scope is set on the ResolveContext that is passed to its Resolve(ResolveContext) method."
  },
  "docs/expressions.html": {
    "href": "docs/expressions.html",
    "title": "Factory expressions | Rezolver IOC Framework",
    "keywords": "Factory expressions If you've read the factory delegate documentation, then you'll know that Rezolver can bind a delegate (with an unlimited number of non- ref , non- out parameters) as a factory for a given type registration. Rezolver can do the same with expression trees (derived from the Expression class) and has one or two additional tricks up its sleeve when doing so. To register expessions you can use one of the many RegisterExpression extension methods for ITargetContainer . To create expression targets you can either: Manually create an instance of ExpressionTarget through its constructor Use the ForExpression overload, which, like the delegate helper function ForDelegate , provides specialisations for lambda expressions whose signatures conform to one of many System.Func<> generic delegate types. Whilst using expressions might appear to be fundamentally the same as using delegates, there is a subtle difference: A DelegateTarget requires an entire function body, whilst an ExpressionTarget supports any expression, from expression 'fragments' like ConstantExpression right up to the delegate-like LambdaExpression . Expression 'fragments' As we've just mentioned, an expression fragment is one of the small, specialised, expression types from the System.Linq.Expressions namespace which wrap a fundamental language expression, such as constants or method calls or whatever. The ExpressionTarget supports these through its ExpressionTarget(Expression, Type) constructor. When creating an ExpressionTarget this way, its DeclaredType (and therefore the default type under which it will be registered, unless overridden at registration time) will, by default, be set to the Type of the expression you pass to the constructor, unless you pass a non-null type explicitly as the second argument. Using ConstantExpression In this example, we'll bake a ConstantExpression into an ExpressionTarget , which will then be used to provide a string : var container = new Container(); container.Register( new ExpressionTarget( Expression.Constant(\"Hello World\") ) ); Assert.Equal(\"Hello World\", container.Resolve<string>()); Using MethodCallExpression Here, we have an instance method declared in our test, which returns the value of a local field: private string _theMessage = \"Hello World\"; public string GetMessage() { return _theMessage; } To instruct Rezolver to execute this method on this instance whenever a string is resolved, we simply do this: var container = new Container(); container.Register( new ExpressionTarget( Expression.Call( Expression.Constant(this), // the instance this.GetType().GetMethod(\"GetMessage\") ) ) ); Assert.Same(_theMessage, container.Resolve<string>()); // now change _theMessage and re-resolve: _theMessage = \"New Message!!!\"; Assert.Same(_theMessage, container.Resolve<string>()); Note Obviously, this can also easily be implemented as a DelegateTarget - but the same reasons for why you might use expressions over delegates in any application (i.e. the ability to analyse and rewrite code or dynamically compose logic) hold for targets in your container. The point of these examples is to show that Rezolver will happily deal with any expression you throw at it, not that you should use expressions where a delegate would be a better choice. Lambda Expressions Lambda expressions can also be used to create or register an ExpressionTarget , meaning you can take advantage of the compiler's translation of code into expression trees to simplify their construction. Note When constructing an ExpressionTarget from a lambda expression, the DeclaredType of the target will be set to the Type of the Body of the lambda, unless overridden by a type explicitly provided on construction. Ultimately, Rezolver doesn't really care if you pass a lambda or a fragment like those in the previous section - the same process is followed - but one additional feature that a lambda provides is parameters. Injecting Arguments As with factory delegates , Rezolver provides automatic argument injection for lambda expressions - so, taking the MethodCallExpression example from above, we could instead do this: // this is equivalent to the previous example, just with a lambda // and explicitly injected argument var container = new Container(); // note - the type of 'this' is ExpressionExamples container.RegisterObject(this); container.RegisterExpression((ExpressionExamples e) => e.GetMessage()); Assert.Same(_theMessage, container.Resolve<string>()); _theMessage = \"Another New Message!!!\"; Assert.Same(_theMessage, container.Resolve<string>()); Note Look past the fact that the object being injected is the same instance on which the test is executed, it's the principle that matters! Injecting the ResolveContext Just as with the DelegateTarget example , you can also inject the ResolveContext into your expression in order to perform late-bound service location within your expression. As the comment at the start of the test states - this example is functionally identical to the DelegateTarget example - but because of the limitations of the C# compiler and its ability to translate code into expression trees, the main expression is written as a series of stacked conditional expressions so that the whole thing is a single expression. static IPrincipal CurrentPrincipal { get; set; } [Fact] public void ShouldGetDifferentImplementationFromResolveContextForUser() { // this test is functionally identical to the one in DelegateExamples.cs, // it's just done with an expression, and therefore the format of the code block // used for the IUserActionsService is different because the compiler can only // translate expression lambdas. IIdentity identity = new AppIdentity(); // three principals, one for each role var adminPrincipal = new AppPrincipal(identity, new[] { \"Admin\" }); var salesPrincipal = new AppPrincipal(identity, new[] { \"Sales\" }); var customerPrincipal = new AppPrincipal(identity, new[] { \"Customer\" }); var container = new Container(); container.RegisterType<AdminActionsService>(); container.RegisterType<SalesActionsService>(); container.RegisterType<CustomerActionsService>(); container.RegisterType<UserControlPanel>(); // register expression to read the CurrentPrincipal property, to make it dynamic container.RegisterExpression(() => CurrentPrincipal); // now register the expression for the IUserActionsService, which does the // role sniffing over the principal as one expression container.RegisterExpression((IPrincipal p, ResolveContext rc) => p.IsInRole(\"Customer\") ? rc.Resolve<CustomerActionsService>() : p.IsInRole(\"Sales\") ? rc.Resolve<SalesActionsService>() : p.IsInRole(\"Admin\") ? rc.Resolve<AdminActionsService>() : (IUserActionsService)null); // set the principal, and resolve CurrentPrincipal = adminPrincipal; var result1 = container.Resolve<UserControlPanel>(); // now swap principals CurrentPrincipal = salesPrincipal; var result2 = container.Resolve<UserControlPanel>(); // and again CurrentPrincipal = customerPrincipal; var result3 = container.Resolve<UserControlPanel>(); Assert.IsType<AdminActionsService>(result1.ActionsService); Assert.IsType<SalesActionsService>(result2.ActionsService); Assert.IsType<CustomerActionsService>(result3.ActionsService); } Note Remember: any expression tree built by the compiler can be built 'by hand' through the factory methods in Expression , meaning that you could also provide an expression in which the conditional statements where built dynamically (or, more likely, a dynamically built SwitchExpression ) and it would still work. Resolving without a ResolveContext These advanced examples with lambda expressions show how you can inject an argument or perform late-bound service location within your expression body. Sometimes, however, you might not want to, or be able to, provide a parameterised lambda expression, or you might be passing an expression fragment which cannot accept injected arguments. For this purpose, Rezolver provides the ExpressionFunctions static class. If the compiler sees a MethodCallExpression bound to one of the Resolve static functions of this class, it will be converted into a call to the appropriate Resolve overload of the ResolveContext that is in scope when the container executes the code compiled from the expression. Warning These functions only work inside expressions - any attempt to execute them outside of an expression passed to a ExpressionTarget will result in a NotImplementedException being thrown. var container = new Container(); container.RegisterType<MyService, IMyService>(); // get the ExpressionFunctions.Resolve<T> method var resolveMethod = typeof(ExpressionFunctions) .GetMethods(BindingFlags.Public | BindingFlags.Static) .SingleOrDefault(m => m.Name == \"Resolve\" && m.IsGenericMethodDefinition); // this expression is equivalent to the lambda expression: // rc => new RequiresMyService(rc.Resolve<IMyService>()) container.Register( new ExpressionTarget( Expression.New( // get the (IMyService) constructor typeof(RequiresMyService).GetConstructor(new[] { typeof(IMyService) }), Expression.Call( resolveMethod.MakeGenericMethod(typeof(IMyService)) ) ) )); var result = container.Resolve<RequiresMyService>(); Assert.NotNull(result.Service); Note The RequiresMyService and MyService types can be seen in the construction injection documentation . Admittedly, this way of dynamically resolving services inside an expression requires some heavy lifting (with reflection in particular) when compared with writing the lambda by hand, but it's not intended to be a direct alternative to doing that. Using this approach is for those times when you simply can't alter how you build the expression you want to register. You can, of course, also use the ExpressionFunctions static class inside a parameterless lambda to achieve exactly the same result: var container = new Container(); container.RegisterType<MyService, IMyService>(); container.RegisterExpression(() => new RequiresMyService(ExpressionFunctions.Resolve<IMyService>()) ); var result = container.Resolve<RequiresMyService>(); Assert.NotNull(result.Service); Next steps If you haven't already, then you should probably look at the aforementioned factory delegate documentation . The next main topic after this covers decorators ."
  },
  "docs/index.html": {
    "href": "docs/index.html",
    "title": "Rezolver Dev Guide | Rezolver IOC Framework",
    "keywords": "Rezolver Dev Guide Welcome to the Rezolver developer guide! This site is always under development, and right now we're doing everything we can to get all high-level documentation in place so that even novice users of DI containers can get up and running with Rezolver. Something missing? Please open an issue over on Github with your question. Getting started As with many open source .Net projects, there are two primary ways to get Rezolver integrated into your project. The easiest is via the Nuget packages By using the Nuget packages, you ensure that you're using the latest (hopefully stable!) releases. Pre-release packages will also be made available for in-development features. Fork or download the Rezolver source from Github Use this if you can't integrate nuget into your build pipeline, or if you'd like to customise or contribute to the project. If you're looking to customise, though, then there should be enough extensibility points in the framework to allow you to do so without having to change core types. If that's not the case, post an issue on the Github project so we can get it added in and make it better for everyone! Tests as Examples Most of the example code shown here is drawn directly from the project Rezolver.Tests.Examples , which can be found in the test folder under the root of the repo. If there's a filename shown at the top of a code example, then that should equal the filename where you can find that code in the examples project. Please note that any example code containing type declarations will be found in the Types folder of that project, with all the individual test files in the root. We're using xunit for all our tests, hence all the examples are written for it too. Matching an example to a test We do omit the test function declaration in these examples - but if you look down a tests file you'll see comments inside each test method with an XML tag. Here's the body of the ObjectExamples.cs file, which contains all the examples for the 'Objects as Services' documentation : using Rezolver.Tests.Examples.Types; using Xunit; namespace Rezolver.Tests.Examples { public class ObjectExamples { [Fact] public void ShouldRegisterAndRetrieveByItsType() { // <example1> var container = new Container(); var service = new MyService(); container.RegisterObject(service); Assert.Same(service, container.Resolve<MyService>()); // </example1> } [Fact] public void ShouldRegisterAndRetrieveByInterface() { // <example2> var container = new Container(); var service = new MyService(); container.RegisterObject<IMyService>(service); // NOTE: Could also use: // container.RegisterObject(service, typeof(IMyService) Assert.Same(service, container.Resolve<IMyService>()); // </example2> } [Fact] public void ShouldNotDisposeByDefault() { // <example10> var disposableObj = new DisposableType(); using (var container = new ScopedContainer()) { container.RegisterObject(disposableObj); var result = container.Resolve<DisposableType>(); Assert.Same(disposableObj, result); } // Should NOT be disposed Assert.False(disposableObj.Disposed); // </example10> } [Fact] public void ShouldDispose() { // <example11> var disposableObj = new DisposableType(); using (var container = new ScopedContainer()) { container.RegisterObject(disposableObj, scopeBehaviour: ScopeBehaviour.Explicit); var result = container.Resolve<DisposableType>(); Assert.Same(disposableObj, result); } // Should be disposed Assert.True(disposableObj.Disposed); // </example11> } [Fact] public void OnlyRootScopeShouldDispose() { // <example12> var disposableObj = new DisposableType(); using (var container = new ScopedContainer()) { container.RegisterObject(disposableObj, scopeBehaviour: ScopeBehaviour.Explicit); using (var scope = container.CreateScope()) { var result = container.Resolve<DisposableType>(); Assert.Same(disposableObj, result); } // Should not be disposed here... Assert.False(disposableObj.Disposed); } // ... but should be disposed here Assert.True(disposableObj.Disposed); // </example12> } } } You'll notice that the body of each test method looks like this: //<example_n> ... (code) ... //</example_n> Note This is a facet of the code snippet feature of docfx Each example is numbered sequentially, so it shouldn't be too hard to marry up the example in the documentation to the test in the tests file. Next Steps Asp.Net Core developers should read how to integrate Rezolver into the Asp.Net Core hosting pipeline . Learn how to create and use a container ."
  },
  "docs/object-lifetimes.html": {
    "href": "docs/object-lifetimes.html",
    "title": "Object lifetimes | Rezolver IOC Framework",
    "keywords": "Object lifetimes Tip Read Creating and using a container if you haven't already done so. As with any IOC container, Rezolver understands the concept of object lifetimes, which are implemented as different ITarget implementations that can be registered in an ITargetContainer . Before we take a look at how you actually use these lifetimes when working with Rezolver, we'll first take a look at exactly what these lifetimes are. Tip If you're already a seasoned IOC god - then you can skip this section and head straight to the Object lifetimes (in Rezolver) section for some examples from the Rezolver.Tests.Examples project. What is a lifetime? No, this is not a philosophical question ;) In a crude sense, an object lifetime describes when a new object is created and whether a previously created object is subsequently returned from a container's Resolve method. Note In practise, it's not that simple - because an IOC container's understanding of a lifetime does not strictly map to whether a new instance is actually created at all. It's more accurate to say that the lifetime determines when the action that's been associated with a given service type is actually executed . Rezolver understands three main lifetimes, which should be familiar to anyone who's used an IOC container before: Transient In general , a transient object is simply one which is created when needed; and thrown away when it's fulfilled its purpose. This typically translates to calling the new operator with the constructor of a particular type, when you want an object, and then allowing that object to go out of scope, as in this snippet: // Factory method always creates a new instance static MyObject CreateObject() { return new MyObject(); } static MyObject _transient = CreateObject(); void Test() { var transient1 = CreateObject(); var transient2 = CreateObject(); //note - using XUnit nomenclature here Assert.NotSame(transient1, transient2); Assert.NotSame(_transient, transient1); Assert.NotSame(_transient, transient2); } This idea of transience is encompassed by the following targets in the Rezolver.Targets namespace: ConstructorTarget DecoratorTarget DelegateTarget (see below) ExpressionTarget (see below) GenericConstructorTarget ListTarget Remember that a target in Rezolver is an instruction to perform an action when the associated service type is resolved by the container. In the case of the above list, for all but two we can definitely say that a new object will be created if that target is registered against a type that's requested. So, the ConstructorTarget will always result in a type's constructor being called; the ListTarget will always result in a new Array or List<T> being created, and so on. In the case of the DelegateTarget and ExpressionTarget targets, however, all we can say about those is that the action they represent will be executed every time the container resolves them. That's the same as if we were to change the definition of CreateObject in our earlier code example as follows: private static IMyObjectService _service = new MyObjectService(); static MyObject CreateObject() { return _service.GetObject(); } The point here being that we can no longer guarantee the transience of the object that is produced by the CreateObject method because we no longer know how the service is producing that object. All we can say is that we definitely execute the service's GetObject method every time we call CreateObject . We will go into more depth about using delegates and expressions (and indeed custom targets) as we delve deeper into the Rezolver framework - but for now it's important to know that some targets produce inherently transient results, whereas some might do, but they equally might not . Singleton Every developer should know what a singleton is. Okay - any reasonably experienced developer should know what a singleton is! In short, a singleton is exactly as the name suggests: a type for which there is guaranteed to be only one instance. Here's a simple implementation (note: please don't take this as the best, or only , way to implement one - it's just an example!): public class MySingleton { public MySingleton Instance { get; } = new MySingleton(); private MySingleton() { } } An application wishing to use the MySingleton object must do so through the Instance property, which is the only instance of that type for the entire AppDomain . Equally, if the singleton object implements an interface or base, then it can be passed to code which requires an instance of that interface or base without knowing that the underlying object itself is always the same reference. Note Different IOC containers have differing understandings of what a singleton really is. In some cases it's one instance per-AppDomain (as with the above code snippet) and in other cases it's one instance per-container. In yet more cases, it's configurable or, indeed, extensible. Rezolver currently supports one instance per-AppDomain, but in future it will also support one per-container and possibly more besides. Scoped Scoping has two flavours, and also often relates specifically to objects which implement the IDisposable interface from the .Net framework (although it doesn't have to). In order for the idea of a scoped object to make any sense, however, you need a scope within which the object will exist. A scope can be thought of as being a 'bag' for objects which the application wants to create and keep alive for a specific period of time and, when it no longer needs those objects, it throws the bag away - or, disposes of it. Scopes can also contain other, 'child' scopes. When a parent scope is disposed it also triggers the disposal of any child scopes it contains, and all their children, and so on. The reason why this pattern is usually applied to disposable objects is because you don't typically need to worry about telling the runtime that you're done with a non-disposable transient object - you simply allow it to go out of scope and, eventually, the garbage collector will reclaim the memory that object occupied. A disposable object, on the other hand, is disposable typically because it contains resources which the framework cannot free automatically when the object falls out of scope - e.g. database connections, or unmanaged memory - and so any container which takes charge of creating objects for us should also provide a way for us to dispose of them in those cases where that is needed. That said, there are scenarios why you might wish to explicitly restrict an otherwise transient object to one-per-scope, so that's why scoped objects do not have to be disposable. One feature which is consistent, however, is that the scope itself is disposable. Implicit scoping Implicit scoping applies only to IDisposable objects and affects when the object is disposed, not when it's created. A simple demonstration of this, if you were writing something like it by hand, would be as follows ( please note the implementation of IDisposable shown here is not recommended! ): public class Scope : IDisposable { private List<IDisposable> _scopeObjects = new List<IDisposable>(); public void Dispose() { //dispose all our tracked disposables foreach(var obj in _scopeObjects) { obj.Dispose(); } } public T CreateObject<T>() { //this bit is merely to take the place of a generic //factory/service/IOC container which knows how to build things. T result; if(typeof(T) == typeof(MyDisposable)) result = (T)(object)new MyDisposable(); else throw new InvalidOperationException($\"Don't know how to create { typeof(T) }\"); //if the object is disposable - track it if(result is IDisposable) _scopeObjects.Add((IDisposable)result); return result; } } public class MyDisposable : IDisposable { public bool Disposed { get; private set; } public void Dispose() { Disposed = true; } } public class XUnitTest { [Fact] public void ShouldDispose() { MyDisposable obj; using(var scope = new Scope()) { obj = scope.CreateObject<MyDisposable>(); } Assert.True(obj.Disposed); } } In the test, we create a new scope in a using block, create an object from it, and then check whether that object is disposed just after the using block is left. At this point, the scope should be disposed and, because the object we requested from the scope was IDisposable it, too, should be disposed. The scope only bothers with disposables - anything else that it might produce (ignoring the fact that our little factory function here only knows how to create an instance of MyDisposable !) would pass straight through. This is ultimately how implicitly scoped objects are handled in Rezolver. Explicit scoping Explicit scoping also does relate to IDisposable objects, inasmuch as disposable objects are expected to be disposed when the scope is disposed - but it's more targeted at controlling when a new object is created regardless of whether the object can be disposed. Explicit scoping can be thought of as a 'scoped singleton'. When the developer indicates he or she wants a scoped object, what they're actually saying is that they want one unique instance of that object per-scope. Note Child scopes also get their own instance of explicitly scoped objects - child scopes do not share instances with their parents. So imagine if we were to change the implementation of the Scope class we defined in the previous section to this: public class Scope : IDisposable { private Dictionary<Type, object> _scopeObjects = new Dictionary<Type, object>(); public void Dispose() { //dispose all our tracked disposables foreach(var obj in _scopeObjects.Values.OfType<IDisposable>()) { obj.Dispose(); } } public T CreateObject<T>() { // start with a look up to see if we have already created an instance of T // and, if so, return it. object cached; if(_scopeObjects.TryGetValue(typeof(T), out cached) return (T)cached; //this bit is merely to take the place of a generic //factory/service/IOC container which knows how to build things. T result; if(typeof(T) == typeof(MyDisposable)) result = (T)(object)new MyDisposable(); else throw new InvalidOperationException($\"Don't know how to create { typeof(T) }\"); _scopeObjects[typeof(T)] = result; return result; } } With a scope implemented like this (and, again, we have to imagine that CreateObject<T> is implemented properly), we will only ever get one instance of a given type from that scope. Explicitly scoped objects, then, treat their scopes as if they behave like this. Singletons in scopes To make things slightly more confusing - the singleton objects discussed earlier also have a special behaviour when materialised in a scope. The singleton is supposed to guarantee a single instance to the whole application, but at the same time, they are typically implicitly scoped , so what happens when you materalise that singleton via a scope, and the singleton is also disposable? Following the definitions of lifetimes we've talked about so far: when the first scope in which we resolve that singleton is disposed, the singleton will also be - rendering it useless. To get around this problem, singletons will actively seek out the root scope of the tree of scopes that it is being materialised within, and ensure that it is tracked for disposal only in that root scope - even if the current scope is a great great granchild - ensuring that it will only be disposed when the rootmost scope is disposed. Tip If your application requires a singleton which you also want to be automatically disposed, then you should ensure that your root container is the ScopedContainer - which contains its own scope that will be the ultimate root for any child scopes it creates. The next step is take a look at how you can work with lifetimes when registering targets in Rezolver ."
  },
  "docs/objects.html": {
    "href": "docs/objects.html",
    "title": "Objects as Services | Rezolver IOC Framework",
    "keywords": "Objects as Services Sometimes you will want to create an object yourself and register that in the container for use as a particular service type. This is done either by creating an ObjectTarget and registering it in a target container, or via the extension method(s) RegisterObject . This type of registration is often thought of as a singleton, but it's more accurate to think of it as a 'constant' service - because, from the moment the registration is created, the object reference is already known and doesn't change. Singletons are different because the container creates the instance for you. We don't need many examples for this, first - this is how you'd register an object against its runtime type: var container = new Container(); var service = new MyService(); container.RegisterObject(service); Assert.Same(service, container.Resolve<MyService>()); And if you want to register it against a different type, the following example shows one way, with another shown in comments: var container = new Container(); var service = new MyService(); container.RegisterObject<IMyService>(service); // NOTE: Could also use: // container.RegisterObject(service, typeof(IMyService) Assert.Same(service, container.Resolve<IMyService>()); That's all there is to it, really. Although before we move on, we should take a quick look at how object-based services interact with scopes. Objects in Scopes A scope (obtained either by using ScopedContainer or through a IContainerScope returned from a container's CreateScope method) will by default dispose of any disposable objects it creates when it is disposed. If those objects are obtained from an ObjectTarget , however, then no scope will ever touch them - because you created them, therefore you will also typically dispose them. Here's an example, using the aforementioned ScopedContainer : var disposableObj = new DisposableType(); using (var container = new ScopedContainer()) { container.RegisterObject(disposableObj); var result = container.Resolve<DisposableType>(); Assert.Same(disposableObj, result); } // Should NOT be disposed Assert.False(disposableObj.Disposed); As the last assertion proves - the supplied object is left untouched by the scoped container. You can change this behaviour, however, by providing a different ScopeBehaviour when creating the target (directly registering with the RegisterObject method): var disposableObj = new DisposableType(); using (var container = new ScopedContainer()) { container.RegisterObject(disposableObj, scopeBehaviour: ScopeBehaviour.Explicit); var result = container.Resolve<DisposableType>(); Assert.Same(disposableObj, result); } // Should be disposed Assert.True(disposableObj.Disposed); Notice the scopeBehaviour: named argument on the 4th line. To enable the correct disposal behaviour, you must use Explicit because you need the scope to know that only one instance should ever be tracked per scope. Warning If you pass Implicit then disposal will still work, although there's a risk that the object will be tracked by the scope multiple times and, therefore, could be disposed multiple times. This behaviour is unintentional and will be prevented in a future release by raising an exception if the Implicit behaviour is set on an ObjectTarget . Child scopes For the seasoned IOC container-user the last phrase of the previous section - 'one instance should ever be tracked per scope ' - will likely be setting alarm bells ringing. As with Singletons, Rezolver knows that a service implemented by a constant object should only ever be tracked in the root-most scope so that the disposal of a child scope does not also cause the disposal of the object. To demonstrate this, another test, which uses a ScopedContainer as before, but which resolves the object only through a child scope which is then immediately disposed. The test shows that the object, however, is not disposed of until the root-most scope - the ScopedContainer - is disposed: var disposableObj = new DisposableType(); using (var container = new ScopedContainer()) { container.RegisterObject(disposableObj, scopeBehaviour: ScopeBehaviour.Explicit); var result = container.Resolve<DisposableType>(); Assert.Same(disposableObj, result); } // Should be disposed Assert.True(disposableObj.Disposed); Next steps Feel free to explore the table of contents or head back to the main service registration overview to explore more features of Rezolver."
  },
  "docs/service-registration.html": {
    "href": "docs/service-registration.html",
    "title": "Registering services | Rezolver IOC Framework",
    "keywords": "Registering services Registering services ultimately means adding ITarget objects to an ITargetContainer . The different built-in implementations of ITarget provide us with the ability to resolve objects in different ways - and this section looks at those implementations in addition to how we actually perform registrations. Tip An ITarget is an object stored within an ITargetContainer which contains information about how an object is to be created or retrieved when a container's Resolve operation is called. This subject means delving into the ITargetContainer interface and our default implementation, TargetContainer - which contains the core registration API, as well as some extra functionality which might be useful to some. What is ITargetContainer ? The ITargetContainer interface supplies service registrations when using the default container types Container and ScopedContainer . All the target container does is to provide a means to register and look up ITarget instances which have been registered against specific types. Registering via extension methods The majority of your work with the Rezolver framework will use extension methods to create and add targets to an ITargetContainer which will ultimately drive the IContainer that you will use to create instances. These extension methods are more expressive than the core API (documented below), and greatly simplify your interaction with the Rezolver framework. The majority of the code samples shown on this site use these registration methods, which are documented in the API section of this site: AliasTargetContainerExtensions - for registering aliases of one type to another (useful for reusing singletons for multiple types) DecoratorTargetContainerExtensions - for registering decorators DelegateTargetContainerExtensions - for registering factory delegates ExpressionTargetContainerExtensions - for registering expression trees MultipleTargetContainerExtensions - for batch registering multiple targets ObjectTargetContainerExtensions - for registering object references/values RegisterTypeTargetContainerExtensions - for registering constructor-injected types (plain and open-generic) ScopedTargetContainerExtensions - for registering scoped constructor-injected types SingletonTargetContainerExtensions - for registering singleton constructor-injected types Note Some of these methods extend ITargetContainerOwner - an interface which extends ITargetContainer to supply advanced functionality to the framework - such as decoration. Registering via Register To add registrations to an ITargetContainer directly, i.e. without extension methods, we ultimately use the Register method, which accepts an ITarget object and an optional Type against which that target is to be registered. If the optional type is not provided, then the target's DeclaredType is used as the default registration type: Note In the next example, we're using the ObjectTarget . We have more in-depth documentation about ObjectTarget if you want to know more. var targets = new TargetContainer(); targets.RegisterObject(\"hello world\"); var target = targets.Fetch(typeof(string)); Assert.IsType<ObjectTarget>(target); So, here, the target container defaults to using System.String as the registration type for the target because that's its DeclaredType . We can also provide any base or interface of the target's type as a valid type, too: Note This time we're creating a ConstructorTarget via one of its static factory functions. Again, this target is covered in more depth here . var targets = new TargetContainer(); targets.Register(Target.ForType<MyService>(), typeof(IMyService)); var target = targets.Fetch(typeof(IMyService)); Assert.IsType<ConstructorTarget>(target); The class MyService implements the interface IMyService in this example If you attempt to register a target against a type which the target does not support then an exception will occur: var targets = new TargetContainer(); // int is obviously not compatible with IMyService. Assert.Throws<ArgumentException>( () => targets.Register(Target.ForObject(50), typeof(IMyService))); How type compatiblity is verified The type(s) against which you can register a target is dependant upon the DeclaredType of the target, but, instead of performing the compatibility checks itself, the target container uses the SupportsType method of the target being registered. Here's just a few example types and the types against which we could register them, given the correct ITarget implementation: ITarget.DeclaredType Can be registered as With Targets int object Any int int? Any int IFormattable Any string IEnumerable<char> Any MyService : IService IService Any MyService<int> : IService<int> IService<int> Any MyService<T> MyService<T> GenericConstructorTarget MyService<T> MyService<string> GenericConstructorTarget MyService<T> : IService<OtherService, T> IService<OtherService, int> GenericConstructorTarget Retrieving registrations As illustrated by earlier examples, you can interrogate the registrations in an ITargetContainer through two methods: Fetch - retrieves the last-registered target for the type FetchAll - retrieves all targets that have been registered for the type, in the order they were registered. These same methods are used by the standard container classes when determining how to resolve an instance (or instances) for a given type. Note There is currently no way to remove a registration from a ITargetContainer . Target types The different ways in which Rezolver can create/obtain objects for your application, then, are pretty much all handled through the ITarget interface, and the different implementations that are available. Whether you want to use constructor injection (via ConstructorTarget or GenericConstructorTarget ), an object you've built yourself (via ObjectTarget ), an expression tree (via ExpressionTarget ) or a factory delegate (via DelegateTarget ), or something else, there's lots of ways to get Rezolver to build the services you want to use in your application. All the targets used by default in Rezolver to create objects can be found in the Rezolver.Targets namespace. In addition to their constructors, the Target static class also contains numerous factory methods for building these targets in isolation, using an API which is similar to the registration API. For example: ForType is a shortcut for building the ConstructorTarget , which binds a type for constructor injection. In the table of contents to the left (or above if on a small screen) you'll also find high-level walkthroughs, including examples, on the most important targets you need to know about. Implementing targets You can also implement ITarget yourself if you're feeling adventurous - but you must provide a way for the container to compile your target into an ICompiledTarget that can be used at resolve-time. Documentation on how to do this will be added to this guide in the future, but if you're curious now, then the types in the Rezolver.Compilation.Expressions namespace will provide a few ideas. Short-circuited targets Rezolver containers also support short-circuited, 'direct' targets which bypass the compilation process when attempting to fulfil a Resolve operation, specifically: If the target also supports the ICompiledTarget interface, then its GetObject method will be used to get the object. If the target can be cast to the type originally requested through the Resolve method, then target will be returned as the object. The framework exploits both of these techniques to use the container as the source of its own services and configuration."
  },
  "docs/constructor-injection/generics.html": {
    "href": "docs/constructor-injection/generics.html",
    "title": "Generic Constructor Injection | Rezolver IOC Framework",
    "keywords": "Generic Constructor Injection Tip Before reading this you should read through the section on construction injection Also, generic types - especially in IOC-world - are an advanced concept that's easy to get very confused over, so if this is entirely new to you and you find you don't understand it fully, then don't worry: this isn't easy! It's probably a good idea to read the MSDN documentation about the IsGenericType property on Type for more about 'open' generics. In Rezolver, binding open generic types, such as IFoo<T> or IBar<T, U, V> , to constructors of generics, e.g. Foo<T> or Bar<T, U, V> is done via the GenericConstructorTarget type. This class knows how to map to a closed generic - i.e. Foo<IMyService> or IBar<MyService1, MyService2, MyService3> - from an open generic and then subsequently bind to the constructor of the closed version of that generic when requested from the container. 'Best-match' only for now The best-match algorithm described in the constructor injection is the only option currently available to you when using GenericConstructorTarget . Theoretically, it's possible to specify the ConstructorInfo for the constructor you want bound on the concrete generic type that Rezolver eventually decides to build for you, but we have not implemented that functionality yet. You also cannot provide named arguments to help in the best-match search - to do so would be incredibly difficult, since if the type of a constructor argument is dependant upon a type argument, then there's no way you could supply a binding for it up-front to satisfy all possible types that might be passed to it. Creating/registering GenericConstructorTarget s You can, of course, simply use the constructors to build a new instance of this target - e.g: new GenericConstructorTarget(typeof(Foo<>)) . However, the non-generic versions of the RegisterType method that we've been using elsewhere to register 'simple' types in our target containers are also generic type-aware. So, if you specify an open generic type as the implementing type, then those functions automatically create a GenericConstructorTarget for you and register it. So, container.RegisterType(typeof(MyGeneric<>)) will register MyGeneric<> for all variants of itself, and container.RegisterType(typeof(MyGeneric<>), typeof(IMyGeneric<>)) will register MyGeneric<> for all variants of IMyGeneric<> . Lets get on with some examples, the first few of which use these types: public interface IDataFormatter<TData> { string FormatData(TData data); } public class DataFormatter<TData> : IDataFormatter<TData> { public string FormatData(TData data) { return data.ToString(); } } Basic examples Direct (no base/interface) Similar to the examples for 'normal' constructor injection, we'll start by looking at registering without worrying about bases or interfaces, registering DataFormatter<> and fetching a few different closed variants of that generic: var container = new Container(); container.RegisterType(typeof(DataFormatter<>)); Assert.NotNull(container.Resolve<DataFormatter<int>>()); Assert.NotNull(container.Resolve<DataFormatter<string>>()); Assert.NotNull(container.Resolve<DataFormatter<IMyService>>()); By Interface And again, except this time we'll register and resolve against the IDataFormatter<> interface: // Same as above, just requesting via interface var container = new Container(); container.RegisterType(typeof(DataFormatter<>), typeof(IDataFormatter<>)); Assert.NotNull(container.Resolve<IDataFormatter<int>>()); Assert.NotNull(container.Resolve<IDataFormatter<string>>()); Assert.NotNull(container.Resolve<IDataFormatter<IMyService>>()); Generic Dependency This time, we have a generic type that has a dependency on another generic type whose generic argument is derived from the dependant's generic argument: public class RequiresIDataFormatter<T> { public IDataFormatter<T> Formatter { get; } public RequiresIDataFormatter(IDataFormatter<T> formatter) { Formatter = formatter; } } var container = new Container(); container.RegisterType(typeof(RequiresIDataFormatter<>)); container.RegisterType(typeof(DataFormatter<>), typeof(IDataFormatter<>)); Assert.NotNull(container.Resolve<RequiresIDataFormatter<int>>().Formatter); Assert.NotNull(container.Resolve<RequiresIDataFormatter<string>>().Formatter); Assert.NotNull(container.Resolve<RequiresIDataFormatter<IMyService>>().Formatter); Advanced - Complex Hierarchies The previous examples showed how we can resolve an instance when the type requested is simply a closed version of the open generic against which we registered a target; or when it's a direct base or interface of it. Naturally, real-world type hierarchies do not always work like that - and sometimes you'll want to implement a type where the implementation is perhaps more 'distant', in inheritance terms, from the base or interface. With generics, this can get particularly complicated as the type parameters do not always remain consistent - consider the following hierarchy: //these types are just used as easy-to-read type arguments public class T1 { } public class T2 { } public class T3 { } public class BaseGeneric<T, U, V> { } public class MidGeneric<T, U, V> : BaseGeneric<V, U, T> { } public class FinalGeneric<T, U, V> : MidGeneric<U, T, V> { } // This type 'closes' over one type parameter public class ClosingGeneric<T, U> : FinalGeneric<T, U, string> { } Notice how on the three first generic types, the order of the type arguments is changing as we move through BaseGeneric<,,> , MidGeneric<,,> and FinalGeneric<,,> . The last generic actually fixes one of the type parameters passed to FinalGeneric<,,> - which introduces a different problem for our container, which we'll get to after looking at the others. We apologise in advance for the complexity of this argument jumbling - but we accept no liability for any headaches you suffer! Base of a Base with Jumbled Args So, yes - this is a deeply contrived example, but it's worth seeing: var container = new Container(); container.RegisterType(typeof(FinalGeneric<,,>), typeof(BaseGeneric<,,>)); // Type arguments should be transformed as follows: // - BaseGeneric<T1, T2, T3> is a base of // - MidGeneric<T3, T2, T1>, which is a base of // - FinalGeneric<T2, T3, T1> // Which is what the container should give us var result = Assert.IsType<FinalGeneric<T2, T3, T1>>( container.Resolve<BaseGeneric<T1, T2, T3>>() ); In order to do this, the container must walk the inheritance chain of the DeclaredType of the GenericConstructorTarget to create a map of the type arguments which must be fed to FinalGeneric<,,> in order to create an instance of BaseGeneric<,,> . Partially Closed Generic Note The term 'Partially Closed' is a term only used here - it merely describes a generic type where some of the type arguments supplied to a generic type's parameters are concrete types. Now we take a look at the ClosingGeneric<T, U> type - it's here we start getting into one of the murkier areas of generic types in Rezolver and, indeed, in general. In this case, we now have a type which can only ever be used to implement a subset of all the possible variants of BaseGeneric<T, U, V> , because, whatever its own T and U arguments are, its base will always be BaseGeneric<string, T, U> . Rezolver is happy to work with this, as the next test shows: var container = new Container(); container.RegisterType(typeof(ClosingGeneric<,>), typeof(BaseGeneric<,,>)); var result = Assert.IsType<ClosingGeneric<T2, T3>>( container.Resolve<BaseGeneric<string, T2, T3>>() ); Note If we were to try to resolve BaseGeneric<T1, T2, T3> as we did before, then the container will correctly tell us that it cannot - and that the registered target is not compatible with that type. Which leads us on to our problem... The problem with partially closed generics With our container configured as above, it is now impossible to resolve BaseGeneric<T1, T2, T3> because the only implementation we have for BaseGeneric<,,> is one where the first type argument must be string . If we were to register another, more general, type for BaseGeneric<,,> it would overwrite our specialised version, wiping it out. It's also impossible for us to specify the type BaseGeneric<string,,> either in a typeof , or via the MakeGenericType API, so we're stuck. We're working on it! This is a limitation of Rezolver right now, but there are plans to implement partially specialised registrations, so that the container would, when ClosingGeneric<T, U> is registered, realise that it should only be used if the first type parameter on BaseGeneric<,,> is string . This would then allow the container to accept a more general registration against BaseGeneric<,,> to be registered side-by-side and used for all other variants of BaseGeneric<,,> . Implementation of this feature would also simplify the scenarios covered in the next section. Advanced - Nested Generics Rezolver also supports generics where type arguments are passed to an interface or base nested within other generics - take these types: public interface IGenericService<T> { } public class GenericEnumerableService<T> : IGenericService<IEnumerable<T>> { } public class GenericEnumerableNullableService<T> : IGenericService<IEnumerable<Nullable<T>>> where T : struct { } Singly nested generic argument var container = new Container(); container.RegisterType( typeof(GenericEnumerableService<>), typeof(IGenericService<>).MakeGenericType(typeof(IEnumerable<>)) ); var result = Assert.IsType<GenericEnumerableService<string>>( container.Resolve<IGenericService<IEnumerable<string>>>() ); Note As with our ClosingGeneric<,> from before, we could perform this registration against IGenericService<> , but if we do, then we wipe out the possibility of being able to register other services - so, we register against IGenericService<IEnumerable<>> , which requires some MakeGenericType jiggery pokery. When we've got partially closed generics working, you will be able to register against IGenericService<> . Doubly nested generic argument Rezolver doesn't care how far it has to go to work out how a type argument on a base is nested from the implementing type: var container = new Container(); // Even more .MakeGenericType jiggery pokery required here container.RegisterType( typeof(GenericEnumerableNullableService<>), typeof(IGenericService<>).MakeGenericType( typeof(IEnumerable<>).MakeGenericType( typeof(Nullable<>) ) ) ); var result = Assert.IsType<GenericEnumerableNullableService<int>>( container.Resolve<IGenericService<IEnumerable<Nullable<int>>>>() ); Using Member Bindings The same techniques that are shown in our member binding documentation also work for generic types - if you supply an IMemberBindingBehaviour to the GenericConstructorTarget when it is created (either by the constructors or the aforementioned factory methods), then that behaviour will be used when the constructor is bound. Refer to the topic for detailed examples on how to use member binding. Next Steps Assuming you've read the previous topics on constructor injection and member binding , then that's it for constructor injection for now. Note A separate topic will be added in the future regarding Generic Specialisation in the container, but that covers all target types, not just the GenericConstructorTarget - so that will go elsewhere. Feel free to explore the table of contents or head back to the main service registration overview to explore more features of Rezolver."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "Rezolver API reference | Rezolver IOC Framework",
    "keywords": "Rezolver API reference Looking for documentation on individual classes or methods in the Rezolver project? You've come to the right place! Crucial types to look at are: TargetContainer (implements ITargetContainer ): Stores ITarget instances, and is the main class you'll use for your 'registration' phase. Container (implements IContainer ): The standard, non-scoped, container you'll use in your composition root - you can create child scopes from this by calling its implementation of CreateScope() , which returns instances of IContainerScope . This class uses an ITargetContainer for its registrations, which you can supply construction if required. ScopedContainer - A disposable IContainer that also acts as a 'root' scope."
  },
  "docs/constructor-injection/member-binding.html": {
    "href": "docs/constructor-injection/member-binding.html",
    "title": "Member Injection | Rezolver IOC Framework",
    "keywords": "Member Injection When executing a type's constructor you also have the option to inject services into the new instance's properties and/or fields. So - the equivalent of: var service = new ServiceWithFields() { Property = foo, Field = bar } This is all done via implementations of the IMemberBindingBehaviour interface - of which there is currently one implementation - DefaultMemberBindingBehaviour . Almost all of the ways in which you can create ConstructorTarget (factory methods, registration methods, constructors etc) will also accept a IMemberBindingBehaviour with which to enable member injection if you want to. Warning DefaultMemberBindingBehaviour will be renamed to AllMembersBindingBehaviour in 1.2, and might also go into a child namespace - e.g. Rezolver.MemberBindingBehaviours . DefaultMemberBindingBehaviour automatically binds all publicly writeable properties and fields on the type being constructed with values from the container when resolved - regardless of whether the required services exist in the container. Example - Injecting all members Given this type: public class Has2InjectableMembers { public MyService1 Service1 { get; set; } public MyService2 Service2 { get; set; } } We simply setup the container to build all three types and make sure to pass the binding behaviour when registering the Has2InjectableMembers target: var container = new Container(); container.RegisterAll( Target.ForType<MyService1>(), Target.ForType<MyService2>() ); container.RegisterType<Has2InjectableMembers>(DefaultMemberBindingBehaviour.Instance); var result = container.Resolve<Has2InjectableMembers>(); Assert.NotNull(result.Service1); Assert.NotNull(result.Service2); Warning As intimated above, when using this behaviour, if one of the services required by any of the writable properties or fields is missing, then the resolve operation will fail. The behaviour is deliberately primitive - because unlike with constructors, where it's reasonable to assume all parameters are to be injected, there are no simple rules that can always applied to an object to determine which properties and/or fields should be auto-injected. It's likely that two extra 'default' behaviours - PropertiesOnlyBindingBehaviour and FieldsOnlyBindingBehaviour , which will only bind publicly writeable properties or public fields, respectively - will be added to the framework in 1.2 Example - Custom binding behaviour If you find you need more control over which properties and/or fields you want bound on an instance, then you can, of course, implement your own binding behaviour. A popular implementation of member injection in some IOC containers is to use an attribute on the properties/fields which should be injected. This is, of course, not something that Rezolver supports out of the box - however it's a trivial thing to implement yourself, and that's what this example does. We will: Add a new attribute InjectAttribute which we will use to mark the properties that we want injected Implement a custom IMemberBindingBehaviour ( AttributeBindingBehaviour ) to bind only properties which have this attribute applied Decorate one or more members on a type with the InjectAttribute Pass the new AttributeBindingBehaviour when we register the type, or create the ConstructorTarget First, the InjectAttribute : [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false, Inherited = false)] public class InjectAttribute : Attribute { /// <summary> /// Gets or sets the type to be resolved. /// from the container for the associated member. /// /// If null, then the member's type will be used. /// /// If not null, then, obviously, it must be compatible! /// </summary> public Type Type { get; } public InjectAttribute(Type type = null) { Type = type; } } Then our type which uses it: public class HasAttributeInjectedMembers { [Inject] public IMyService InjectedServiceField; [Inject(typeof(MyService6))] public IMyService InjectedServiceProp { get; set; } //these two will not be injeccted public IMyService ServiceField; public IMyService ServiceProp { get; set; } } Finally, our binding behaviour - which extends the aforementioned DefaultMemberBindingBehaviour as that class has plenty of extension points: /// <summary> /// Class AttributeBindingBehaviour - we reuse the DefaultMemberBindingBehaviour class /// because it has numerous virtual hooks we can use to customise behaviour, and takes care /// of reflecting the target type for us. /// </summary> /// <seealso cref=\"Rezolver.DefaultMemberBindingBehaviour\" /> public class AttributeBindingBehaviour : DefaultMemberBindingBehaviour { protected override IEnumerable<FieldInfo> GetBindableFields(ICompileContext context, Type type) { //filter the fields to those which have an InjectAttribute defined return base.GetBindableFields(context, type) .Where(f => f.IsDefined(typeof(InjectAttribute))); } protected override IEnumerable<PropertyInfo> GetBindableProperties(ICompileContext context, Type type) { return base.GetBindableProperties(context, type) .Where(f => f.IsDefined(typeof(InjectAttribute))); } protected override MemberBinding CreateBinding(ICompileContext context, Type type, FieldInfo field) { //the base method merely creates a new MemberBinding, bound to a new ResolvedTarget //whose type is set to the field type. //This is similar except we read the InjectAttribute's ResolveType, and use that //type if it's not null. var attr = field.GetCustomAttribute<InjectAttribute>(); return new MemberBinding(field, new ResolvedTarget(attr.Type ?? field.FieldType)); } protected override MemberBinding CreateBinding(ICompileContext context, Type type, PropertyInfo prop) { //identical to above var attr = prop.GetCustomAttribute<InjectAttribute>(); return new MemberBinding(prop, new ResolvedTarget(attr.Type ?? prop.PropertyType)); } } With that in place, we can then test: var container = new Container(); // register the type which uses the attributes, passing our custom binding behaviour container.RegisterType<HasAttributeInjectedMembers>(new AttributeBindingBehaviour()); // The first injected field will request an IMyService container.RegisterType<MyService1, IMyService>(); // The second requests an MyService6 by way of the type override on the attribute container.RegisterType<MyService6>(); var result = container.Resolve<HasAttributeInjectedMembers>(); Assert.IsType<MyService1>(result.InjectedServiceField); Assert.IsType<MyService6>(result.InjectedServiceProp); Assert.Null(result.ServiceField); Assert.Null(result.ServiceProp); Hopefully this example will inspire you to create your own custom binding behaviour :) Next steps Head back to the Constructor topic Or, see how constructor injection works with generic types"
  },
  "docs/lifetimes/container-scopes.html": {
    "href": "docs/lifetimes/container-scopes.html",
    "title": "Markdown File | Rezolver IOC Framework",
    "keywords": "Markdown File"
  },
  "api/Rezolver.Targets.ObjectTarget.html": {
    "href": "api/Rezolver.Targets.ObjectTarget.html",
    "title": "Class ObjectTarget | Rezolver IOC Framework",
    "keywords": "Class ObjectTarget Implements ITarget by wrapping a single instance that's already been constructed by application code. Inheritance Object TargetBase ObjectTarget Inherited Members TargetBase.UseFallback TargetBase.SupportsType(Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Targets Assembly :rezolver-docfx.dll Syntax public class ObjectTarget : TargetBase, ITarget, ICompiledTarget Constructors | Improve this Doc View Source ObjectTarget(Object, Type, ScopeBehaviour) Creates a new instance of the ObjectTarget class. Declaration public ObjectTarget(object obj, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description Object obj The object to be returned by this target when resolved. Type declaredType Optional. The declared type of this target, if different from the absolute type of the obj ScopeBehaviour scopeBehaviour Optional. If you want the object to be disposed by Rezolver when the root scope is disposed, then specify a behaviour other than the default. Note - the only real behaviour that makes sense for this is Explicit , since the Implicit behaviour will typically fool a scope that multiple instances are being created and, therefore, the object will be tracked multiple times by that scope. Remarks Please note - if you enable scope tracking, but the object is never resolved, then the object will not be disposed and you will need to ensure you dispose of it. Properties | Improve this Doc View Source DeclaredType Gets the declared type of object that is returned by this target. Might be different from the type of Value if explicitly defined when this target was constructed. Declaration public override Type DeclaredType { get; } Property Value Type Description Type The type of the declared. Overrides TargetBase.DeclaredType | Improve this Doc View Source ScopeBehaviour Gets the scope behaviour. Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour | Improve this Doc View Source Value Gets the value that will be exposed by expressions built by this instance. Declaration public object Value { get; } Property Value Type Description Object The value. Methods | Improve this Doc View Source SelectScope(ResolveContext) Selects the scopem in which instance should be tracked for disposal. Declaration public override IContainerScope SelectScope(ResolveContext context) Parameters Type Name Description ResolveContext context The context. Returns Type Description IContainerScope Overrides TargetBase.SelectScope(ResolveContext) Explicit Interface Implementations | Improve this Doc View Source ICompiledTarget.GetObject(ResolveContext) Declaration object ICompiledTarget.GetObject(ResolveContext context) Parameters Type Name Description ResolveContext context Returns Type Description Object Implements ICompiledTarget.GetObject(ResolveContext) Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.CachingContainerBase.html": {
    "href": "api/Rezolver.CachingContainerBase.html",
    "title": "Class CachingContainerBase | Rezolver IOC Framework",
    "keywords": "Class CachingContainerBase Builds on the ContainerBase base class to introduce thread-safe caching of compiled targets so they are only compiled once per requested type. Only creatable through inheritance. Inheritance Object ContainerBase CachingContainerBase Container Inherited Members ContainerBase.NoChangeCompilerConfiguration ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Targets ContainerBase.Resolve(ResolveContext) ContainerBase.TryResolve(ResolveContext, Object) ContainerBase.CreateScope() ContainerBase.FetchCompiled(ResolveContext) ContainerBase.CanResolve(ResolveContext) ContainerBase.GetFallbackCompiledRezolveTarget(ResolveContext) ContainerBase.IServiceProvider.GetService(Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) ContainerBase.ITargetContainer.Fetch(Type) ContainerBase.ITargetContainer.FetchAll(Type) ContainerBase.ITargetContainer.CombineWith(ITargetContainer, Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class CachingContainerBase : ContainerBase, IContainer, IServiceProvider, IScopeFactory, ITargetContainer Remarks Internally, the class uses a ConcurrentDictionary<TKey, TValue> to store ICompiledTarget s keyed by the requested type. All the main IContainer implementations used directly in an application should ideally inherit from this class, because otherwise every Resolve(ResolveContext) operation would require a compilation phase before the object could be returned, which would be incredibly slow. It's because of this caching that registering new targets in any ITargetContainer used by this class is not recommended: because after the first request for a particular type is made, the resultant ICompiledTarget is fixed until the container is thrown away. Constructors | Improve this Doc View Source CachingContainerBase(ITargetContainer, ICompilerConfigurationProvider) Initializes a new instance of the CachingContainerBase class. Declaration protected CachingContainerBase(ITargetContainer targets = null, ICompilerConfigurationProvider compilerConfig = null) Parameters Type Name Description ITargetContainer targets Optional. Contains the targets that will be used to create the ICompiledTarget s that this container will use to produce objects when requested. If not provided, then the base class' default (see ContainerBase(ITargetContainer, ICompilerConfigurationProvider) ) will be used. ICompilerConfigurationProvider compilerConfig Optional. An object which will be used to configure this container and its targets to use a specific compilation strategy. If null , then the DefaultProvider provider will be used. Methods | Improve this Doc View Source GetCompiledRezolveTarget(ResolveContext) Obtains an ICompiledTarget for the given context . Declaration protected override ICompiledTarget GetCompiledRezolveTarget(ResolveContext context) Parameters Type Name Description ResolveContext context Returns Type Description ICompiledTarget Overrides ContainerBase.GetCompiledRezolveTarget(ResolveContext) Remarks The method is called by Resolve(ResolveContext) to get the compiled target whose GetObject(ResolveContext) method is to be used to get the instance that is to be resolved for a given request. The internal cache is examined first to see if an entry exists for the RequestedType type and, if not, then the result of the base class' GetCompiledRezolveTarget(ResolveContext) is cached and returned. Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionCompiler.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionCompiler.html",
    "title": "Class ExpressionCompiler | Rezolver IOC Framework",
    "keywords": "Class ExpressionCompiler Implementation of the ITargetCompiler interface which produces ICompiledTarget objects by building and compiling expression trees from the ITarget objects which are registered. Inheritance Object ExpressionCompiler Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class ExpressionCompiler : IExpressionCompiler, ITargetCompiler, ICompileContextProvider Remarks This compiler is automatically configured as the default for all containers because the ConfigProvider from this class is set as the DefaultProvider . This class works by directly resolving IExpressionBuilder instances which can build an expression for a given ITarget from the IExpressionCompileContext . Typically, this is done by searching for an IExpressionBuilder<TTarget> where 'TTarget' is equal to the runtime type of the target - e.g. ConstructorTarget . If one cannot be found, it will then search for an IExpressionBuilder whose CanBuild(ITarget, IExpressionCompileContext) function returns true for the given target. With a correctly configured target dictionary (using the ConfigProvider which, as mentioned previously, is used by default if no configuration provider is explicitly passed to the constructor of one of the ContainerBase deriving types) this should resolve to an instance of the ConstructorTargetBuilder class, which implements IExpressionBuilder<ConstructorTarget> . As such, the compiler can be extended to support extra target types and its existing expression builders can be replaced for customised behaviour because they are all resolved from the ITargetContainer underpinning a particular CompileContext . There is a caveat for this, however: you cannot use the traditional targets ( ConstructorTarget etc) to extend the compiler because they need to be compiled in order to work - which would cause an infinite recursion. Therefore, the targets which are registered as expression builders must directly implement either the IExpressionBuilder<TTarget> or IExpressionBuilder interfaces; or implement the ICompiledTarget interface and produce an instance of those interfaces when GetObject(ResolveContext) is called on them. Because of this requirement, the most common way to register an expression builder is to register an instance inside an ObjectTarget against the correct type, because that class does implement ICompiledTarget in addition to ITarget . Using this pattern, it's important that an expression builder is completely threadsafe and recursion safe (since one target's compilation might depend on the compilation of another of the same type). Under the default configuration, if you want to get hold of this compiler then you should request the type IExpressionCompiler from the current compilation context, or from your target container. Properties | Improve this Doc View Source ConfigProvider Gets the default expression compiler configuration provider which is also set, by default, into the DefaultProvider property. Declaration public static ExpressionCompilerConfigurationProvider ConfigProvider { get; } Property Value Type Description ExpressionCompilerConfigurationProvider | Improve this Doc View Source Default Gets the default expression compiler which is registered by the ConfigProvider by default. Declaration public static ExpressionCompiler Default { get; } Property Value Type Description ExpressionCompiler Methods | Improve this Doc View Source Build(ITarget, IExpressionCompileContext) Called to build an expression for the specified target for the given IExpressionCompileContext - implementation of the Build(ITarget, IExpressionCompileContext) method. Declaration public Expression Build(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target for which an expression is to be built IExpressionCompileContext context The compilation context. Returns Type Description Expression Implements IExpressionCompiler.Build(ITarget, IExpressionCompileContext) Remarks This implementation attempts to resolve an IExpressionBuilder<TTarget> (with TTarget\" equal to the runtime type of the target ) or IExpressionBuilder whose CanBuild(ITarget, IExpressionCompileContext) function returns true for the given target and context. If that lookup fails, then an ArgumentException is raised. If the lookup succeeds, then the builder's Build(ITarget, IExpressionCompileContext, IExpressionCompiler) function is called, and the expression it produces is returned. Exceptions Type Condition ArgumentException If the compiler is unable to resolve an IExpressionBuilder from the context for the target | Improve this Doc View Source BuildCompiledTargetForLambda(Expression<Func<ResolveContext, Object>>) Creates an ICompiledTarget from the finalised lambda expression which was previously built for a target. Declaration protected virtual ICompiledTarget BuildCompiledTargetForLambda(Expression<Func<ResolveContext, object>> lambda) Parameters Type Name Description Expression < Func < ResolveContext , Object >> lambda The lambda expression representing the code to be executed in order to get the underlying object which will be resolved. Typically, this is fed directly from the BuildResolveLambda(Expression, IExpressionCompileContext) implementation. Returns Type Description ICompiledTarget | Improve this Doc View Source BuildResolveLambda(Expression, IExpressionCompileContext) Takes the unoptimised expression built for a target and optimises it and turns it into a lambda expression ready to be compiled into an ICompiledTarget . Declaration public virtual Expression<Func<ResolveContext, object>> BuildResolveLambda(Expression expression, IExpressionCompileContext context) Parameters Type Name Description Expression expression The expression. IExpressionCompileContext context The context. Returns Type Description Expression < Func < ResolveContext , Object >> Implements IExpressionCompiler.BuildResolveLambda(Expression, IExpressionCompileContext) | Improve this Doc View Source CompileTarget(ITarget, ICompileContext) Create the ICompiledTarget for the given target using the context to inform the type of object that is to be built, and for compile-time dependency resolution. Declaration public ICompiledTarget CompileTarget(ITarget target, ICompileContext context) Parameters Type Name Description ITarget target Required. The target to be compiled. ICompileContext context Required. The current compilation context. Returns Type Description ICompiledTarget Implements ITargetCompiler.CompileTarget(ITarget, ICompileContext) Exceptions Type Condition ArgumentException context must be an instance of IExpressionCompileContext | Improve this Doc View Source CreateContext(ResolveContext, ITargetContainer, IContainer) Implementation of CreateContext(ResolveContext, ITargetContainer, IContainer) Declaration public ICompileContext CreateContext(ResolveContext resolveContext, ITargetContainer targets, IContainer containerOverride = null) Parameters Type Name Description ResolveContext resolveContext ITargetContainer targets IContainer containerOverride Returns Type Description ICompileContext Implements ICompileContextProvider.CreateContext(ResolveContext, ITargetContainer, IContainer) | Improve this Doc View Source ResolveBuilder(ITarget, IExpressionCompileContext) Resolves an expression builder that can build the given target for the given compile context. Or Returns null if no builder can be found. Declaration public virtual IExpressionBuilder ResolveBuilder(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context The context. Returns Type Description IExpressionBuilder Remarks The function builds a list of all the types in the hierarchy represented by the type of the target and, for each of those types which are compatible with ITarget , it looks for an IExpressionBuilder<TTarget> which is specialised for that type. If no compatible builder is found, then it attempts to find a general purpose IExpressionBuilder which can build the type. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) ExpressionCompilerBuildExtensions.BuildResolveLambda(IExpressionCompiler, ITarget, IExpressionCompileContext) See Also IExpressionCompiler ITargetCompiler"
  },
  "api/Rezolver.Compilation.Expressions.IExpressionBuilder-1.html": {
    "href": "api/Rezolver.Compilation.Expressions.IExpressionBuilder-1.html",
    "title": "Interface IExpressionBuilder<TTarget> | Rezolver IOC Framework",
    "keywords": "Interface IExpressionBuilder<TTarget> Interface for an object that produces expressions from instances of TTarget . This is a generic extension to the IExpressionBuilder interface. Inherited Members IExpressionBuilder.CanBuild(ITarget, IExpressionCompileContext) IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public interface IExpressionBuilder<in TTarget> : IExpressionBuilder where TTarget : ITarget Type Parameters Name Description TTarget The type of the target. Methods | Improve this Doc View Source Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target. Declaration Expression Build(TTarget target, IExpressionCompileContext context, IExpressionCompiler compiler = null) Parameters Type Name Description TTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the builder should attempt to fetch the compiler from the context; or throw an exception if it is required but not provided and cannot be resolved fromm the context. Returns Type Description Expression Remarks When invoked by the ExpressionCompiler class, the compiler parameter will always be provided. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also IExpressionBuilder"
  },
  "api/Rezolver.Compilation.Expressions.OptionalParameterTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.OptionalParameterTargetBuilder.html",
    "title": "Class OptionalParameterTargetBuilder | Rezolver IOC Framework",
    "keywords": "Class OptionalParameterTargetBuilder An IExpressionBuilder specialised for building an expression for the OptionalParameterTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < OptionalParameterTarget > OptionalParameterTargetBuilder Inherited Members ExpressionBuilderBase<OptionalParameterTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<OptionalParameterTarget>.IExpressionBuilder<OptionalParameterTarget>.Build(OptionalParameterTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<OptionalParameterTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class OptionalParameterTargetBuilder : ExpressionBuilderBase<OptionalParameterTarget>, IExpressionBuilder<OptionalParameterTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(OptionalParameterTarget, IExpressionCompileContext, IExpressionCompiler) Always returns a which contains the Value . Declaration protected override Expression Build(OptionalParameterTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description OptionalParameterTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.OptionalParameterTarget>.Build(Rezolver.Targets.OptionalParameterTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.ICompileContextProvider.html": {
    "href": "api/Rezolver.Compilation.ICompileContextProvider.html",
    "title": "Interface ICompileContextProvider | Rezolver IOC Framework",
    "keywords": "Interface ICompileContextProvider Interface for an object which creates ICompileContext instances for when the system needs to compile an ITarget into an ICompiledTarget . Namespace :Rezolver.Compilation Assembly :rezolver-docfx.dll Syntax public interface ICompileContextProvider Remarks In normal operation, this interface is closely related to the ITargetCompiler interface because the core ContainerBase class (which provides most of the default implementation for IContainer ) obtains a new ICompileContext by resolving an instance of this interface, and calling the CreateContext(ResolveContext, ITargetContainer, IContainer) method, passing the result to the CompileTarget(ITarget, ICompileContext) method, along with the target to be compiled. Frequently, implementations of ITargetCompiler will also implement this interface to ensure that the compilation context contains everything the compiler needs to do its work. Methods | Improve this Doc View Source CreateContext(ResolveContext, ITargetContainer, IContainer) Creates a compilation context for the given resolveContext - which is used to determine the RequestedType that the eventual ICompiledTarget should return. Declaration ICompileContext CreateContext(ResolveContext resolveContext, ITargetContainer targets, IContainer containerOverride = null) Parameters Type Name Description ResolveContext resolveContext The resolve context - used to get the RequestedType and the Container (if containerOverride is not provided). ITargetContainer targets The target container that should be used to lookup other non-compiled targets. IContainer containerOverride The container requesting the new compilation context, if different from the Container on the resolveContext Returns Type Description ICompileContext Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ContainerBase.DirectResolveCompiledTarget.html": {
    "href": "api/Rezolver.ContainerBase.DirectResolveCompiledTarget.html",
    "title": "Class ContainerBase.DirectResolveCompiledTarget | Rezolver IOC Framework",
    "keywords": "Class ContainerBase.DirectResolveCompiledTarget Used when an ITarget is also of the same type as the one for which it is returned by the Fetch(Type) method of the Targets container. In this case, the target is not compiled, but instead is simply returned as the desired object. Inheritance Object ContainerBase.DirectResolveCompiledTarget Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax protected class DirectResolveCompiledTarget : ICompiledTarget Constructors | Improve this Doc View Source DirectResolveCompiledTarget(ITarget) Constructs a new instance of the ContainerBase.DirectResolveCompiledTarget Declaration public DirectResolveCompiledTarget(ITarget target) Parameters Type Name Description ITarget target Methods | Improve this Doc View Source GetObject(ResolveContext) Implementation of GetObject(ResolveContext) - simply returns the target with which this instance was constructed. Declaration public object GetObject(ResolveContext context) Parameters Type Name Description ResolveContext context ignored Returns Type Description Object Implements ICompiledTarget.GetObject(ResolveContext) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.DecoratorTargetContainerExtensions.html": {
    "href": "api/Rezolver.DecoratorTargetContainerExtensions.html",
    "title": "Class DecoratorTargetContainerExtensions | Rezolver IOC Framework",
    "keywords": "Class DecoratorTargetContainerExtensions Extensions for ITargetContainerOwner which simplify the registration of decorators (via the DecoratingTargetContainer pseudo-target) Inheritance Object DecoratorTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public static class DecoratorTargetContainerExtensions Remarks Note: The decoration functionality provided by the framework is only possible on ITargetContainer implementations which also implement the ITargetContainerOwner interface. All the main target container types you'll use in your application ( TargetContainer and ChildTargetContainer ) do support this interface. Methods | Improve this Doc View Source RegisterDecorator(ITargetContainerOwner, Type, Type) Registers a decorator container which will cause all instances of decoratedType to be decorated with the type decoratorType . Any existing registrations for decoratedType will be decorated correctly, and subsequent registrations of decoratedType will also be decorated as expected. Declaration public static void RegisterDecorator(this ITargetContainerOwner targetContainerOwner, Type decoratorType, Type decoratedType) Parameters Type Name Description ITargetContainerOwner targetContainerOwner The container into which the decorator will be registered. Type decoratorType The type to be used as the decorator implementation Type decoratedType The type which will be decorated by decoratorType . | Improve this Doc View Source RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) Registers a decorator container which will cause all instances of TDecorated to be decorated with the type TDecorator . Any existing registrations for TDecorated will be decorated correctly, and subsequent registrations of TDecorated will also be decorated as expected. Declaration public static void RegisterDecorator<TDecorator, TDecorated>(this ITargetContainerOwner targetContainerOwner) Parameters Type Name Description ITargetContainerOwner targetContainerOwner The container into which the decorator will be registered. Type Parameters Name Description TDecorator The type to be used as the decorator implementation TDecorated The type which will be decorated by TDecorator ."
  },
  "api/Rezolver.IChildTargetContainer.html": {
    "href": "api/Rezolver.IChildTargetContainer.html",
    "title": "Interface IChildTargetContainer | Rezolver IOC Framework",
    "keywords": "Interface IChildTargetContainer An ITargetContainer that inherits all registrations from a ( Parent ) target container. If it cannot resolve a target for a particular type, will defer to its parent for fallback. Inherited Members ITargetContainer.Register(ITarget, Type) ITargetContainer.Fetch(Type) ITargetContainer.FetchAll(Type) ITargetContainer.CombineWith(ITargetContainer, Type) Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public interface IChildTargetContainer : ITargetContainer Remarks Note that the framework does not require that enumerables of targets (retrieved by calling FetchAll(Type) are merged between a child and parent container. Typically, as soon as one registration exists in a child container for the same type as in the parent, it overrides all registrations in the parent for that same type. Properties | Improve this Doc View Source Parent Gets the parent target container. Declaration ITargetContainer Parent { get; } Property Value Type Description ITargetContainer The parent. Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also ITargetContainer"
  },
  "api/Rezolver.MemberBinding.html": {
    "href": "api/Rezolver.MemberBinding.html",
    "title": "Class MemberBinding | Rezolver IOC Framework",
    "keywords": "Class MemberBinding Represents the binding of an ITarget to a property or field of a given type. Not to be confused with the type of the same name from the System.Linq.Expressions namespace, although they are technically equivalent. Inheritance Object MemberBinding Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class MemberBinding Remarks You typically don't create this type directly - instead, other targets such as ConstructorTarget will create it as needed through the use of an IMemberBindingBehaviour object. Constructors | Improve this Doc View Source MemberBinding(MemberInfo, ITarget) Initializes a new instance of the MemberBinding class. Declaration public MemberBinding(MemberInfo member, ITarget target) Parameters Type Name Description MemberInfo member The member to be bound. ITarget target The target whose value will be written to the member. Fields | Improve this Doc View Source None Empty bindings. Declaration public static readonly MemberBinding[] None Field Value Type Description MemberBinding [] Properties | Improve this Doc View Source Member Gets the member against which this binding is to be applied. Declaration public MemberInfo Member { get; } Property Value Type Description MemberInfo The member. | Improve this Doc View Source MemberType Gets the type of the Member . E.g. if the member represents a String property on the declaring type, then this will return the String type. If the member represents an integer field, this it will return the Int32 type. Declaration public Type MemberType { get; } Property Value Type Description Type The type of the member. | Improve this Doc View Source Target Gets the target whose value when resolved will be written to the Member Declaration public ITarget Target { get; } Property Value Type Description ITarget The target. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.MethodBinding.html": {
    "href": "api/Rezolver.MethodBinding.html",
    "title": "Class MethodBinding | Rezolver IOC Framework",
    "keywords": "Class MethodBinding Represents a binding to a method whose arguments will be supplied by ITarget instances. Inheritance Object MethodBinding ConstructorBinding Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class MethodBinding Constructors | Improve this Doc View Source MethodBinding(MethodBase, ParameterBinding[]) Initializes a new instance of the MethodBinding class. Declaration public MethodBinding(MethodBase method, ParameterBinding[] boundArgs = null) Parameters Type Name Description MethodBase method The method. ParameterBinding [] boundArgs Optional. The bound arguments. Can be null or empty. Properties | Improve this Doc View Source BoundArguments Gets the argument bindings for the method call. Never null but can be empty. Declaration public ParameterBinding[] BoundArguments { get; } Property Value Type Description ParameterBinding [] The bound arguments. | Improve this Doc View Source Method Gets the method to be invoked. Declaration public MethodBase Method { get; } Property Value Type Description MethodBase The method. Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "docs/benchmarks.html": {
    "href": "docs/benchmarks.html",
    "title": "Rezolver Benchmarks | Rezolver IOC Framework",
    "keywords": "Rezolver Benchmarks Benchmarking an IOC container obviously has pitfalls. In a web environment, for example, it's highly unlikely you'll hit the kind of traffic levels required for your choice of container to have a noticeable impact on speed. But, that said, speed is still important - especially with something as fundamental as an object which is taking control of how you create your objects! In any case, if you're reading this then you're a developer - which means you're probably interested in how fast Rezolver stacks up against your previous favourite container ;) Methodology Over on GitHub Daniel Palme has, for a while now, been maintaining a benchmarking suite for IOC containers - called IOCPerformance . In addition to our own performance analysis, this program offers an easy way to stress test the Rezolver containers both on their own, but also against other popular containers. The tests include singletons, transients, objects which require a mixture of these, complex objects which require lots of nested dependencies, resolving enumerables and child containers, and does provide a reasonably thorough examination of a container's features in addition to its performance. Excluding Rezolver and the 'No' container, which the baseline, there are 31 containers now being stress-tested by this application, with the list growing. So, we forked this project and added an adapter for Rezolver. We then ran it on an Intel(R) Xeon(R) CPU E3-1230 v3 @ 3.30GHz (power management options set to 'maximum performance' to ensure the processor runs at its maximum clock). Results Note A couple of results which you'll find on the IOCPerformance page are left out of the individual results because Rezolver doesn't yet support them (specifically Interception and Conditional services) - implementations for these are planned. Singleton Singleton service via SingletonTarget Transient Transient service using ConstructorTarget Combined Singleton and transient mixed together. Complex Deep dependency graph, mix of transient and singleton Properties Constructor injection with property injection - ConstructorTarget in conjunction with an IMemberBindingBehaviour Generics Using GenericConstructorTarget to register Foo<> and then request instances of Foo<Bar> , Foo<Baz> , Foo<Bat> etc. Enumerable Registering multiple services for T and then resolving an IEnumerable<T> Child Containers Create a new container from an existing one, register new services in it and resolve. Note The poor performance of Rezolver here is caused by the fact that there's an overhead on the first Resolve call to a container, as that's when it compiles the associated ICompiledTarget for that service. Because of the way this benchmark is performed, it means that Rezolver spends most of its time dynamically compiling delegates. A solution is in the pipeline for this, which will be implemented once we've implemented another compiler that's based entirely on reflection and late-bound delegates instead of dynamically constructed expression trees. When this is done and merged with the current expression-tree based compiler, the performance of child containers will improve drastically. Registering/Preparing the Container Creating a container, registering services and optionally 'baking' the container (not required by Rezolver). Registering/Preparing the Container (+ Resolve) Same as above, except a resolve operation is then subsequently fired at the container. Again, Rezolver suffers for the same reason as with the child containers. When performance for that has been improved, then this one will also. 'Advanced' compound results All the so-called 'advanced' operations' times summed and graphed (note - if a container doesn't even support a particular feature, then there's a good chance it'll be higher up these graphs). Fastest Slowest Notes Rezolver doesn't make it into the 'Fast' graph purely because of the aforementioned first-call overhead when resolving a service of a given type for the very first time. This will change. 'Basic' compound results All the so-called 'basic' operations' times summed and graphed (again - if a container doesn't even support a particular feature, then it'll be higher up these graphs). Fastest Slowest Notes Top 10 for Rezolver! Register/Prepare (+ Resolve operation) Fasters Slowest"
  },
  "docs/create-and-use-a-container.html": {
    "href": "docs/create-and-use-a-container.html",
    "title": "Creating and using a container | Rezolver IOC Framework",
    "keywords": "Creating and using a container Using Rezolver is the same as with all other IOC containers: Create and configure the root container Register the services which your application needs Resolve services from the container All of this setup is ultimately conducted through just a few primary types, which we'll take a brief look at now. Core types For all the built-in container types, Rezolver splits registration and resolving responsibilities between two primary interfaces: ITargetContainer This interface describes a registry of ITarget objects, keyed by type, describing the type of object that is to be created (and how) when a given type is requested. It is through this interface that you setup your container with registrations, which are then later used when resolving objects. You might also see ITargetContainerOwner - which is a special type required by some of the more complex registration mechanisms (decorators, for example). Tip The primary implementation of this interface that you will use in your application is TargetContainer . IContainer This is the interface through which we resolve objects. The interface does not expose any registration mechanisms at all (even if the 'standard' implementations of those classes all do) - only the ability to request objects from the container. This interface does not mandate that a container has an ITargetContainer , it's simply the case that all the provided implementations which we will discuss in the rest of this documentation do use that interface as the source of their service registrations. Tip The primary implementation of this interface is ContainerBase , an abstract class which also implements the ITargetContainer interface by wrapping around the Targets property that it exposes. As a consumer of Rezolver, however, you will be using the Container and ScopedContainer classes most of the time - which derive most of their functionality from this abstract class. Creating a container There are numerous ways to create an IContainer instance. The easiest, from the point of view registering services and then resolving them, is to create an instance of the Container type. Or, if you want your root container to act as a global lifetime scope for explicitly scoped objects (see ScopedTarget ) then you can also use ScopedContainer : void Foo() { //create a standard non-scoping container var container = new Container(); //or create a scoped container: var container = new ScopedContainer(); All code samples assume you have added a using statement ( imports in VB) for the Rezolver namespace. Once you have a local reference to either of these classes, you can start registering services in the container, and resolving objects from it. Registering services As mentioned above, with our default implementations of IContainer , registration of services ultimately means adding targets to a container's Targets target container, associating them with service types which we will later resolve. The core registration method for this is the Register method, which accepts an ITarget and an optional type against which the registration is to be made. There's too much to cover in a few sub headings here for this - the service registration topic has more detail, and links to the different types of registration you can perform. Resolving services Resolving objects from your container is done through the Resolve method which, you'll notice, accepts a ResolveContext as its single parameter, and returns an Object . Again, if you're familiar with IOC containers then you're probably wondering where your strongly-typed Resolve<TService>() method is! Well, fear not. As with the many extension methods available on ITargetContainer , the IContainer interface (through which all resolving of objects is done) has extension methods to provide a more traditional IOC API, and these are found on the ContainerResolveExtensions static class. The one you'll use most frequently, of course, is the Resolve<TObject>(IContainer) method, which provides the aforementioned Resolve<TService>() API. So, assuming we have the container that we've been using up till now, we would resolve an instance of MyService simply by doing one of the following: MyService service = container.Resolve<MyService>(); //or MyServiceBase service = container.Resolve<MyServiceBase>(); //or IMyService service = container.Resolve<IMyService>(); Note The ResolveContext class is used to capture the context of a call to the Resolve method, tracking the container on which the call is originally made, whether there is an IContainerScope active for the call, and other things besides. You will rarely use it directly in application code unless you are extending Rezolver. These Resolve extension methods create the ResolveContext for a given operation on your behalf, so you never have to worry about it. Assuming the container can locate the service registration for the type you request, it will fetch/produce an instance of the associated object type according to the behaviour described by the ITarget which we previously registered. If no registration is found, then an InvalidOperationException is raised by the container. Tip IContainer also implements the System.IServiceProvider interface from the .Net framework, which requires that missing services yield a null result instead of throwing an exception. CanResolve/TryResolve Sometimes you might want to attempt to resolve an object from the container, but not have an exception raised if it cannot be found. In this case you can use the TryResolve method, which returns the object via an out parameter and returns a bool indicating whether the operation succeeds. Naturally, as with the Resolve operation, this method has a generic overload ( TryResolve<TObject>(IContainer, out TObject) ) to avoid the need for a temporary Object reference: MyService result; bool success = container.TryResolve(out result); //success == true or false depending on registrations. Similarly we can also introspect a container to find out if it can resolve an instance of a given type by using the CanResolve method. This method also has friendly overloads via extension methods (e.g. CanResolve<TObject>(IContainer) )): bool canResolve = container.CanResolve<MyService>(); Next Steps Now read up on how to register services in the container . <!--Alternatively, you might be interested in Rezolver's understanding of [object lifetimes](object-lifetimes.md).-->"
  },
  "docs/decorators.html": {
    "href": "docs/decorators.html",
    "title": "Decorators | Rezolver IOC Framework",
    "keywords": "Decorators The decorator pattern is a key part of many software projects, and Rezolver offers first-class support for implementing it, but only if you have a reference to the ITargetContainerOwner interface - which you will, if you use the TargetContainer class directly to register your targets instead of simply creating a new Container instance. Note This limitation will be removed in 1.2 - in which issue #25 will be addressed - so that the extension methods shown in these examples will be available on the ITargetContainer interface instead, with a NotSupportedException being thrown if the target container on which you call the method is not also a ITargetContainerOwner . Registering decorators in Rezolver Registration of Decorators in Rezolver is done through the overloaded extension method RegisterDecorator . There is a generic and non-generic version (as is typical for nearly all Rezolver registration functions), but, unlike many other target types, there is no factory method in the Target static class to create one on its own. The sharp-eyed developer will be confused by this omission, especially since the type DecoratorTarget is a key part of Rezolver's implementation of decorators - but if you read the summary notes about that class, it should be apparent why: Decoration isn't solely implemented through an ITarget implementation, it also needs a special target container type in which that target will be registered - DecoratingTargetContainer , the creation of which is handled automatically by the RegisterDecorator methods. Now, as mentioned in the introduction, you cannot currently register a decorator directly into a IContainer - because it does not (and will never) support the interface required by the extension methods. As a result, the examples here do not follow the same pattern that you should already be familiar with: var container = new Container(); // Add registrations to the container through its implementation of // Rezolver.ITargetContainer. var ifoo = container.Resolve<some_type>(); Instead, until v1.2 we have to create a TargetContainer separately on which we will perform our registrations, and then construct a new Container , passing those targets as a constructor argument: var targets = new TargetContainer(); targets.RegisterType<Foo, IFoo>(); targets.RegisterDecorator<FooDecorator, IFoo>(); var container = new Container(targets); var result = container.Resolve<IFoo>(); Although this is somewhat inconvenient, it should be said that if you are looking to use Rezolver's integration with Asp.Net Core , you almost certainly will be working with a target container when performing registrations anyway. Examples For the first few examples, we'll be using these decorators for the interface IMyService , which has also been used in many of the other examples. If you've already looked at the enumerable examples then you'll be familiar with them: public class MyServiceDecorator1 : IMyService { public IMyService Inner { get; } public MyServiceDecorator1(IMyService inner) { Inner = inner; } } public class MyServiceDecorator2 : IMyService { public IMyService Inner { get; } public MyServiceDecorator2(IMyService inner) { Inner = inner; } } Single decorator, single service Here, we simply register an IMyService implementation and one of our decorators. We then resolve an instance and we should get an instance of the decorator, with the original IMyService as its Inner . var targets = new TargetContainer(); targets.RegisterType<MyService, IMyService>(); targets.RegisterDecorator<MyServiceDecorator1, IMyService>(); var container = new Container(targets); var result = container.Resolve<IMyService>(); var decorator = Assert.IsType<MyServiceDecorator1>(result); Assert.IsType<MyService>(decorator.Inner); Two decorators, single service You can also 'stack' decorators for a given type, meaning you can decorate the decorators: // same as before - but two decorators // note that the order they're registered determines the order in which // the decoration occurs. var targets = new TargetContainer(); targets.RegisterType<MyService, IMyService>(); targets.RegisterDecorator<MyServiceDecorator2, IMyService>(); targets.RegisterDecorator<MyServiceDecorator1, IMyService>(); var container = new Container(targets); var result = container.Resolve<IMyService>(); var decorator = Assert.IsType<MyServiceDecorator1>(result); var innerDecorator = Assert.IsType<MyServiceDecorator2>(decorator.Inner); Assert.IsType<MyService>(innerDecorator.Inner); As the test shows, the decorators are applied in the order they are registered for the given type. Two decorators, enumerable Decorators are also applied to elements of an enumerable: var targets = new TargetContainer(); // this time we'll register the decorators first, not because // we have to, but because we can :) targets.RegisterDecorator<MyServiceDecorator2, IMyService>(); targets.RegisterDecorator<MyServiceDecorator1, IMyService>(); // note: this array of types is purely to simplify the asserts // used at the end. var serviceTypes = new[] { typeof(MyService1), typeof(MyService2), typeof(MyService3), typeof(MyService4), typeof(MyService5), typeof(MyService6) }; var serviceTargets = serviceTypes.Select( t => Target.ForType(t) ); // another way to bulk-register multiple targets // against the same service type. targets.RegisterMultiple(serviceTargets, typeof(IMyService)); var container = new Container(targets); var result = container.Resolve<IEnumerable<IMyService>>(); Assert.All(serviceTypes.Zip(result, (t, s) => (type: t, service: s)), ts => { var decorator = Assert.IsType<MyServiceDecorator1>(ts.service); var innerDecorator = Assert.IsType<MyServiceDecorator2>(decorator.Inner); Assert.IsType(ts.type, innerDecorator.Inner); }); Open Generic Decorator You can also use decorators with open generics - register them just like normal generic types , except via the RegisterDecorator method. For this, our basic generic decorator is this: public class UsesAnyServiceDecorator<TAnyService> : IUsesAnyService<TAnyService> { public IUsesAnyService<TAnyService> Inner { get; } public UsesAnyServiceDecorator(IUsesAnyService<TAnyService> inner) { Inner = inner; } public void UseTheService(TAnyService service) { throw new NotImplementedException(); } } And the code to register it shouldn't be too much of a surprise: var targets = new TargetContainer(); targets.RegisterType(typeof(UsesAnyService<>), typeof(IUsesAnyService<>)); targets.RegisterDecorator(typeof(UsesAnyServiceDecorator<>), typeof(IUsesAnyService<>)); var container = new Container(targets); var result = container.Resolve<IUsesAnyService<MyService>>(); var decorator = Assert.IsType<UsesAnyServiceDecorator<MyService>>(result); Assert.IsType<UsesAnyService<MyService>>(decorator.Inner); Tip Enumerables of open generics can also be decorated in a similar way to the previous example. Just register multiple IService<> registrations, then one or more open generic decorators as normal - then an IEnumerable<IService<Foo>> will produce an enumerable with each element correctly decorated. Specialised Generic Decorator Note This section is intended to show how you can apply decorators to specific closed variants of an open generic, however, whilst preparing the example, an issue was discovered in the implementation. Not in the least bit embarrassing! :) A fix is planned for v1.2, and is right at the top of the priority list - which you can see on the project board"
  },
  "docs/delegates.html": {
    "href": "docs/delegates.html",
    "title": "Factory Delegates | Rezolver IOC Framework",
    "keywords": "Factory Delegates You can register delegates in a Rezolver container so that, when the associated service type is resolved, your delegate will be executed and its result returned as the instance. The delegate can be of any type, subject to the following constraints: The delegate must have non- void return type It must not have any ref or out parameters To register delegates you can use one of the many RegisterDelegate extension methods for ITargetContainer . To create delegate targets you can either: Manually create an instance of DelegateTarget through its constructor Use the ForDelegate overload, which provides specialisations for variants of the System.Func<> generic delegate Delegates are a useful tool in the context of IOC containers as support for them gives you the opportunity to perform much more complex tasks in order to resolve an object than the functionality offered by the standard targets in Rezolver. Whether you should perform excessively complex logic in these factories is a topic of debate. Our view is that you should be able to if you want, or need, to, so Rezolver's support for delegates is extensive, including the ability to inject arguments to your delegate from the container, or resolve additional services inside your delegate through ResolveContext . Basic Examples Here are some straightforward examples RegisterType analogue In this example, we simply register a delegate that fires a type's constructor: var container = new Container(); container.RegisterDelegate(() => new MyService()); var result = container.Resolve<MyService>(); Assert.NotNull(result); As a Singleton We can also use the Singleton and the Scoped extension methods to modify the lifetime of the object produced by the delegate: var container = new Container(); container.Register( // RegisterSingleton specialises for types only, so // we create the target manually and apply this .Singleton // extension method to to it before registering Target.ForDelegate(() => new MyService()).Singleton() ); var result = container.Resolve<MyService>(); var result2 = container.Resolve<MyService>(); Assert.Same(result, result2); Honouring Scopes ( IContainerScope ) As you would expect, if the object is resolved through a scope, then it will be tracked and disposed by that scope when it is disposed: var container = new Container(); container.RegisterDelegate(() => new DisposableType()); DisposableType result, result2; using (var scope = container.CreateScope()) { result = scope.Resolve<DisposableType>(); using (var childScope = scope.CreateScope()) { result2 = childScope.Resolve<DisposableType>(); } Assert.True(result2.Disposed); } Assert.True(result.Disposed); Advanced Examples Argument injection As mentioned in the introduction, Rezolver can inject arguments into your factory delegates just like they were constructors bound by ConstructorTarget or GenericConstructorTarget . var container = new Container(); container.RegisterType<MyService, IMyService>(); // delegate requires an IMyService to feed as a dependency, along with // another value which is not injection-friendly (DateTime) DateTime expectedStartDate = new DateTime(2014, 5, 5); container.RegisterDelegate((IMyService service) => new RequiresIMyServiceAndDateTime(service, new DateTime(2014, 5, 5))); var result = container.Resolve<RequiresIMyServiceAndDateTime>(); Assert.NotNull(result.Service); Assert.Equal(expectedStartDate, result.StartDate); Any delegate type, with any number of parameters, is supported, so long as it has a return type. Injecting ResolveContext All Resolve operations have a ResolveContext at their heart. Through the context, you can get the Container that originally received the call, the Scope and the RequestedType . It can also be used to create a new child scope (through its implementation of the IScopeFactory interface). If you need the context to be passed to your delegate - just make sure to declare a parameter of that type, most commonly you'll probably use the single parameter specialisation of the RegisterDelegate or ForDelegate methods, but ultimately the parameter can appear anywhere in the delegate's signature and it will be injected. This example shows the Func<RezolveContext, TResult> overload in action: var container = new Container(); // RegisterDelegate has a specialisation for a delegate which takes ResolveContext container.RegisterDelegate(rc => new RequiresResolveContext(rc)); var result = container.Resolve<RequiresResolveContext>(); // the context was injected Assert.NotNull(result.Context); // and the container on the context will be the one on which we called Resolve<> Assert.Same(container, result.Context.Container); Resolving inside a delegate Building on the above, here's an example which injects the ResolveContext in order to perform a late-bound Resolve operation to inject a different dependency based on some ambient information about a user (which is also injected into the delegate). This is quite a long example which, admittedly, can be solved in a few different ways. We're not saying this is the only way :) public class AppIdentity : IIdentity { public string AuthenticationType { get; } = \"Magic\"; public bool IsAuthenticated { get; } = true; public string Name { get; } = \"Joe Bloggs\"; } public class AppPrincipal : IPrincipal { public IIdentity Identity { get; } private string[] Roles { get; } public AppPrincipal(IIdentity identity, string[] roles) { Identity = identity; Roles = roles ?? new string[0]; } public bool IsInRole(string role) { return Roles.Contains(role, StringComparer.OrdinalIgnoreCase); } } public interface IUserActionsService { IEnumerable<string> GetActions(); } public interface IRoleBasedActionsService : IUserActionsService { } public class CustomerActionsService : IRoleBasedActionsService { public IEnumerable<string> GetActions() => new[] { \"View Products\" }; } public class SalesActionsService : IRoleBasedActionsService { public IEnumerable<string> GetActions() => new[] { \"Create Customers\", \"View Products\" }; } public class AdminActionsService : IRoleBasedActionsService { public IEnumerable<string> GetActions() => new[] { \"Manage Users\", \"Manage Products\", \"Create Customers\", \"View Products\" }; } public class UserControlPanel { public IUserActionsService ActionsService { get; } public UserControlPanel(IUserActionsService actionsService) { ActionsService = actionsService; } } The goal is to create a UserControlPanel which is correct for the current User (identified by a static property CurrentPrincipal ), so that it has access to a list of actions the user can perform based on their role. The UserControlPanel class requires an IUserActionsService which provides access to that list of actions, and we have three separate implementations of that interface which we could use, based on the user's role. We will use the @RezolveContext.Resolve* operation to create the instance we want to inject after deciding which type to resolve based on the user's role: static IPrincipal CurrentPrincipal { get; set; } [Fact] public void ShouldGetDifferentImplementationFromResolveContextForUser() { IIdentity identity = new AppIdentity(); // three principals, one for each role var adminPrincipal = new AppPrincipal(identity, new[] { \"Admin\" }); var salesPrincipal = new AppPrincipal(identity, new[] { \"Sales\" }); var customerPrincipal = new AppPrincipal(identity, new[] { \"Customer\" }); var container = new Container(); container.RegisterType<AdminActionsService>(); container.RegisterType<SalesActionsService>(); container.RegisterType<CustomerActionsService>(); container.RegisterType<UserControlPanel>(); // register delegate to read the CurrentPrincipal property, to make it dynamic container.RegisterDelegate(() => CurrentPrincipal); // now register the delegate handler for the IUserActionsService, which does the // role sniffing over the principal container.RegisterDelegate((IPrincipal p, ResolveContext rc) => { IUserActionsService toReturn = null; if (p != null) { if (p.IsInRole(\"Customer\")) toReturn = rc.Resolve<CustomerActionsService>(); else if (p.IsInRole(\"Sales\")) toReturn = rc.Resolve<SalesActionsService>(); else if (p.IsInRole(\"Admin\")) toReturn = rc.Resolve<AdminActionsService>(); } return toReturn; }); // set the principal, and resolve CurrentPrincipal = adminPrincipal; var result1 = container.Resolve<UserControlPanel>(); // now swap principals CurrentPrincipal = salesPrincipal; var result2 = container.Resolve<UserControlPanel>(); // and again CurrentPrincipal = customerPrincipal; var result3 = container.Resolve<UserControlPanel>(); Assert.IsType<AdminActionsService>(result1.ActionsService); Assert.IsType<SalesActionsService>(result2.ActionsService); Assert.IsType<CustomerActionsService>(result3.ActionsService); } Next Steps That's about it for delegate registrations. There are plans to add functionality to decorate instances via delegate, but in the meantime feel free to explore the table of contents or head back to the main service registration overview to explore more features of Rezolver."
  },
  "docs/enumerables.html": {
    "href": "docs/enumerables.html",
    "title": "Enumerables | Rezolver IOC Framework",
    "keywords": "Enumerables By default, a TargetContainer (the default ITargetContainer used by all containers in the Rezolver framework) comes with a behaviour enabled which allows any ContainerBase derivative to resolve an IEnumerable<Service> . The contents of this enumerable will depend on how many times the Register method has been called against the target type Service : If no target has been registered against the type, then the enumerable will be empty Otherwise, the enumerable will contain instances obtained from each ITarget that was registered against that type, in the order they were registered. Note Automatic resolving of enumerables is a configurable behaviour which can currently be disabled when creating a TargetContainer via its constructor. It can also be explicitly opted-in (if it has been disabled) by calling the EnableEnumerableResolving extension method. Disabling the behaviour through the constructor might be removed in a future version, as we intend to move to a configuration callback-based mechanism for configuring containers. You are not restricted in the targets you use to produce instances for an enumerable, and each one can have its own lifetime (scoped/singleton etc). Empty enumerable Here's an example where we only register the service we're going to create, which has a single constructor that requires an IEnumerable<IMyService> . First, the type RequiresEnumerableOfServices : public class RequiresEnumerableOfServices { public IEnumerable<IMyService> Services { get; } public RequiresEnumerableOfServices(IEnumerable<IMyService> services) { Services = services; } } And then the test: var container = new Container(); container.RegisterType<RequiresEnumerableOfServices>(); var result = container.Resolve<RequiresEnumerableOfServices>(); Assert.Empty(result.Services); Same ITarget type Here, we register each type one after another: var container = new Container(); var expectedTypes = new[] { typeof(MyService1), typeof(MyService2), typeof(MyService3) }; foreach (var t in expectedTypes) { container.RegisterType(t, typeof(IMyService)); } container.RegisterType<RequiresEnumerableOfServices>(); var result = container.Resolve<RequiresEnumerableOfServices>(); Assert.Equal(3, result.Services.Count()); Assert.All( result.Services.Zip( expectedTypes, (s, t) => (service: s, expectedType: t) ), t => Assert.IsType(t.expectedType, t.service)); Mixed ITarget types This time, we're mixing it up a bit by registering multiple different target types (a constructor target, a delegate target and an object target), and we're also using a delegate to create the RequiresEnumerableOfServices just to show that the enumerable can be injected into a delegate as you'd expect: var container = new Container(); container.RegisterType<MyService1, IMyService>(); container.RegisterDelegate<IMyService>(() => new MyService2()); container.RegisterObject<IMyService>(new MyService3()); // shows also that injection of IEnumerables holds wherever injection // is normally supported - such as here, with delegate argument injection container.RegisterDelegate((IEnumerable<IMyService> services) => { // if MyService4 is missing, add it to the enumerable if (!services.OfType<MyService4>().Any()) services = services.Concat(new[] { new MyService4() }); return new RequiresEnumerableOfServices(services); }); var result = container.Resolve<RequiresEnumerableOfServices>(); Assert.Equal(4, result.Services.Count()); // just check they're all different types this time. Assert.Equal(4, result.Services.Select(s => s.GetType()).Distinct().Count()); Mixed lifetimes When registering targets, you have three lifetimes at your disposal: Transient (a new object created for every Resolve call) Singleton (only one object is ever created) Scoped (one object created per IContainerScope ) Note Of course, the ObjectTarget (see objects as services ) is technically a singleton, also, but that's because it wraps a constant reference supplied by you. If you register multiple targets for the same type, and those targets have different lifetimes, then those lifetimes are honoured if the container injects an IEnumerable<> . The following example registers three implementations for IMyService again which will appear in the enumerables in the following positions: [0] : A singleton [1] : A scoped object [2] : A transient It then resolves IEnumerable<IMyService> multiple times - twice from the root container (which is a ScopedContainer so that the scoped MyService2 registration has a scope to 'live' in) and then twice again from a child scope: // since we're using a scoped registration here, // we'll use the ScopedContainer, which establishes // a root scope. var container = new ScopedContainer(); container.RegisterSingleton<MyService1, IMyService>(); container.RegisterScoped<MyService2, IMyService>(); container.RegisterType<MyService3, IMyService>(); // So - each enumerable will contain, in order: // 1) Singleton IMyService // 2) Scoped IMyService // 3) Transient IMyService var fromRoot1 = container.Resolve<IEnumerable<IMyService>>().ToArray(); var fromRoot2 = container.Resolve<IEnumerable<IMyService>>().ToArray(); Assert.Same(fromRoot1[0], fromRoot2[0]); // both scoped objects should be the same because we've resolved // from the root scope Assert.Same(fromRoot1[1], fromRoot2[1]); Assert.NotSame(fromRoot1[2], fromRoot2[2]); using (var childScope = container.CreateScope()) { var fromChildScope1 = childScope.Resolve<IEnumerable<IMyService>>().ToArray(); // singleton should be the same as before, but // the scoped object will be different Assert.Same(fromRoot1[0], fromChildScope1[0]); Assert.NotSame(fromRoot1[1], fromChildScope1[1]); Assert.NotSame(fromRoot1[2], fromChildScope1[2]); var fromChildScope2 = childScope.Resolve<IEnumerable<IMyService>>().ToArray(); // the scoped object will be the same as above Assert.Same(fromChildScope1[0], fromChildScope2[0]); Assert.Same(fromChildScope1[1], fromChildScope2[1]); Assert.NotSame(fromChildScope1[2], fromChildScope2[2]); } To summarise: [0] is always the same reference [1] is created once per enclosing scope (remember - the container itself is a scope in this example) [2] is created once per call Advanced examples On to generics and decorators, now... Enumerables of open generics You can also register multiple open generics of the same type (e.g. IFoo<> ) and then resolve an enumerable of IFoo<Bar> , and the container will create an enumerable containing an object for each open generic registration: public interface IUsesAnyService<TAnyService> { void UseTheService(TAnyService service); } public class UsesAnyService<TAnyService> : IUsesAnyService<TAnyService> { public void UseTheService(TAnyService service) { throw new NotImplementedException(); } } public class UsesAnyService2<TAnyService> : IUsesAnyService<TAnyService> { public void UseTheService(TAnyService service) { throw new NotImplementedException(); } } var container = new Container(); container.RegisterType(typeof(UsesAnyService<>), typeof(IUsesAnyService<>)); container.RegisterType(typeof(UsesAnyService2<>), typeof(IUsesAnyService<>)); var result = container.Resolve<IEnumerable<IUsesAnyService<IMyService>>>().ToArray(); Assert.Equal(2, result.Length); Assert.IsType<UsesAnyService<IMyService>>(result[0]); Assert.IsType<UsesAnyService2<IMyService>>(result[1]); Note When working with generics, the enumerable handler searches for the first generic registration which has least one ITarget whose UseFallback is false - searching from least generic to most generic (e.g. Foo<Bar> is less generic than Foo<> ). So if you request an IEnumerable<Foo<Bar>> , targets are first sought for Foo<Bar> and, if none are found, it then searches for Foo<> . The side effect of this is that your enumerable will always only contain objects produced from targets registered against the most-specific generic type that's applicable for the type requested. The next example expands on this. Mixing open/closed generics Let's say that we have one open generic registration for IUsesAnyService<> to be used as a catch-all, but that when IMyService is used, we have two types that we want to use instead. In this case, we still have an open generic registration, but we want it to be superseded for certain generic types by two specialised registrations where the inner generic type argument is known. Given these extra generic types: public class UsesIMyService : IUsesAnyService<IMyService> { public void UseTheService(IMyService service) { throw new NotImplementedException(); } } public class UsesIMyService2 : IUsesAnyService<IMyService> { public void UseTheService(IMyService service) { throw new NotImplementedException(); } } We can do this: var container = new Container(); // register our open generic container.RegisterType(typeof(UsesAnyService<>), typeof(IUsesAnyService<>)); // register our two specialisations for IMyService container.RegisterType<UsesIMyService, IUsesAnyService<IMyService>>(); container.RegisterType<UsesIMyService2, IUsesAnyService<IMyService>>(); // will use the UsesIMyService and UsesIMyService2 specialised registrations var result = container.Resolve<IEnumerable<IUsesAnyService<IMyService>>>().ToArray(); // will use the open generic registration - array of one var result2 = container.Resolve<IEnumerable<IUsesAnyService<MyService>>>().ToArray(); Assert.Equal(2, result.Length); Assert.IsType<UsesIMyService>(result[0]); Assert.IsType<UsesIMyService2>(result[1]); Assert.Equal(1, result2.Length); Assert.IsType<UsesAnyService<MyService>>(result2[0]); So, as soon as we want an IEnumerable<IUsesAnyService<IMyService>> , the enumerable will use only the two explicit registrations made against the closed generic type IUsesAnyService<IMyService> , but if we request any other type, we only get items produced by registrations against the open generic IUsesAnyService<> . Warning There is currently no way to fall back on an open generic registration for given generic once you make a registration for a closed generic. The framework might, however, be extended to allow you to make an explicit registration which instructs the container to fall back to a more generic registration and include any results from that in the enumerable. It doesn't matter what order you register the open generics and closed generics - the logic is applied on a type-by-type basis; but the order of an individual enumerable of a given type is, however, governed by the order of registration. Decorators and Enumerables Note At the time of writing, the decorators topic has not been written, so this is preview of how to use decorators as well as how they work in enumerables. Decorators that have been registered against the element type of an enumerable will be applied to all instances that the container produces for the enumerable. This also applies to stacked decorators (where multiple decorators are applied on top of one other). So, we have two decorator types for IMyService : public class MyServiceDecorator1 : IMyService { public IMyService Inner { get; } public MyServiceDecorator1(IMyService inner) { Inner = inner; } } public class MyServiceDecorator2 : IMyService { public IMyService Inner { get; } public MyServiceDecorator2(IMyService inner) { Inner = inner; } } And in this example we'll have one of those decorators being used to decorate three registrations: // the extension API for RegisterDecorator currently only appears for ITargetContainerOwner // thus, for this test we need to change how we create the container. // The extension API will be changed to allow it to be called on ITargetContainer objects // in v1.2 - see #25 (https://github.com/ZolutionSoftware/Rezolver/issues/25) var targets = new TargetContainer(); // register the decorator up front. Note - it doesn't actually matter when it's registered targets.RegisterDecorator<MyServiceDecorator1, IMyService>(); targets.RegisterType<MyService, IMyService>(); targets.RegisterType<MyService2, IMyService>(); targets.RegisterType<MyService3, IMyService>(); // create the container with these targets var container = new Container(targets); var result = container.Resolve<IEnumerable<IMyService>>().ToArray(); // make sure each item in the enumerable is an instance of our decorator. // then make sure the decorated services are correct. Assert.All(result, r => Assert.IsType<MyServiceDecorator1>(r)); Assert.IsType<MyService>(((MyServiceDecorator1)result[0]).Inner); Assert.IsType<MyService2>(((MyServiceDecorator1)result[1]).Inner); Assert.IsType<MyService3>(((MyServiceDecorator1)result[2]).Inner); Note As the first comment states - you cannot currently call any RegisterDecorator extension method via an IContainer , or, more importantly, a ContainerBase derivative. This is because the extensions require an @Rezolver.ITargetContainerOwner , which is not implemented by these types. This will change with the 1.2 release, though (see Issue #25 ). If more decorators were added, of course - then each element would be 're-decorated' accordingly. Explicit IEnumerable<T> registrations Although you get IEnumerable<T> handling automatically, it doesn't prevent you from manually adding registrations which override the default behaviour. For example, let's say that you have two registrations for services which share a common interface, but they have only been registered against their concrete type (perhaps it's historical code you can't risk changing). Your code now wants an enumerable of that common interface. Well, assuming you know what the specific registrations are - you can use delegate registrations (note, there are lots of ways, this is just the most illustrative): var container = new Container(); container.RegisterType<MyService1>(); container.RegisterType<MyService2>(); container.RegisterDelegate<IEnumerable<IMyService>>( rc => new IMyService[] { rc.Resolve<MyService1>(), rc.Resolve<MyService2>() }); var result = container.Resolve<IEnumerable<IMyService>>().ToArray(); Assert.Equal(2, result.Length); Assert.IsType<MyService1>(result[0]); Assert.IsType<MyService2>(result[1]); Next steps Recommend going to take (another) look at decorators - although, at the time of writing it might not be written yet! The generic constructor injection documentation contains more useful guidance about open generics etc."
  },
  "docs/lifetimes/index.html": {
    "href": "docs/lifetimes/index.html",
    "title": "Object Lifetimes | Rezolver IOC Framework",
    "keywords": "Object Lifetimes As with most IOC containers, Rezolver understands three primary lifetimes for the objects it produces, including support for automatic disposal of IDisposable objects when an IContainerScope is used. Transient Objects This is what's ultimately produced by a Rezolver IContainer most of the time - a transient object is created when needed and thrown away when no longer required. It's the same as using new to create an instance inside a function and then allowing it to go out of scope when that function returns. Read more about transient objects . Singletons Most developers will be familiar with the singleton pattern - an object created only once per process (often created lazily - i.e. on demand) and which is frequently accessed via static accessors or similar. Specifically, an application will usually enforce rules at the code level to ensure that it's impossible to create more than one instance of the type. Rezolver lets you change any registration into a singleton by simply wrapping an ITarget inside a @Rezolver.SingletonTarget. Read more about singletons . Scoped Objects Unsurprisingly, understanding scoped objects requires an understanding of scopes. At its most fundamental level, a scope is simply a disposable 'bag' of objects which is created at the start of a particular process (e.g when a web request is received, or when a job is pulled off a job queue) and which is then disposed when that process completes. Most IOC containers refer to these as lifetime scopes ( note: 'container scopes' in Rezolver, implemented by the IContainerScope interface ) and they are most often used (but not exclusively) to track objects that implement the IDisposable interface in order that they can be disposed without the developer explicitly having to do so themselves - often because the developer can never really be sure that she has definitely finished with that object. But the presence of a scope at the point where an object is produced/obtained by the container does not automatically mean that that object is itself 'scoped'. Indeed, transients and singletons can be used inside a scope in exactly the same way as outside. Instead, a scoped object has a special lifetime behaviour such that it behaves like a singleton, except you get one instance per scope instead of one per-process. A scoped object also requires a scope to be available in order for it to be resolved. Scopes are also hierarchical - one scope can contain zero or more other child scopes whose scoped objects are independent of each other (and those of the parent) - but each child scope will be disposed when the parent scope is disposed. Rezolver allows you to change any registration into a scoped object by wrapping an ITarget inside a @Rezolver.ScopedTarget. Read more about scoped objects . Read more about container scopes (particularly if you will be using IDisposable objects in your application)."
  },
  "docs/lifetimes/scoped.html": {
    "href": "docs/lifetimes/scoped.html",
    "title": "Markdown File | Rezolver IOC Framework",
    "keywords": "Markdown File"
  },
  "docs/lifetimes/singleton.html": {
    "href": "docs/lifetimes/singleton.html",
    "title": "Markdown File | Rezolver IOC Framework",
    "keywords": "Markdown File"
  },
  "index.html": {
    "href": "index.html",
    "title": "Rezolver | Rezolver IOC Framework",
    "keywords": "Rezolver Rezolver is a fast , efficient, extensible, open source IOC container supporting .Net Core, .Net 4.5.2 and .Net 4.6 - with Asp.Net Core integration too. This site contains API documentation and developer guides for getting the most out of it. Features Linked topics provide high level overviews and examples in our developer guide - click on them to find out more! (*) Constructor Injection Multiple constructors supported 'Intelligent' constructor discovery based on registered services Named argument binding Parameters with default arguments are supported Member injection (extensible) Open generics (with specific closed generics taking precedence) Decorators (non-generic and generic) Enumerables (empty enumerables returned by default) Child containers (overriding registrations in one container with those of another) Child registration containers (lower-level overriding of registrations for similar but sibling containers) Hierarchical lifetime scoping Delegates and Expressions as factories, with argument injection Explicit resolving supported inside factory/expression bodies Singletons Objects as services Scoped objects (i.e. 'singleton per scope') No 'prepare' phase - you can register targets in a container after you start using it Note - services which have already been used cannot yet be replaced, but high-performance mutable containers are on their way Extensible compiler framework Expression tree compiler used by default Direct Asp.Net Core integration via extensions to the Microsoft.Extensions.DependencyInjection and Microsoft.AspNetCore.Hosting packages via nuget packages (click the links to go to our package docs) Extensible configuration framework (still in development) Json configuration (still in development) * If a topic isn't linked, it's probably because we're still working on the documentation! Quick Links Developer Guide Benchmarks Nuget Packages API Reference Release History (On Github)"
  },
  "docs/lifetimes/transient.html": {
    "href": "docs/lifetimes/transient.html",
    "title": "Transient Objects | Rezolver IOC Framework",
    "keywords": "Transient Objects Most registrations performed on an ITargetContainer will result in transient objects being created when the Resolve method of an IContainer is called. Ultimately, the transience of an object is determined by the ITarget that is registered against the type that's requested from the container. Some of these targets create inherently transient objects, whilst some inherit or expressly control the lifetimee of other targets. The following table summarises this: ITarget implementation Transient? Notes <xref:Rezolver.Targets.ChangeTypeTarget> Inherited Target doesn't create anything, only changes the type of another target's result, therefore it inherits that target's lifetime. ConstructorTarget Yes @Rezolver.Targets.DecoratorTarget<sup>*</sup> Yes It's not currently possible to directly control the lifetime of a decorator - only the object it decorates. DefaultTarget No Default values are cached per-type, therefore even value type defaults are technically singletons. DelegateTarget Depends on the delegate The delegate is always executed, so the transience of the object it returns depends on the delegate's logic. ExpressionTarget Depends on the expression Like DelegateTarget , the expression itself determines the lifetime of the object produced. GenericConstructorTarget Yes Same as ConstructorTarget . ListTarget Yes ObjectTarget No * OptionalParameterTarget No Only used to bind optional constructor parameters to their default values ResolvedTarget Depends This target represents an explicit instruction to resolve an object/value from the container - therefore the lifetime of the object produced depends on the lifetime of the registration which ultimately gets resolved. ScopedTarget No This target is responsible for Rezolver's implementation of scoped objects . SingletonTarget No This target is responsible for Rezolver's implementation of singleton objects . * UnscopedTarget Inherited This target is used to strip explicit or implicit scoping behaviour from another target. *Denotes a target which is used indirectly by other registrations and not generally used directly by applications"
  },
  "docs/nuget-packages/index.html": {
    "href": "docs/nuget-packages/index.html",
    "title": "Rezolver Nuget Packages | Rezolver IOC Framework",
    "keywords": "Rezolver Nuget Packages Rezolver is primarily distributed as a suite of Nuget packages whose functionality stacks one on top of another. Depending on the level of functionality you require, there should be a Nuget package which contains only the code you need, with the main package ( Rezolver ) being the root dependency for all. All the core nuget packages support the .NetStandard 1.1 profile (don't know what this is? Learn more ), .Net 4.5.1 and .Net 4.6. Note Where a package has a dependency on a third party package (such as Newtonsoft's Json.Net or .Net Core's Microsoft.Extensions.DependencyInjection packages), then we try to maintain full support for the same frameworks and profiles that those packages support. List of packages Rezolver Rezolver.Configuration (needs verifying) Rezolver.Microsoft.Extensions.DependencyInjection Rezolver.Microsoft.AspNetCore.Hosting Versioning Our versioning approach is the same as recommended by Nuget.org - semantic versioning - where: A major version bump ( x.y.z.w -> (++x).y.z.w ) indicates a breaking change A minor version bump ( x.y.z.w => x.(++y).z.w ) indicates new functionality that shouldn't be a breaking change A build version bump ( x.y.x.w => x.y.(++z).w ) indicates small new functionality or bugfixes A revision bump ( x.y.z.w => x.y.z.(++w) ) indicates a cock-up on our part that had to be corrected :) Obviously, we try to keep the latter to a minimum!"
  },
  "docs/nuget-packages/rezolver.configuration.html": {
    "href": "docs/nuget-packages/rezolver.configuration.html",
    "title": "Nuget Package: Rezolver.Configuration | Rezolver IOC Framework",
    "keywords": "Nuget Package: Rezolver.Configuration This package provides the Rezolver configuration object model, whose purpose is to describe how a Target Container should be constructed and configured based on a configuration file/script loaded at runtime. It doesn't define any specific code for parsing configuration files - but it does provide a standard implementation of the @Rezolver.Configuration.IConfigurationAdapter, whose job it is to create a ITargetContainer from a @Rezolver.Configuration.IConfiguration instance. You can implement your own configuration file formats with this simply by writing code to read your desired format and getting your parser to create an instance of @Rezolver.Configuration.IConfiguration"
  },
  "docs/nuget-packages/rezolver.html": {
    "href": "docs/nuget-packages/rezolver.html",
    "title": "Rezolver Nuget Package | Rezolver IOC Framework",
    "keywords": "Rezolver Nuget Package See package page on nuget . The core nuget package for using Rezolver in your class library or application, includes: All the core abstractions and classes required to create TargetContainer and Container objects. The core ITarget implementations which allow you to create/retrieve objects using all the standard techniques documented here (constructor injection, enumerables, delegates and expressions etc) from the get-go. The expression compiler which builds bespoke factories for each service you resolve in your container Simply add the package, add an using / import for the Rezolver namespace and you're all set."
  },
  "docs/nuget-packages/rezolver.microsoft.aspnetcore.hosting.html": {
    "href": "docs/nuget-packages/rezolver.microsoft.aspnetcore.hosting.html",
    "title": "Rezolver.Microsoft.AspNetCore.Hosting Package | Rezolver IOC Framework",
    "keywords": "Rezolver.Microsoft.AspNetCore.Hosting Package See package page on nuget . This builds on the Rezolver.Microsoft.Extensions.DependencyInjection package to enable the integration of Rezolver into your Asp.Net Core site somewhwat earlier in its startup phase. After adding the package, open your site's program.cs and add a call to the UseRezolver() extension method that's now available, as shown: public class Program { public static void Main(string[] args) { var host = new WebHostBuilder() .UseKestrel() //add the Rezolver container to the host builder .UseRezolver() .UseContentRoot(Directory.GetCurrentDirectory()) .UseIISIntegration() .UseStartup<Startup>() .Build(); host.Run(); } } Then we need to tell the Asp.Net Core stack that you want an ITargetContainer to be created in order to construct the IContainer that will be used as the DI container. We do this in your application's startup.cs - simply by declaring a single method: public void ConfigureContainer(ITargetContainer container) { //by declaring this method - even if empty - you trigger the //creation of the ITargetContainer which will ultimately //be used to create the IContainer that will be used //as the application's container. //Here you can perform additional registrations/configuration on the //ITargetContainer here. } And that's it - your application is configured."
  },
  "docs/nuget-packages/rezolver.microsoft.extensions.dependencyinjection.html": {
    "href": "docs/nuget-packages/rezolver.microsoft.extensions.dependencyinjection.html",
    "title": "Rezolver.Microsoft.Extensions.DependencyInjection Package | Rezolver IOC Framework",
    "keywords": "Rezolver.Microsoft.Extensions.DependencyInjection Package See package page on nuget . Tip It's recommended that you use the Asp.Net Core Hosting integration package on top of this one to enable integration of Rezolver into your Asp.Net core website at an earlier stage of its lifetime. This package provides Rezolver's implementation of the Microsoft DI Container which drives the new Asp.Net Core stack. After adding the package, configuring your Asp.Net website to use Rezolver as the DI container is simple: Replace the default ConfigureServices function in your application's Startup.cs file with this one: // This method gets called by the runtime. Use this method to add services to the container. public IServiceProvider ConfigureServices(IServiceCollection services) { // Add framework services. services.AddMvc(); //create the Rezolver container from the services, without making any additional //registrations var container = services.CreateRezolverContainer(); //use IContainer/ITargetContainer methods and extensions here to add extra registrations, e.g. //decorators or your own application's registrations. //IContainers implement the IServiceProvider interface natively - so can simply be returned. return container; } This returns a new service provider to the Asp.Net Core stack - thus replacing the default service provider that's already built. As the comment in the snippet suggests, you will likely want to perform additional registration operations on the IContainer object that's returned by the CreateRezolverContainer function called here, since the Rezolver container supports more functionality (e.g. expressions, decorators, custom targets, and more) than the MS DI container does through its ServiceRegistrations class."
  },
  "docs/constructor-injection/index.html": {
    "href": "docs/constructor-injection/index.html",
    "title": "Constructor Injection | Rezolver IOC Framework",
    "keywords": "Constructor Injection The most basic, fundamental feature of any IOC container is the ability to create instances of services through a constructor, automatically injecting arguments into that constructor from the services which have been registered in the container. Tip Constructor injection is achieved in Rezolver through the targets ConstructorTarget and GenericConstructorTarget (for open generic types). The examples here show how to create and register these directly and via some of the extension methods in RegisterTypeTargetContainerExtensions , SingletonTargetContainerExtensions and ScopedTargetContainerExtensions . You can see the tests from which these examples are taken, and run them yourself, if you grab the Rezolver source from Github , open the main solution and run the tests in the 'Rezolver.Tests.Examples' project. Some IOC containers restrict you to types with a single constructor. In some cases this is because of the design of the container itself - i.e. in order to achieve good performance - and in others it's to encourage good program design. Rezolver's constructor injection, implemented by the types ConstructorTarget and GenericConstructorTarget , supports binding to types which have multiple constructors. The ConstructorTarget actually has two modes: Find the best matching constructor Explicitly-supplied constructor (where you supply a ConstructorInfo on creation) Example - Injected class So, given these types: public class MyService : IMyService { } and public class RequiresMyService : IRequiresIMyService { public MyService Service { get; } public RequiresMyService(MyService service) { Service = service; } public RequiresMyService(IMyService service) { if (service.GetType() != typeof(MyService)) { throw new ArgumentException($\"{ service.GetType() } not supported\", nameof(service)); } Service = (MyService)service; } IMyService IRequiresIMyService.Service { get { return Service; } } } Note The rather silly explicit implementation and argument checking in the second constructor is purely for illustrative purposes! In order to build RequiresMyService we need an instance of MyService or IMyService , so let's try injecting a MyService , and resolve: var container = new Container(); container.RegisterType<MyService>(); container.RegisterType<RequiresMyService>(); var result = container.Resolve<RequiresMyService>(); Assert.NotNull(result.Service); Example - Injected interface Now, obviously a key facet of dependency injection is that we can depend upon an abstraction of a service instead of a concrete implementation - so most of the time your constructors will request an interface instead of a concrete type. To do this, we simply register MyService against the type IMyService : var container = new Container(); container.RegisterType<MyService, IMyService>(); container.RegisterType<RequiresMyService>(); var result = container.Resolve<RequiresMyService>(); Assert.NotNull(result.Service); 'So what?' you say, 'it's doing exactly what I want it to!' Yes, but there's more going on here than you'd think: the ConstructorTarget is selecting the best-matched constructor based on the service registrations present in the container when it's asked to Resolve the object. Best-match examples Let's take a bit of deep dive into how Rezolver determines a 'best-match' for the constructor to be called by the container. Example - Best-match (proof) First, to prove that it's the IMyService constructor we bound in the previous example, and not the other one - let's try registering a different implementation of IMyService - one which the class will not support because it'll fail that silly argument type-check in the second constructor of RequiresMyService : var container = new Container(); container.RegisterType<MyAlternateService, IMyService>(); container.RegisterType<RequiresMyService>(); // Proves that the ConstructorTarget is selecting the constructor // based on the available services. Assert.Throws<ArgumentException>(\"service\", () => container.Resolve<RequiresMyService>()); Example - Best-match (fewest params) The best-match algorithm is similar to how a compiler matches a method overload when writing code by hand. The rules aren't necessarily exactly the same as, say, the C# spec, but they're close. At the time the first Resolve call is made, the algorithm will first attempt to select the greediest constructor whose parameters are completely satisfied by services available to the container. Thus, if a class has two constructors - one with 1 parameter and one with 3 parameters - if the single parameter version can be successfully injected, but only 2 of the other constructor's parameters can be, then the single-parameter constructor wins. So, given this type: public class RequiresMyServices { #region Sentinel Instances public static readonly MyService2 Default2 = new MyService2(); public static readonly MyService3 Default3 = new MyService3(); #endregion #region Instance Properties public MyService1 Service1 { get; private set; } public MyService2 Service2 { get; private set; } public MyService3 Service3 { get; private set; } #endregion public RequiresMyServices(MyService1 service1) : this(service1, Default2, Default3) { } public RequiresMyServices(MyService1 service1, MyService2 service2, MyService3 service3) { Service1 = service1; Service2 = service2; Service3 = service3; } } If we register Service1 & Service2 , but not Service3 , the single-parameter constructor will be used: var container = new Container(); // Building ConstructorTargets directly here, // and using the batch-registration 'RegisterAll' method, // which registers against the target's DeclaredType container.RegisterAll( Target.ForType<RequiresMyServices>(), Target.ForType<MyService1>(), Target.ForType<MyService2>()); var result = container.Resolve<RequiresMyServices>(); // Because we didn't have MyService3 registered, the // container will bind the first constructor, which defaults // services 2 & 3: Assert.NotNull(result.Service1); Assert.Same(RequiresMyServices.Default2, result.Service2); Assert.Same(RequiresMyServices.Default3, result.Service3); Example - Best-match (with defaults) When a constructor's parameters have default values, the rules change slightly. The algorithm treats parameters which have defaults as always satisfied, even if a service is not registered of the correct type. So if we extend RequiresMyServices with a new class whose 3-parameter constructor specifies default values for parameters 2 & 3: public class RequiresMyServicesWithDefaults : RequiresMyServices { public RequiresMyServicesWithDefaults(MyService1 service1) : base(service1) { } public RequiresMyServicesWithDefaults(MyService1 service1, MyService2 service2 = null, MyService3 service3 = null) : base(service1, service2 ?? Default2, service3 ?? Default3) { } } And then we swap RequiresMyServices for RequiresMyServicesWithDefaults , this time, the 3-parameter constructor will be executed, with parameters 1 & 2 receiving injected arguments, and parameter 3 receiving the default instance from the base: var container = new Container(); container.RegisterAll( // Note - using .As<T> here to create a ChangeTypeTarget // which makes our .ForType<T> target appear // to be for RequiresMyService // Could also have done: // container.RegisterType<RequiresMyServicesWithDefaults, RequiresMyServices>() Target.ForType<RequiresMyServicesWithDefaults>() .As<RequiresMyServices>(), Target.ForType<MyService1>(), Target.ForType<MyService2>()); var result = container.Resolve<RequiresMyServices>(); // this time all but Service3 will have been injected Assert.NotNull(result.Service1); Assert.NotNull(result.Service2); Assert.NotSame(RequiresMyServices.Default2, result.Service2); Assert.Same(RequiresMyServices.Default3, result.Service3); Tip The use of ChangeTypeTarget (via the As extension method) there might be a little confusing. In truth, we're only sneaking it in here to show some other parts of the framework :) Think of it as being the same as an explicit cast from one type to another - you put a target inside it and tell it what type you want it to be. In the example, we have to use this if we're determined to the use the RegisterAll method(s), because they don't allow us to override the registration type for the targets that we're registering. Example - Best partial match If, however, none of the constructors can be completely satisfied, then we look for the greediest constructor with the most number of successfully resolved arguments. If there's a clear winner, then we proceed with that constructor anyway even though one or more required services are missing. Note You might wonder why we would allow binding even though we can't actually satisfy all the parameters of the constructor, well we'll get to that in a moment. This time, we'll have a type which needs one or two services - either MyService1 or both MyService2 and MyService3 : // Slightly different to before properties are IMyService, but // constructors use concrete types. public class Requires2MyServices { public IMyService First { get; } public IMyService Second { get; } public Requires2MyServices(MyService1 first) { First = first; Second = null; } public Requires2MyServices(MyService2 first, MyService3 second) { First = first; Second = second; } } To force the selection of the second constructor for the test, we'll only register MyService2 in the container and, when we attempt to resolve the instance, we should get an InvalidOperationException explaining that MyService3 couldn't be resolved: var container = new Container(); container.RegisterType<MyService2>(); container.RegisterType<Requires2MyServices>(); var exception = Assert.Throws<InvalidOperationException>( () => container.Resolve<Requires2MyServices>()); // the InvalidOperationException contains the name of the type that // couldn't be resolved Assert.Contains(\"MyService3\", exception.Message); Why we allow partial matches As mentioned in the intro to the last example - it's probably not obvious why we would want to allow binding to a constructor in a container which can't actually fulfil that constructor's requirements! Well, it's clearly not normal , but it's a valid use-case when you consider that Rezolver supports a concept that is typically referred to as 'child containers', except Rezolver calls them 'overriding containers'. A more complete discussion of this functionality will be added to the documentation soon, but in the meantime, let's see two ways in which we could 'fix' the container in the previous test so that it successfully builds an instance of Requires2MyServices . Example - OverridingContainer This is the solution which most closely matches the child container functionality provided by other IOC libraries - take a container which is already 'established' and override it with another container that has its own registrations. The two will work together, sharing registrations when creating instances, so long as the overriding container's Resolve implementation is used: var container = new Container(); container.RegisterType<MyService2>(); container.RegisterType<Requires2MyServices>(); // create an overriding container var containerOverride = new OverridingContainer(container); containerOverride.RegisterType<MyService3>(); // resolve instance via containerOverride var result = containerOverride.Resolve<Requires2MyServices>(); Assert.NotNull(result.First); Assert.NotNull(result.Second); Note If we were to try to resolve from container after creating containerOverride , it would still fail, because it doesn't know anything about the overriding container. Hopefully this should all seem pretty logical. If so, and you're happy simply to accept it, you can skip the next bit. How it works If you're interested in the inner workings when using overriding containers, the process is this: The overridingContainer receives the Resolve call for Requires2MyServices It looks inside its Targets target container for a registration for Requires2MyServices and doesn't find one So the call is passed to the overidden container ... ... which finds its registration and binds to the 2-parameter constructor of Requires2MyServices as before The bound constructor is executed The MyService2 parameter is fulfiled by the container 's own registration But, for the MyService3 parameter, container sees that it was not the container whose Resolve method was originally called (i.e. overridingContainer ), so it forwards the call for MyService3 to overridingContainer . overridingContainer receives the Resolve call for MyService3 It finds its registration, and executes it to get the instance, passing it back to container - thus completing the constructor call for Requires2MyServices Example - ChildTargetContainer This solution is similar to the previous one, except this time we're not overriding the container, but overriding the target container used by a container. Note The choice of name 'ChildTargetContainer' is deliberate, despite the overriding behaviour shown here, because it is more a parent-child relationship than in the previous example. In order to do this, however, we have to change how we create our container. Until now, we've simply been creating a new Container instance and registering targets via its own implementation of ITargetContainer (which, as mentioned elsewhere, wraps its Targets property). This time, we're going to create a TargetContainer directly, register MyService2 and Requires2MyServices in it, then create a ChildTargetContainer on top of that with the other registration of MyService3 . This target container is then passed to the new container on construction. var targets = new TargetContainer(); targets.RegisterType<MyService2>(); targets.RegisterType<Requires2MyServices>(); var childTargets = new ChildTargetContainer(targets); childTargets.RegisterType<MyService3>(); // pass the childTargets ITargetContainer to // the container on construction var container = new Container(childTargets); var result = container.Resolve<Requires2MyServices>(); Assert.NotNull(result.First); Assert.NotNull(result.Second); Why do this? This might seem a little confusing - why would you split target containers like this? Firstly - it's quite an advanced concept, and truly understanding the difference between this and the last example requires a lot of understanding about the internals of Rezolver. Therefore it's more suited to developers who are extending the framework, rather than the average developer who's simply looking to use it to drive their application. The framework itself takes advantage of this functionality throughout in order to override behaviours, or to extend a user-configured container with additional transient targets. The DecoratorTarget wouldn't work without this functionality, for example. Also, if you delve into the compiler pipeline, you will be using this functionality all the time. Providing full examples of how you'd leverage this functionality is outside the scope of this topic, but we'll add them to the guide as soon as we've got the rest of the guide complete. Best-match (named args) When using best-match, you can also supply a dictionary of named argument bindings (as a dictionary of ITarget s) which can be used to provide a hint as to your preferred constructor and, more crucially, override the default behaviour of resolving every argument from container. You don't need to provide all named arguments, the binder will use as many as it can and auto-bind the rest. Example - Supplying a DateTime To demonstrate this, we'll have a new type which requires an IMyService and also accepts a DateTime . DateTime s and other primitive types ( string s etc) are typically not great for use in IOC containers, because you can only have one of them registered (or one collection) unless you start using overriding containers or child target containers, which means you typically can only allow one type to have them as dependencies. public class RequiresIMyServiceAndDateTime { public DateTime StartDate { get; } public IMyService Service { get; } public RequiresIMyServiceAndDateTime(IMyService service) : this(service, DateTime.UtcNow) { } public RequiresIMyServiceAndDateTime(IMyService service, DateTime startDate) { Service = service; StartDate = startDate; } } Note that the single parameter constructor defaults the StartDate to DateTime.UtcNow , but in our test, we'll explicitly provide a DateTime which is DateTime.UtcNow.AddDays(1) to create a date in the future: var container = new Container(); container.RegisterType<MyService, IMyService>(); // Currently a couple of different ways to do this - use the // ConstructorTarget's constructor directly with a dictionary, // or use this static method which creates a dictionary from an object // TODO: Will add object overload to the constructor in the future container.Register(Target.ForType<RequiresIMyServiceAndDateTime>( new { // each member of this object must be an ITarget startDate = Target.ForObject(DateTime.UtcNow.AddDays(1)) } )); var result = container.Resolve<RequiresIMyServiceAndDateTime>(); // if the datetime was used, then StartDate will be in the future Assert.True(result.StartDate > DateTime.UtcNow); What happens is that the named arguments contribute to the argument binding process - thus allowing us to 'cheat' and promote a constructor to being a better match than the one that would normally be. Warning Obviously - named argument binding is potentially very brittle - as if the parameter name changes, then the binding will no longer work. In the future, we will also add the ability to supply an ITargetContainer to a ConstructorTarget whose registrations will be used in preference to the main container - thus allowing us simply to register a DateTime in this example, removing the dependency on the parameter name. When you supply ITarget instances up-front to another target in this way, you can use any of the targets in the Rezolver.Targets namespace to supply a value, and they will work as if they were registered in the container. With a ConstructorInfo Instead of relying on the best match algorithm, you can also specify the constructor you want bound up-front, and you can supply parameter bindings too. To illustrate, we'll have a type with a default constructor and one which accepts a service: public class AcceptsOptionalIMyService { public IMyService Service { get; } public AcceptsOptionalIMyService() { } public AcceptsOptionalIMyService(IMyService service) { if (service == null) throw new ArgumentNullException(nameof(service)); Service = service; } } Example - No parameter bindings The first test ignores the registered services and forcibly targets the default constructor: var container = new Container(); container.RegisterType<MyService, IMyService>(); // under best-match, the container would select the greedy constructor, // but we're going to force it to use the default constructor container.Register(new ConstructorTarget( typeof(AcceptsOptionalIMyService).GetConstructor(Type.EmptyTypes) )); var result = container.Resolve<AcceptsOptionalIMyService>(); Assert.Null(result.Service); Example - Pre-bound parameters We can also explicitly bind the parameters of a particular constructor by providing an array of ParameterBinding objects along with a ConstructorInfo . var container = new Container(); // get the constructor: var ctor = typeof(AcceptsOptionalIMyService).GetConstructor(new[] { typeof(IMyService) }); // create parameter bindings var bindings = new[] { new ParameterBinding(ctor.GetParameters()[0], Target.ForType<MyService>() ) }; container.Register(new ConstructorTarget(ctor, parameterBindings: bindings)); var result = container.Resolve<AcceptsOptionalIMyService>(); Assert.NotNull(result.Service); As you can see - using explicitly bound parameters is a little verbose, given the need to find the constructor and then setup those ParameterBinding objects with the correct ParameterInfo s; but it's guaranteed to target the constructor you choose. Next steps See how constructor injection works with generic types Learn how to enable member injection (injecting services into properties and/or fields)"
  },
  "api/Rezolver.IContainer.html": {
    "href": "api/Rezolver.IContainer.html",
    "title": "Interface IContainer | Rezolver IOC Framework",
    "keywords": "Interface IContainer The primary IOC container interface in the Rezolver framework. Inherited Members IServiceProvider.GetService(Type) IScopeFactory.CreateScope() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public interface IContainer : IServiceProvider, IScopeFactory Remarks Instances of objects (typically known as 'services' in IOC-speak) are resolved via the Resolve(ResolveContext) or TryResolve(ResolveContext, out Object) methods. You can introspect the container to check in advance whether a given type can be resolved through the CanResolve(ResolveContext) method. Lifetime scoping (where IDisposable objects are created within a scope and destroyed when that scope is destroyed) can be achieved by obtaining a new scope through the object's implementatio of the CreateScope() method; although a container might also implement the IScopedContainer interface, in which case the container itself is a lifetime scope. Many of the functions which accept a ResolveContext also have alternatives (in the form of extension methods) in the ContainerResolveExtensions class. If you're looking for the 'traditional' IOC container methods (e.g. Resolve<TObject>(IContainer) , that's where you'll find them. Note that while the standard implementation of this interface supplied by the framework ( ContainerBase and its derivatives) all utilitise the ITargetContainer to actually locate registrations for types which are ultimately requested from the container; the interface doesn't actually mandate that pattern. Methods | Improve this Doc View Source CanResolve(ResolveContext) Returns true if a resolve operation for the given context will succeed. If you're going to be calling Resolve(ResolveContext) immediately afterwards, consider using the TryResolve(ResolveContext, out Object) method instead, which allows you to check and obtain the result at the same time. Declaration bool CanResolve(ResolveContext context) Parameters Type Name Description ResolveContext context The resolve context. Returns Type Description Boolean true if this instance can resolve a type for the specified context; otherwise, false . | Improve this Doc View Source FetchCompiled(ResolveContext) Fetches the ICompiledTarget for the given context, whose GetObject(ResolveContext) method would ultimately be called if the same context was passed to Resolve(ResolveContext) or TryResolve(ResolveContext, out Object) . Declaration ICompiledTarget FetchCompiled(ResolveContext context) Parameters Type Name Description ResolveContext context The context. Returns Type Description ICompiledTarget Remarks This is not typically a method that you're likely to use as the consumer of an IContainer . It's more typically used by implementations of ITargetCompiler or implementations of IContainer when communicating with other containers. As such, its use at an application level is limited. | Improve this Doc View Source Resolve(ResolveContext) Called to resolve a reference to an object for the given context (which provides the RequestedType of the object that is required, among other things). Declaration object Resolve(ResolveContext context) Parameters Type Name Description ResolveContext context The context. Returns Type Description Object The resolved object, if successful. Exceptions Type Condition InvalidOperationException If the requested type cannot be resolved. | Improve this Doc View Source TryResolve(ResolveContext, out Object) Merges the CanResolve(ResolveContext) and Resolve(ResolveContext) operations into one operation. Declaration bool TryResolve(ResolveContext context, out object result) Parameters Type Name Description ResolveContext context The context. Object result Receives the resultant resolved object if the operation succeeds. Returns Type Description Boolean true if the operation succeeded (the resolved object will be set into the result parameter); false otherwise. Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.ObjectTargetContainerExtensions.html": {
    "href": "api/Rezolver.ObjectTargetContainerExtensions.html",
    "title": "Class ObjectTargetContainerExtensions | Rezolver IOC Framework",
    "keywords": "Class ObjectTargetContainerExtensions Extensions for ITargetContainer relating to registering concrete instances via the ObjectTarget target. Inheritance Object ObjectTargetContainerExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public static class ObjectTargetContainerExtensions Methods | Improve this Doc View Source RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) Registers an instance to be used when resolve a particular service type via the ObjectTarget Declaration public static void RegisterObject(this ITargetContainer targetContainer, object obj, Type declaredType = null, Type serviceType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description ITargetContainer targetContainer The target container which will receive the registration. Object obj Required, but can be null . The instance that will be resolved when the service type is requested. Type declaredType Type to be set as the DeclaredType of the ObjectTarget that is created for obj , if different from the object's type. Type serviceType The service type against which this object is to be registered, if different from declaredType (or the object's type). ScopeBehaviour scopeBehaviour Sets the ScopeBehaviour for the ObjectTarget that's created Remarks null objects are implicitly treated as Object if declaredType is not passed. | Improve this Doc View Source RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) Registers an instance to be used when resolving a particular service type via the ObjectTarget target. Declaration public static void RegisterObject<T>(this ITargetContainer targetContainer, T obj, Type declaredType = null, Type serviceType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description ITargetContainer targetContainer The target container which will receive the registration. T obj The instance that will be resolved when the service type is requested. Type declaredType Type to be set as the DeclaredType of the ObjectTarget that is created for obj , if different from T . Type serviceType The service type against which this object is to be registered, if different from T . ScopeBehaviour scopeBehaviour Sets the ScopeBehaviour for the ObjectTarget that's created Type Parameters Name Description T Type of the object - will be used as the service type for registration if serviceType is not provied. Remarks By default, the DeclaredType of the ObjectTarget that is created is fixed to T - use the declaredType parameter to override this if T is a less specific type than the one for which you wish to create a registration."
  },
  "api/Rezolver.OverridingContainer.html": {
    "href": "api/Rezolver.OverridingContainer.html",
    "title": "Class OverridingContainer | Rezolver IOC Framework",
    "keywords": "Class OverridingContainer An IContainer which can override the resolve operations of another. This is useful when you have a core application-wide container, with some objects being customised based on some ambient information, e.g. configuration, MVC Area/Controller, Brand (in a multi-tenant application for example) or more. Inheritance Object ContainerBase CachingContainerBase Container OverridingContainer Inherited Members CachingContainerBase.GetCompiledRezolveTarget(ResolveContext) ContainerBase.NoChangeCompilerConfiguration ContainerBase.GetMissingTarget(Type) ContainerBase.IsMissingTarget(ICompiledTarget) ContainerBase.Targets ContainerBase.Resolve(ResolveContext) ContainerBase.TryResolve(ResolveContext, Object) ContainerBase.CreateScope() ContainerBase.FetchCompiled(ResolveContext) ContainerBase.IServiceProvider.GetService(Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) ContainerBase.ITargetContainer.Fetch(Type) ContainerBase.ITargetContainer.FetchAll(Type) ContainerBase.ITargetContainer.CombineWith(ITargetContainer, Type) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver Assembly :rezolver-docfx.dll Syntax public class OverridingContainer : Container, IContainer, IServiceProvider, IScopeFactory, ITargetContainer Remarks When overriding another IContainer , you are overriding the ICompiledTarget objects that will be returned when FetchCompiled(ResolveContext) is called on that container and, therefore, the compiled target which is executed when the Resolve(ResolveContext) method is called. This has the side effect of overriding automatically resolved arguments (bound to a ResolvedTarget ) compiled in the overridden container by virtue of the fact that the overriding container is a different reference, because the ResolvedTarget is typically compiled with a check, at resolve-time, that the Container is the same container as the one that was active when it was originally compiled. In essence, when resolving an instance as a dependency the ResolvedTarget does something like this: resolveContext.Container == compileContext.Container ? (execute compile-time target) : resolveContext.Container.Resolve(type) Constructors | Improve this Doc View Source OverridingContainer(IContainer, ITargetContainer, ICompilerConfigurationProvider) Creates a new instance of the OverridingContainer Declaration public OverridingContainer(IContainer inner, ITargetContainer targets = null, ICompilerConfigurationProvider compilerConfig = null) Parameters Type Name Description IContainer inner Required. The inner container that this one combines with. Any dependencies not served by the new combined container's own targets will be sought from this container. Equally, any targets in the base which are resolved when the overriding container is the root container for a resolve operation, will resolve their dependencies from this container. ITargetContainer targets Optional. A specific target container to be used for this container's own registrations. ICompilerConfigurationProvider compilerConfig Optional. An object which will be used to configure this container and its targets to use a specific compilation strategy. If null (recommended), then the inner container's configuration will be inherited. Methods | Improve this Doc View Source CanResolve(ResolveContext) Called to determine if this container is able to resolve the type specified in the passed context . Declaration public override bool CanResolve(ResolveContext context) Parameters Type Name Description ResolveContext context Required. The ResolveContext . Returns Type Description Boolean Overrides ContainerBase.CanResolve(ResolveContext) | Improve this Doc View Source GetFallbackCompiledRezolveTarget(ResolveContext) Overrides the base implementation to pass the lookup for an ITarget to the inner container - this is how dependency chaining from this container to the inner container is achieved. Declaration protected override ICompiledTarget GetFallbackCompiledRezolveTarget(ResolveContext context) Parameters Type Name Description ResolveContext context Required. The ResolveContext . Returns Type Description ICompiledTarget Overrides ContainerBase.GetFallbackCompiledRezolveTarget(ResolveContext) Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<ResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<ResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Targets.DecoratorTarget.html": {
    "href": "api/Rezolver.Targets.DecoratorTarget.html",
    "title": "Class DecoratorTarget | Rezolver IOC Framework",
    "keywords": "Class DecoratorTarget Represents the action of implementing a common DecoratedType by decorating one instance (produced by DecoratedTarget ) with another ( InnerTarget , which will create an instance of DecoratorType ). NOTE - You shouldn't register or otherwise create instances of this target unless you absolutely know what you're doing. Rather, decorators should be registered using the extension method RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) or its non-generic alternative because the target needs a DecoratingTargetContainer to work properly (the creation of which is automatically handled by these extension methods). Inheritance Object TargetBase DecoratorTarget Inherited Members TargetBase.UseFallback TargetBase.SelectScope(ResolveContext) TargetBase.ScopeBehaviour Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Targets Assembly :rezolver-docfx.dll Syntax public class DecoratorTarget : TargetBase, ITarget Constructors | Improve this Doc View Source DecoratorTarget(Type, ITarget, Type) Creates a new instance of the DecoratorTarget type, initialising the InnerTarget to a just-in-time-bound ConstructorTarget for the decoratorType . Declaration public DecoratorTarget(Type decoratorType, ITarget decoratedTarget, Type decoratedType) Parameters Type Name Description Type decoratorType The type which is decorating the decoratedType ITarget decoratedTarget The target which is being decorated Type decoratedType The common type which is being decorated - e.g. IService when the decoratedTarget is bound to the type MyService : IService and the decoratorType is set to MyServiceDecorator : IService . Properties | Improve this Doc View Source DeclaredType Always returns DecoratorType Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source DecoratedTarget Gets the target whose instance will be wrapped (decorated) by the one produced by InnerTarget . Declaration public ITarget DecoratedTarget { get; } Property Value Type Description ITarget | Improve this Doc View Source DecoratedType Gets the underlying type (e.g. a common service interface or base) that is being implemented through decoration. Declaration public Type DecoratedType { get; } Property Value Type Description Type | Improve this Doc View Source DecoratorType Gets the type which is decorating the instance produced by the DecoratedTarget for the common service type DecoratedType Declaration public Type DecoratorType { get; } Property Value Type Description Type | Improve this Doc View Source InnerTarget Gets the target which will create an instance of the DecoratorType Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget Remarks The constructor currently auto-initialises this to a just-in-time-bound ConstructorTarget targetting the DecoratorType by using the Auto(Type, IMemberBindingBehaviour) method. Methods | Improve this Doc View Source SupportsType(Type) Overrides SupportsType(Type) to forward the call to InnerTarget . Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type The type which is to be checked. Returns Type Description Boolean true if the type is compatible with the object created by InnerTarget , false if not. Overrides TargetBase.SupportsType(Type) Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour) See Also TargetBase"
  },
  "api/Rezolver.Targets.DefaultTarget.html": {
    "href": "api/Rezolver.Targets.DefaultTarget.html",
    "title": "Class DefaultTarget | Rezolver IOC Framework",
    "keywords": "Class DefaultTarget A target that simply creates a default instance of a given type. I.e. the same as doing default(type) in C#. Inheritance Object TargetBase DefaultTarget Inherited Members TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.SelectScope(ResolveContext) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Targets Assembly :rezolver-docfx.dll Syntax public class DefaultTarget : TargetBase, ITarget, ICompiledTarget Remarks The type also implements the ICompiledTarget interface for direct resolving. Constructors | Improve this Doc View Source DefaultTarget(Type) Initializes a new instance of the DefaultTarget class. Declaration public DefaultTarget(Type type) Parameters Type Name Description Type type The type. Properties | Improve this Doc View Source DeclaredType Always equal to the type for which the default value will be returned Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source ScopeBehaviour Override of ScopeBehaviour - always returns None . Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour | Improve this Doc View Source Value Gets the actual default value represented by this instance. Declaration public object Value { get; } Property Value Type Description Object Explicit Interface Implementations | Improve this Doc View Source ICompiledTarget.GetObject(ResolveContext) Declaration object ICompiledTarget.GetObject(ResolveContext context) Parameters Type Name Description ResolveContext context Returns Type Description Object Implements ICompiledTarget.GetObject(ResolveContext) Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Targets.html": {
    "href": "api/Rezolver.Targets.html",
    "title": "Namespace Rezolver.Targets | Rezolver IOC Framework",
    "keywords": "Namespace Rezolver.Targets Classes ChangeTypeTarget This target is specifically used for explicitly casting the result of one target to another type. Its use is rare, since the framework already caters for downcasting the result of targets to base types. ConstructorTarget A target that binds to a type's constructor with zero or more arguments supplied by other ITarget s and, optionally binding to the new instance's writeable properties. The target supports en explicitly supplied constructor, as well as just-in-time lookups for the best available constructor based on the available services and/or any named arguments which might been provided up front. DecoratorTarget Represents the action of implementing a common DecoratedType by decorating one instance (produced by DecoratedTarget ) with another ( InnerTarget , which will create an instance of DecoratorType ). NOTE - You shouldn't register or otherwise create instances of this target unless you absolutely know what you're doing. Rather, decorators should be registered using the extension method RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) or its non-generic alternative because the target needs a DecoratingTargetContainer to work properly (the creation of which is automatically handled by these extension methods). DefaultTarget A target that simply creates a default instance of a given type. I.e. the same as doing default(type) in C#. DelegateTarget An ITarget which resolve objects by executing a delegate with argument injection. ExpressionTarget A generic target for all expressions not explicitly supported by a particular target. Enables more complex behaviours to be registered and used with the more formal ITarget implementations. GenericConstructorTarget Equivalent of ConstructorTarget but for open generic types. So, this will handle the open generic MyType<,>, for example, whereas ConstructorTarget would handle the closed type MyType<int, string>. GenericConstructorTarget.GenericTypeMapping Result returned from the MapType(Type) function. Represents various levels of success - from a completely incompatible mapping ( Success = false ), or a successful mapping from an open generic type to a closed generic type which can then be constructed ( Success = true and IsFullyBound = true ) or, a successful mapping from an open generic type to another open generic type ( Success = true but IsFullyBound = false ). This mapping is then used by both the SupportsType(Type) and Bind(ICompileContext) functions. Only fully bound mappings are supported by Bind(ICompileContext) , whereas SupportsType(Type) will return true so long as the Success is true. The caller, therefore, must ensure it is aware of the difference between open and closed generics. ListTarget This target produces arrays ( AsArray = true ) or lists ( AsArray = false ) whose individual items are built by ITarget instances. Primarily used by the Rezolver.EnumerableTargetContainer and the configuration framework, but can also be used by your code. ObjectTarget Implements ITarget by wrapping a single instance that's already been constructed by application code. OptionalParameterTarget Used specifically when binding arguments to method parameters when a parameter is optional and its default value is to be used when binding to it. It is highly unlikely you'll ever create one of these directly. ResolvedTarget Represents a target that is rezolved statically at compile time via the ICompileContext , or dynamically (at 'resolve time') from the IContainer that is attached to the current ResolveContext when Resolve(ResolveContext) is called. This is the most common way that we bind constructor parameters, for example - i.e. 'I want an IService instance - go get it'. ScopedTarget A target that produces or fetches a single instance of an object within a lifetime scope. SingletonTarget A target which applies the singleton pattern to any ITarget . The inner target is available from the InnerTarget property. TargetBase Abstract base class, suggested as a starting point for implementations of ITarget . UnscopedTarget Wraps another target to force scoping to be ignored for the object that it produces, regardless of whether that object is IDisposable or otherwise has its own scoping behaviour."
  },
  "api/Rezolver.html": {
    "href": "api/Rezolver.html",
    "title": "Namespace Rezolver | Rezolver IOC Framework",
    "keywords": "Namespace Rezolver Classes AliasTargetContainerExtensions Contains extension methods for ITargetContainer to create targets which alias others by different types. CachingContainerBase Builds on the ContainerBase base class to introduce thread-safe caching of compiled targets so they are only compiled once per requested type. Only creatable through inheritance. ChildTargetContainer A version of TargetContainer which overrides the registrations of another (the Parent ). ConstructorBinding Represents a binding specifically to a class constructor, optionally with an additional set of MemberBindings to be used to initialise a new instance's properties or fields directly. Container The standard IOC container class in Rezolver. ContainerBase Starting point for implementations of IContainer - only creatable through inheritance. ContainerBase.DirectResolveCompiledTarget Used when an ITarget is also of the same type as the one for which it is returned by the Fetch(Type) method of the Targets container. In this case, the target is not compiled, but instead is simply returned as the desired object. ContainerBase.MissingCompiledTarget Used as a sentinel type when a type cannot be resolved by a ContainerBase instance. Instead of returning a null ICompiledTarget instance, the container will construct an instance of this type (typically through GetMissingTarget(Type) , which caches singleton instances of this class on a per-type basis) which can then be used just as if the lookup succeeded. ContainerResolveExtensions Extension methods for IContainer which provide shortcuts for the Resolve(ResolveContext) operation. ContainerScope Standard implementation of the IContainerScope interface. ContainerScopeExtensions Standard extensions for the IContainerScope ContainerScopeResolveExtensions Extensions for IContainerScope so that instances of that interface present a similar set of functionality to IContainer . DecoratingTargetContainer Implements service decoration in an ITargetContainer , producing instances of the DecoratorTarget when Fetch(Type) or FetchAll(Type) are called. The best way to add a decorator to your target container is to use the extension method RegisterDecorator<TDecorator, TDecorated>(ITargetContainerOwner) or its non-generic equivalent. DecoratorTargetContainerExtensions Extensions for ITargetContainerOwner which simplify the registration of decorators (via the DecoratingTargetContainer pseudo-target) DefaultMemberBindingBehaviour WILL BE RENAMED TO AllMembersBindingBehaviour IN 1.2 - SEE https://github.com/ZolutionSoftware/Rezolver/issues/7 FOR MORE The default implementation of IMemberBindingBehaviour when you are creating a ConstructorTarget or GenericConstructorTarget and you want publicly writable properties and public fields to be assigned values obtained from the container. If you do not require properties or fields to be bound from the container, then use a null IMemberBindingBehaviour . DelegateTargetContainerExtensions Extension methods for ITargetContainer designed to simplify the registration of DelegateTarget and its numerous generic variants. EnumerableTargetBuilderExtensions Houses an extension method which enables native resolving of IEnumerables of services on ITargetContainer containers which, in turn, enables it for any ContainerBase containers which use that target container. ExceptionResources A strongly-typed resource class, for looking up localized strings, etc. ExpressionFunctions This type is only used when using expressions as targets(via the ExpressionTarget type) - it's functions serve no actual purpose other than to act as hooks to create specific ITarget objects in place of static code. All the functions will throw a NotImplementedException if called at runtime. ExpressionTargetContainerExtensions Extensions for to simplify registering expressions in an ITargetContainer . GenericTargetContainer A special type of ITargetContainerOwner which stores targets (and potentially other containers) which are specifically keyed either to a particular open generic type or a closed generic built from it. MemberBinding Represents the binding of an ITarget to a property or field of a given type. Not to be confused with the type of the same name from the System.Linq.Expressions namespace, although they are technically equivalent. MethodBinding Represents a binding to a method whose arguments will be supplied by ITarget instances. MethodCallExtractor Used to help grab method and constructor info from expressions (which is easier than writing long strings of reflection code). For example: MethodCallExtractor.ExtractCalledMethod(() => Console.WriteLine(\"foo\")) Will return the MethodInfo for the WriteLine method of the Console class. MultipleTargetContainerExtensions Extensions for registering multiple targets individually and against the same type ObjectTargetContainerExtensions Extensions for ITargetContainer relating to registering concrete instances via the ObjectTarget target. OverridingContainer An IContainer which can override the resolve operations of another. This is useful when you have a core application-wide container, with some objects being customised based on some ambient information, e.g. configuration, MVC Area/Controller, Brand (in a multi-tenant application for example) or more. ParameterBinding Represents a binding between a method parameter and an ITarget RegisterTypeTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for the simplest cases of registering ConstructorTarget and GenericConstructorTarget targets. ResolveContext Captures the state for a call to Resolve(ResolveContext) (or TryResolve(ResolveContext, out Object) ), including the container on which the operation is invoked, any IScopedContainer that might be active for the call (if different), and the type that is being resolved from the IContainer . ScopedContainer Extends the Container to implement lifetime implicit scoping through the Scope that's created along with it. Implementation of the IScopedContainer interface. ScopedTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for registering constructor-injected types whose lifetimes are slaved to that of a parent IScopedContainer . All of the extension methods ultimately create a ScopedTarget SingletonTargetContainerExtensions Extension methods for the ITargetContainer interface which simplify the registration of singletons. Target Provides static factory methods (including extension methods) for creating numerous types of targets from the Rezolver.Targets namespace. TargetContainer Root container for ITarget s that can be used as the backing for the standard IContainer classes - Container and ScopedContainer . Stores and retrieves registrations of ITarget s, is also Generic type aware, unlike its base class - TargetDictionaryContainer . TargetCreationExtensions Has been replaced by the Target static class, and will be removed in 1.2 TargetDictionaryContainer An ITargetContainerOwner implementation that stores and retrieves ITarget and ITargetContainer by type. TargetListContainer An ITargetContainer that stores multiple targets in a list. This is not a type that you would typically use directly in your code, unless you are writing custom logic/behaviour for ITarget registration. Interfaces IChildTargetContainer An ITargetContainer that inherits all registrations from a ( Parent ) target container. If it cannot resolve a target for a particular type, will defer to its parent for fallback. ICompiledTarget Provides an abstraction for creating objects based on a given ResolveContext - this is the ultimate target of all Resolve(ResolveContext) calls in the standard container implementations within the Rezolver framework. IContainer The primary IOC container interface in the Rezolver framework. IContainerScope This is an IContainer -like object (resolving functionality is provided through the extension methods in the ContainerScopeResolveExtensions class) which provides lifetime scoping for disposable objects, and scoped singleton functionality for any object. Implementations of this interface must, in their implementation of IScopeFactory , create a child scope of this scope. IMemberBindingBehaviour Describes a type which discovers and creates property/field bindings, typically for use when creating a new instance. IScopedContainer An IContainer that also has a Scope attached to it. Many applications will use such a container as the root container to use as anchors for things like scoped singletons. IScopeFactory Represents an object from which a scope can be created ITarget Represents an action to be performed in order to obtain an object to satisfy a call to Resolve(ResolveContext) , when the standard implementations of IContainer are used (e.g. Container ). ITargetContainer Stores and retrieves ITarget instances, keyed by the type of service that the targets are registered against. This is where all your service registrations will ultimately go. ITargetContainerOwner Interface for an ITargetContainer which also contains other target containers. It is not typically used by your application code since it's primarily an infrastructure interface - if you are extending the API, however, then you might need to work with it. Enums ScopeBehaviour Describes different ways in which objeects interact with scopes."
  },
  "api/Rezolver.Compilation.Expressions.ConstructorTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ConstructorTargetBuilder.html",
    "title": "Class ConstructorTargetBuilder | Rezolver IOC Framework",
    "keywords": "Class ConstructorTargetBuilder An IExpressionBuilder specialised for building the target ConstructorTarget Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ConstructorTarget > ConstructorTargetBuilder Inherited Members ExpressionBuilderBase<ConstructorTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ConstructorTarget>.IExpressionBuilder<ConstructorTarget>.Build(ConstructorTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ConstructorTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class ConstructorTargetBuilder : ExpressionBuilderBase<ConstructorTarget>, IExpressionBuilder<ConstructorTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ConstructorBinding, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the specified ConstructorBinding . Called by Build(ConstructorTarget, IExpressionCompileContext, IExpressionCompiler) Declaration protected virtual Expression Build(ConstructorBinding binding, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ConstructorBinding binding The binding. IExpressionCompileContext context The context. IExpressionCompiler compiler The compiler to be used to build the target. Returns Type Description Expression Remarks The returned expression will either be a NewExpression or a MemberInitExpression | Improve this Doc View Source Build(ConstructorTarget, IExpressionCompileContext, IExpressionCompiler) Override of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Declaration protected override Expression Build(ConstructorTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ConstructorTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The compiler to be used to build the target Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ConstructorTarget>.Build(Rezolver.Targets.ConstructorTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.DecoratorTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.DecoratorTargetBuilder.html",
    "title": "Class DecoratorTargetBuilder | Rezolver IOC Framework",
    "keywords": "Class DecoratorTargetBuilder Specialised builder for DecoratorTarget targets. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < DecoratorTarget > DecoratorTargetBuilder Inherited Members ExpressionBuilderBase<DecoratorTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DecoratorTarget>.IExpressionBuilder<DecoratorTarget>.Build(DecoratorTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DecoratorTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class DecoratorTargetBuilder : ExpressionBuilderBase<DecoratorTarget>, IExpressionBuilder<DecoratorTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(DecoratorTarget, IExpressionCompileContext, IExpressionCompiler) Creates a new compilation context, registers the target's DecoratedTarget into it as the correct target for the DecoratedType , and then builds the expression for the InnerTarget (which is typically a constructor target). Declaration protected override Expression Build(DecoratorTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description DecoratorTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.DecoratorTarget>.Build(Rezolver.Targets.DecoratorTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.IExpressionBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.IExpressionBuilder.html",
    "title": "Interface IExpressionBuilder | Rezolver IOC Framework",
    "keywords": "Interface IExpressionBuilder The interface for an object that produces expressions (which can be compiled to delegates) from ITarget instances. Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public interface IExpressionBuilder Methods | Improve this Doc View Source Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the specified target. Declaration Expression Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler = null) Parameters Type Name Description ITarget target The target for which an expression is to be built IExpressionCompileContext context The compilation context. IExpressionCompiler compiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the builder should attempt to fetch the compiler from the context; or throw an exception if it is required but not provided and cannot be resolved fromm the context. Returns Type Description Expression Remarks When invoked by the ExpressionCompiler class, the compiler parameter will always be provided. | Improve this Doc View Source CanBuild(ITarget, IExpressionCompileContext) Determines whether this instance can build an expression for the specified target. Declaration bool CanBuild(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context The compilation context. Returns Type Description Boolean Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  },
  "api/Rezolver.Compilation.Expressions.SingletonTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.SingletonTargetBuilder.html",
    "title": "Class SingletonTargetBuilder | Rezolver IOC Framework",
    "keywords": "Class SingletonTargetBuilder An IExpressionBuilder specialised for the building the expression for a SingletonTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < SingletonTarget > SingletonTargetBuilder Inherited Members ExpressionBuilderBase<SingletonTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<SingletonTarget>.IExpressionBuilder<SingletonTarget>.Build(SingletonTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<SingletonTarget>.CanBuild(ITarget, IExpressionCompileContext) ExpressionBuilderBase.IContainerScope_Resolve_Method ExpressionBuilderBase.ITarget_SelectScope_Method ExpressionBuilderBase.ResolveContext_CreateNew_Method_Type ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(ScopeBehaviour, Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace :Rezolver.Compilation.Expressions Assembly :rezolver-docfx.dll Syntax public class SingletonTargetBuilder : ExpressionBuilderBase<SingletonTarget>, IExpressionBuilder<SingletonTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(SingletonTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(SingletonTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description SingletonTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.SingletonTarget>.Build(Rezolver.Targets.SingletonTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Extension Methods TargetCreationExtensions.AsObjectTarget<T>(T, Type, ScopeBehaviour)"
  }
}