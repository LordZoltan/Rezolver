{
  "api/Rezolver.IMemberBindingBehaviour.html": {
    "href": "api/Rezolver.IMemberBindingBehaviour.html",
    "title": "Interface IMemberBindingBehaviour | Rezolver IOC",
    "keywords": "Interface IMemberBindingBehaviour Describes a type which discovers and creates property/field bindings, typically for use when creating a new instance. Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface IMemberBindingBehaviour Methods | Improve this Doc View Source GetMemberBindings(ICompileContext, Type) Retrieves the property and/or field bindings for the given type based on the given context . Declaration MemberBinding[] GetMemberBindings(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The current compilation context (will be used to look up ITarget references from its implementation of ITargetContainer Type type The type whose writable members are to be probed. Returns Type Description MemberBinding [] Zero or more bindings for the members of the type . See Also BindNoMembersBehaviour BindAllMembersBehaviour MemberBindingBehaviour"
  },
  "api/Rezolver.ICovariantTypeIndex.html": {
    "href": "api/Rezolver.ICovariantTypeIndex.html",
    "title": "Interface ICovariantTypeIndex | Rezolver IOC",
    "keywords": "Interface ICovariantTypeIndex For any type T , there exists a list of zero or more other types with which it is compatible when covariance is supported. This index provides the mechanism by which Rezolver can perform this reverse lookup. Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface ICovariantTypeIndex Remarks In an IOC container, contravariance is signficantly easier to support since the only knowledge required is the type you want to retrieve - e.g. Action&lt;Derived> . To build a list of all the generic versions of Action&lt;> which will be assignment-compatible to that type simply requires walking 'up' the type hierarchy of Derived . Covariance, on the other hand, is the opposite problem. The caller requests a concrete generic type - e.g. Func&lt;Base> - where one or more of the arguments is passed to a covariant type parameter. In this case, there is a theoretically infinite set of types which might be assignment compatible to Base , so how do you determine which versions of Func<>` to search for if there is no registration for the exact type? One way would be iterate all the registrations and filter out only those which are compatible, however this would take up quite a lot of time. Rezolver, instead, uses this index, into which you add concrete types that you know have got at least one registered ITarget . Later, when a generic type is sought, you can call that type up from this index, and it'll return a list of all the known types that have been added which are assignment compatible to that type by virtue of covariance. This index provides two lookups based on types that are registered: pure covariant-compatible types (e.g. IEnumerable&lt;Derived> can be assigned to a reference of type IEnumerable&lt;Base> ) and assignment-compatible types (e.g IEnumerable&lt;Base> can be assigned to a reference of type IEnumerable . When searching for a generic type that matches one in-hand - the covariant compatibility lookup is the one you need. If you are conducting a search for a generic type which has a covariant type parameter (e.g. such as IEnumerable&lt;> then you want the full assignment-compatibility lookup which does covariance as well as base/interface compatibility. Methods | Improve this Doc View Source AddKnownType(Type) Called to add a new known service type to the index which is then mapped back to all the types with which it is assignment compatible via covariance and via base class or interface inheritance. The GetKnownCovariantTypes(Type) will then return the serviceType when called with one of these compatible types. Declaration void AddKnownType(Type serviceType) Parameters Type Name Description Type serviceType The type to be added to the index. | Improve this Doc View Source GetKnownCompatibleTypes(Type) This method returns the same types as GetKnownCovariantTypes(Type) but also adds any other types which are assignment compatible with the serviceType . This includes derived types or types which implement the interface, or other generics which are covariantly compatible via implemented interfaces. This method is suited for use when you are searching for targets for a covariant type parameter - such as looking for targets which can be included in an IEnumerable&lt;T> (which is exactly what Rezolver does for enumerables). In this case, the order is most to least recent covariants, followed by most to least recent derived types. Declaration IEnumerable<Type> GetKnownCompatibleTypes(Type serviceType) Parameters Type Name Description Type serviceType The type for which all assignment-compatible known types are sought. Returns Type Description System.Collections.Generic.IEnumerable < Type > A non-null (possibly empty) enumerable of types which have been previously been added to the index via a call to AddKnownType(Type) and which are covariantly compatible with serviceType either directly or by inheritance. | Improve this Doc View Source GetKnownCovariantTypes(Type) This method returns all types, in order of most to least recently added - that have been added via the AddKnownType(Type) method and which are of the same generic type but which have one or more type arguments that are reference compatible to those in the passed serviceType . So, if you pass Func&lt;Base> then you might get back Func&lt;Derived> if it has been added. Declaration IEnumerable<Type> GetKnownCovariantTypes(Type serviceType) Parameters Type Name Description Type serviceType The type for which covariantly compatible known types are sought. Returns Type Description System.Collections.Generic.IEnumerable < Type > A non-null (possibly empty) enumerable of types which have been previously been added to the index via a call to AddKnownType(Type) and which are covariantly compatible with serviceType ."
  },
  "api/Rezolver.Events.TargetContainerRegisteredEvent.html": {
    "href": "api/Rezolver.Events.TargetContainerRegisteredEvent.html",
    "title": "Class TargetContainerRegisteredEvent | Rezolver IOC",
    "keywords": "Class TargetContainerRegisteredEvent Inheritance Object TargetContainerRegisteredEvent Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Events Assembly : Rezolver.dll Syntax public sealed class TargetContainerRegisteredEvent Constructors | Improve this Doc View Source TargetContainerRegisteredEvent(ITargetContainer, Type) Declaration public TargetContainerRegisteredEvent(ITargetContainer targetContainer, Type type) Parameters Type Name Description ITargetContainer targetContainer Type type Properties | Improve this Doc View Source TargetContainer Declaration public ITargetContainer TargetContainer { get; } Property Value Type Description ITargetContainer | Improve this Doc View Source Type Declaration public Type Type { get; } Property Value Type Description Type"
  },
  "api/Rezolver.DelegateTargetContainerExtensions.html": {
    "href": "api/Rezolver.DelegateTargetContainerExtensions.html",
    "title": "Class DelegateTargetContainerExtensions | Rezolver IOC",
    "keywords": "Class DelegateTargetContainerExtensions Extension methods for ITargetContainer designed to simplify the registration of DelegateTarget and its numerous generic variants. Inheritance Object DelegateTargetContainerExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class DelegateTargetContainerExtensions Methods | Improve this Doc View Source RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) Constructs a DelegateTarget from the passed factory delegate (optionally with the given declaredType ) and registers it in the target container. Declaration public static void RegisterDelegate(this ITargetContainer targetContainer, Delegate factory, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targetContainer The target container in which the new target is to registered Delegate factory The factory delegate that is to be executed by the DelegateTarget that is created. Type declaredType Optional - if provided, then it overrides the DeclaredType of the DelegateTarget that is created which, in turn, will change the type against which the target will be registered in the target container. If null, then the return type of the factory will be used. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the factory delegate will be tracked if the target is executed within an IContainerScope . The default is Implicit . | Improve this Doc View Source RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) Registers a DelegateTarget built from a parameterless factory delegate which returns an instance of TResult Declaration public static void RegisterDelegate<TResult>(this ITargetContainer targets, Func<TResult> factory, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered System.Func <TResult> factory Required. The factory delegate which is to be executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the factory delegate will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description TResult The type of the object produced by the factory delegate. | Improve this Doc View Source RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) Registers a DelegateTarget built from a factory delegate which takes an IResolveContext and which returns an instance of TResult Declaration public static void RegisterDelegate<TResult>(this ITargetContainer targets, Func<IResolveContext, TResult> factory, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered System.Func < IResolveContext , TResult> factory Required. The factory delegate which is to be executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the factory delegate will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description TResult The type of the object produced by the factory delegate. | Improve this Doc View Source RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) Registers a DelegateTarget built from a factory delegate which takes 1 argument and which returns an instance of TResult Declaration public static void RegisterDelegate<T1, TResult>(this ITargetContainer targets, Func<T1, TResult> factory, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered System.Func <T1, TResult> factory Required. The factory delegate which is to be executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the factory delegate will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st delegate parameter TResult The type of the object produced by the factory delegate. | Improve this Doc View Source RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) Registers a DelegateTarget built from a factory delegate which takes 2 arguments and which returns an instance of TResult Declaration public static void RegisterDelegate<T1, T2, TResult>(this ITargetContainer targets, Func<T1, T2, TResult> factory, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered System.Func <T1, T2, TResult> factory Required. The factory delegate which is to be executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the factory delegate will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st delegate parameter T2 Type of the 2nd delegate parameter TResult The type of the object produced by the factory delegate. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) Registers a DelegateTarget built from a factory delegate which takes 3 arguments and which returns an instance of TResult Declaration public static void RegisterDelegate<T1, T2, T3, TResult>(this ITargetContainer targets, Func<T1, T2, T3, TResult> factory, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered System.Func <T1, T2, T3, TResult> factory Required. The factory delegate which is to be executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the factory delegate will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st delegate parameter T2 Type of the 2nd delegate parameter T3 Type of the 3rd delegate parameter TResult The type of the object produced by the factory delegate. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) Registers a DelegateTarget built from a factory delegate which takes 4 arguments and which returns an instance of TResult Declaration public static void RegisterDelegate<T1, T2, T3, T4, TResult>(this ITargetContainer targets, Func<T1, T2, T3, T4, TResult> factory, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered System.Func <T1, T2, T3, T4, TResult> factory Required. The factory delegate which is to be executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the factory delegate will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st delegate parameter T2 Type of the 2nd delegate parameter T3 Type of the 3rd delegate parameter T4 Type of the 4th delegate parameter TResult The type of the object produced by the factory delegate. | Improve this Doc View Source RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) Registers a DelegateTarget built from a factory delegate which takes 5 arguments and which returns an instance of TResult Declaration public static void RegisterDelegate<T1, T2, T3, T4, T5, TResult>(this ITargetContainer targets, Func<T1, T2, T3, T4, T5, TResult> factory, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered System.Func <T1, T2, T3, T4, T5, TResult> factory Required. The factory delegate which is to be executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the factory delegate will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st delegate parameter T2 Type of the 2nd delegate parameter T3 Type of the 3rd delegate parameter T4 Type of the 4th delegate parameter T5 Type of the 5th delegate parameter TResult The type of the object produced by the factory delegate."
  },
  "api/Rezolver.Configuration.InjectEnumerables.html": {
    "href": "api/Rezolver.Configuration.InjectEnumerables.html",
    "title": "Class InjectEnumerables | Rezolver IOC",
    "keywords": "Class InjectEnumerables An ITargetContainerConfig which enables automatic handling of fetching targets for System.Collections.Generic.IEnumerable<T> based on all the targets registered for a given T in an ITargetContainer . Inheritance Object OptionDependentConfig < EnableEnumerableInjection > InjectEnumerables Implements ITargetContainerConfig IDependant Inherited Members OptionDependentConfig<EnableEnumerableInjection>.Dependencies System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Configuration Assembly : Rezolver.dll Syntax public sealed class InjectEnumerables : OptionDependentConfig<EnableEnumerableInjection>, ITargetContainerConfig, IDependant Remarks This behaviour is added to the default configuration for all TargetContainer -derived objects via the DefaultConfig . To disable it, you can either remove it from that configuration object (which then disables it for all) or you can add an option configuration to it (via ConfigureOption<TOption>(CombinedTargetContainerConfig, TOption) or similar) for the EnableEnumerableInjection option, setting it to false . If this behaviour is not attached to an ITargetContainer , or is disabled via the EnableEnumerableInjection option, then only explicitly registered enumerables will be able to be resolved by any IContainer built from that target container. Lazy vs Eager evaluation The enumerables created by Rezolver can be lazy or eager. Lazy enumerables create instances as you enumerate them, and will create a unique set of instances each time they are enumerated (assuming no Singleton or Scoped lifetimes are in play). Eager enumerables create all their instances up-front, and remain constant for the life of that enumerable. The LazyEnumerables option (default true ) is used to control this behaviour, and can be applied on a per-enumerable-type basis to an ITargetContainer . E.g. you can set the option to false for IEnumerable<Foo> - thus ensuring that all enumerables of Foo are eager, but leave it at its default of true for all other enumerable types. Properties | Improve this Doc View Source Instance The one and only instance of the InjectEnumerables type. Declaration public static InjectEnumerables Instance { get; } Property Value Type Description InjectEnumerables Methods | Improve this Doc View Source Configure(IRootTargetContainer) Implementation of Configure(IRootTargetContainer) Declaration public override void Configure(IRootTargetContainer targets) Parameters Type Name Description IRootTargetContainer targets Overrides Rezolver.Configuration.OptionDependentConfig<Rezolver.Options.EnableEnumerableInjection>.Configure(Rezolver.IRootTargetContainer) Remarks This implementation registers a special target container (via RegisterContainer(Type, ITargetContainer) ) for System.Collections.Generic.IEnumerable<T> in passed targets if the EnableEnumerableInjection option evaluates to true when read from targets . This is the default value for that option anyway, so, as the remarks section on the class states, all that's required to enable the enumerable resolving behaviour is simply to make sure this configuration object is applied to an IRootTargetContainer Implements ITargetContainerConfig IDependant Extension Methods DependantExtensions.GetDependencies<T, TDependency>(T, IEnumerable<TDependency>) DependantExtensions.CreateTypeDependency<TDependency>(IDependant, Boolean) DependantExtensions.CreateObjectDependency<TDependency>(IDependant, TDependency, Boolean)"
  },
  "api/Rezolver.Configuration.InjectCollections.html": {
    "href": "api/Rezolver.Configuration.InjectCollections.html",
    "title": "Class InjectCollections | Rezolver IOC",
    "keywords": "Class InjectCollections Applying this configuration to an ITargetContainer will enable automatic injection of collection types such as Collection<T> , System.Collections.Generic.ICollection<T> , ReadOnlyCollection<T> and IReadOnlyCollection<T> (so long as there are no registrations for these types in the target container when the configuration is applied). Out of the box, such collections will be seeded by any objects that have been registered against the element type. Inheritance Object OptionDependentConfig < EnableCollectionInjection > InjectCollections Implements ITargetContainerConfig IDependant Inherited Members OptionDependentConfig<EnableCollectionInjection>.Dependencies System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Configuration Assembly : Rezolver.dll Syntax public class InjectCollections : OptionDependentConfig<EnableCollectionInjection>, ITargetContainerConfig, IDependant Remarks As with InjectLists this configuration object has a partner option - EnableCollectionInjection - which can be used to control whether collection injection is actually enabled by this configuration. In normal operation, this configuration is applied by default to TargetContainer and OverridingTargetContainer instances via the DefaultConfig combined config. To use the EnableCollectionInjection option to disable it, you can use the Configure<TOption> configuration to configure the EnableCollectionInjection option to false . The easiest way to do that is via the ConfigureOption<TOption>(CombinedTargetContainerConfig, TOption) extension method or one of its overloads. Requires List Injection Note that because Collection<T> and ReadOnlyCollection<T> both require an instance of System.Collections.Generic.IList<T> in their constructor, the target container MUST also be able to inject an instance of System.Collections.Generic.IList<T> . The best way to do this is to ensure the InjectLists and InjectEnumerables are both enabled (which they are, by default). Properties | Improve this Doc View Source Instance The one and only instance of the InjectCollections configuration. Declaration public static InjectCollections Instance { get; } Property Value Type Description InjectCollections Methods | Improve this Doc View Source Configure(IRootTargetContainer) Adds registrations for Collection<T> and ReadOnlyCollection<T> to the targets (including their primary interfaces) so long as none of the types are already registered. Declaration public override void Configure(IRootTargetContainer targets) Parameters Type Name Description IRootTargetContainer targets Overrides Rezolver.Configuration.OptionDependentConfig<Rezolver.Options.EnableCollectionInjection>.Configure(Rezolver.IRootTargetContainer) Implements ITargetContainerConfig IDependant Extension Methods DependantExtensions.GetDependencies<T, TDependency>(T, IEnumerable<TDependency>) DependantExtensions.CreateTypeDependency<TDependency>(IDependant, Boolean) DependantExtensions.CreateObjectDependency<TDependency>(IDependant, TDependency, Boolean)"
  },
  "api/Rezolver.Compilation.ITargetCompiler.html": {
    "href": "api/Rezolver.Compilation.ITargetCompiler.html",
    "title": "Interface ITargetCompiler | Rezolver IOC",
    "keywords": "Interface ITargetCompiler An object that produces ICompiledTarget s from ITarget s given a particular ICompileContext - for which it also acts as a factory. Namespace : Rezolver.Compilation Assembly : Rezolver.dll Syntax public interface ITargetCompiler Methods | Improve this Doc View Source CompileTarget(ITarget, ICompileContext) Create the ICompiledTarget for the given target using the context to inform the type of object that is to be built, and for compile-time dependency resolution. Declaration ICompiledTarget CompileTarget(ITarget target, ICompileContext context) Parameters Type Name Description ITarget target Required. The target to be compiled. ICompileContext context Required. The compilation context to use for compilation. Obtain this by calling CreateContext(IResolveContext, ITargetContainer) . Returns Type Description ICompiledTarget A compiled target which can then be used to get produce objects represented by the target . | Improve this Doc View Source CreateContext(IResolveContext, ITargetContainer) Creates a compilation context for the given resolveContext - which is used to determine the RequestedType that the eventual ICompiledTarget should return. Declaration ICompileContext CreateContext(IResolveContext resolveContext, ITargetContainer targets) Parameters Type Name Description IResolveContext resolveContext The resolve context - used to get the RequestedType and the Container , and will be set on the ResolveContext property of the returned context. ITargetContainer targets The target container that should be used to lookup other non-compiled targets. Returns Type Description ICompileContext Extension Methods TargetCompilerExtensions.CompileTarget(ITargetCompiler, ITarget, IResolveContext, ITargetContainer)"
  },
  "api/Rezolver.Compilation.Expressions.ScopedTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ScopedTargetBuilder.html",
    "title": "Class ScopedTargetBuilder | Rezolver IOC",
    "keywords": "Class ScopedTargetBuilder An IExpressionBuilder specialised for building expressions for ScopedTarget targets. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ScopedTarget > ScopedTargetBuilder Implements IExpressionBuilder < ScopedTarget > IExpressionBuilder Inherited Members ExpressionBuilderBase<ScopedTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ScopedTarget>.IExpressionBuilder<ScopedTarget>.Build(ScopedTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ScopedTarget>.CanBuild(ITarget) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class ScopedTargetBuilder : ExpressionBuilderBase<ScopedTarget>, IExpressionBuilder<ScopedTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ScopedTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(ScopedTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ScopedTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ScopedTarget>.Build(Rezolver.Targets.ScopedTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Implements IExpressionBuilder<TTarget> IExpressionBuilder"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionBuilderBase.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionBuilderBase.html",
    "title": "Class ExpressionBuilderBase | Rezolver IOC",
    "keywords": "Class ExpressionBuilderBase Abstract starting point for implementing IExpressionBuilder . Note that the interface is implemented explicitly; but exposes protected abstract or virtual methods for inheritors to extend. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase <TTarget> Implements IExpressionBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public abstract class ExpressionBuilderBase : IExpressionBuilder Remarks This class takes care of checking the type requested in the IExpressionCompileContext is compatible with the target that's passed to the Build(ITarget, IExpressionCompileContext, IExpressionCompiler) method Methods | Improve this Doc View Source ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) Called by the BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) method. Applies the scoping behaviour to the builtExpression such that when it is executed it correctly interfaces with the active scope (from the IResolveContext ) if one is present for the scope behaviour and preference determined from the context and target . Declaration protected virtual Expression ApplyScoping(Expression builtExpression, ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description Expression builtExpression The expression that was built for the target . ITarget target The target that is currently being compiled and from which the builtExpression was built. IExpressionCompileContext context The current active compilation context - this context's ScopeBehaviourOverride and ScopePreferenceOverride will be used to override those of the target . IExpressionCompiler compiler The compiler. Returns Type Description Expression | Improve this Doc View Source Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Abstract method used as part implementation of the Build(ITarget, IExpressionCompileContext, IExpressionCompiler) It's called by BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) . Declaration protected abstract Expression Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context The context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression | Improve this Doc View Source BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) The core expression build function - takes care of handling mismatched types between the target and the requested type in the context - both checking compatibility and producing conversion expressions where necessary. Also performs cyclic dependency checking and rewriting expressions to take advantage of a target's ScopeBehaviour (which can be overriden with ScopeBehaviourOverride ) Declaration protected Expression BuildCore(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ITarget target The target to be compiled. IExpressionCompileContext context The context. IExpressionCompiler compiler The compiler. Returns Type Description Expression Remarks This class' implementation of Build(ITarget, IExpressionCompileContext, IExpressionCompiler) calls this, as does the derived abstract class ExpressionBuilderBase<TTarget> for its implementation of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) . It is this function that is responsible for calling the abstract Build(ITarget, IExpressionCompileContext, IExpressionCompiler) function, which deriving classes implement to actually produce their expression for the target . Exceptions Type Condition ArgumentException targetType doesn't support the context's TargetType InvalidOperationException The target is already being compiled. | Improve this Doc View Source CanBuild(ITarget) Abstract method (implementation of CanBuild(ITarget) ) which determines whether this instance can build an expression for the specified target. Declaration public abstract bool CanBuild(ITarget target) Parameters Type Name Description ITarget target The target. Returns Type Description Boolean | Improve this Doc View Source GetContextCompiler(IExpressionCompileContext) Gets the IExpressionCompiler to be used for the given context, if different from one passed to this class' implementation of Build(ITarget, IExpressionCompileContext, IExpressionCompiler) . Declaration protected virtual IExpressionCompiler GetContextCompiler(IExpressionCompileContext context) Parameters Type Name Description IExpressionCompileContext context The current compile context. Returns Type Description IExpressionCompiler Remarks This function is called by BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) which will throw an exception if it returns null and no compiler was provided to BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) (typically via the explicit implementation of IExpressionBuilder ). The base implementation simply attempts to resolve an instance of IExpressionCompiler from the Container of the context's ResolveContext which should, with the default configuration, resolve to the root ExpressionCompiler . In order for this to work, it is imperative that the underlying registered target implements the ICompiledTarget interface - so as to avoid needing a (or, more precisely, this) compiler needing to compile it. Explicit Interface Implementations | Improve this Doc View Source IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Explicit implementation of Build(ITarget, IExpressionCompileContext, IExpressionCompiler) - ultimately forwards the call to the BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) function. Declaration Expression IExpressionBuilder.Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ITarget target The target for which an expression is to be built IExpressionCompileContext context The compilation context. IExpressionCompiler compiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the implementation attempts to locate the context compiler using the GetContextCompiler(IExpressionCompileContext) method, and will throw an InvalidOperationException if it cannot do so. Returns Type Description Expression Exceptions Type Condition ArgumentNullException target is null or context is null InvalidOperationException compiler is null and an IExpressionCompiler couldn't be resolved for the current context (via GetContextCompiler(IExpressionCompileContext) Implements IExpressionBuilder See Also IExpressionBuilder"
  },
  "api/Rezolver.Compilation.Expressions.ConstructorTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ConstructorTargetBuilder.html",
    "title": "Class ConstructorTargetBuilder | Rezolver IOC",
    "keywords": "Class ConstructorTargetBuilder An IExpressionBuilder specialised for building the target ConstructorTarget Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ConstructorTarget > ConstructorTargetBuilder Implements IExpressionBuilder < ConstructorTarget > IExpressionBuilder Inherited Members ExpressionBuilderBase<ConstructorTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ConstructorTarget>.IExpressionBuilder<ConstructorTarget>.Build(ConstructorTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ConstructorTarget>.CanBuild(ITarget) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class ConstructorTargetBuilder : ExpressionBuilderBase<ConstructorTarget>, IExpressionBuilder<ConstructorTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ConstructorBinding, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the specified ConstructorBinding . Called by Build(ConstructorTarget, IExpressionCompileContext, IExpressionCompiler) Declaration protected virtual Expression Build(ConstructorBinding binding, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ConstructorBinding binding The binding. IExpressionCompileContext context The context. IExpressionCompiler compiler The compiler to be used to build the target. Returns Type Description Expression Remarks The returned expression will either be a NewExpression or a MemberInitExpression | Improve this Doc View Source Build(ConstructorTarget, IExpressionCompileContext, IExpressionCompiler) Override of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Declaration protected override Expression Build(ConstructorTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ConstructorTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The compiler to be used to build the target Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ConstructorTarget>.Build(Rezolver.Targets.ConstructorTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Implements IExpressionBuilder<TTarget> IExpressionBuilder"
  },
  "api/Rezolver.CombinedTargetContainerConfig.html": {
    "href": "api/Rezolver.CombinedTargetContainerConfig.html",
    "title": "Class CombinedTargetContainerConfig | Rezolver IOC",
    "keywords": "Class CombinedTargetContainerConfig An ITargetContainerConfig which contains zero or or more other ITargetContainerConfig objects. Configurations can depend on others, and this collection ensures that they are applied in the correct order. Inheritance Object DependantCollection < ITargetContainerConfig > CombinedTargetContainerConfig Implements System.Collections.Generic.IList < ITargetContainerConfig > System.Collections.Generic.ICollection < ITargetContainerConfig > System.Collections.Generic.IEnumerable < ITargetContainerConfig > IEnumerable ITargetContainerConfig Inherited Members DependantCollection<ITargetContainerConfig>.Ordered DependantCollection<ITargetContainerConfig>.Clone<TDerived>() DependantCollection<ITargetContainerConfig>.Replace(ITargetContainerConfig, ITargetContainerConfig) DependantCollection<ITargetContainerConfig>.ReplaceOrAdd(ITargetContainerConfig, ITargetContainerConfig) DependantCollection<ITargetContainerConfig>.ReplaceAnyOrAdd<TOriginal>(ITargetContainerConfig) DependantCollection<ITargetContainerConfig>.ReplaceAnyOrAdd<TOriginal>(Func<IEnumerable<ITargetContainerConfig>, ITargetContainerConfig>) DependantCollection<ITargetContainerConfig>.Item[Int32] DependantCollection<ITargetContainerConfig>.Count DependantCollection<ITargetContainerConfig>.IsReadOnly DependantCollection<ITargetContainerConfig>.Clear() DependantCollection<ITargetContainerConfig>.Contains(ITargetContainerConfig) DependantCollection<ITargetContainerConfig>.CopyTo(ITargetContainerConfig[], Int32) DependantCollection<ITargetContainerConfig>.GetEnumerator() DependantCollection<ITargetContainerConfig>.IndexOf(ITargetContainerConfig) DependantCollection<ITargetContainerConfig>.Insert(Int32, ITargetContainerConfig) DependantCollection<ITargetContainerConfig>.Remove(ITargetContainerConfig) DependantCollection<ITargetContainerConfig>.RemoveAt(Int32) DependantCollection<ITargetContainerConfig>.Add(ITargetContainerConfig) DependantCollection<ITargetContainerConfig>.AddAll(IEnumerable<ITargetContainerConfig>) DependantCollection<ITargetContainerConfig>.AddAll(ITargetContainerConfig[]) DependantCollection<ITargetContainerConfig>.RemoveAll(IEnumerable<ITargetContainerConfig>) DependantCollection<ITargetContainerConfig>.IEnumerable.GetEnumerator() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class CombinedTargetContainerConfig : DependantCollection<ITargetContainerConfig>, IList<ITargetContainerConfig>, ICollection<ITargetContainerConfig>, IEnumerable<ITargetContainerConfig>, IEnumerable, ITargetContainerConfig Constructors | Improve this Doc View Source CombinedTargetContainerConfig() Constructs a new instance of the CombinedTargetContainerConfig type Declaration public CombinedTargetContainerConfig() | Improve this Doc View Source CombinedTargetContainerConfig(ITargetContainerConfig[]) Constructs a new instance of the CombinedTargetContainerConfig type, using the passed configurations to seed the underlying collection. Declaration public CombinedTargetContainerConfig(params ITargetContainerConfig[] configs) Parameters Type Name Description ITargetContainerConfig [] configs The behaviours to be added to the collection on construction. | Improve this Doc View Source CombinedTargetContainerConfig(IEnumerable<ITargetContainerConfig>) Constructs a new instance of the CombinedTargetContainerConfig type, using the passed configurations to seed the underlying collection. Declaration public CombinedTargetContainerConfig(IEnumerable<ITargetContainerConfig> configs) Parameters Type Name Description System.Collections.Generic.IEnumerable < ITargetContainerConfig > configs The behaviours to be added to the collection on construction. Methods | Improve this Doc View Source Clone() Creates a clone of this combined configuration collection and returns it. Declaration public CombinedTargetContainerConfig Clone() Returns Type Description CombinedTargetContainerConfig A new instance of CombinedTargetContainerConfig whose items are identical to the collection on which the method is called. | Improve this Doc View Source Configure(IRootTargetContainer) Applies each configuration in this collection to the passed targets ITargetContainer . Declaration public void Configure(IRootTargetContainer targets) Parameters Type Name Description IRootTargetContainer targets The target container to which the configurations in this collection are to be applied. Remarks The implementation runs through each configuration that has been added to the collection, in dependency order, calling its Configure(IRootTargetContainer) method. Implements System.Collections.Generic.IList<T> System.Collections.Generic.ICollection<T> System.Collections.Generic.IEnumerable<T> IEnumerable ITargetContainerConfig Extension Methods CombinedTargetContainerConfigExtensions.ConfigureOption<TOption>(CombinedTargetContainerConfig, TOption) CombinedTargetContainerConfigExtensions.ConfigureOption<TOption, TService>(CombinedTargetContainerConfig, TOption) CombinedTargetContainerConfigExtensions.ConfigureOption<TOption>(CombinedTargetContainerConfig, Type, TOption) CombinedTargetContainerConfigExtensions.ConfigureOption<TOption>(CombinedTargetContainerConfig, Func<ITargetContainer, TOption>) CombinedTargetContainerConfigExtensions.ConfigureOption<TOption, TService>(CombinedTargetContainerConfig, Func<ITargetContainer, Type, TOption>) CombinedTargetContainerConfigExtensions.ConfigureOption<TOption>(CombinedTargetContainerConfig, Type, Func<ITargetContainer, Type, TOption>) See Also CombinedContainerConfig"
  },
  "api/Microsoft.Extensions.DependencyInjection.RezolverServiceProviderServiceCollectionExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.RezolverServiceProviderServiceCollectionExtensions.html",
    "title": "Class RezolverServiceProviderServiceCollectionExtensions | Rezolver IOC",
    "keywords": "Class RezolverServiceProviderServiceCollectionExtensions Provides the AddRezolver(IServiceCollection, Action<RezolverOptions>) extension method which adds the IServiceProviderFactory service registration for the ITargetContainer service provider builder. Inheritance Object RezolverServiceProviderServiceCollectionExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Rezolver.Microsoft.AspNetCore.Hosting.dll Syntax public static class RezolverServiceProviderServiceCollectionExtensions Methods | Improve this Doc View Source AddRezolver(IServiceCollection, Action<RezolverOptions>) Adds a Rezolver service provider factory to the service collection. Used by the UseRezolver(IWebHostBuilder, Action<RezolverOptions>) extension method. Declaration public static IServiceCollection AddRezolver(this IServiceCollection services, Action<RezolverOptions> configureRezolverOptions = null) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceCollection services Required. The services to be configured. System.Action < RezolverOptions > configureRezolverOptions Optional. Configuration callback to be applied to the RezolverOptions instance that configures the ITargetContainer and IContainer creation process. Note - in order for this to be applied, your application will also need to call the Microsoft.Extensions.DependencyInjection.OptionsServiceCollectionExtensions.AddOptions(Microsoft.Extensions.DependencyInjection.IServiceCollection) extension method (usually in your application's ConfigureServices method). Returns Type Description Microsoft.Extensions.DependencyInjection.IServiceCollection"
  },
  "docs/enumerables/generics.html": {
    "href": "docs/enumerables/generics.html",
    "title": "Enumerables of Generics | Rezolver IOC",
    "keywords": "Enumerables of Generics Now you've seen how Rezolver's automatic enumerable injection works , let's move on to how generics work in the context of enumerable injection. Open Generics You can register multiple open generics of the same type (e.g. IFoo<> ), resolve an enumerable of IFoo<Bar> , and the container will create an enumerable containing an object for each open generic registration: public interface IUsesAnyService<TAnyService> { void UseTheService(TAnyService service); } public class UsesAnyService<TAnyService> : IUsesAnyService<TAnyService> { public void UseTheService(TAnyService service) { throw new NotImplementedException(); } } public class UsesAnyService2<TAnyService> : IUsesAnyService<TAnyService> { public void UseTheService(TAnyService service) { throw new NotImplementedException(); } } var container = new Container(); container.RegisterType(typeof(UsesAnyService<>), typeof(IUsesAnyService<>)); container.RegisterType(typeof(UsesAnyService2<>), typeof(IUsesAnyService<>)); var result = container.ResolveMany<IUsesAnyService<IMyService>>().ToArray(); Assert.Equal(2, result.Length); Assert.IsType<UsesAnyService<IMyService>>(result[0]); Assert.IsType<UsesAnyService2<IMyService>>(result[1]); Constrained Generics When one or more constrained open generic types are registered against an open generic type, Rezolver will only include results from registrations whose target type's constraints are met. public interface IGeneric<T> { } public class GenericAny<T> : IGeneric<T> { } public class GenericAnyIMyService<T> : IGeneric<T> where T: IMyService { } public class GenericAnyMyService1<T> : IGeneric<T> where T: MyService1 { } /// <summary> /// Note - used in the per-service 'best match only' example /// </summary> public class GenericMyService2 : IGeneric<MyService2> { } var container = new Container(); container.RegisterType(typeof(GenericAny<>), typeof(IGeneric<>)); container.RegisterType(typeof(GenericAnyIMyService<>), typeof(IGeneric<>)); container.RegisterType(typeof(GenericAnyMyService1<>), typeof(IGeneric<>)); var anyResult = container.ResolveMany<IGeneric<string>>().ToArray(); var myServiceResult = container.ResolveMany<IGeneric<MyService>>().ToArray(); var myService1Result = container.ResolveMany<IGeneric<MyService1>>().ToArray(); // only the first registration matches IGeneric<string> Assert.Equal(1, anyResult.Length); Assert.IsType<GenericAny<string>>(anyResult[0]); // First and second registrations match IGeneric<MyService> // Note the order: both registrations were IGeneric<> so the constrained generic // appears after the non-constrained one. Assert.Equal(2, myServiceResult.Length); Assert.IsType<GenericAny<MyService>>(myServiceResult[0]); Assert.IsType<GenericAnyIMyService<MyService>>(myServiceResult[1]); // All registrations match and, again, all are returned in order. Assert.Equal(3, myService1Result.Length); Assert.IsType<GenericAny<MyService1>>(myService1Result[0]); Assert.IsType<GenericAnyIMyService<MyService1>>(myService1Result[1]); Assert.IsType<GenericAnyMyService1<MyService1>>(myService1Result[2]); Mixing open/closed generics In many applications which use DI and generics, you often have 'common' open generic registrations, such as those in the first example above , and then specific registrations for one or more well-known closed generics. When resolving a single instance for a given generic, Rezolver will of course select the newest most specific registration it can find. This means that if you have registrations for both IFoo<> and IFoo<Bar> and request an instance of IFoo<Bar> , then the second registration is used. Tip Rezolver's generic type matching works on an inside-out basis, so if you request IGeneric<IFoo<IBar>> from the container, it searches for registrations for the following types, in this order: IGeneric<IFoo<IBar>> IGeneric<IFoo<>> IGeneric<> This search order is the same regardless of the order the registrations are made. So, if an IGeneric<IFoo<IBar>> was the last to be added to the target container, it's still returned first. If, however, you request an IEnumerable<IFoo<Bar>> , what should Rezolver return? The answer is: it depends on your specific need. Sometimes you might want all applicable objects to be returned (the default behaviour), and sometimes you might only want the best-matched registrations (i.e. the first batch of registrations found for one of the generic types being searched, as per the above Tip callout) to be used. The good news is that it's easy to tell Rezolver which of the behaviours you want it to use - both globally and on a per-service basis. All possible generics Note The new default functionality described here represents a breaking change from 1.2. The old behaviour can be re-enabled by setting the FetchAllMatchingGenerics option to false , as shown in the next example. Let's say that we have one open generic registration for IUsesAnyService<> to be used as a catch-all, but that we also have specific implementations we want to use for IUsesAnyService<IMyService> in addition to the catch-all. In this case, we simply need to add one or more registration(s) for the concrete generic type in addition to the open generic registrations, and Rezolver will intelligently select all the generics that apply when building its enumerable. So, given these extra generic types: public class UsesIMyService : IUsesAnyService<IMyService> { public void UseTheService(IMyService service) { throw new NotImplementedException(); } } public class UsesIMyService2 : IUsesAnyService<IMyService> { public void UseTheService(IMyService service) { throw new NotImplementedException(); } } We can do this: var container = new Container(); container.RegisterType(typeof(UsesAnyService<>), typeof(IUsesAnyService<>)); container.RegisterType<UsesIMyService, IUsesAnyService<IMyService>>(); container.RegisterType<UsesIMyService2, IUsesAnyService<IMyService>>(); var result = container.ResolveMany<IUsesAnyService<IMyService>>().ToArray(); var result2 = container.ResolveMany<IUsesAnyService<MyService>>().ToArray(); //Note - enumerable is in registration order, regardless of open/closed generic Assert.Equal(3, result.Length); Assert.IsType<UsesAnyService<IMyService>>(result[0]); Assert.IsType<UsesIMyService>(result[1]); Assert.IsType<UsesIMyService2>(result[2]); Assert.Equal(1, result2.Length); Assert.IsType<UsesAnyService<MyService>>(result2[0]); In the simplest terms, what we're seeing here is the container walking through all the possible generic service types that could apply for the requested type, and returning all the instances produced by all those registrations, in the order that those registrations were made. So, if an open generic registration is made after a series of closed generic registrations, the open registration will still be last in the enumerable. Note This is not the same as when resolving a single instance - which will return the last, best-matched registration for the generic type. So if one or more closed generic registrations exist for the exact type requested, then the one that was added last will be used for the single instance. Also note that Constrained generic implementations are not equal to closed generic registrations. So an explicit registration against IFoo<Bar> will always beat a constrained generic implementation such as MyFoo<T> : IFoo<T> where T : Bar (see further down). Best match only (global) Sometimes, you might only want objects in your enumerable which were registered against the best-matched generic, so, if you have two open generic registrations for IFoo<> but a specific registration for IFoo<Bar> . When requesting an enumerable of IFoo<Baz> , you want the two objects registered against the open generic. However, when you request an enumerable of IFoo<Bar> , you only want one object - from the specific IFoo<Bar> registration. As mentioned in the note in the previous example, to do this, we use the FetchAllMatchingGenerics option to control this globally for a container: var container = new Container(); // same test - we're just setting an option on the container // which changes how generics are matched for the FetchAll() call // which sits behind the automatic enumerable resolving behaviour. container.SetOption<Options.FetchAllMatchingGenerics>(false); container.RegisterType(typeof(UsesAnyService<>), typeof(IUsesAnyService<>)); container.RegisterType<UsesIMyService, IUsesAnyService<IMyService>>(); container.RegisterType<UsesIMyService2, IUsesAnyService<IMyService>>(); // This time, this will only match the second two registrations which // specialise for IUsesAnyService<IMyService> var result = container.ResolveMany<IUsesAnyService<IMyService>>().ToArray(); Assert.Equal(2, result.Length); Assert.IsType<UsesIMyService>(result[0]); Assert.IsType<UsesIMyService2>(result[1]); Best match only (per-service) We can also control this on a per-service basis - simply set the FetchAllMatchingGenerics option to false for a given service type. Here, we're using the same types that we introduced for the constrained generics example , and disabling the 'fetch all' behaviour for a specific closed generic: var container = new Container(); // set this option for the IGeneric<MyService2> service ONLY container.SetOption<Options.FetchAllMatchingGenerics>(false, typeof(IGeneric<MyService2>)); // same registrations as our constrained generics example plus an // extra for IGeneric<MyService2> which will 'win'. container.RegisterType(typeof(GenericAny<>), typeof(IGeneric<>)); container.RegisterType(typeof(GenericAnyIMyService<>), typeof(IGeneric<>)); container.RegisterType(typeof(GenericAnyMyService1<>), typeof(IGeneric<>)); container.RegisterType(typeof(GenericMyService2), typeof(IGeneric<MyService2>)); // will get two as before var myServiceResult = container.ResolveMany<IGeneric<MyService>>().ToArray(); // would normally get three (via 1st, 2nd and 4th registrations), but will only // get one. var myService2Result = container.ResolveMany<IGeneric<MyService2>>().ToArray(); Assert.Equal(2, myServiceResult.Length); Assert.Equal(1, myService2Result.Length); You can also set this against an open generic - which then has the same effect but for all generics based on the same open generic (here we're disabling it for IGeneric<> ) var container = new Container(); container.SetOption<Options.FetchAllMatchingGenerics>(false, typeof(IGeneric<>)); // similar to the constraints example and the previous one, except this time we // only have one open generic registration, and the other two that we have are closed // (for IGeneric<MyService1> and IGeneric<MyService2>) container.RegisterType(typeof(GenericAny<>), typeof(IGeneric<>)); // just reusing this open generic as a closed generic container.RegisterType(typeof(GenericAnyMyService1<MyService1>), typeof(IGeneric<MyService1>)); container.RegisterType(typeof(GenericMyService2), typeof(IGeneric<MyService2>)); // ordinarily, both of these would return two results because of the IGeneric<> open // registration. But because the FetchAll behaviour has been disabled for all IGeneric<> // types, both only get one result. var myService1Result = container.ResolveMany<IGeneric<MyService1>>().ToArray(); var myService2Result = container.ResolveMany<IGeneric<MyService2>>().ToArray(); Assert.Equal(1, myService1Result.Length); Assert.Equal(1, myService2Result.Length); Assert.NotEqual(myService1Result[0].GetType(), myService2Result[0].GetType()); Generic Variance Rezolver's support for generic variance means that enumerables of generics will automatically include all concrete-generic registrations (i.e. T<A> as opposed to T<> ) which are reference compatible with the element type of the enumerable by way of generic covariance or contravariance. Covariance Say you have a series of Func<out T> registrations for concrete types - e.g. Func<Foo1> , Func<Foo2> and so on, with Foo1 and Foo2 and the rest all supporting the IFoo interface. Rezolver will automatically be able to resolve an IEnumerable<Func<IFoo>> containing all matching registrations, since each of those registrations is compatible with Func<IFoo> via generic covariance: interface IFoo {} class Foo1 : IFoo {} class Foo2 : IFoo {} // ... container.RegisterObject<Func<Foo1>>(() => new Foo1()); container.RegisterObject<Func<Foo2>>(() => new Foo2()); var funcs = container.ResolveMany<Func<IFoo>>(); // will contain the two delegates registered above You can read more about this, including examples, in the dedicated section on covariance . Disabling Enumerable Covariance As with much of Rezolver's functionality, you can control whether the automatically generated enumerables handle covariance as described above with a simple option - the EnableEnumerableCovariance option. It can be used to disable enumerable covariance for all enumerables, or for enumerables of specific types: Tip Both these snippets assume the Rezolver.Options namespace has been imported into the current file via a using directive ( imports in VB). container.SetOption<EnableEnumerableCovariance>(false); Disables it globally, while: container.SetOption<EnableEnumerableCovariance, IFoo>(false); Disables it only for enumerables of the type IFoo . Contravariance Generic types which are compatible with each other via contravariance will also be included in any IEnumerable<T> with which they'd usually be compatible. For example: container.RegisterObject<Action<IFoo>>(o => Console.WriteLine(\"interface\")); container.RegisterObject<Action<object>>(o => Console.WriteLine(\"object\")); var actions = container.ResolveMany<Action<Foo1>>(); // will contain the two delegates registered above Again, this is covered in more depth in the section on covariance . Next steps Learn about Rezolver's support for lazy and eager enumerables (note: all auto-generated enumerables are lazily evaluated by default) The covariance section includes examples of how covariance works within Rezolver's enumerable support. By default, also, Rezolver handles contravariant generic type parameters - see this in action with enumerables in the section dedicated to generic contravariance"
  },
  "docs/decorators/delegates.html": {
    "href": "docs/decorators/delegates.html",
    "title": "Decorating with delegates | Rezolver IOC",
    "keywords": "Decorating with delegates If you've read about Rezolver's support for the decorator pattern (including collection decoration ) then you'll know that you have most of the functionality you could ever need to implement the decorator design pattern. There are some types, however, whose registrations cannot be decorated by a constructor-injected instance - in particular: Value types (since you cannot inherit from them) Arrays Delegate types Plus, there are some types - e.g. IEnumerable<T> - where a more natural method of decoration is method-based instead of class-based. For this, Rezolver provides the ability to register delegates that decorate a specific concrete (i.e. non -generic) type. The delegate will be executed, passing the undecorated result as an argument, and its return value used in place of the original result. Decorating an int Our first example simply shows how decorate all int objects produced by the container so that they are doubled. It's not a particularly real-world example - but it's a simple way to show how this works. var container = new Container(); container.RegisterDecorator((int i) => i * 2); container.RegisterObject(10); Assert.Equal(20, container.Resolve<int>()); Tip The RegisterDecorator is overloaded for the delegate types @System.Func`2 and Delegate - the second of which allows any delegate to be registered as a decorator, subject to parameter and return type checks. The framework will inject arguments to any parameters the delegate has, with a parameter of the decorated type receiving the undecorated instance. Integration with IEnumerable<T> As shown in the enumerables documentation , enumerables of a given type will honour any and all decorators which are registered for that type when they are created, so if we extend the above example and produce an IEnumerable<int> from multiple int registrations, then each one will be doubled in the enumerable that's created: var container = new Container(); container.RegisterDecorator((int i) => i * 2); container.RegisterObject(10); container.RegisterObject(20); container.RegisterObject(30); Assert.Equal( new[] { 20, 40, 60 }, container.ResolveMany<int>()); Decorating a delegate If you are injecting delegates in your application, then the only way you can decorate them is with another delegate - you can't use classes. In this example, we implement a number classifier as a single delegate ( Action<int> ) composed of many others. As numbers are passed to the delegate, they are placed into one of four sets. This example showws how you might implement the chain of responsibility purely via the container itself, with delegates. One of the decorator delegates accepts both the original delegate and an extra depeSndency ( IPrimeChecker ), thus showing how decorator delegates support the same argument injection that's supported by Rezolver's standard delegate registrations . Here's the code for IPrimeChecker and a basic implementation: public interface IPrimeChecker { bool IsPrime(int i); } public class PrimesUnder20Checker : IPrimeChecker { static readonly HashSet<int> PrimesUnderTwenty = new HashSet<int>(new[] { 2, 3, 5, 7, 11, 13, 17, 19 }); public bool IsPrime(int i) { if (i == 0 || i == 1) return false; else if (i > 1 && i < 20) return PrimesUnderTwenty.Contains(i); else throw new ArgumentOutOfRangeException(nameof(i)); } } And here's the test: var container = new Container(); // create some 'bags' into which we'll sort some numbers HashSet<int> productsOf5 = new HashSet<int>(); // numbers with 5 as a factor will go in here HashSet<int> primeNumbers = new HashSet<int>(); // prime numbers will go in here HashSet<int> evenNumbers = new HashSet<int>(); // even numbers go in here HashSet<int> otherNumbers = new HashSet<int>(); // any other numbers go in here // base delegate simply adds the number it gets to the 'otherNumbers' bag container.RegisterObject<Action<int>>(i => otherNumbers.Add(i)); // now decorate with our even-number detector container.RegisterDecorator<Action<int>>(next => i => { if (i != 0 && (i % 2) == 0) evenNumbers.Add(i); else next(i); }); // prime number detector (demonstrates other delegate types as decorators) container.RegisterType<PrimesUnder20Checker, IPrimeChecker>(); container.RegisterDecorator<Action<int>>( new Func<Action<int>, IPrimeChecker, Action<int>>( (next, primeChecker) => i => { if (primeChecker.IsPrime(i)) primeNumbers.Add(i); else next(i); })); // and finally our numbers with 5 as a factor (includes 5) // basically identical to the even numbers detector above container.RegisterDecorator<Action<int>>(next => i => { if (i != 0 && (i % 5) == 0) productsOf5.Add(i); else next(i); }); var sort = container.Resolve<Action<int>>(); foreach (var number in Enumerable.Range(0, 20)) { sort(number); } // check the results Assert.Equal( new[] { 5, 10, 15 }, productsOf5.OrderBy(i => i)); Assert.Equal( new[] { 2, 3, 7, 11, 13, 17, 19 }, primeNumbers.OrderBy(i => i)); Assert.Equal( new[] { 4, 6, 8, 12, 14, 16, 18 }, evenNumbers.OrderBy(i => i)); Assert.Equal( new[] { 0, 1, 9 }, otherNumbers.OrderBy(i => i)); Note Unfortunately, although decorator classes support generic types, Rezolver cannot currently bind to generic methods - as there's no 'nice' way to pass an open generic method around. We're looking into it, though - and in the meantime it's possible to add support in yourself by extending Rezolver, if you like... 😉"
  },
  "index.html": {
    "href": "index.html",
    "title": "Rezolver | Rezolver IOC",
    "keywords": "Rezolver Rezolver is a fast , efficient, extensible, open source IOC container with Asp.Net Core integration. The nuget package has binaries specifically targeted to these .Net versions/standards: .Net Standard 2.0 .Net Standard 1.1 .Net 4.5.1 .Net 4.6 Asp.Net Core Support Asp.Net Core Support (v2.0 and v1.1) is provided by the Rezolver.Microsoft.AspNetCore.Hosting package , supported by the Rezolver.Microsoft.Extensions.DependencyInjection package which provides an implementation of the new .Net Core DI container abstraction. Release Highlights For full release notes for each version - see release notes on Github . 1.3.2 Generic Covariance added Mixed Variance supported 1.3.1 Added .Net Standard 2.0 support and more. Feature Overview Linked topics provide high level overviews and examples in our developer guide - click on them to find out more! (*) Core Features Constructor Injection Multiple constructors supported 'Intelligent' constructor discovery based on registered services Named argument binding Parameters with default arguments are supported Member injection (extensible) Open Generic Constructor Injection Specific closed generics take precedence Factory Delegates Argument injection Explicit resolving supported inside factory bodies Factory Expressions Argument injection Explicit resolving as above Singletons Constant services Hierarchical lifetime scoping Scoped objects (i.e. 'singleton per scope') Enumerables, Arrays and Collections Automatic enumerable injection Empty enumerables returned by default Lazy and eager enumerables Configurable on a per-type basis (added in 1.3) Enumerables of generics Enumerable covariance support Array injection List<T> injection Also IList<T> and IReadOnlyList<T> Collection<T> injection Also ICollection<T> , ReadOnlyCollection<T> and IReadOnlyCollection<T> Advanced Generic Variance Generic Contravariance ( Action<IFoo> resolved for Action<Foo> ) Generic Covariance ( Func<Foo> resolved for Func<IFoo> ) Mixed Variance ( Func<IFoo, Bar> resolved for Func<Foo, IBar> ) Can be enabled and disabled globally and per-type (As noted above) Enumerables and collections automatically include all generic variant matches Decorators Non-generic & generic constructor injection Specialised generic ( where a decorator for IFoo<> is redecorated by another decorator for IFoo<Bar> only when IFoo<Bar> is requested ) Enumerables of decorated instances Decorator Delegates Can decorate any of the built-in enumerable/collection types Constrained generics Child containers Including child registration containers (lower-level overriding of registrations for similar but sibling containers) Other No 'prepare' phase - you can register targets in a container after you start using it Note - services which have already been used cannot yet be replaced, but high-performance mutable containers are on their way Extensible compiler framework Expression tree compiler used by default Extensible 'targets' Can write your own code which produces objects when Rezolver matches it to a requested type * If a topic isn't linked, it's probably because we're still working on the documentation, or because it's covered in the parent topic Quick Links Developer Guide Nuget Packages API Reference Release History (On Github)"
  },
  "docs/variance/mixed.html": {
    "href": "docs/variance/mixed.html",
    "title": "Mixing Covariant and Contravariant parameters | Rezolver IOC",
    "keywords": "Mixing Covariant and Contravariant parameters All of our covariant and contravariant examples have focused on variant generic interfaces or delegates which have all covariant or all contravariant type parameters, but Rezolver is not limited to this. Rezolver can also match registrations to generics whose type arguments don't match the requested types, but which are still compatible across all type arguments, regardless of whether the underlying type parameters are covariant or contravariant. Consider the Converter<TInput, TOutput> type: public delegate TOutput Converter<in TInput, out TOutput>(TInput input); Tip These examples use the same shapes types that are used in the contravariance examples. In this example, we'll resolve a Converter<Rectangle, IDictionary<string, string>> - but neither type argument matches the types used in the registration ( Converter<object, Dictionary<string, string>> ). However, because the first is contravariant and the second is covariant, Rezolver pulls out the registered converter, seeing that it is compatible: var container = new Container(); var expected = new Converter<object, Dictionary<string, string>>( o => new Dictionary<string, string> { [\"type\"] = o.GetType().ToString(), [\"value\"] = o.ToString() }); container.RegisterObject(expected); var result = container.Resolve<Converter<Rectangle, IDictionary<string, string>>>(); Assert.Same(expected, result); And, of course, if you resolve an IEnumerable<> of a type containing a mixture of covariant and contravariant type parameters - it works exactly as expected: var container = new Container(); var objectConverter = new Converter<object, Dictionary<string, string>>( o => new Dictionary<string, string> { [\"type\"] = o.GetType().ToString(), [\"value\"] = o.ToString() }); var shapeConverter = new Converter<I2DShape, Dictionary<string, string>>( o => new Dictionary<string, string> { [\"area\"] = o.CalcArea().ToString() }); var rectangleConverter = new Converter<Rectangle, Dictionary<string, string>>( o => new Dictionary<string, string> { [\"width\"] = o.Length.ToString(), [\"height\"] = o.Height.ToString() }); var circleConverter = new Converter<Circle, Dictionary<string, string>>( o => new Dictionary<string, string> { [\"radius\"] = o.Radius.ToString() }); container.RegisterObject(objectConverter); container.RegisterObject(shapeConverter); container.RegisterObject(rectangleConverter); container.RegisterObject(circleConverter); // for <Circle, IDictionary<string, string>>, we should get three: var result1 = container.ResolveMany<Converter<Circle, IDictionary<string, string>>>(); Assert.Equal(new Converter<Circle, IDictionary<string, string>>[] { objectConverter, shapeConverter, circleConverter }, result1); // and for <Square, IDictionary<string, string>>, we should also get three: // this time, there are *no* exact matches var result2 = container.ResolveMany<Converter<Square, IDictionary<string, string>>>(); Assert.Equal(new Converter<Square, IDictionary<string, string>>[] { objectConverter, shapeConverter, rectangleConverter }, result2); Note Remember that auto-generated enumerables always return objects in registration order. Further examples for this functionality which don't also require lots of background and other classes are thin on the ground right now. That said, generic variance is something you either know you need, or you don't. So, if you do, hopefully these examples - and the rest in this section - should be enough to satisfy you that Rezolver will be able to support you in whatever you need. Certainly, don't start marking all your generic parameters as in or out just because they can be - variant interfaces and delegates are typically variant for a specific reason . If you don't have a good reason, then don't make your types variant."
  },
  "docs/variance/index.html": {
    "href": "docs/variance/index.html",
    "title": "Generic Variance in Rezolver | Rezolver IOC",
    "keywords": "Generic Variance in Rezolver Rezolver, as of 1.3.2, supports both covariant and contravariant type parameters in generic types. It supports these transparently - i.e. you don't need to do anything special to enable the support (but it can be disabled) except to request types which have type arguments specified for parameters declared as either in or out as per normal generic variance rules. Rezolver also supports any combination of variance for type parameters of variant types - i.e. a mixture of covariance and contravariance . Follow the links above or below to see examples of variance in action in Rezolver. Contravariance Covariance Mixed Variance Tip If you don't know anything about generic variance in .Net then you should read through the MSDN topic 'Covariance and Contravariance in Generics' as it explains these concepts in far greater detail than we can!"
  },
  "docs/variance/covariance.html": {
    "href": "docs/variance/covariance.html",
    "title": "Generic Covariance | Rezolver IOC",
    "keywords": "Generic Covariance v1.3.2 of Rezolver sees the introduction of generic covariance, which is a much more commonly used type of generic variance in .Net, compared to contravariance , however it's also more rare in the IOC world. Generic covariance allows a variable of type Generic<Ta> to be assigned to an instance of Generic<Tb> so long as the type Tb is reference compatible with Ta . Warning Note that this precludes Ta being object and Tb being a struct (a value type), because assignment of a value type to object requires a boxing conversion. Here are some examples: Func<object> f1 = new Func<string>(() => \"Hello World\"); Func<IEnumerable<object> f2 = new Func<IEnumerable<string>>(() => new string[] { \"Hello World\" }); Func<IEnumerable<object>> f3 = new Func<string[]>(() => new string[] { \"Hello World\" }); The first assignment is allowed because string is a reference type which, of course, inherits from object - therefore an instance of Func<string> can be assigned to a Func<object> reference. The second assignment is allowed because IEnumerable<out T> is also a covariant generic type, which means that an instance of IEnumerable<string> can be assigned to an IEnumerable<object> reference; which therefore also means that the two Func<out T> types are also reference compatible. The third assignment is allowed because of array covariance (which is, admittedly, slightly broken in .Net). Again, a string[] instance can be assigned to an object[] reference; and since IEnumerable<object> is then an implemented interface of object[] ; it means they, too, are reference compatible. In Rezolver Rezolver's implementation of covariance relies only on the declaration of covariant type parameters on generic types which are registered as services. So, consider this: interface ICovariant<out T> { T Foo(); } class MyBase { } class MyDerived { } class ProducesMyDerived : ICovariant<MyDerived> { MyDerived Foo() { //get a MyDerived object and return it. } } Given an IContainer called container , we can now do this: container.RegisterType<ProducesMyDerived, ICovariant<MyDerived>(); var result = container.Resolve<ICovariant<MyBase>>(); Assuming no other registrations exist, result will be an instance of our ProducesMyDerived class in the previous code block. Last-registered wins Note If a registration exists for the exact type requested, then covariance is ignored in favour of the most-recently registered exact match. Just as with all other registrations (except contravariance ), the registration that serves a request for a particular service type which is matched covariantly is the one that was registered most recently. So a Func<MyBase> registration will supersede a Func<MyDerived> registration for a request for a Func<object> service if the Func<MyBase> registration was made last. Examples Constant Func<out T> service Here's an example, in unit test form, similar to the type of covariance we've just covered above, this time with delegates: var container = new Container(); container.RegisterObject<Func<MyService2>>(() => new MyService2()); var result = container.Resolve<Func<IMyService>>(); Assert.IsType<Func<MyService2>>(result); Note Notice that with delegates, you typically register the delegate directly against its actual type - the 'service type' for the registration is exactly the same as the delegate type itself. Enumerables Single-service scenarios like the MyBase / MyDerived example above are less common with covariance in the IOC world. The most common example is with IEnumerable<T> functionality - where an application has several registrations for concrete types which all happen to share a common base or interface, and your application wants to be able to resolve them all automatically by that base or interface whilst still also needing to be able to resolve them by their concrete types. Clearly, without covariance, this could be achieved by creating two separate registrations for the same type - one against the concrete type and one against the common base/interface. However, since IEnumerable<T> is covariant, any registration whose type is reference compatible with the T really should be automatically identified and included in the enumerable. Rezolver's automatic enumerable handling supports this without any effort from you: var container = new Container(); container.RegisterType<MyService1>(); container.RegisterType<MyService2>(); container.RegisterType<MyService3>(); var result = container.ResolveMany<IMyService>(); Assert.Collection(result, new Action<IMyService>[] { s => Assert.IsType<MyService1>(s), s => Assert.IsType<MyService2>(s), s => Assert.IsType<MyService3>(s) }); Nested Generic Covariance This can be extended even further when the element type of an enumerable is itself a generic which contains one or more covariant type parameters. This is similar to the above example, except this time we have a series of concrete Func<out T> registrations: var container = new Container(); container.RegisterObject<Func<MyService1>>(() => new MyService1()); container.RegisterObject<Func<MyService2>>(() => new MyService2()); container.RegisterObject<Func<MyService3>>(() => new MyService3()); var result = container.ResolveMany<Func<IMyService>>(); Assert.Collection(result, new Action<Func<IMyService>>[] { f => Assert.IsType<Func<MyService1>>(f), f => Assert.IsType<Func<MyService2>>(f), f => Assert.IsType<Func<MyService3>>(f) }); Nested Generic Contravariance You might be wondering why we'd have an example about contravariance in the section about covariance - well an enumerable of Action<T> , for example, can still match covariantly: var container = new Container(); container.RegisterObject<Action<IMyService>>(s => Console.WriteLine(\"interface\")); container.RegisterObject<Action<object>>(s => Console.WriteLine(\"object\")); var result = container.ResolveMany<Action<MyService>>(); Assert.Collection(result, new Action<Action<MyService>>[]{ a => Assert.IsType<Action<IMyService>>(a), a => Assert.IsType<Action<object>>(a) }); Tip When you start combining different types of variance you very quickly encounter counter-intuitive scenarios. In this case, try not to be distracted by the fact that the types in the Action<> delegate appear to be going the 'wrong way' up or down a type hierarchy. Remember that variance is all about reference-compatibility , not specifically about whether two types share a common base or interface. So, since an instance of Action<MyService> is reference compatible with a variable of type Action<IMyService> , this means that an IEnumerable<MyService> can also contain an instance of Action<IMyService> . If you're already familiar with the term 'reference compatible' then this will be of no surprise to you after learning that Rezolver supports generic variance 😉"
  },
  "docs/constructor-injection/member-injection.html": {
    "href": "docs/constructor-injection/member-injection.html",
    "title": "Member Injection | Rezolver IOC",
    "keywords": "Member Injection When executing a type's constructor you also have the option to inject services into the new instance's properties and/or fields. So - the equivalent of: var service = new ServiceWithFields() { Property = foo, Field = bar } This is all done via implementations of the IMemberBindingBehaviour interface - of which there are a few implementations supplied by Rezolver, which can be found in the MemberBindingBehaviour static class: BindNone : prevents binding of any field or properties (implemented by BindNoMembersBehaviour ) BindAll : binds all publicly writeable properties and fields to values from the container, even if the container doesn't have a registration for the member's type. Implemented by an instance of BindAllMembersBehaviour . BindProperties : binds only publicly writeable properties to values from the container. Fields are ignored. Implemented by an instance of BindPublicPropertiesBehaviour . BindFields : binds only public fields to values from the container. Properties are ignored. Implemented by an instance of BindPublicFieldsBehaviour . Enabling member injection Via Container Options The simplest way to configure member injection is through the Options API, which provides a way to define metadata globally or on a per-type basis. To do this, you need an ITargetContainer , an interface which is implemented by all the standard container classes, in addition to the primary implementation types TargetContainer and OverridingTargetContainer . This short example shows how to set the default member binding behaviour for all constructed types to the BindAll behaviour, thus enabling member injection for all publicly writeable properties and fields: using Rezolver; namespace MyApp { public static void Main() { var container = new Container(); container.SetOption(MemberBindingBehaviour.BindAll); // objects created through constructor injection by this container will now also have their members injected // you can also set a specific behaviour for a type in this way container.SetOption(typeof(ClassWithProperties), MemberBindingBehaviour.BindProperties); // now, any instance of ClassWithProperties created by constructor injection will have only its properties injected // also works for open generics container.SetOption(typeof(GenericWithFields<>), MemberBindingBehaviour.BindFields); // any instance of any generic based on GenericWithFields<> will have only its fields injected } } Via Explicit IMemberBindingBehaviour Almost all of the ways in which you register types for construction by the container (be it via ITarget factory methods like ForType , registration extension methods such as those in RegisterTypeTargetContainerExtensions , or any of the constructors for ConstructorTarget or GenericConstructorTarget constructors etc) will accept an IMemberBindingBehaviour which is specific to the target being created. Such explicitly provided member binding behaviours will override any which might otherwise be applied via the Options API (as shown in the last example). container.RegisterType<MyClass>(MemberBindingBehaviour.BindAll); The rest of the examples in this topic will show both in action. Examples Injecting all members Given this type: public class Has2InjectableMembers { public MyService1 Service1 { get; set; } public MyService2 Service2 { get; set; } } We simply setup the container to build all three types and make sure to pass the binding behaviour when registering the Has2InjectableMembers target. We'll see how to do this using both an explicit IMemberBindingBehaviour , but also via the Options API. Explicit IMemberBindingBehaviour Here we'll register the Has2InjectableMembers type in the container with the BindAll behaviour passed with the registration. Doing this overrides the container's default behaviour, thus guaranteeing that the members are always bound. var container = new Container(); container.RegisterAll( Target.ForType<MyService1>(), Target.ForType<MyService2>() ); container.RegisterType<Has2InjectableMembers>(MemberBindingBehaviour.BindAll); var result = container.Resolve<Has2InjectableMembers>(); Assert.NotNull(result.Service1); Assert.NotNull(result.Service2); Warning When using the BindAll behaviour, if one of the services required by any of the writable properties or fields is not present in the container, then the resolve operation will fail. The behaviour is deliberately primitive - because unlike with constructors, where it's reasonable to assume all parameters are to be injected, there are no simple rules that can always applied to an object to determine which properties and/or fields should be auto-injected. Global Option In this version of the example, we'll set the BindAll behaviour as a global option on the container itself. var container = new Container(); container.SetOption(MemberBindingBehaviour.BindAll); container.RegisterAll( Target.ForType<MyService1>(), Target.ForType<MyService2>() ); container.RegisterType<Has2InjectableMembers>(); var result = container.Resolve<Has2InjectableMembers>(); Assert.NotNull(result.Service1); Assert.NotNull(result.Service2); Service-specific option But what if we only want instances of one type (or any of its derivatives) to have their members injected? Well, instead of setting the option globally, we can associate it with a particular service type: var container = new Container(); // Here - the behaviour will *only* kick in for the Has2InjectableMembers type container.SetOption(MemberBindingBehaviour.BindAll, typeof(Has2InjectableMembers)); container.RegisterAll( Target.ForType<MyService1>(), Target.ForType<MyService2>() ); container.RegisterType<Has2InjectableMembers>(); var result = container.Resolve<Has2InjectableMembers>(); Assert.NotNull(result.Service1); Assert.NotNull(result.Service2); Clearly, in this case we might just as well use an explicitly-provided member binding behaviour, as shown two examples above, however this facility is useful if you have a whole hierarchy of objects with a common interface or base whose properties and/or fields should be auto-injected. Custom binding behaviour Tip The options approach shown in the previous two examples will work also with the the custom binding behaviour shown in this example. If you find you need more control over which properties and/or fields you want bound on an instance, then you can, of course, implement your own binding behaviour. A popular implementation of member injection in some IOC containers is to use an attribute on the properties/fields which should be injected. This is not something that Rezolver supports out of the box - however it's a trivial thing to implement yourself, and that's what this example does. We will: Add a new attribute InjectAttribute which we will use to mark the properties that we want injected Implement a custom IMemberBindingBehaviour ( AttributeBindingBehaviour ) to bind only properties which have this attribute applied Decorate one or more members on a type with the InjectAttribute Pass the new AttributeBindingBehaviour when we register the type, or create the ConstructorTarget First, the InjectAttribute : [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false, Inherited = false)] public class InjectAttribute : Attribute { /// <summary> /// Gets or sets the type to be resolved. /// from the container for the associated member. /// /// If null, then the member's type will be used. /// /// If not null, then, obviously, it must be compatible! /// </summary> public Type Type { get; } public InjectAttribute(Type type = null) { Type = type; } } Then our type which uses it: public class HasAttributeInjectedMembers { [Inject] public IMyService InjectedServiceField; [Inject(typeof(MyService6))] public IMyService InjectedServiceProp { get; set; } //these two will not be injeccted public IMyService ServiceField; public IMyService ServiceProp { get; set; } } Finally, our binding behaviour - which extends the aforementioned BindAllMembersBehaviour as that class has plenty of extension points: /// <summary> /// Class AttributeBindingBehaviour - we reuse the BindAllMembersBehaviour class /// because it has numerous virtual hooks we can use to customise behaviour, and takes care /// of reflecting the target type for us. /// </summary> /// <seealso cref=\"Rezolver.BindAllMembersBehaviour\" /> public class AttributeBindingBehaviour : BindAllMembersBehaviour { protected override IEnumerable<FieldInfo> GetBindableFields( ICompileContext context, Type type) { //filter the fields to those which have an InjectAttribute defined return base.GetBindableFields(context, type) .Where(f => f.IsDefined(typeof(InjectAttribute))); } protected override IEnumerable<PropertyInfo> GetBindableProperties( ICompileContext context, Type type) { return base.GetBindableProperties(context, type) .Where(f => f.IsDefined(typeof(InjectAttribute))); } protected override MemberBinding CreateBinding( ICompileContext context, Type type, FieldInfo field) { //the base method merely creates a new MemberBinding, bound to a new ResolvedTarget //whose type is set to the field type. //This is similar except we read the InjectAttribute's ResolveType, and use that //type if it's not null. var attr = field.GetCustomAttribute<InjectAttribute>(); return new MemberBinding(field, new ResolvedTarget(attr.Type ?? field.FieldType)); } protected override MemberBinding CreateBinding( ICompileContext context, Type type, PropertyInfo prop) { //identical to above var attr = prop.GetCustomAttribute<InjectAttribute>(); return new MemberBinding(prop, new ResolvedTarget(attr.Type ?? prop.PropertyType)); } } With that in place, we can then test: var container = new Container(); // register the type which uses the attributes, passing our custom binding behaviour container.RegisterType<HasAttributeInjectedMembers>(new AttributeBindingBehaviour()); // The first injected field will request an IMyService container.RegisterType<MyService1, IMyService>(); // The second requests an MyService6 by way of the type override on the attribute container.RegisterType<MyService6>(); var result = container.Resolve<HasAttributeInjectedMembers>(); Assert.IsType<MyService1>(result.InjectedServiceField); Assert.IsType<MyService6>(result.InjectedServiceProp); Assert.Null(result.ServiceField); Assert.Null(result.ServiceProp); Tip You can, of course, then enable member injection for all constructor-injected types (including open generics) simply by registering this behaviour as a global option, as shown earlier in this topic . Hopefully this example will inspire you to create your own custom binding behaviour :) Next steps Head back to the Constructor topic Or, see how constructor injection works with generic types"
  },
  "docs/constructor-injection/index.html": {
    "href": "docs/constructor-injection/index.html",
    "title": "Constructor Injection | Rezolver IOC",
    "keywords": "Constructor Injection The most basic, fundamental feature of any IOC container is the ability to create instances of services through a constructor, automatically injecting arguments into that constructor from the services which have been registered in the container. Tip Constructor injection is achieved in Rezolver through the targets ConstructorTarget and GenericConstructorTarget (for open generic types). The examples here show how to create and register these directly and via some of the extension methods in RegisterTypeTargetContainerExtensions , SingletonTargetContainerExtensions and ScopedTargetContainerExtensions . You can see the tests from which these examples are taken, and run them yourself, if you grab the Rezolver source from Github , open the main solution and run the tests in the 'Rezolver.Tests.Examples' project. Some IOC containers restrict you to types with a single constructor. In some cases this is because of the design of the container itself - i.e. in order to achieve good performance - and in others it's to encourage good program design. Rezolver's constructor injection, implemented by the types ConstructorTarget and GenericConstructorTarget , supports binding to types which have multiple constructors. The ConstructorTarget actually has two modes: Find the best matching constructor Explicitly-supplied constructor (where you supply a ConstructorInfo on creation) Example - Injected class So, given these types: public class MyService : IMyService { } and public class RequiresMyService : IRequiresIMyService { public MyService Service { get; } public RequiresMyService(MyService service) { Service = service; } public RequiresMyService(IMyService service) { if (service.GetType() != typeof(MyService)) { throw new ArgumentException($\"{ service.GetType() } not supported\", nameof(service)); } Service = (MyService)service; } IMyService IRequiresIMyService.Service { get { return Service; } } } Note The rather silly explicit implementation and argument checking in the second constructor is purely for illustrative purposes! In order to build RequiresMyService we need an instance of MyService or IMyService , so let's try injecting a MyService , and resolve: var container = new Container(); container.RegisterType<MyService>(); container.RegisterType<RequiresMyService>(); var result = container.Resolve<RequiresMyService>(); Assert.NotNull(result.Service); Example - Injected interface Now, obviously a key facet of dependency injection is that we can depend upon an abstraction of a service instead of a concrete implementation - so most of the time your constructors will request an interface instead of a concrete type. To do this, we simply register MyService against the type IMyService : var container = new Container(); container.RegisterType<MyService, IMyService>(); container.RegisterType<RequiresMyService>(); var result = container.Resolve<RequiresMyService>(); Assert.NotNull(result.Service); 'So what?' you say, 'it's doing exactly what I want it to!' Yes, but there's more going on here than you'd think: the ConstructorTarget is selecting the best-matched constructor based on the service registrations present in the container when it's asked to Resolve the object. Best-match examples Let's take a bit of deep dive into how Rezolver determines a 'best-match' for the constructor to be called by the container. Example - Best-match (proof) First, to prove that it's the IMyService constructor we bound in the previous example, and not the other one - let's try registering a different implementation of IMyService - one which the class will not support because it'll fail that silly argument type-check in the second constructor of RequiresMyService : var container = new Container(); container.RegisterType<MyAlternateService, IMyService>(); container.RegisterType<RequiresMyService>(); // Proves that the ConstructorTarget is selecting the constructor // based on the available services. Assert.Throws<ArgumentException>(\"service\", () => container.Resolve<RequiresMyService>()); Example - Best-match (fewest params) The best-match algorithm is similar to how a compiler matches a method overload when writing code by hand. The rules aren't necessarily exactly the same as, say, the C# spec, but they're close. At the time the first Resolve call is made, the algorithm will first attempt to select the greediest constructor whose parameters are completely satisfied by services available to the container. Thus, if a class has two constructors - one with 1 parameter and one with 3 parameters - if the single parameter version can be successfully injected, but only 2 of the other constructor's parameters can be, then the single-parameter constructor wins. So, given this type: public class RequiresMyServices { #region Sentinel Instances public static readonly MyService2 Default2 = new MyService2(); public static readonly MyService3 Default3 = new MyService3(); #endregion #region Instance Properties public MyService1 Service1 { get; private set; } public MyService2 Service2 { get; private set; } public MyService3 Service3 { get; private set; } #endregion public RequiresMyServices(MyService1 service1) : this(service1, Default2, Default3) { } public RequiresMyServices(MyService1 service1, MyService2 service2, MyService3 service3) { Service1 = service1; Service2 = service2; Service3 = service3; } } If we register Service1 & Service2 , but not Service3 , the single-parameter constructor will be used: var container = new Container(); // Building ConstructorTargets directly here, // and using the batch-registration 'RegisterAll' method, // which registers against the target's DeclaredType container.RegisterAll( Target.ForType<RequiresMyServices>(), Target.ForType<MyService1>(), Target.ForType<MyService2>()); var result = container.Resolve<RequiresMyServices>(); // Because we didn't have MyService3 registered, the // container will bind the first constructor, which defaults // services 2 & 3: Assert.NotNull(result.Service1); Assert.Same(RequiresMyServices.Default2, result.Service2); Assert.Same(RequiresMyServices.Default3, result.Service3); Example - Best-match (with defaults) When a constructor's parameters have default values, the rules change slightly. The algorithm treats parameters which have defaults as always satisfied, even if a service is not registered of the correct type. So if we extend RequiresMyServices with a new class whose 3-parameter constructor specifies default values for parameters 2 & 3: public class RequiresMyServicesWithDefaults : RequiresMyServices { public RequiresMyServicesWithDefaults(MyService1 service1) : base(service1) { } public RequiresMyServicesWithDefaults(MyService1 service1, MyService2 service2 = null, MyService3 service3 = null) : base(service1, service2 ?? Default2, service3 ?? Default3) { } } And then we swap RequiresMyServices for RequiresMyServicesWithDefaults , this time, the 3-parameter constructor will be executed, with parameters 1 & 2 receiving injected arguments, and parameter 3 receiving the default instance from the base: var container = new Container(); container.RegisterAll( // Note - using .As<T> here to create a ChangeTypeTarget // which makes our .ForType<T> target appear // to be for RequiresMyService // Could also have done: // container.RegisterType<RequiresMyServicesWithDefaults, RequiresMyServices>() Target.ForType<RequiresMyServicesWithDefaults>() .As<RequiresMyServices>(), Target.ForType<MyService1>(), Target.ForType<MyService2>()); var result = container.Resolve<RequiresMyServices>(); // this time all but Service3 will have been injected Assert.NotNull(result.Service1); Assert.NotNull(result.Service2); Assert.NotSame(RequiresMyServices.Default2, result.Service2); Assert.Same(RequiresMyServices.Default3, result.Service3); Tip The use of ChangeTypeTarget (via the As extension method) there might be a little confusing. In truth, we're only sneaking it in here to show some other parts of the framework :) Think of it as being the same as an explicit cast from one type to another - you put a target inside it and tell it what type you want it to be. In the example, we have to use this if we're determined to the use the RegisterAll method(s), because they don't allow us to override the registration type for the targets that we're registering. Example - Best partial match If, however, none of the constructors can be completely satisfied, then we look for the greediest constructor with the most number of successfully resolved arguments. If there's a clear winner, then we proceed with that constructor anyway even though one or more required services are missing. Note You might wonder why we would allow binding even though we can't actually satisfy all the parameters of the constructor, well we'll get to that in a moment. This time, we'll have a type which needs one or two services - either MyService1 or both MyService2 and MyService3 : // Slightly different to before properties are IMyService, but // constructors use concrete types. public class Requires2MyServices { public IMyService First { get; } public IMyService Second { get; } public Requires2MyServices(MyService1 first) { First = first; Second = null; } public Requires2MyServices(MyService2 first, MyService3 second) { First = first; Second = second; } } To force the selection of the second constructor for the test, we'll only register MyService2 in the container and, when we attempt to resolve the instance, we should get an InvalidOperationException explaining that MyService3 couldn't be resolved: var container = new Container(); container.RegisterType<MyService2>(); container.RegisterType<Requires2MyServices>(); var exception = Assert.Throws<InvalidOperationException>( () => container.Resolve<Requires2MyServices>()); // the InvalidOperationException contains the name of the type that // couldn't be resolved Assert.Contains(\"MyService3\", exception.Message); Tip This next bit isn't essential knowledge unless you're looking to understand how child container-like functionality is achieved in Rezolver. If that term means nothing to you, then it's suggested you skip it until you need it :) Why we allow partial matches As mentioned in the intro to the last example - it's probably not obvious why we would want to allow binding to a constructor in a container which can't actually fulfil that constructor's requirements! Well, it's clearly not normal , but it's a valid use-case when you consider that Rezolver supports a concept that is typically referred to as 'child containers', except Rezolver calls them 'overriding containers'. A more complete discussion of this functionality will be added to the documentation soon, but in the meantime, let's see two ways in which we could 'fix' the container in the previous test so that it successfully builds an instance of Requires2MyServices . Example - OverridingContainer This is the solution which most closely matches the child container functionality provided by other IOC libraries - take a container which is already 'established' and override it with another container that has its own registrations. The two will work together, sharing registrations when creating instances, so long as the overriding container's Resolve implementation is used: var container = new Container(); container.RegisterType<MyService2>(); container.RegisterType<Requires2MyServices>(); // create an overriding container var containerOverride = new OverridingContainer(container); containerOverride.RegisterType<MyService3>(); // resolve instance via containerOverride var result = containerOverride.Resolve<Requires2MyServices>(); Assert.NotNull(result.First); Assert.NotNull(result.Second); Note If we were to try to resolve from container after creating containerOverride , it would still fail, because it doesn't know anything about the overriding container. Hopefully this should all seem pretty logical. If so, and you're happy simply to accept it, you can skip the next bit. How it works If you're interested in the inner workings when using overriding containers, the process is this: The overridingContainer receives the Resolve call for Requires2MyServices It looks inside its Targets target container for a registration for Requires2MyServices and doesn't find one So the call is passed to the overidden container ... ... which finds its registration and binds to the 2-parameter constructor of Requires2MyServices as before The bound constructor is executed The MyService2 parameter is fulfiled by the container 's own registration But, for the MyService3 parameter, container sees that it was not the container whose Resolve method was originally called (i.e. overridingContainer ), so it forwards the call for MyService3 to overridingContainer . overridingContainer receives the Resolve call for MyService3 It finds its registration, and executes it to get the instance, passing it back to container - thus completing the constructor call for Requires2MyServices Example - OverridingTargetContainer This solution is similar to the previous one, except this time we're not overriding the container, but overriding the target container used by a container. In order to do this, however, we have to change how we create our container. Until now, we've simply been creating a new Container instance and registering targets via its own implementation of ITargetContainer (which, as mentioned elsewhere, wraps its Targets property). This time, we're going to create a TargetContainer directly, register MyService2 and Requires2MyServices in it, then create a OverridingTargetContainer on top of that with the other registration of MyService3 . This target container is then passed to the new container on construction. var targets = new TargetContainer(); targets.RegisterType<MyService2>(); targets.RegisterType<Requires2MyServices>(); var childTargets = new OverridingTargetContainer(targets); childTargets.RegisterType<MyService3>(); // pass the childTargets ITargetContainer to // the container on construction var container = new Container(childTargets); var result = container.Resolve<Requires2MyServices>(); Assert.NotNull(result.First); Assert.NotNull(result.Second); Why do this? This might seem a little confusing - why would you split target containers like this? Firstly - it's quite an advanced concept, and truly understanding the difference between this and the last example requires a lot of understanding about the internals of Rezolver. Therefore it's more suited to developers who are extending the framework, rather than the average developer who's simply looking to use it to drive their application. The framework itself takes advantage of this functionality throughout in order to override behaviours, or to extend a user-configured container with additional transient targets. The DecoratorTarget wouldn't work without this functionality, for example. Also, if you delve into the compiler pipeline, you will be using this functionality all the time. Providing full examples of how you'd leverage this functionality is outside the scope of this topic, but we'll add them to the guide as soon as we've got the rest of the guide complete. Best-match (named args) When using best-match, you can also supply a dictionary of named argument bindings (as a dictionary of ITarget s) which can be used to provide a hint as to your preferred constructor and, more crucially, override the default behaviour of resolving every argument from container. You don't need to provide all named arguments, the binder will use as many as it can and auto-bind the rest. Example - Supplying a DateTime To demonstrate this, we'll have a new type which requires an IMyService and also accepts a DateTime . DateTime s and other primitive types ( string s etc) are typically not great for use in IOC containers, because you can only have one of them registered (or one collection) unless you start using overriding containers or child target containers, which means you typically can only allow one type to have them as dependencies. public class RequiresIMyServiceAndDateTime { public DateTime StartDate { get; } public IMyService Service { get; } public RequiresIMyServiceAndDateTime(IMyService service) : this(service, DateTime.UtcNow) { } public RequiresIMyServiceAndDateTime(IMyService service, DateTime startDate) { Service = service; StartDate = startDate; } } Note that the single parameter constructor defaults the StartDate to DateTime.UtcNow , but in our test, we'll explicitly provide a DateTime which is DateTime.UtcNow.AddDays(1) to create a date in the future: var container = new Container(); container.RegisterType<MyService, IMyService>(); // Currently a couple of different ways to do this - use the // ConstructorTarget's constructor directly with a dictionary, // or use this static method which creates a dictionary from an object // TODO: Will add object overload to the constructor in the future container.Register(Target.ForType<RequiresIMyServiceAndDateTime>( new { // each member of this object must be an ITarget startDate = Target.ForObject(DateTime.UtcNow.AddDays(1)) } )); var result = container.Resolve<RequiresIMyServiceAndDateTime>(); // if the datetime was used, then StartDate will be in the future Assert.True(result.StartDate > DateTime.UtcNow); Note Technically speaking we should really be generating a new DateTime at the point at which the object is actually created, that could easily be achieved by replacing Target.ForObject with a call to Target.ForDelegate (see 'Factory Delegates' ) What happens is that the named arguments contribute to the argument binding process - thus allowing us to 'cheat' and promote a constructor to being a better match than the one that would normally be. Warning Obviously - named argument binding is potentially very brittle - as if the parameter name changes, then the binding will no longer work. In the future, we will also add the ability to supply an ITargetContainer to a ConstructorTarget whose registrations will be used in preference to the main container - thus allowing us simply to register a DateTime in this example, removing the dependency on the parameter name. When you supply ITarget instances up-front to another target in this way, you can use any of the targets in the Rezolver.Targets namespace to supply a value, and they will work as if they were registered in the container. With a ConstructorInfo Instead of relying on the best match algorithm, you can also specify the constructor you want bound up-front, and you can supply parameter bindings too. To illustrate, we'll have a type with a default constructor and one which accepts a service: public class AcceptsOptionalIMyService { public IMyService Service { get; } public AcceptsOptionalIMyService() { } public AcceptsOptionalIMyService(IMyService service) { if (service == null) throw new ArgumentNullException(nameof(service)); Service = service; } } Example - No parameter bindings The first test ignores the registered services and forcibly targets the default constructor: var container = new Container(); container.RegisterType<MyService, IMyService>(); // under best-match, the container would select the greedy constructor, // but we're going to force it to use the default constructor container.Register(new ConstructorTarget( typeof(AcceptsOptionalIMyService).GetConstructor(Type.EmptyTypes) )); var result = container.Resolve<AcceptsOptionalIMyService>(); Assert.Null(result.Service); Example - Pre-bound parameters We can also explicitly bind the parameters of a particular constructor by providing an array of ParameterBinding objects along with a ConstructorInfo . var container = new Container(); // get the constructor: var ctor = typeof(AcceptsOptionalIMyService).GetConstructor(new[] { typeof(IMyService) }); // create parameter bindings var bindings = new[] { new ParameterBinding(ctor.GetParameters()[0], Target.ForType<MyService>() ) }; container.Register(new ConstructorTarget(ctor, parameterBindings: bindings)); var result = container.Resolve<AcceptsOptionalIMyService>(); Assert.NotNull(result.Service); As you can see - using explicitly bound parameters is a little verbose, given the need to find the constructor and then setup those ParameterBinding objects with the correct ParameterInfo s; but it's guaranteed to target the constructor you choose. Next steps See how constructor injection works with generic types Learn how to enable member injection (injecting services into properties and/or fields)"
  },
  "docs/constructor-injection/generics.html": {
    "href": "docs/constructor-injection/generics.html",
    "title": "Open Generic Constructor Injection | Rezolver IOC",
    "keywords": "Open Generic Constructor Injection Tip Before reading this you should read through the section on constructor injection Also, generic types - especially in IOC-world - are an advanced concept that's easy to get very confused over, so if this is entirely new to you and you find you don't understand it fully, then don't worry: this isn't easy! It's probably a good idea to read the MSDN documentation about the IsGenericType property on Type for more about 'open' generics. In Rezolver, binding open generic types, such as IFoo<T> or IBar<T, U, V> , to constructors of generics, e.g. Foo<T> or Bar<T, U, V> is done via the GenericConstructorTarget type. This class knows how to map to a closed generic - i.e. Foo<IMyService> or IBar<MyService1, MyService2, MyService3> - from an open generic and then subsequently bind to the constructor of the closed version of that generic when requested from the container. 'Best-match' only for now The best-match algorithm described in the constructor injection is the only option currently available to you when using GenericConstructorTarget . Theoretically, it's possible to specify the ConstructorInfo for the constructor you want bound on the concrete generic type that Rezolver eventually decides to build for you, but we have not implemented that functionality yet. You also cannot provide named arguments to help in the best-match search - to do so would be incredibly difficult, since if the type of a constructor argument is dependant upon a type argument, then there's no way you could supply a binding for it up-front to satisfy all possible types that might be passed to it. Creating/registering GenericConstructorTarget s You can, of course, simply use the constructors to build a new instance of this target - e.g: new GenericConstructorTarget(typeof(Foo<>)) . However, the non-generic versions of the RegisterType method that we've been using elsewhere to register 'simple' types in our target containers are also generic type-aware. So, if you specify an open generic type as the implementing type, then those functions automatically create a GenericConstructorTarget for you and register it. So, container.RegisterType(typeof(MyGeneric<>)) will register MyGeneric<> for all variants of itself, and container.RegisterType(typeof(MyGeneric<>), typeof(IMyGeneric<>)) will register MyGeneric<> for all variants of IMyGeneric<> . Lets get on with some examples, the first few of which use these types: public interface IDataFormatter<TData> { string FormatData(TData data); } public class DataFormatter<TData> : IDataFormatter<TData> { public string FormatData(TData data) { return data.ToString(); } } Basic examples Direct (no base/interface) Similar to the examples for 'normal' constructor injection, we'll start by looking at registering without worrying about bases or interfaces, registering DataFormatter<> and fetching a few different closed variants of that generic: var container = new Container(); container.RegisterType(typeof(DataFormatter<>)); Assert.NotNull(container.Resolve<DataFormatter<int>>()); Assert.NotNull(container.Resolve<DataFormatter<string>>()); Assert.NotNull(container.Resolve<DataFormatter<IMyService>>()); By Interface And again, except this time we'll register and resolve against the IDataFormatter<> interface: // Same as above, just requesting via interface var container = new Container(); container.RegisterType(typeof(DataFormatter<>), typeof(IDataFormatter<>)); Assert.NotNull(container.Resolve<IDataFormatter<int>>()); Assert.NotNull(container.Resolve<IDataFormatter<string>>()); Assert.NotNull(container.Resolve<IDataFormatter<IMyService>>()); Generic Dependency This time, we have a generic type that has a dependency on another generic type whose generic argument is derived from the dependant's generic argument: public class RequiresIDataFormatter<T> { public IDataFormatter<T> Formatter { get; } public RequiresIDataFormatter(IDataFormatter<T> formatter) { Formatter = formatter; } } var container = new Container(); container.RegisterType(typeof(RequiresIDataFormatter<>)); container.RegisterType(typeof(DataFormatter<>), typeof(IDataFormatter<>)); Assert.NotNull(container.Resolve<RequiresIDataFormatter<int>>().Formatter); Assert.NotNull(container.Resolve<RequiresIDataFormatter<string>>().Formatter); Assert.NotNull(container.Resolve<RequiresIDataFormatter<IMyService>>().Formatter); Advanced - Complex Hierarchies The previous examples showed how we can resolve an instance when the type requested is simply a closed version of the open generic against which we registered a target; or when it's a direct base or interface of it. Naturally, real-world type hierarchies do not always work like that - and sometimes you'll want to implement a type where the implementation is perhaps more 'distant', in inheritance terms, from the base or interface. With generics, this can get particularly complicated as the type parameters do not always remain consistent - consider the following hierarchy: //these types are just used as easy-to-read type arguments public class T1 { } public class T2 { } public class T3 { } public class BaseGeneric<T, U, V> { } public class MidGeneric<T, U, V> : BaseGeneric<V, U, T> { } public class FinalGeneric<T, U, V> : MidGeneric<U, T, V> { } // This type 'closes' over one type parameter public class ClosingGeneric<T, U> : FinalGeneric<T, U, string> { } Notice how on the three first generic types, the order of the type arguments is changing as we move through BaseGeneric<,,> , MidGeneric<,,> and FinalGeneric<,,> . The last generic actually fixes one of the type parameters passed to FinalGeneric<,,> - which introduces a different problem for our container, which we'll get to after looking at the others. We apologise in advance for the complexity of this argument jumbling - but we accept no liability for any headaches you suffer! Base of a Base with Jumbled Args So, yes - this is a deeply contrived example, but it's worth seeing: var container = new Container(); container.RegisterType(typeof(FinalGeneric<,,>), typeof(BaseGeneric<,,>)); // Type arguments should be transformed as follows: // - BaseGeneric<T1, T2, T3> is a base of // - MidGeneric<T3, T2, T1>, which is a base of // - FinalGeneric<T2, T3, T1> // Which is what the container should give us var result = Assert.IsType<FinalGeneric<T2, T3, T1>>( container.Resolve<BaseGeneric<T1, T2, T3>>() ); In order to do this, the container must walk the inheritance chain of the DeclaredType of the GenericConstructorTarget to create a map of the type arguments which must be fed to FinalGeneric<,,> in order to create an instance of BaseGeneric<,,> . Partially Closed Generic Note The term 'Partially Closed' is a term only used here - it merely describes a generic type where some of the type arguments supplied to a generic type's parameters are concrete types. Now we take a look at the ClosingGeneric<T, U> type - it's here we start getting into one of the murkier areas of generic types in Rezolver and, indeed, in general. In this case, we now have a type which can only ever be used to implement a subset of all the possible variants of BaseGeneric<T, U, V> , because, whatever its own T and U arguments are, its base will always be BaseGeneric<string, T, U> . Rezolver is happy to work with this, as the next test shows: var container = new Container(); container.RegisterType(typeof(ClosingGeneric<,>), typeof(BaseGeneric<,,>)); var result = Assert.IsType<ClosingGeneric<T2, T3>>( container.Resolve<BaseGeneric<string, T2, T3>>() ); Note If we were to try to resolve BaseGeneric<T1, T2, T3> as we did before, then the container will correctly tell us that it cannot - and that the registered target is not compatible with that type. Which leads us on to our problem... The problem with partially closed generics With our container configured as above, it is now impossible to resolve BaseGeneric<T1, T2, T3> because the only implementation we have for BaseGeneric<,,> is one where the first type argument must be string . If we were to register another, more general, type for BaseGeneric<,,> it would overwrite our specialised version, wiping it out. It's also impossible for us to specify the type BaseGeneric<string,,> either in a typeof , or via the MakeGenericType API, so we're stuck. We're working on it! This is a limitation of Rezolver right now, but there are plans to implement partially specialised registrations, so that the container would, when ClosingGeneric<T, U> is registered, realise that it should only be used if the first type parameter on BaseGeneric<,,> is string . This would then allow the container to accept a more general registration against BaseGeneric<,,> to be registered side-by-side and used for all other variants of BaseGeneric<,,> . Implementation of this feature would also simplify the scenarios covered in the next section. Advanced - Nested Generics Rezolver also supports generics where type arguments are passed to an interface or base nested within other generics - take these types: public interface IGenericService<T> { } public class GenericEnumerableService<T> : IGenericService<IEnumerable<T>> { } public class GenericEnumerableNullableService<T> : IGenericService<IEnumerable<Nullable<T>>> where T : struct { } Singly Nested Generic Argument var container = new Container(); container.RegisterType( typeof(GenericEnumerableService<>), typeof(IGenericService<>).MakeGenericType(typeof(IEnumerable<>)) ); var result = Assert.IsType<GenericEnumerableService<string>>( container.Resolve<IGenericService<IEnumerable<string>>>() ); Note As with our ClosingGeneric<,> from before, we could perform this registration against IGenericService<> , but if we do, then we wipe out the possibility of being able to register other services - so, we register against IGenericService<IEnumerable<>> , which requires some MakeGenericType jiggery pokery. When we've got partially closed generics working, you will be able to register against IGenericService<> . Doubly Nested Generic Argument Rezolver doesn't care how far it has to go to work out how a type argument on a base is nested from the implementing type: var container = new Container(); // Even more .MakeGenericType jiggery pokery required here container.RegisterType( typeof(GenericEnumerableNullableService<>), typeof(IGenericService<>).MakeGenericType( typeof(IEnumerable<>).MakeGenericType( typeof(Nullable<>) ) ) ); var result = Assert.IsType<GenericEnumerableNullableService<int>>( container.Resolve<IGenericService<IEnumerable<Nullable<int>>>>() ); Member Injection with Generics The same techniques that are shown in our member injection documentation also work for generic types - if you supply an IMemberBindingBehaviour to the GenericConstructorTarget when it is created (either by the constructors or the aforementioned factory methods), then that behaviour will be used when the constructor is bound. Equally, container-specific IMemberBindingBehaviour s that are set through the options API will also be used automatically. Refer to the topic for detailed examples on how to use member binding. Next Steps Assuming you've read the previous topics on constructor injection and member injection , then that's it for constructor injection for now. Note A separate topic will be added in the future regarding Generic Specialisation in the container, but that covers all target types, not just the GenericConstructorTarget - so that will go elsewhere. Feel free to explore the table of contents or head back to the main service registration overview to explore more features of Rezolver."
  },
  "docs/arrays-lists-collections/lists.html": {
    "href": "docs/arrays-lists-collections/lists.html",
    "title": "Automatic List Injection | Rezolver IOC",
    "keywords": "Automatic List Injection There are three primary types related to generic lists that are commonly used in .Net projects: List<T> @System.Collections.Generic.IList`1 @System.Collections.Generic.IReadOnlyList`1 In addition to being able to add explicit registrations for specific closed generic list types, Rezolver supports the automatic creation and injection of these types in the same way that enumerables are also supported. Note For all three types, Rezolver creates/injects an instance of List<T> by binding to the List<T>(IEnumerable<T>) constructor - which means that enumerable injection must be enabled unless you intend to take control of all of your IEnumerable<T> registrations. Unfortunately, this also means that an instance of IReadOnlyList<T> can be cross-cast to List<T> or IList<T> in order to make modifications to it - this will be changed in a future release. Examples Because all the automatic IEnumerable<T> functionality supported by Rezolver also flows through to these list types (e.g. open generics etc), not many examples are required - we'll just cover the basics (as is the case in the arrays documentation), and then the rest you can learn from the enumerables documentation . So - an empty container can automatically inject an empty list instance: var container = new Container(); var result1 = container.Resolve<List<IMyService>>(); var result2 = container.Resolve<IList<IMyService>>(); var result3 = container.Resolve<IReadOnlyList<IMyService>>(); Assert.NotNull(result1); Assert.NotNull(result2); Assert.NotNull(result3); Assert.Equal(0, result1.Count); Assert.Equal(0, result2.Count); Assert.Equal(0, result3.Count); And, after adding three registrations for IMyService , any list that is created will contain three instances created from those registrations: var container = new Container(); container.RegisterType<MyService1, IMyService>(); container.RegisterType<MyService2, IMyService>(); container.RegisterType<MyService3, IMyService>(); var result1 = container.Resolve<List<IMyService>>(); var result2 = container.Resolve<IList<IMyService>>(); var result3 = container.Resolve<IReadOnlyList<IMyService>>(); Assert.NotNull(result1); Assert.NotNull(result2); Assert.NotNull(result3); Assert.Equal(3, result1.Count); Assert.Equal(3, result2.Count); Assert.Equal(3, result3.Count); Assert.IsType<MyService1>(result1[0]); Assert.IsType<MyService2>(result1[1]); Assert.IsType<MyService3>(result1[2]); Assert.IsType<MyService1>(result2[0]); Assert.IsType<MyService2>(result2[1]); Assert.IsType<MyService3>(result2[2]); Assert.IsType<MyService1>(result3[0]); Assert.IsType<MyService2>(result3[1]); Assert.IsType<MyService3>(result3[2]); Disabling Automatic List Injection First, you should look at how to disable array injection as the process to do it for lists is exactly the same - except it's a different option: var container = new Container( new TargetContainer( TargetContainer.DefaultConfig .Clone() .ConfigureOption<Options.EnableListInjection>(false))); Assert.Throws<InvalidOperationException>( () => container.Resolve<List<IMyService>>()); See Also Enumerables Arrays Collections"
  },
  "docs/arrays-lists-collections/index.html": {
    "href": "docs/arrays-lists-collections/index.html",
    "title": "Injection other collection types | Rezolver IOC",
    "keywords": "Injection other collection types As described in the enumerables section , Rezolver can automatically build and inject instances of IEnumerable<T> of generic and non-generic types based purely off the registrations within the container. Sometimes, however, you might also want to inject arrays, lists or collections (using such types such as List<T> , IList<T> , T[] , Collection<T> etc) whose contents are also built automatically purely from the registrations of the type T present in the container. Note The functionality described in this section does not supersede your ability to create explicit registrations for these types. By default Rezolver has the ability to automatically build and inject the following types which are commonly used to represent series of objects: Arrays List<T> , <xref:System.Collections.Generic.IList`1>, <xref:System.Collections.Generic.IReadOnlyList`1> - Collection<T> , @System.Collections.Generic.ICollection`1, ReadOnlyCollection<T> , IReadOnlyCollection<T> Requires IEnumerable<T> Injection The key thing to note about Rezolver's implementation of these is that they all, in some way, rely upon the injection of IEnumerable<T> mentioned at the start of this topic and, in some cases, rely on each other. Next steps Array injection List injection Collection injection"
  },
  "docs/arrays-lists-collections/collections.html": {
    "href": "docs/arrays-lists-collections/collections.html",
    "title": "Collection injection | Rezolver IOC",
    "keywords": "Collection injection There are four commonly used generic collection types in .Net, two classes and two interfaces: Collection<T> and the interface type @System.Collections.Generic.ICollection`1 ReadOnlyCollection<T> and the interface type IReadOnlyCollection<T> In addition to being able to auto-inject IEnumerable<T> , Rezolver can also automatically build instances of any of these types, with empty collections being created by default if no registrations are present. Warning Collection injection relies on list injection because, behind the scenes, the container is using the IList<T> constructors Collection<T>(IList<T>) and ReadOnlyCollection<T>(IList<T>) to create the collection instances. Therefore, if you disable automatic list injection, automatic collection injection will only work if you specifically add registrations for the corresponding IList<T> types. Examples The following two examples are the same as the first two for IEnumerable<T> , and identical to those used for arrays and lists . Empty collections: // this is fundamentally identical to the first example in the // enumerables section var container = new Container(); var result1 = container.Resolve<Collection<IMyService>>(); var result2 = container.Resolve<ICollection<IMyService>>(); var result3 = container.Resolve<ReadOnlyCollection<IMyService>>(); var result4 = container.Resolve<IReadOnlyCollection<IMyService>>(); Assert.NotNull(result1); Assert.NotNull(result2); Assert.NotNull(result3); Assert.NotNull(result4); Assert.Equal(0, result1.Count); Assert.Equal(0, result2.Count); Assert.Equal(0, result3.Count); Assert.Equal(0, result4.Count); Collections after registrations have been added: var container = new Container(); container.RegisterType<MyService1, IMyService>(); container.RegisterType<MyService2, IMyService>(); container.RegisterType<MyService3, IMyService>(); var result1 = container.Resolve<Collection<IMyService>>(); var result2 = container.Resolve<ICollection<IMyService>>(); var result3 = container.Resolve<ReadOnlyCollection<IMyService>>(); var result4 = container.Resolve<IReadOnlyCollection<IMyService>>(); Assert.NotNull(result1); Assert.NotNull(result2); Assert.NotNull(result3); Assert.NotNull(result4); Assert.Equal(3, result1.Count); Assert.Equal(3, result2.Count); Assert.Equal(3, result3.Count); Assert.Equal(3, result4.Count); Assert.IsType<MyService1>(result1[0]); Assert.IsType<MyService2>(result1[1]); Assert.IsType<MyService3>(result1[2]); Assert.IsType<MyService1>(result2.First()); Assert.IsType<MyService2>(result2.Skip(1).First()); Assert.IsType<MyService3>(result2.Skip(2).First()); Assert.IsType<MyService1>(result3[0]); Assert.IsType<MyService2>(result3[1]); Assert.IsType<MyService3>(result3[2]); Assert.IsType<MyService1>(result4.First()); Assert.IsType<MyService2>(result4.Skip(1).First()); Assert.IsType<MyService3>(result4.Skip(2).First()); Disabling Collection Injection First, you should look at how to disable array injection as the process to do it for collections is exactly the same - except it's a different option: var targets = new TargetContainer( TargetContainer.DefaultConfig .Clone() .ConfigureOption<Options.EnableCollectionInjection>(false)); var container = new Container(targets); Assert.Throws<InvalidOperationException>( () => container.Resolve<Collection<IMyService>>()); See Also Enumerables Arrays Lists"
  },
  "docs/arrays-lists-collections/arrays.html": {
    "href": "docs/arrays-lists-collections/arrays.html",
    "title": "Automatic creation/injection of arrays | Rezolver IOC",
    "keywords": "Automatic creation/injection of arrays As with all IOC containers, you can create registrations for array types just as you would any type, e.g: // registers a constant integer array container.RegisterObject(new int[] { 1, 2, 3 }); However, arrays of objects can also be injected automatically by Rezolver just the same as IEnumerable<T> instances - i.e. by building them dynamically from the registrations present against the array's element type. As a result, if you read through the enumerables documentation , all of the examples there can be repeated with the corresponding array type - e.g. int[] instead of IEnumerable<int> . Examples By default, an empty container (or one which has not had any specific registrations for the array's element type) will automatically build an empty array: // this is fundamentally identical to the first example in the // enumerables section var container = new Container(); var result = container.Resolve<IMyService[]>(); Assert.NotNull(result); Assert.Equal(0, result.Length); And, as you would expect, as soon as you start registering objects of a particular type, you can inject an array of that type: var container = new Container(); container.RegisterType<MyService1, IMyService>(); container.RegisterType<MyService2, IMyService>(); container.RegisterType<MyService3, IMyService>(); var result = container.Resolve<IMyService[]>(); Assert.NotNull(result); Assert.Equal(3, result.Length); Assert.IsType<MyService1>(result[0]); Assert.IsType<MyService2>(result[1]); Assert.IsType<MyService3>(result[2]); All the other enumerable behaviour - such as open generics etc also applies to arrays. Tip The same is also true for lists and collections . Decorating arrays Note Decoration of array elements is exactly the same as it is for enumerables - if you register a decorator for a particular type, then it will decorate every instance of that type when regardless of whether the object is destined for an enumerable/array/collection/list - see 'decorators and enumerables' for more on this. If you want to decorate an array instance (e.g. to pad an array with certain values, perhaps), you cannot do it using a decorator class - for the obvious reason that you cannot inherit from .Net's array type. Instead, you will need to use decorator delegates - a delegate that will be executed every time an instance of a given type is produced by the container - which will be passed the undecorated instance as an argument and which returns a (potentially different) instance to be used in its place. Disabling Automatic Array Injection As with many other Rezolver behaviours, the automatic injection of arrays can be enabled (the default) and disabled via an option - however, it is an option that must be applied when the container's ITargetContainer is created, and before some of the core configurations have been applied to it. To do this, you need to supply an instance of ITargetContainer (typically TargetContainer ) to your Container (or ScopedContainer ) to which you pass a specific ITargetContainerConfig in which you add a configuration object that will set the EnableArrayInjection option to false . Note You can of course supply an empty ITargetContainerConfig to the TargetContainer on construction, but this will also disable other configurations such as enumerable injection, contravariance and so on. The easiest way to do this, then, is to use the DefaultConfig collection - either manipulate it directly (which will change the options for all TargetContainer instances) or use it as a starting point for a custom configuration - which what this example shows, using the Clone() method, followed by the ConfigureOption<T> extension method: // create a clone of the default config // and then explicitly set the EnableArrayInjection option to false var config = TargetContainer.DefaultConfig .Clone() .ConfigureOption<Options.EnableArrayInjection>(false); // now explicitly create a TargetContainer using this config var container = new Container(new TargetContainer(config)); Assert.Throws<InvalidOperationException>( () => container.Resolve<IMyService[]>()); Tip Another option is to remove the InjectArrays configuration from the DefaultConfig or a clone of it. See Also Enumerables Lists Collections"
  },
  "docs/expressions.html": {
    "href": "docs/expressions.html",
    "title": "Factory expressions | Rezolver IOC",
    "keywords": "Factory expressions If you've read the factory delegate documentation, then you'll know that Rezolver can bind a delegate (with an unlimited number of non- ref , non- out parameters) as a factory for a given type registration. Rezolver can do the same with expression trees (derived from the Expression class) and has one or two additional tricks up its sleeve when doing so. To register expessions you can use one of the many RegisterExpression extension methods for ITargetContainer . To create expression targets you can either: Manually create an instance of ExpressionTarget through its constructor Use the ForExpression overload, which, like the delegate helper function ForDelegate , provides specialisations for lambda expressions whose signatures conform to one of many System.Func<> generic delegate types. Whilst using expressions might appear to be fundamentally the same as using delegates, there is a subtle difference: A DelegateTarget requires an entire function body, whilst an ExpressionTarget supports any expression, from expression 'fragments' like ConstantExpression right up to the delegate-like LambdaExpression . Expression 'fragments' As we've just mentioned, an expression fragment is one of the small, specialised, expression types from the System.Linq.Expressions namespace which wrap a fundamental language expression, such as constants or method calls or whatever. The ExpressionTarget supports these through its ExpressionTarget(Expression, Type) constructor. When creating an ExpressionTarget this way, its DeclaredType (and therefore the default type under which it will be registered, unless overridden at registration time) will, by default, be set to the Type of the expression you pass to the constructor, unless you pass a non-null type explicitly as the second argument. Using ConstantExpression In this example, we'll bake a ConstantExpression into an ExpressionTarget , which will then be used to provide a string : var container = new Container(); container.Register( new ExpressionTarget( Expression.Constant(\"Hello World\") ) ); Assert.Equal(\"Hello World\", container.Resolve<string>()); Using MethodCallExpression Here, we have an instance method declared in our test, which returns the value of a local field: private string _theMessage = \"Hello World\"; public string GetMessage() { return _theMessage; } To instruct Rezolver to execute this method on this instance whenever a string is resolved, we simply do this: var container = new Container(); container.Register( new ExpressionTarget( Expression.Call( Expression.Constant(this), // the instance this.GetType().GetMethod(\"GetMessage\") ) ) ); Assert.Same(_theMessage, container.Resolve<string>()); // now change _theMessage and re-resolve: _theMessage = \"New Message!!!\"; Assert.Same(_theMessage, container.Resolve<string>()); Note Obviously, this can also easily be implemented as a DelegateTarget - but the same reasons for why you might use expressions over delegates in any application (i.e. the ability to analyse and rewrite code or dynamically compose logic) hold for targets in your container. The point of these examples is to show that Rezolver will happily deal with any expression you throw at it, not that you should use expressions where a delegate would be a better choice. Lambda Expressions Lambda expressions can also be used to create or register an ExpressionTarget , meaning you can take advantage of the compiler's translation of code into expression trees to simplify their construction. Note When constructing an ExpressionTarget from a lambda expression, the DeclaredType of the target will be set to the Type of the Body of the lambda, unless overridden by a type explicitly provided on construction. Ultimately, Rezolver doesn't really care if you pass a lambda or a fragment like those in the previous section - the same process is followed - but one additional feature that a lambda provides is parameters. Injecting Arguments As with factory delegates , Rezolver provides automatic argument injection for lambda expressions - so, taking the MethodCallExpression example from above, we could instead do this: // this is equivalent to the previous example, just with a lambda // and explicitly injected argument var container = new Container(); // note - the type of 'this' is ExpressionExamples container.RegisterObject(this); container.RegisterExpression((ExpressionExamples e) => e.GetMessage()); Assert.Same(_theMessage, container.Resolve<string>()); _theMessage = \"Another New Message!!!\"; Assert.Same(_theMessage, container.Resolve<string>()); Note Look past the fact that the object being injected is the same instance on which the test is executed, it's the principle that matters! Injecting the IResolveContext Just as with the DelegateTarget example , you can also inject the IResolveContext into your expression in order to perform late-bound service location within your expression. As the comment at the start of the test states - this example is functionally identical to the DelegateTarget example - but because of the limitations of the C# compiler and its ability to translate code into expression trees, the main expression is written as a series of stacked conditional expressions so that the whole thing is a single expression. static IPrincipal CurrentPrincipal { get; set; } [Fact] public void ShouldGetDifferentImplementationFromResolveContextForUser() { // this test is functionally identical to the one in DelegateExamples.cs, // it's just done with an expression, and therefore the format of the code block // used for the IUserActionsService is different because the compiler can only // translate expression lambdas. IIdentity identity = new AppIdentity(); // three principals, one for each role var adminPrincipal = new AppPrincipal(identity, new[] { \"Admin\" }); var salesPrincipal = new AppPrincipal(identity, new[] { \"Sales\" }); var customerPrincipal = new AppPrincipal(identity, new[] { \"Customer\" }); var container = new Container(); container.RegisterType<AdminActionsService>(); container.RegisterType<SalesActionsService>(); container.RegisterType<CustomerActionsService>(); container.RegisterType<UserControlPanel>(); // register expression to read the CurrentPrincipal property, to make it dynamic container.RegisterExpression(() => CurrentPrincipal); // now register the expression for the IUserActionsService, which does the // role sniffing over the principal as one expression container.RegisterExpression((IPrincipal p, IResolveContext rc) => p.IsInRole(\"Customer\") ? rc.Resolve<CustomerActionsService>() : p.IsInRole(\"Sales\") ? rc.Resolve<SalesActionsService>() : p.IsInRole(\"Admin\") ? rc.Resolve<AdminActionsService>() : (IUserActionsService)null); // set the principal, and resolve CurrentPrincipal = adminPrincipal; var result1 = container.Resolve<UserControlPanel>(); // now swap principals CurrentPrincipal = salesPrincipal; var result2 = container.Resolve<UserControlPanel>(); // and again CurrentPrincipal = customerPrincipal; var result3 = container.Resolve<UserControlPanel>(); Assert.IsType<AdminActionsService>(result1.ActionsService); Assert.IsType<SalesActionsService>(result2.ActionsService); Assert.IsType<CustomerActionsService>(result3.ActionsService); } Note Remember: any expression tree built by the compiler can be built 'by hand' through the factory methods in Expression , meaning that you could also provide an expression in which the conditional statements where built dynamically (or, more likely, a dynamically built SwitchExpression ) and it would still work. Resolving without an IResolveContext These advanced examples with lambda expressions show how you can inject an argument or perform late-bound service location within your expression body. Sometimes, however, you might not want to, or be able to, provide a parameterised lambda expression, or you might be passing an expression fragment which cannot accept injected arguments. For this purpose, Rezolver provides the ExpressionFunctions static class. If the compiler sees a MethodCallExpression bound to one of the Resolve static functions of this class, it will be converted into a call to the appropriate Resolve overload of the IResolveContext that is in scope when the container executes the code compiled from the expression. Warning These functions only work inside expressions - any attempt to execute them outside of an expression passed to a ExpressionTarget will result in a NotImplementedException being thrown. var container = new Container(); container.RegisterType<MyService, IMyService>(); // get the ExpressionFunctions.Resolve<T> method var resolveMethod = typeof(ExpressionFunctions) .GetMethods(BindingFlags.Public | BindingFlags.Static) .SingleOrDefault(m => m.Name == \"Resolve\" && m.IsGenericMethodDefinition); // this expression is equivalent to the lambda expression: // rc => new RequiresMyService(rc.Resolve<IMyService>()) container.Register( new ExpressionTarget( Expression.New( // get the (IMyService) constructor typeof(RequiresMyService).GetConstructor(new[] { typeof(IMyService) }), Expression.Call( resolveMethod.MakeGenericMethod(typeof(IMyService)) ) ) )); var result = container.Resolve<RequiresMyService>(); Assert.NotNull(result.Service); Note The RequiresMyService and MyService types can be seen in the construction injection documentation . Admittedly, this way of dynamically resolving services inside an expression requires some heavy lifting (with reflection in particular) when compared with writing the lambda by hand, but it's not intended to be a direct alternative to doing that. Using this approach is for those times when you simply can't alter how you build the expression you want to register. You can, of course, also use the ExpressionFunctions static class inside a parameterless lambda to achieve exactly the same result: var container = new Container(); container.RegisterType<MyService, IMyService>(); container.RegisterExpression(() => new RequiresMyService(ExpressionFunctions.Resolve<IMyService>()) ); var result = container.Resolve<RequiresMyService>(); Assert.NotNull(result.Service); Next steps If you haven't already, then you should probably look at the aforementioned factory delegate documentation . The next main topic after this covers decorators ."
  },
  "docs/enumerables.html": {
    "href": "docs/enumerables.html",
    "title": "Automatic Enumerable Injection | Rezolver IOC",
    "keywords": "Automatic Enumerable Injection By default, a TargetContainer (the default ITargetContainer used by all containers in the Rezolver framework) is configured to allow any ContainerBase derivative to resolve an IEnumerable<Service> . The contents of this enumerable will depend on how many times the Register method has been called against the target type Service : If no target has been registered against the type, then the enumerable will be empty Otherwise, the enumerable will contain instances obtained from each ITarget that was registered against that type, in the order they were registered. Note The functionality described here depends on two target container options: AllowMultiple and EnableEnumerableInjection - which are both configured to be equivalent to true by default for all ITargetContainer instances. You are not restricted in the targets you use to produce instances for an enumerable (e.g. ObjectTarget , ConstructorTarget or DelegateTarget ), and each one can have its own lifetime (scoped/singleton etc). Tip By default, Rezolver will build 'lazy' enumerables, but can be configured to build 'eager' enumerables - for more on this, read the topic Lazy vs Eager Enumerables Warning In an Asp.Net Core 2.0 application, however, eager enumerables are the default until the fix for this issue in the aspnet/DependencyInjection repo has been pushed to an official package release. Resolving enumerables To resolve an enumerable from a container or through a scope, you can simply use IEnumerable<Foo> as the input type for a Resolve call: var enumerable = container.Resolve<IEnumerable<Foo>>(); However, the ResolveMany extension methods (see ResolveMany and ResolveMany ) provide a shortcut which allow you to pass just the element type of the enumerable to reduce the 'angle-bracket percent' of code which directly resolves enumerables (which of course you won't be doing because you're not using 'service location' are you!? 😉 ): // this is equivalent to resolving IEnumerable<Foo> var enumerable2 = container.ResolveMany<Foo>(); Most, if not all, the examples in this section use this shortcut - but it's worth noting that the two methods are absolutely equivalent. Empty enumerable By default, you don't need to register anything against a particular type in order to be able to inject an enumerable of that type. If there are no registrations, then an empty enumerable will be injected instead. Here's an example where we only register the service we're going to create, which has a single constructor that requires an IEnumerable<IMyService> . First, the type RequiresEnumerableOfServices : public class RequiresEnumerableOfServices { public IEnumerable<IMyService> Services { get; } public RequiresEnumerableOfServices(IEnumerable<IMyService> services) { Services = services; } } And then the test: var container = new Container(); container.RegisterType<RequiresEnumerableOfServices>(); var result = container.Resolve<RequiresEnumerableOfServices>(); Assert.Empty(result.Services); Multiple new objects Here, we associate three types (created by constructor injection) to a common service type, which are all then included in the auto-injected enumerable: var container = new Container(); var expectedTypes = new[] { typeof(MyService1), typeof(MyService2), typeof(MyService3) }; foreach (var t in expectedTypes) { container.RegisterType(t, typeof(IMyService)); } container.RegisterType<RequiresEnumerableOfServices>(); var result = container.Resolve<RequiresEnumerableOfServices>(); Assert.Equal(3, result.Services.Count()); Assert.All( result.Services.Zip( expectedTypes, (s, t) => (service: s, expectedType: t) ), t => Assert.IsType(t.expectedType, t.service)); Mixed ITarget types This time, we're mixing it up a bit by registering multiple different target types (a constructor target, a delegate target and an object target), and we're also using a delegate to create the RequiresEnumerableOfServices just to show that the enumerable can be injected into a delegate as you'd expect: var container = new Container(); container.RegisterType<MyService1, IMyService>(); container.RegisterDelegate<IMyService>(() => new MyService2()); container.RegisterObject<IMyService>(new MyService3()); // shows also that injection of IEnumerables holds wherever injection // is normally supported - such as here, with delegate argument injection container.RegisterDelegate((IEnumerable<IMyService> services) => { // if MyService4 is missing, add it to the enumerable if (!services.OfType<MyService4>().Any()) services = services.Concat(new[] { new MyService4() }); return new RequiresEnumerableOfServices(services); }); var result = container.Resolve<RequiresEnumerableOfServices>(); Assert.Equal(4, result.Services.Count()); // just check they're all different types this time. Assert.Equal(4, result.Services.Select(s => s.GetType()).Distinct().Count()); Mixed lifetimes When registering targets, you have three lifetimes at your disposal: Transient (a new object created for every Resolve call) Singleton (only one object is ever created) Scoped (one object created per IContainerScope ) Note Of course, the ObjectTarget (see objects as services ) is technically a singleton, also, but that's because it wraps a constant reference supplied by you. If you register multiple targets for the same type, and those targets have different lifetimes, then those lifetimes are honoured if the container injects an IEnumerable<> . The following example registers three implementations for IMyService again which will appear in the enumerables in the following positions: [0] : A singleton [1] : A scoped object [2] : A transient It then resolves IEnumerable<IMyService> multiple times - twice from the root container (which is a ScopedContainer so that the scoped MyService2 registration has a scope to 'live' in) and then twice again from a child scope: // since we're using a scoped registration here, // we'll use the ScopedContainer, which establishes // a root scope. var container = new ScopedContainer(); container.RegisterSingleton<MyService1, IMyService>(); container.RegisterScoped<MyService2, IMyService>(); container.RegisterType<MyService3, IMyService>(); // So - each enumerable will contain, in order: // 1) Singleton IMyService // 2) Scoped IMyService // 3) Transient IMyService var fromRoot1 = container.ResolveMany<IMyService>().ToArray(); var fromRoot2 = container.ResolveMany<IMyService>().ToArray(); Assert.Same(fromRoot1[0], fromRoot2[0]); // both scoped objects should be the same because we've resolved // from the root scope Assert.Same(fromRoot1[1], fromRoot2[1]); Assert.NotSame(fromRoot1[2], fromRoot2[2]); using (var childScope = container.CreateScope()) { var fromChildScope1 = childScope.ResolveMany<IMyService>().ToArray(); // singleton should be the same as before, but // the scoped object will be different Assert.Same(fromRoot1[0], fromChildScope1[0]); Assert.NotSame(fromRoot1[1], fromChildScope1[1]); Assert.NotSame(fromRoot1[2], fromChildScope1[2]); var fromChildScope2 = childScope.ResolveMany<IMyService>().ToArray(); // the scoped object will be the same as above Assert.Same(fromChildScope1[0], fromChildScope2[0]); Assert.Same(fromChildScope1[1], fromChildScope2[1]); Assert.NotSame(fromChildScope1[2], fromChildScope2[2]); } To summarise: [0] is always the same reference [1] is created once per enclosing scope (remember - the container itself is a scope in this example) [2] is created once per call Automatic Covariance Since the T type parameter in IEnumerable<T> is a covariant, Rezolver automatically resolves all types which are reference compatible with the T that you specify. So, resolving an IEnumerable<IFoo> will result in an enumerable containing all objects produced from registrations made against types which implement IFoo (the registrations do not need to have been made explicitly against the IFoo interface). A concrete example of this can be found in the section on covariance . Decorators and Enumerables Decorators that have been registered against the element type of an enumerable will be applied to all instances that the container produces for the enumerable. This also applies to stacked decorators (where multiple decorators are applied on top of one other). So, we have two decorator types for IMyService : public class MyServiceDecorator1 : IMyService { public IMyService Inner { get; } public MyServiceDecorator1(IMyService inner) { Inner = inner; } } public class MyServiceDecorator2 : IMyService { public IMyService Inner { get; } public MyServiceDecorator2(IMyService inner) { Inner = inner; } } And in this example we'll have one of those decorators being used to decorate three registrations: var container = new Container(); // register the decorator up front. Note - it doesn't actually matter when it's registered container.RegisterDecorator<MyServiceDecorator1, IMyService>(); container.RegisterType<MyService, IMyService>(); container.RegisterType<MyService2, IMyService>(); container.RegisterType<MyService3, IMyService>(); // create the container with these targets var result = container.ResolveMany<IMyService>().ToArray(); // make sure each item in the enumerable is an instance of our decorator. // then make sure the decorated services are correct. Assert.All(result, r => Assert.IsType<MyServiceDecorator1>(r)); Assert.IsType<MyService>(((MyServiceDecorator1)result[0]).Inner); Assert.IsType<MyService2>(((MyServiceDecorator1)result[1]).Inner); Assert.IsType<MyService3>(((MyServiceDecorator1)result[2]).Inner); If more decorators were added, of course - then each element would be 're-decorated' accordingly. Tip You can also decorate instances of IEnumerable<T> , IList<T> , ICollection<T> - plus any other supported collection types. Read about this now . Explicit IEnumerable<T> registrations Although you get IEnumerable<T> handling automatically when the InjectEnumerables configuration is applied (and not also disabled by the @Rezolver.Options.EnumerableInjection option being set to false ), it doesn't prevent you from manually adding registrations for specific IEnumerable<> types which override the default behaviour. For example, let's say that you have two registrations for services which share a common interface, but they have only been registered against their concrete type (perhaps it's historical code you can't risk changing). Your code now wants an enumerable of that common interface. Well, assuming you know what the specific registrations are - you can use delegate registrations (note, there are lots of ways, this is just the most illustrative): var container = new Container(); container.RegisterType<MyService1>(); container.RegisterType<MyService2>(); // reversing the 'normal' order that would usually be // produced by the default IEnumerable functionality, to show // that it's this enumerable that we resolve container.RegisterDelegate<IEnumerable<IMyService>>( rc => new IMyService[] { rc.Resolve<MyService2>(), rc.Resolve<MyService1>() } ); var result = container.ResolveMany<IMyService>().ToArray(); Assert.Equal(2, result.Length); Assert.IsType<MyService2>(result[0]); Assert.IsType<MyService1>(result[1]); Warning As soon as you create a manual registration for a particular IEnumerable<T> type, Rezolver no longer has any control over how that particular enumerable is produced - so none of the enumerable-related options demonstrated in this documentation will be honoured. Disabling Enumerable Injection As with much of the built-in functionality in Rezolver, you can control whether enumerables are automatically built or not through the use of options and configuration. In the case of enumerable injection, it is a feature that is enabled by an ITargetContainerConfig that is added by default to a set of configuration objects in the DefaultConfig collection which is applied, by default, to all new instances of the TargetContainer class (which is, in turn, used by both the main container types - Container and ScopedContainer ). This means that, to disable it, you have to either remove that config (it's the InjectEnumerables configuration singleton) from the collection, or set the EnableEnumerableInjection option to false on the target container before the configuration is applied. You also have another choice, in that you can either do this directly on the DefaultConfig collection, which will affect all instances of TargetContainer , or you can Clone the collection and apply it only to a single target container. It's the second of these options that the example shows, below: var config = TargetContainer.DefaultConfig.Clone(); config.ConfigureOption<Options.EnableEnumerableInjection>(false); // pass our custom config to a new target container which, in turn, // we pass to the constructor of the Container class var container = new Container(new TargetContainer(config)); Assert.Throws<InvalidOperationException>(() => container.ResolveMany<int>()); Notice that we're explicitly creating a TargetContainer and passing a cloned config to it; passing the result to the Container constructor. Tip Many other examples throughout this documentation show options simply being set directly on the container. In those cases, it's because the options are used by logic within Rezolver to make decisions. Enumerable injection, however, is configured at the point a new TargetContainer is created , because the configuration is applied by one of its constructors; hence the different approach is required in order to ensure the option is set before the configuration gets applied. The InjectEnumerables configuration looks for the EnableEnumerableInjection option and, if it's false it disables itself. Warning If you disable automatic enumerable injection then the other automatic collection-type injection behaviour will only work when you explicitly register the correct IEnumerable<T> for it. Order of enumerables Note This is new in 1.3.1 The order that an enumerable returns its items is always equal to the order in which the underlying registrations were made. Next steps Read about how Rezolver handles building enumerables of generics from open and closed generic registrations. Learn about Rezolver's support for lazy and eager enumerables (note: all auto-generated enumerables are lazily evaluated by default) Rezolver also supports arrays, lists and collection injection"
  },
  "docs/decorators/collections.html": {
    "href": "docs/decorators/collections.html",
    "title": "Decorating Collections | Rezolver IOC",
    "keywords": "Decorating Collections As already discussed in the main topic , Rezolver's auto-generated enumerables , arrays , collections and lists are all decorator aware - so if you register a decorator for IFoo and then request any of the supported types, e.g: IEnumerable<IFoo> IFoo[] ICollection<IFoo> IList<IFoo> Then any individual instances within those collection types will be correctly decorated. However, it's also possible to decorate the collection instance too, using a decorator class - with one notable exception (which we'll deal with later). So let's say that we're not using, or can't use, scoping and we want an IList<T> into which we might be adding IDisposable objects. We want those disposable objects to be disposed automatically when they are removed from the list - which can easily be implemented via decoration: public class DisposableListDecorator<T> : IList<T> { private readonly IList<T> _inner; public DisposableListDecorator(IList<T> inner) { _inner = inner ?? throw new ArgumentNullException(nameof(inner)); } private void Dispose(IEnumerable<IDisposable> items) { foreach (var obj in items.ToArray()) { try { obj.Dispose(); } catch (Exception) { /* gulp! */ } } } private void Dispose(IEnumerable<T> items) { Dispose(items.OfType<IDisposable>()); } private void Dispose(T item) { Dispose(new[] { item }); } public T this[int index] { get => _inner[index]; set { var old = _inner[index]; if (old != null && !old.Equals(value)) Dispose(old); _inner[index] = value; } } public int Count => _inner.Count; public bool IsReadOnly => _inner.IsReadOnly; public void Add(T item) { _inner.Add(item); } public void Clear() { Dispose(_inner.OfType<IDisposable>()); _inner.Clear(); } public bool Contains(T item) { return _inner.Contains(item); } public void CopyTo(T[] array, int arrayIndex) { _inner.CopyTo(array, arrayIndex); } public IEnumerator<T> GetEnumerator() { return _inner.GetEnumerator(); } public int IndexOf(T item) { return _inner.IndexOf(item); } public void Insert(int index, T item) { _inner.Insert(index, item); } public bool Remove(T item) { var result = _inner.Remove(item); if (result) Dispose(item); return result; } public void RemoveAt(int index) { if (index >= 0 && index < _inner.Count) { var toRemove = _inner[index]; if (toRemove != null) Dispose(toRemove); _inner.RemoveAt(index); } } IEnumerator IEnumerable.GetEnumerator() { return _inner.GetEnumerator(); } } And then the test: var container = new Container(); container.RegisterDecorator(typeof(DisposableListDecorator<>), typeof(IList<>)); // Note above - we only register the decorator, the underlying List<> // is always created by Rezolver from its own default behaviour var list = container.Resolve<IList<object>>(); var toDispose = new DisposableType(); list.Add(toDispose); list.Clear(); //disposes here Assert.True(toDispose.Disposed); As with all decorators, they stack and they will honour the order in which they are registered. Decorating IEnumerable<T> Decorating IEnumerable<T> can be done in a similar way to that shown in the example in the contravariance topic in which IOrderedEnumerable<T> is configured - simply change the registration of the OrderedEnumerableWrapper<T> from this: container.RegisterType(typeof(OrderedEnumerableWrapper<>), typeof(IOrderedEnumerable<>)); To this: container.RegisterDecorator(typeof(OrderedEnumerableWrapper<>), typeof(IEnumerable<>)); And all enumerables will now be sorted by default using an injected IComparer<T> . However, there is another way to decorate IEnumerable<T> that doesn't involve writing a new class - especially if the intention is to use one of the many Linq extension methods for a specific IEnumerable<T> - and that's the same as the decoration strategy that's needed for arrays. Decorating arrays Decorating arrays is not possible via a decorator class - for the obvious reason that arrays are neither classes that can be created via inheritance, nor do they have an interface that's exclusive to the array type. So, that means Rezolver cannot create array decorators via constructor injection - therefore it's not possible to write a class that can decorate an array. Instead, Rezolver offers another decoration strategy - decorator delegates - which allow you to alter the object that is produced by the container before it's returned to the caller (or injected into another object's constructor or whatever)."
  },
  "docs/variance/contravariance.html": {
    "href": "docs/variance/contravariance.html",
    "title": "Generic Contravariance | Rezolver IOC",
    "keywords": "Generic Contravariance Generic contravariance in .Net is where an instance of a generic type featuring a less derived type as a type argument can be assigned to a reference to a the same generic, but with a more derived type argument. Contravariant type parameters are declared using the in modifier in the generic declaration. Commonly used contravariant generics are any of the System.Action<> delegate derivatives, or interface types such as the IComparer<T> interface (used in the examples below). Here are some examples of legal assignments which take advantage of contravariance: Action<string> a = new Action<object>(o => Console.WriteLine(o)); IComparer<string> b = Comparer<object>.Default; When a generic interface or delegate declares a contravariant type parameter, it restricts that type to being used as a method parameter - i.e. it becomes an 'input' type, hence the in modifier. In Rezolver When a generic type is requested from the container, Rezolver builds a search list of all the possible instances of that generic type which could satisfy that request, returning an instance produced by the registration that was made against the best-matching version of that generic (and, in the case of enumerables , potentially more instances in registration order). The same is also true when the requested type has one or more contravariant type parameters - in which case bases or interfaces of the corresponding type argument are also sought. The important thing to note here is that, just as with covariance , it's the type that an ITarget is registered against that matters - not the implementing type. So, given these types: interface IContravariant<in T> { void Foo(T t); } class MyBase {} class MyDerived : MyBase {} class AcceptsMyBase : IContravariant<MyBase> { void Foo(MyBase t) { } } AcceptsMyBase will be used to create instances of IContravariant<MyDerived> if it is registered against the contravariant interface type IContravariant<MyBase> : container.RegisterType<AcceptsMyBase, IContravariant<MyBase>>(); // gets an instance of AcceptsMyBase var result = container.Resolve<IContravariant<MyDerived>(); Type Precedence is King In nearly all cases (including for covariance ), Rezolver uses the most recently registered target to provide the result for a particular service type. For requests for generic types which have one or more contravariant type parameters, however, this is not the case. For these, Rezolver instead looks for an exact match and, if it doesn't find one, it then walks 'up' the type hierarchies of each contravariant type parameter looking for a hit, prioritising non- object base types over interfaces, and interfaces over the object base type. So, given a type hierarchy like this: interface IBase { } class Base : IBase { } interface IDerived : IBase { } class Derived : Base, IDerived { } If a request is made for an Action<Derived> , Rezolver will search for registrations for these types: Action<Derived> Action<Base> Action<IDerived> Action<IBase> Action<object> Action<> I.e. an 'open' generic registration The first ITarget to be retrieved from the container's ITargetContainer for one of these types will 'win'. Also, generic interfaces are given precedence over non-generic interfaces; with consideration given to interfaces which 'inherit' other interfaces (not a technically correct phrase, but we all know what it means). Array Types For generic types to which an array type is passed to a contravariant type argument, the picture gets more complicated - as the dynamically built Array type for a given element type also brings with it several interfaces. The search list for an array type, like the one above, then, starts getting very complex very quickly, e.g: Action<Derived[]> Action<IList<Derived>> Action<IEnumerable<Derived>> ... Action<Base[]> Action<IList<Base>> ... Action<IEnumerable> Action<Array> Action<object> The above list is, by no means, exhaustive - but you should be able to get the picture. Notice that the Array base type, like the object type before, is included as one of the last types, since it is ubiquitous to all arrays. Examples Contravariance is a tricky subject at the best of times and contriving examples for how to take advantage of it when using a DI container is even trickier. That said, you'll know when you need it, so hopefully what's presented here will help you. Hopefully, when you get to the stage of wanting to use it, you should just naturally expect it to work, and it will! 😉 Injecting IComparer<T> Let's say that in addition to Rezolver's own enumerables functionality, our application wants to be able to inject explicitly ordered enumerables. For that, we'll need the IComparer<T> interface, whose type parameter is contravariant. Now, the idea is that our application will be able to request an IOrderedEnumerable<T> for any type for which it could also request an IEnumerable<T> - this means that we're going to have to have a default comparer that can be used, whilst allowing specific comparers for known types to be registered in addition. The most natural way to do this is to try to wrap the OrderBy extension method, but Rezolver cannot (currently) bind to generic methods Instead, we can quite easily write a class which implements IOrderedEnumerable<T> by wrapping around the OrderBy extension method: public class OrderedEnumerableWrapper<T> : IOrderedEnumerable<T> { private readonly IOrderedEnumerable<T> _orderedEnumerable; // note - key selector and ascending/descending might also be desirable - but we'll // leave this out public OrderedEnumerableWrapper(IEnumerable<T> enumerable, IComparer<T> comparer) { _orderedEnumerable = enumerable.OrderBy(t => t, comparer); } IOrderedEnumerable<T> IOrderedEnumerable<T>.CreateOrderedEnumerable<TKey1>( Func<T, TKey1> keySelector, IComparer<TKey1> comparer, bool descending) { return _orderedEnumerable.CreateOrderedEnumerable(keySelector, comparer, descending); } IEnumerator<T> IEnumerable<T>.GetEnumerator() { return _orderedEnumerable.GetEnumerator(); } IEnumerator IEnumerable.GetEnumerator() { return _orderedEnumerable.GetEnumerator(); } } The generic class accepts an enumerable (automatically injected by Rezolver) and an IComparer<T> - the default version of which will wrap around the Comparer<T>.Default property: public class DefaultComparerWrapper<T> : IComparer<T> { int IComparer<T>.Compare(T x, T y) { return Comparer<T>.Default.Compare(x, y); } } Now - if we configure the container correctly and resolve the correct types, getting an ordered enumerable is pretty simple: var container = new Container(); container.RegisterType(typeof(DefaultComparerWrapper<>), typeof(IComparer<>)); container.RegisterType(typeof(OrderedEnumerableWrapper<>), typeof(IOrderedEnumerable<>)); // explicit registration for IEnumerable<int> container.RegisterObject(Enumerable.Range(0, 10).Reverse()); var unordered = container.ResolveMany<int>(); var ordered = container.Resolve<IOrderedEnumerable<int>>(); Assert.NotEqual(unordered, ordered); Assert.Equal(Enumerable.Range(0, 10), ordered); So far, so 'open generic' - we can now get ordered enumerables which work for any of the built-in .Net types that Comparer<T>.Default also works for. Now we need to extend it for custom types. Let's use a similar example to the one used on MSDN for the Comparer<T> type - and introduce some types which represent 2D geometries: public interface I2DShape { double CalcArea(); } public class Rectangle : I2DShape { public double Length { get; } public double Height { get; } public Rectangle(double length, double height) { Length = length; Height = height; } public double CalcArea() { return Length * Height; } } public class Square : Rectangle { public Square(double size) : base(size, size) { } } public class Circle : I2DShape { public double Radius { get; } public Circle(double radius) { Radius = radius; } public double CalcArea() { return Math.PI * Math.Pow(Radius, 2); } } And let's introduce an IComparer<T> which sorts these objects by their area: public class ShapeAreaComparer : IComparer<I2DShape> { private readonly IComparer<double> _doubleComparer; public ShapeAreaComparer(IComparer<double> doubleComparer) { _doubleComparer = doubleComparer; } public int Compare(I2DShape x, I2DShape y) { return _doubleComparer.Compare(x.CalcArea(), y.CalcArea()); } } Clearly, with this in place it would be trivial to register shape instances as I2DShape and register the ShapeAreaComparer as the comparer for the type IComparer<I2DShape> - thus allowing us to request an IOrderedEnumerable<I2DShape> , we don't need a contravariance-aware DI container to be able to do that. But what if we want to inject an IOrderedEnumerable<T> where T is one of the concrete shape types: Rectangle Square Circle Meaning that our OrderedEnumerableWrapper<T> will be looking for one of these, respectively: IComparer<Rectangle> IComparer<Square> IComparer<Circle> Without a contravariance-aware container, this would cause us a problem, because we'd need to register the ShapeAreaComparer type for each and every specialisation of IComparer<T> applicable for every I2DShape -implementation present in our application. Thankfully, Rezolver is aware of the contravariance of T in IComparer<T> , which means that all we have to do is to register the type ShapeAreaComparer as IComparer<I2DShape> , and Rezolver will automatically use it whenever it is compatible with a given T . The following example breaks this into two demonstrations - one explicit set of assertions which verify the ShapeAreaComparer is being used for any compatible comparer type, and another which verifies that ordered enumerables of concrete shape types are being created correctly: var container = new Container(); // use the same two wrapper registrations as before. We need the default // comparer to inject IComparer<double> into our ShapeAreaComparer container.RegisterType(typeof(DefaultComparerWrapper<>), typeof(IComparer<>)); container.RegisterType(typeof(OrderedEnumerableWrapper<>), typeof(IOrderedEnumerable<>)); // now register our shape comparer container.RegisterType<ShapeAreaComparer, IComparer<I2DShape>>(); // ## TEST 1: Check contravariance is working for the comparer types: var rectangleComparer = Assert.IsType<ShapeAreaComparer>(container.Resolve<IComparer<Rectangle>>()); var squareComparer = Assert.IsType<ShapeAreaComparer>(container.Resolve<IComparer<Square>>()); var circleComparer = Assert.IsType<ShapeAreaComparer>(container.Resolve<IComparer<Circle>>()); // ## TEST 2: Add some shapes and make sure they get sorted correctly: container.RegisterObject<IEnumerable<Rectangle>>( new Rectangle[] { new Rectangle(3, 1), new Rectangle(1, 2), new Rectangle(1, 1) }); container.RegisterObject<IEnumerable<Square>>( new Square[] { new Square(3), new Square(2), new Square(1) }); container.RegisterObject<IEnumerable<Circle>>( new Circle[] { new Circle(3), new Circle(2), new Circle(1) }); var sortedRectangles = container.Resolve<IOrderedEnumerable<Rectangle>>(); var sortedSquares = container.Resolve<IOrderedEnumerable<Square>>(); var sortedCircles = container.Resolve<IOrderedEnumerable<Circle>>(); Assert.Equal( Enumerable.Range(1, 3).Select(i => (double)i), sortedRectangles.Select(r => r.CalcArea())); Assert.Equal( Enumerable.Range(1, 3).Select(i=> (double)i * i), sortedSquares.Select(s => s.CalcArea())); Assert.Equal( Enumerable.Range(1, 3).Select(i => Math.PI * Math.Pow(i, 2)), sortedCircles.Select(c => c.CalcArea())); Note In the example, it would make sense for ShapeAreaComparer to be registered as a singleton, the idea being that one single instance is used for all IComparer<I2DShape> -compatible requests. While this will work at the moment, Rezolver incorrectly creates one instance per unique IComparer<T> type instead of one 'master' instance for all. This bug is being tracked on issue #53 Overriding Contravariant Registrations As described in the opening paragraph above, Rezolver conducts searches for compatible registrations in the order of best-to-worst match which, for contravariant type parameters, means that registrations which target a derived type are used in preference to a registration which targets a base or interface. So, extending our above example, let's say we want to sort rectangles by area and then by length if their areas are the same, and then by height if their lengths are the same. For this we need a new RectangleComparer : public class RectangleComparer : IComparer<Rectangle> { private readonly IComparer<I2DShape> _shapeComparer; private readonly IComparer<double> _dimensionComparer; public RectangleComparer( IComparer<I2DShape> shapeComparer, IComparer<double> dimensionComparer) { _shapeComparer = shapeComparer; _dimensionComparer = dimensionComparer; } public int Compare(Rectangle x, Rectangle y) { var result = _shapeComparer.Compare(x, y); if (result == 0) { result = _dimensionComparer.Compare(x.Length, y.Length); if(result == 0) { result = _dimensionComparer.Compare(x.Height, y.Height); } } return result; } } Note that it has a dependency on two other comparers: IComparer<I2DShape> - which explicitly targets our catch-all ShapeAreaComparer as per the original setup - and IComparer<double> so we can compare lengths and highlights (which will use the 'catch-all' DefaultComparerWrapper<T> ). Now we just add the registration (shown in the example being added before our catch-all just to highlight the fact that the order in which these registrations are added doesn't affect the logic) and use it. Note As the comments in the next example point out - the enumerable that's added in this example is deliberately ordered such that a stable sort by area alone would yield the wrong result (as would be the case if we only used our original ShapeAreaComparer ) var container = new Container(); container.RegisterType(typeof(DefaultComparerWrapper<>), typeof(IComparer<>)); container.RegisterType(typeof(OrderedEnumerableWrapper<>), typeof(IOrderedEnumerable<>)); // register the comparers container.RegisterType<RectangleComparer, IComparer<Rectangle>>(); container.RegisterType<ShapeAreaComparer, IComparer<I2DShape>>(); // Requesting either IComparer<Rectangle> *or* IComparer<Square> now // resolves to the RectangleComparer - because Rectangle is Square's base. Assert.IsType<RectangleComparer>(container.Resolve<IComparer<Rectangle>>()); Assert.IsType<RectangleComparer>(container.Resolve<IComparer<Square>>()); // This array is written in the exact opposite order to the one we desire // And a stable sort by area would leave objects 1 + 2 in the same order, // and 3, 4 + 5 in the same order. IEnumerable<Rectangle> rectangles = new[] { new Rectangle(20, 1), //╗ new Rectangle(1, 20), //╩ Area = 20 new Rectangle(8, 2), //╗ new Square(4), //╠ Area = 16 new Rectangle(2, 8), //╝ }; container.RegisterObject(rectangles); Assert.Equal( rectangles.Reverse(), container.Resolve<IOrderedEnumerable<Rectangle>>()); Warning Eager readers will have noticed that the RectangleComparer is effectively a decorator and, while it's certainly possible to implement it and register it as such (with some tweaks), there is currently a bug affecting contravariant Decorators which prevents them being used for more derived types unless they are specifically registered for those types. The bug is being tracked on issue #54 So note that we are creating an explicit registration for IComparer<Rectangle> which then supersedes our IComparer<I2DShape> registration for Rectangle , but it also kicks in for Square as well - because Rectangle is 'closer' to Square than I2DShape is. Contravariance with Enumerables If you have read through the documentation on enumerables of generics then you will already be aware of Rezolver's powerful auto-enumerable functionality, and you can probably already guess how it works when requesting enumerables of contravariant generics. For an enumerable of a generic with one or more contravariant type parameters, every registration that matches the given type will be returned - in registration order, as demonstrated by this example which builds on our I2DShape types to configure the container to write shape information to a StringBuilder : var container = new Container(); container.RegisterObject<Action<Rectangle, StringBuilder>>( (r, sb) => sb.AppendLine($\"Length: { r.Length }, Height: { r.Height }\")); container.RegisterObject<Action<I2DShape, StringBuilder>>( (s, sb) => sb.AppendLine($\"Area: { s.CalcArea() }\")); container.RegisterObject<Action<object, StringBuilder>>( (o, sb) => sb.AppendLine($\"Type: { o.GetType() }\")); StringBuilder stringBuilder = new StringBuilder(); Square square = new Square(7); int count = 0; foreach(var action in container.ResolveMany<Action<Square, StringBuilder>>()) { action(square, stringBuilder); count++; } Assert.Equal(3, count); Assert.Equal( \"Length: 7, Height: 7\\r\\nArea: 49\\r\\nType: Rezolver.Tests.Examples.Types.Square\\r\\n\", stringBuilder.ToString()); Disabling Contravariance (Advanced) Warning If you need to start playing around with how contravariance works naturally within the container to make things work for your application then, assuming it's not to avoid a bug in Rezolver, you should consider instead whether your design is correct. Generally, if you've written a delegate or interface type with a contravariant parameter and are subsequently injecting instances of it, then the way that Rezolver will locate registrations for that type should be correct as per the registrations you add to the container. So, in most cases, if you're getting unexpected results it's likely you've missed something in your registrations. As with much of the rest of the built-in functionality in Rezolver, it's possible to disable contravariance by setting an option on the ITargetContainer which underpins your IContainer (which, if you're using either Container or ScopedContainer is the container itself). The option is EnableContravariance , which has a Default value that is, unsurprisingly, equivalent to true . You can set the option to true or false : Globally Against a specific closed generic, e.g. Foo<Bar> , to control contravariance for that specific type Against an open generic, e.g. Foo<> , to control contravariance for any generic type based on it Against a non-generic type, e.g. Bar , to control contravariance when that type, or any of its derivatives, is supplied as a type argument to any contravariant type parameter. Note When you disable contravariance using any of the following methods, Rezolver will expect registrations for the associated concrete generic types that your application requests. Disabling contravariance is something you might do when resolving multiple instances of a contravariant type, as in the previous delegate example, so we'll build on that with additional delegates for the Square type. We'll show five different ways to disable contravariance such that we only get one delegate when we request an array of Action<Square, StringBuilder> (which simply reuses the container's IEnumerable<> functionality. Note : We're using this method in these examples: private static void RegisterShapeDelegates(Container container) { container.RegisterObject<Action<Square, StringBuilder>>( (sq, sb) => sb.AppendLine($\"Square of size: { sq.Height }\")); container.RegisterObject<Action<Rectangle, StringBuilder>>( (r, sb) => sb.AppendLine($\"Length: { r.Length }, Height: { r.Height }\")); container.RegisterObject<Action<I2DShape, StringBuilder>>( (s, sb) => sb.AppendLine($\"Area: { s.CalcArea() }\")); container.RegisterObject<Action<object, StringBuilder>>( (o, sb) => sb.AppendLine($\"Type: { o.GetType() }\")); } Disabling for generics When you disable per-generic, if that type has one or more contravariant type parameters, then you are instructing Rezolver to suspend contravariant searches for any of those type parameters either for a specific closed version of that generic, or for any. Tip If a generic type doesn't have contravariant parameters, and you disable contravariance for it, you are telling Rezolver to suspend contravariance when that type is passed as an argument to another generic's contravariant type parameter - as shown in the next section . In the first example, we'll disable contravariance for Action<Square, StringBuilder> - which means we only get one delegate in our array: var container = new Container(); // set the option to disable contravariance container.SetOption<Options.EnableContravariance, Action<Square, StringBuilder>>(false); RegisterShapeDelegates(container); // this time we'll just resolve an array, which uses the enumerable functionality // behind the scenes. StringBuilder stringBuilder = new StringBuilder(); Square square = new Square(7); var squareResult = container.Resolve<Action<Square, StringBuilder>[]>(); Assert.Equal(1, squareResult.Length); squareResult[0](square, stringBuilder); Assert.Equal(\"Square of size: 7\\r\\n\", stringBuilder.ToString()); We can also disable it for all Action<,> delegates: var container = new Container(); // set the option to disable contravariance for all Action<,> types container.SetOption<Options.EnableContravariance>(false, typeof(Action<,>)); RegisterShapeDelegates(container); var squareResult = container.Resolve<Action<Square, StringBuilder>[]>(); var rectResult = container.Resolve<Action<Rectangle, StringBuilder>[]>(); var shapeResult = container.Resolve<Action<I2DShape, StringBuilder>[]>(); Assert.Equal(1, squareResult.Length); Assert.Equal(1, rectResult.Length); Assert.Equal(1, shapeResult.Length); Disabling for type arguments The previous two examples show how we can control Rezolver's contravariance for specific generic types. But sometimes you might want to suspend contravariance for a type, or any of its derivatives or implementations, for any generic to which they are passed as type arguments. So, the next example shows how we can disable contravariance for the Square type, which means that when any concrete generic is requested, if Square is passed as the type argument to a contravariant type parameter, the contravariance for that parameter will be ignored: var container = new Container(); // set the option to disable contravariance for the Square type only container.SetOption<Options.EnableContravariance, Square>(false); RegisterShapeDelegates(container); var squareResult = container.Resolve<Action<Square, StringBuilder>[]>(); Assert.Equal(1, squareResult.Length); And we can also do the same for any type which has the I2DShape interface: var container = new Container(); // set the option to disable contravariance for any type which implements I2DShape container.SetOption<Options.EnableContravariance, I2DShape>(false); RegisterShapeDelegates(container); var squareResult = container.Resolve<Action<Square, StringBuilder>[]>(); var rectResult = container.Resolve<Action<Rectangle, StringBuilder>[]>(); var shapeResult = container.Resolve<Action<I2DShape, StringBuilder>[]>(); Assert.Equal(1, squareResult.Length); Assert.Equal(1, rectResult.Length); Assert.Equal(1, shapeResult.Length); Disabling globally Finally, the simplest of all: disabling contravariance for all types: var container = new Container(); // set the option to disable contravariance completely container.SetOption<Options.EnableContravariance>(false); RegisterShapeDelegates(container); var squareResult = container.Resolve<Action<Square, StringBuilder>[]>(); var rectResult = container.Resolve<Action<Rectangle, StringBuilder>[]>(); var shapeResult = container.Resolve<Action<I2DShape, StringBuilder>[]>(); Assert.Equal(1, squareResult.Length); Assert.Equal(1, rectResult.Length); Assert.Equal(1, shapeResult.Length); Caution: Changing to 'Opt-in' As will have become apparent, Rezolver uses an opt-out model by default for contravariance simply because a generic type parameter is either contravariant or it isn't; and if it is then the container should adapt accordingly. If you want selective contravariance for only certain types in your application, then you will typically switch it off globally and then start setting the EnableContravariance option to true for those types you want to have opted in. But, in almost all cases, you will need to set it to true for more types than you initially thought - as contravariance has been switched off not only for the generics but also for all the types which are being passed as type arguments. So, our final example shows how we can re-enable contravariance only for the Action<Square, StringBuilder> delegate type - which actually involves re-enabling it for the Square type also: var container = new Container(); // set the option to disable contravariance completely container.SetOption<Options.EnableContravariance>(false); //re-enable for the Action<Square, StringBuilder> type *AND* the Square type container.SetOption<Options.EnableContravariance, Action<Square, StringBuilder>>(true); container.SetOption<Options.EnableContravariance, Square>(true); RegisterShapeDelegates(container); var squareResult = container.Resolve<Action<Square, StringBuilder>[]>(); Assert.Equal(4, squareResult.Length); Summary Rezolver's support for contravariance is comprehensive - including support for nesting contravariant types within others (examples not included because it gets very complicated very quickly, but you can see the test cases for this in the standard Rezolver test suite). So if you start working with contravariant types, then you should find Rezolver just works ."
  },
  "docs/nuget-packages/rezolver.microsoft.extensions.dependencyinjection.html": {
    "href": "docs/nuget-packages/rezolver.microsoft.extensions.dependencyinjection.html",
    "title": "Rezolver.Microsoft.Extensions.DependencyInjection Package | Rezolver IOC",
    "keywords": "Rezolver.Microsoft.Extensions.DependencyInjection Package See package page on nuget . Tip It's recommended that you use the Asp.Net Core Hosting integration package on top of this one to enable integration of Rezolver into your Asp.Net core website at an earlier stage of its lifetime. This package provides Rezolver's implementation of the Microsoft DI Container which drives the new Asp.Net Core stack. After adding the package, configuring your Asp.Net website to use Rezolver as the DI container is simple: Replace the default ConfigureServices function in your application's Startup.cs file with this one: // This method gets called by the runtime. Use this method to add services to the container. public IServiceProvider ConfigureServices(IServiceCollection services) { // Add framework services. services.AddMvc(); //create the Rezolver container from the services, without making any additional //registrations return services.CreateRezolverContainer(); // Or you can separate the process, allowing you to configure the underlying // target container, or the container or whatever: // ITargetContainer targets = new TargetContainer(); // targets.Populate(services); // return new ScopedContainer(targets); } This returns a new service provider to the Asp.Net Core stack - thus replacing the default service provider that's already built. As the comment in the snippet suggests, you will likely want to perform additional registration operations on the IContainer object that's returned by the CreateRezolverContainer function called here, since the Rezolver container supports more functionality (e.g. expressions, decorators, custom targets, and more) than the MS DI container does through its ServiceRegistrations class. An alternative to calling that one-shot method is shown in the comments at the end of the function. As the tips says at the top of this page, however, the Asp.Net Core Hosting package is probably the best way to integrate Rezolver into your application. That uses this package, but uses additional extension points in the Asp.Net Core stack to integrate Rezolver at an earlier stage in the application lifecycle."
  },
  "docs/nuget-packages/rezolver.microsoft.aspnetcore.hosting.html": {
    "href": "docs/nuget-packages/rezolver.microsoft.aspnetcore.hosting.html",
    "title": "Rezolver.Microsoft.AspNetCore.Hosting Package | Rezolver IOC",
    "keywords": "Rezolver.Microsoft.AspNetCore.Hosting Package This builds on the Rezolver.Microsoft.Extensions.DependencyInjection package to enable the integration of Rezolver into your Asp.Net Core site somewhat earlier in its startup phase. See package page on nuget . Rezolver integration is available for both Asp.Net Core 1.1 and 2.0, with the Asp.Net Core 2.0 integration offering more flexibility as it allows you to perform configuration on the container(s) that are created before any registrations are made. Asp.Net Core 2.0 Version 2.0 of the package supports Asp.Net Core 2.0. Program.cs changes After adding the package, change your program.cs file so it looks like this: public class Program { public static void Main(string[] args) { BuildWebHost(args).Run(); } public static IWebHost BuildWebHost(string[] args) => WebHost.CreateDefaultBuilder(args) .UseRezolver() .UseStartup<Startup>() .Build(); // NOTE - you can also pass a configuration callback to UseRezolver(), e.g: /* * .UseRezolver(o => * { * // Example of disabling contravariance * o.TargetContainerConfig.ConfigureOption<EnableContravariance>(false); * * // you can also add configuration to the container configuration via * // the ContainerConfig property (e.g. change compilers). * }) */ } So, at the most basic level you just call the UseRezolver method, and that's enough. If you've been reading some of the topics on this site - say, about contravariance or lazy and eager enumerables then you'll have seen how we can use options to control complex behaviours in Rezolver containers. That's what is shown in the alternative call to UseRezolver in the commented code. you can also pass a configuration callback that will be called to modify the RezolverOptions that will be used to create both the IRootTargetContainer that forms the basis of the registrations, and the ScopedContainer that will ultimately create the objects for the application. Note Please note that lazy enumerables are currently switched off in Rezolver's integration with Asp.Net Core because of a mis-specification of a test by the Dependency Injection team. The specification test is something which a DI container should pass if it's intending to be used with Asp.Net Core - and unfortunately there was one test that failed when Rezolver was using lazy enumerables - which is its default behaviour. An issue was raised on the Git repo and has been fixed, but it'll take a few more days/weeks before we see it in the wild. We can say that if you need lazy enumerables, then you should be able to re-enable them and your application will work. Startup.cs changes Now we need to tell the Asp.Net Core stack that you want an IRootTargetContainer to be created in order to construct the ScopedContainer that will be used as the DI container. The simplest way to do this is to add a single method (it can be empty) called ConfigureContainer , which accepts a single parameter of the type IRootTargetContainer . Note The IRootTargetContainer interface was added in Rezolver 1.3.2 to accommodate covariance and is now the interface used for 'top-level' target containers. You can still declare your method as ConfigureContainer<ITargetContainer> without losing any functionality - so projects which are upgrading from v2.0.x of the Hosting package will still work without any code changes. public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { // you need AddOptions if you intend to use the configuration callback // in your call to UseRezolver() in program.cs services.AddOptions(); services.AddMvc(); } // Adding this method (even if empty) is enough to trigger the use of Rezolver // as the Asp.Net Core 2 Application's DI container. public void ConfigureContainer(IRootTargetContainer targets) { // The targets passed here will be used to create the ScopedContainer. // Perform additional Rezolver-specific registrations (e.g. Decoration) here. } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IHostingEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); app.UseBrowserLink(); } else { app.UseExceptionHandler(\"/Home/Error\"); } app.UseStaticFiles(); app.UseMvc(routes => { routes.MapRoute( name: \"default\", template: \"{controller=Home}/{action=Index}/{id?}\"); }); } } Note Note the call to AddOptions() in the ConfigureServices method. As the comment in the code says, you need this if you intend to use configuration callbacks in your UseRezolver method call in program.cs . By adding that ConfigureContainer method, a new Rezolver ScopedContainer will be created and populated from the IServiceCollection that contains all the service registrations for the application. As the comment states, inside that method you can also perform more configuration or registrations on the IRootTargetContainer , such as decorators, expressions etc which are not supported by Microsoft's DI abstractions, before the target container is passed to a new ScopedContainer that will then be used as the application's IServiceProvider . And that's it - your application is configured. Asp.Net Core 1.1 Version 1.3 is the latest version of the package that supports Asp.Net Core 1.1. The setup is fundamentally identical, except the UseRezolver method does not accept any callbacks. public class Program { public static void Main(string[] args) { var host = new WebHostBuilder() //add the Rezolver container to the host builder .UseRezolver() .UseKestrel() .UseContentRoot(Directory.GetCurrentDirectory()) .UseIISIntegration() .UseStartup<Startup>() .Build(); host.Run(); } } The startup.cs is similar to what's required for Asp.Net Core 2.0 - except your ConfigureContainer method should accept an ITargetContainer - i.e. ConfigureContainer(ITargetContainer) and then Rezolver will be used as the container for your application. Clearly, we recommmend moving to Asp.Net Core 2.0 ASAP as it has more features, is faster, and is generally way cooler than 1.1! 😉"
  },
  "docs/nuget-packages/rezolver.html": {
    "href": "docs/nuget-packages/rezolver.html",
    "title": "Rezolver Nuget Package | Rezolver IOC",
    "keywords": "Rezolver Nuget Package See package page on nuget . The core nuget package for using Rezolver in your class library or application, includes: All the core abstractions and classes required to create TargetContainer and Container objects. The core ITarget implementations which allow you to create/retrieve objects using all the standard techniques documented here (constructor injection, enumerables, delegates and expressions etc) from the get-go. The expression compiler which builds bespoke factories for each service you resolve in your container Simply add the package, add an using / import for the Rezolver namespace and you're all set."
  },
  "docs/nuget-packages/rezolver.configuration.html": {
    "href": "docs/nuget-packages/rezolver.configuration.html",
    "title": "Nuget Package: Rezolver.Configuration | Rezolver IOC",
    "keywords": "Nuget Package: Rezolver.Configuration This package provides the Rezolver configuration object model, whose purpose is to describe how a Target Container should be constructed and configured based on a configuration file/script loaded at runtime. It doesn't define any specific code for parsing configuration files - but it does provide a standard implementation of the @Rezolver.Configuration.IConfigurationAdapter, whose job it is to create a ITargetContainer from a @Rezolver.Configuration.IConfiguration instance. You can implement your own configuration file formats with this simply by writing code to read your desired format and getting your parser to create an instance of @Rezolver.Configuration.IConfiguration"
  },
  "docs/service-registration.html": {
    "href": "docs/service-registration.html",
    "title": "Registering services | Rezolver IOC",
    "keywords": "Registering services Registering services ultimately means adding ITarget objects to an ITargetContainer . The different built-in implementations of ITarget provide us with the ability to resolve objects in different ways - and this section looks at those implementations in addition to how we actually perform registrations. Tip An ITarget is an object stored within an ITargetContainer which contains information about how an object is to be created or retrieved when a container's Resolve operation is called. This subject means delving into the ITargetContainer interface and our default implementation, TargetContainer - which contains the core registration API, as well as some extra functionality which might be useful to some. What is ITargetContainer ? The ITargetContainer interface supplies service registrations when using the default container types Container and ScopedContainer . All the target container does is to provide a means to register and look up ITarget instances which have been registered against specific types. Note These two container types actually require an IRootTargetContainer - an interface which is implemented by the standard target container: TargetContainer . Registering via extension methods The majority of your work with the Rezolver framework will use extension methods to create and add targets to an ITargetContainer which will ultimately drive the IContainer that you will use to create instances. These extension methods are more expressive than the core API (documented below), and greatly simplify your interaction with the Rezolver framework. The majority of the code samples shown on this site use these registration methods, which are documented in the API section of this site: AliasTargetContainerExtensions - for registering aliases of one type to another (useful for reusing singletons for multiple types) DecoratorTargetContainerExtensions - for registering decorators DelegateTargetContainerExtensions - for registering factory delegates ExpressionTargetContainerExtensions - for registering expression trees MultipleTargetContainerExtensions - for batch registering multiple targets ObjectTargetContainerExtensions - for registering object references/values RegisterTypeTargetContainerExtensions - for registering constructor-injected types (plain and open-generic) ScopedTargetContainerExtensions - for registering scoped constructor-injected types SingletonTargetContainerExtensions - for registering singleton constructor-injected types Registering via Register To add registrations to an ITargetContainer directly, i.e. without extension methods, we ultimately use the Register method, which accepts an ITarget object and an optional Type against which that target is to be registered. If the optional type is not provided, then the target's DeclaredType is used as the default registration type: Tip In the next example, we're using the ObjectTarget . We have more in-depth documentation about ObjectTarget if you want to know more. var targets = new TargetContainer(); targets.RegisterObject(\"hello world\"); var target = targets.Fetch(typeof(string)); Assert.IsType<ObjectTarget>(target); So, here, the target container defaults to using System.String as the registration type for the target because that's its DeclaredType . We can also provide any base or interface of the target's type as a valid type, too: Tip This time we're creating a ConstructorTarget via one of its static factory functions. Again, this target is covered in more depth here . var targets = new TargetContainer(); targets.Register(Target.ForType<MyService>(), typeof(IMyService)); var target = targets.Fetch(typeof(IMyService)); Assert.IsType<ConstructorTarget>(target); The class MyService implements the interface IMyService in this example If you attempt to register a target against a type which the target does not support then an exception will occur: var targets = new TargetContainer(); // int is obviously not compatible with IMyService. Assert.Throws<ArgumentException>( () => targets.Register(Target.ForObject(50), typeof(IMyService))); Note THE DOCUMENTATION AFTER THIS POINT IS PRIMARILY AIMED AT DEVELOPER WHO ARE LOOKING TO EXTEND REZOLVER Retrieving registrations As illustrated by earlier examples, you can interrogate the registrations in an ITargetContainer through two methods: Fetch - retrieves the last-registered target for the type FetchAll - retrieves all targets that have been registered for the type, in the order they were registered. These same methods are used by the standard container classes when determining how to resolve an instance (or instances) for a given type. Note There is currently no way to remove a registration from a ITargetContainer . You can, however, create an OverridingTargetContainer to override the registrations of another, and pass that as the target container to a new Container or ScopedContainer . Target types The different ways in which Rezolver can create/obtain objects for your application, then, are pretty much all handled through the ITarget interface, and the different implementations that are available. Whether you want to use constructor injection (via ConstructorTarget or GenericConstructorTarget ), an object you've built yourself (via ObjectTarget ), an expression tree (via ExpressionTarget ) or a factory delegate (via DelegateTarget ), or something else, there's lots of ways to get Rezolver to build the services you want to use in your application. All the targets used by default in Rezolver to create objects can be found in the Rezolver.Targets namespace. In addition to their constructors, the Target static class also contains numerous factory methods for building these targets in isolation, using an API which is similar to the registration API. For example: ForType is a shortcut for building the ConstructorTarget , which binds a type for constructor injection. In the table of contents to the left (or above if on a small screen) you'll also find high-level walkthroughs, including examples, on the most important targets you need to know about. Implementing targets You can also implement ITarget yourself if you're feeling adventurous - but you must provide a way for the container to compile your target into an ICompiledTarget that can be used at resolve-time. Documentation on how to do this will be added to this guide in the future, but if you're curious now, then the types in the Rezolver.Compilation.Expressions namespace will provide a few ideas. Short-circuited targets Rezolver containers also support short-circuited, 'direct' targets which bypass the compilation process when attempting to fulfil a Resolve operation, specifically: If the target also supports the ICompiledTarget interface, then its GetObject method will be used to get the object. If the target can be cast to the type originally requested through the Resolve method, then target will be returned as the object. The framework exploits both of these techniques to use the container as the source of its own services and configuration. Next steps Use some of the links above to start exploring different ways to create objects in Rezolver. If you haven't already, explore Rezolver's concept of object lifetimes to learn about transient, singleton and scoped objects."
  },
  "docs/objects.html": {
    "href": "docs/objects.html",
    "title": "Objects as Services | Rezolver IOC",
    "keywords": "Objects as Services Sometimes you will want to create an object yourself and register that in the container for use as a particular service type. This is done either by creating an ObjectTarget and registering it in a target container, or via the extension method(s) RegisterObject . This type of registration is often thought of as a singleton, but it's more accurate to think of it as a 'constant' service - because, from the moment the registration is created, the object reference is already known and doesn't change. Singletons are different because the container creates the instance for you. We don't need many examples for this, first - this is how you'd register an object against its runtime type: var container = new Container(); var service = new MyService(); container.RegisterObject(service); Assert.Same(service, container.Resolve<MyService>()); And if you want to register it against a different type, the following example shows one way, with another shown in comments: var container = new Container(); var service = new MyService(); container.RegisterObject<IMyService>(service); // NOTE: Could also use: // container.RegisterObject(service, typeof(IMyService) Assert.Same(service, container.Resolve<IMyService>()); That's all there is to it, really. Although before we move on, we should take a quick look at how object-based services interact with scopes. Objects in Scopes A scope (obtained either by using ScopedContainer or through a IContainerScope returned from a container's CreateScope method) will by default dispose of any disposable objects it creates when it is disposed. If those objects are obtained from an ObjectTarget , however, then no scope will ever touch them - because you created them, therefore you will also typically dispose them. Here's an example, using the aforementioned ScopedContainer : var disposableObj = new DisposableType(); using (var container = new ScopedContainer()) { container.RegisterObject(disposableObj); var result = container.Resolve<DisposableType>(); Assert.Same(disposableObj, result); } // Should NOT be disposed Assert.False(disposableObj.Disposed); As the last assertion proves - the supplied object is left untouched by the scoped container. You can change this behaviour, however, by providing a different ScopeBehaviour when creating the target (directly registering with the RegisterObject method): var disposableObj = new DisposableType(); using (var container = new ScopedContainer()) { container.RegisterObject(disposableObj, scopeBehaviour: ScopeBehaviour.Explicit); var result = container.Resolve<DisposableType>(); Assert.Same(disposableObj, result); } // Should be disposed Assert.True(disposableObj.Disposed); Notice the scopeBehaviour: named argument on the 4th line. To enable the correct disposal behaviour, you must use Explicit because you need the scope to know that only one instance should ever be tracked per scope. Warning If you pass Implicit then disposal will still work, although there's a risk that the object will be tracked by the scope multiple times and, therefore, could be disposed multiple times. This behaviour is unintentional and will be prevented in a future release by raising an exception if the Implicit behaviour is set on an ObjectTarget . Child scopes For the seasoned IOC container-user the last phrase of the previous section - 'one instance should ever be tracked per scope ' - will likely be setting alarm bells ringing. As with Singletons, Rezolver knows that a service implemented by a constant object should only ever be tracked in the root-most scope so that the disposal of a child scope does not also cause the disposal of the object. To demonstrate this, another test, which uses a ScopedContainer as before, but which resolves the object only through a child scope which is then immediately disposed. The test shows that the object, however, is not disposed of until the root-most scope - the ScopedContainer - is disposed: var disposableObj = new DisposableType(); using (var container = new ScopedContainer()) { container.RegisterObject(disposableObj, scopeBehaviour: ScopeBehaviour.Explicit); var result = container.Resolve<DisposableType>(); Assert.Same(disposableObj, result); } // Should be disposed Assert.True(disposableObj.Disposed); Next steps Feel free to explore the table of contents or head back to the main service registration overview to explore more features of Rezolver."
  },
  "docs/index.html": {
    "href": "docs/index.html",
    "title": "Rezolver Dev Guide | Rezolver IOC",
    "keywords": "Rezolver Dev Guide Welcome to the Rezolver developer guide - the best resource to learn about all the features of Rezolver, and tips and tricks to get the most out of it. Getting started As with many open source .Net projects, there are two primary ways to get Rezolver integrated into your project. The easiest is via the Nuget packages By using the Nuget packages, you ensure that you're using the latest (hopefully stable!) releases. Pre-release packages will also be made available for in-development features. Fork or download the Rezolver source from Github Use this if you can't integrate nuget into your build pipeline, or if you'd like to customise or contribute to the project. If you're looking to customise, though, then there should be enough extensibility points in the framework to allow you to do so without having to change core types. If that's not the case, post an issue on the Github project so we can get it added in and make it better for everyone! Tests as Examples Most of the example code shown here is drawn directly from the project Rezolver.Tests.Examples , which can be found in the test folder under the root of the repo. If there's a filename shown at the top of a code example, then that should equal the filename where you can find that code in the examples project. Please note that any example code containing type declarations will be found in the Types folder of that project, with all the individual test files in the root. We're using xunit for all our tests, hence all the examples are written for it too. Matching an example to a test We do omit the test function declaration in these examples - but if you look down a tests file you'll see comments inside each test method with an XML tag. Here's the body of the ObjectExamples.cs file, which contains all the examples for the 'Objects as Services' documentation : using Rezolver.Tests.Examples.Types; using Xunit; namespace Rezolver.Tests.Examples { public class ObjectExamples { [Fact] public void ShouldRegisterAndRetrieveByItsType() { // <example1> var container = new Container(); var service = new MyService(); container.RegisterObject(service); Assert.Same(service, container.Resolve<MyService>()); // </example1> } [Fact] public void ShouldRegisterAndRetrieveByInterface() { // <example2> var container = new Container(); var service = new MyService(); container.RegisterObject<IMyService>(service); // NOTE: Could also use: // container.RegisterObject(service, typeof(IMyService) Assert.Same(service, container.Resolve<IMyService>()); // </example2> } [Fact] public void ShouldNotDisposeByDefault() { // <example10> var disposableObj = new DisposableType(); using (var container = new ScopedContainer()) { container.RegisterObject(disposableObj); var result = container.Resolve<DisposableType>(); Assert.Same(disposableObj, result); } // Should NOT be disposed Assert.False(disposableObj.Disposed); // </example10> } [Fact] public void ShouldDispose() { // <example11> var disposableObj = new DisposableType(); using (var container = new ScopedContainer()) { container.RegisterObject(disposableObj, scopeBehaviour: ScopeBehaviour.Explicit); var result = container.Resolve<DisposableType>(); Assert.Same(disposableObj, result); } // Should be disposed Assert.True(disposableObj.Disposed); // </example11> } [Fact] public void OnlyRootScopeShouldDispose() { // <example12> var disposableObj = new DisposableType(); using (var container = new ScopedContainer()) { container.RegisterObject(disposableObj, scopeBehaviour: ScopeBehaviour.Explicit); using (var scope = container.CreateScope()) { var result = container.Resolve<DisposableType>(); Assert.Same(disposableObj, result); } // Should not be disposed here... Assert.False(disposableObj.Disposed); } // ... but should be disposed here Assert.True(disposableObj.Disposed); // </example12> } } } You'll notice that the body of each test method looks like this: //<examplen> ... (code) ... //</examplen> Note This is a facet of the code snippet feature of docfx Each example is numbered sequentially (the n ), so it shouldn't be too hard to marry up the example in the documentation to the test in the tests file. Something missing? This site is always under development, and we're doing everything we can to get all high-level documentation in place so that even novice users of DI containers can get up and running with Rezolver. If you have a question about something that's not covered here, please feel free to open an issue over on Github . Next Steps Asp.Net Core developers should read how to integrate Rezolver into the Asp.Net Core hosting pipeline . Learn how to create and use a container ."
  },
  "docs/delegates.html": {
    "href": "docs/delegates.html",
    "title": "Factory Delegates | Rezolver IOC",
    "keywords": "Factory Delegates You can register delegates in a Rezolver container so that, when the associated service type is resolved, your delegate will be executed and its result returned as the instance. The delegate can be of any type, subject to the following constraints: The delegate must have non- void return type It must not have any ref or out parameters To register delegates you can use one of the many RegisterDelegate extension methods for ITargetContainer . To create delegate targets you can either: Manually create an instance of DelegateTarget through its constructor Use the ForDelegate overload, which provides specialisations for variants of the System.Func<> generic delegate Delegates are a useful tool in the context of IOC containers as support for them gives you the opportunity to perform much more complex tasks in order to resolve an object than the functionality offered by the standard targets in Rezolver. Whether you should perform excessively complex logic in these factories is a topic of debate. Our view is that you should be able to if you want, or need, to, so Rezolver's support for delegates is extensive, including the ability to inject arguments to your delegate from the container, or resolve additional services inside your delegate through IResolveContext . Basic Examples Here are some straightforward examples RegisterType analogue In this example, we simply register a delegate that fires a type's constructor: var container = new Container(); container.RegisterDelegate(() => new MyService()); var result = container.Resolve<MyService>(); Assert.NotNull(result); As a Singleton We can also use the Singleton and the Scoped extension methods to modify the lifetime of the object produced by the delegate: var container = new Container(); container.Register( // RegisterSingleton specialises for types only, so // we create the target manually and apply this .Singleton // extension method to to it before registering Target.ForDelegate(() => new MyService()).Singleton() ); var result = container.Resolve<MyService>(); var result2 = container.Resolve<MyService>(); Assert.Same(result, result2); Honouring Scopes ( IContainerScope ) As you would expect, if the object is resolved through a scope, then it will be tracked and disposed by that scope when it is disposed: var container = new Container(); container.RegisterDelegate(() => new DisposableType()); DisposableType result, result2; using (var scope = container.CreateScope()) { result = scope.Resolve<DisposableType>(); using (var childScope = scope.CreateScope()) { result2 = childScope.Resolve<DisposableType>(); } Assert.True(result2.Disposed); } Assert.True(result.Disposed); Advanced Examples Argument injection As mentioned in the introduction, Rezolver can inject arguments into your factory delegates just like they were constructors bound by ConstructorTarget or GenericConstructorTarget . var container = new Container(); container.RegisterType<MyService, IMyService>(); // delegate requires an IMyService to feed as a dependency, along with // another value which is not injection-friendly (DateTime) DateTime expectedStartDate = new DateTime(2014, 5, 5); container.RegisterDelegate((IMyService service) => new RequiresIMyServiceAndDateTime(service, new DateTime(2014, 5, 5))); var result = container.Resolve<RequiresIMyServiceAndDateTime>(); Assert.NotNull(result.Service); Assert.Equal(expectedStartDate, result.StartDate); Any delegate type, with any number of parameters, is supported, so long as it has a return type. Injecting IResolveContext All Resolve operations have an IResolveContext at their heart. Through the context, you can get the Container that originally received the call, the Scope and the RequestedType . It can also be used to create a new child scope (through its implementation of the IScopeFactory interface). If you need the context to be passed to your delegate - just make sure to declare a parameter of that type, most commonly you'll probably use the single parameter specialisation of the RegisterDelegate or ForDelegate methods, but ultimately the parameter can appear anywhere in the delegate's signature and it will be injected. This example shows the Func<IRezolveContext, TResult> overload in action: var container = new Container(); // RegisterDelegate has a specialisation for a delegate which takes ResolveContext container.RegisterDelegate(rc => new RequiresResolveContext(rc)); var result = container.Resolve<RequiresResolveContext>(); // the context was injected Assert.NotNull(result.Context); // and the container on the context will be the one on which we called Resolve<> Assert.Same(container, result.Context.Container); Resolving inside a delegate Building on the above, here's an example which injects the IResolveContext in order to perform a late-bound Resolve operation to inject a different dependency based on some ambient information about a user (which is also injected into the delegate). This is quite a long example which, admittedly, can be solved in a few different ways. We're not saying this is the only way :) public class AppIdentity : IIdentity { public string AuthenticationType { get; } = \"Magic\"; public bool IsAuthenticated { get; } = true; public string Name { get; } = \"Joe Bloggs\"; } public class AppPrincipal : IPrincipal { public IIdentity Identity { get; } private string[] Roles { get; } public AppPrincipal(IIdentity identity, string[] roles) { Identity = identity; Roles = roles ?? new string[0]; } public bool IsInRole(string role) { return Roles.Contains(role, StringComparer.OrdinalIgnoreCase); } } public interface IUserActionsService { IEnumerable<string> GetActions(); } public interface IRoleBasedActionsService : IUserActionsService { } public class CustomerActionsService : IRoleBasedActionsService { public IEnumerable<string> GetActions() => new[] { \"View Products\" }; } public class SalesActionsService : IRoleBasedActionsService { public IEnumerable<string> GetActions() => new[] { \"Create Customers\", \"View Products\" }; } public class AdminActionsService : IRoleBasedActionsService { public IEnumerable<string> GetActions() => new[] { \"Manage Users\", \"Manage Products\", \"Create Customers\", \"View Products\" }; } public class UserControlPanel { public IUserActionsService ActionsService { get; } public UserControlPanel(IUserActionsService actionsService) { ActionsService = actionsService; } } The goal is to create a UserControlPanel which is correct for the current User (identified by a static property CurrentPrincipal ), so that it has access to a list of actions the user can perform based on their role. The UserControlPanel class requires an IUserActionsService which provides access to that list of actions, and we have three separate implementations of that interface which we could use, based on the user's role. We will use the @RezolveContext.Resolve* operation to create the instance we want to inject after deciding which type to resolve based on the user's role: static IPrincipal CurrentPrincipal { get; set; } [Fact] public void ShouldGetDifferentImplementationFromResolveContextForUser() { IIdentity identity = new AppIdentity(); // three principals, one for each role var adminPrincipal = new AppPrincipal(identity, new[] { \"Admin\" }); var salesPrincipal = new AppPrincipal(identity, new[] { \"Sales\" }); var customerPrincipal = new AppPrincipal(identity, new[] { \"Customer\" }); var container = new Container(); container.RegisterType<AdminActionsService>(); container.RegisterType<SalesActionsService>(); container.RegisterType<CustomerActionsService>(); container.RegisterType<UserControlPanel>(); // register delegate to read the CurrentPrincipal property, to make it dynamic container.RegisterDelegate(() => CurrentPrincipal); // now register the delegate handler for the IUserActionsService, which does the // role sniffing over the principal container.RegisterDelegate((IPrincipal p, IResolveContext rc) => { IUserActionsService toReturn = null; if (p != null) { if (p.IsInRole(\"Customer\")) toReturn = rc.Resolve<CustomerActionsService>(); else if (p.IsInRole(\"Sales\")) toReturn = rc.Resolve<SalesActionsService>(); else if (p.IsInRole(\"Admin\")) toReturn = rc.Resolve<AdminActionsService>(); } return toReturn; }); // set the principal, and resolve CurrentPrincipal = adminPrincipal; var result1 = container.Resolve<UserControlPanel>(); // now swap principals CurrentPrincipal = salesPrincipal; var result2 = container.Resolve<UserControlPanel>(); // and again CurrentPrincipal = customerPrincipal; var result3 = container.Resolve<UserControlPanel>(); Assert.IsType<AdminActionsService>(result1.ActionsService); Assert.IsType<SalesActionsService>(result2.ActionsService); Assert.IsType<CustomerActionsService>(result3.ActionsService); } Next Steps That's about it for delegate registrations. There are plans to add functionality to decorate instances via delegate, but in the meantime feel free to explore the table of contents or head back to the main service registration overview to explore more features of Rezolver."
  },
  "docs/decorators.html": {
    "href": "docs/decorators.html",
    "title": "Decorators | Rezolver IOC",
    "keywords": "Decorators The decorator pattern is a key part of many software projects, and Rezolver offers first-class support for implementing it either non-generically, or generically. Note If you're looking for how to register and use decorator delegates - there is a separate topic in this section dedicated to those. Registering decorators in Rezolver Registration of Decorators in Rezolver is done through the overloaded extension method RegisterDecorator . There is a generic and non-generic version (as is typical for nearly all Rezolver registration functions), but, unlike many other target types, there is no factory method in the Target static class to create one on its own. The sharp-eyed developer will be confused by this omission, especially since the type DecoratorTarget is a key part of Rezolver's implementation of decorators - but if you read the summary notes about that class, it should be apparent why: Decoration isn't solely implemented through an ITarget implementation, it also needs a special target container type in which that target will be registered - DecoratingTargetContainer , the creation of which is handled automatically by the RegisterDecorator methods. Examples For the first few examples, we'll be using these decorators for the interface IMyService , which has also been used in many of the other examples. If you've already looked at the enumerable examples then you'll be familiar with them: public class MyServiceDecorator1 : IMyService { public IMyService Inner { get; } public MyServiceDecorator1(IMyService inner) { Inner = inner; } } public class MyServiceDecorator2 : IMyService { public IMyService Inner { get; } public MyServiceDecorator2(IMyService inner) { Inner = inner; } } Single decorator, single service Here, we simply register an IMyService implementation and one of our decorators. We then resolve an instance and we should get an instance of the decorator, with the original IMyService as its Inner . var container = new Container(); container.RegisterType<MyService, IMyService>(); container.RegisterDecorator<MyServiceDecorator1, IMyService>(); var result = container.Resolve<IMyService>(); var decorator = Assert.IsType<MyServiceDecorator1>(result); Assert.IsType<MyService>(decorator.Inner); Two decorators, single service You can also 'stack' decorators for a given type, meaning you can decorate the decorators: // same as before - but two decorators // note that the order they're registered determines the order in which // the decoration occurs. var container = new Container(); container.RegisterType<MyService, IMyService>(); container.RegisterDecorator<MyServiceDecorator2, IMyService>(); container.RegisterDecorator<MyServiceDecorator1, IMyService>(); var result = container.Resolve<IMyService>(); var decorator = Assert.IsType<MyServiceDecorator1>(result); var innerDecorator = Assert.IsType<MyServiceDecorator2>(decorator.Inner); Assert.IsType<MyService>(innerDecorator.Inner); As the test shows, the decorators are applied in the order they are registered for the given type. Two decorators, enumerable Decorators are also applied to elements of an enumerable: var container = new Container(); // this time we'll register the decorators first, not because // we have to, but because we can :) container.RegisterDecorator<MyServiceDecorator2, IMyService>(); container.RegisterDecorator<MyServiceDecorator1, IMyService>(); // note: this array of types is purely to simplify the asserts // used at the end. var serviceTypes = new[] { typeof(MyService1), typeof(MyService2), typeof(MyService3), typeof(MyService4), typeof(MyService5), typeof(MyService6) }; var serviceTargets = serviceTypes.Select( t => Target.ForType(t) ); // another way to bulk-register multiple targets // against the same service type. container.RegisterMultiple(serviceTargets, typeof(IMyService)); var result = container.Resolve<IEnumerable<IMyService>>(); Assert.All(serviceTypes.Zip(result, (t, s) => (type: t, service: s)), ts => { var decorator = Assert.IsType<MyServiceDecorator1>(ts.service); var innerDecorator = Assert.IsType<MyServiceDecorator2>(decorator.Inner); Assert.IsType(ts.type, innerDecorator.Inner); }); Open Generic Decorator You can also use decorators with open generics - register them just like normal generic types , except via the RegisterDecorator method. For this, our basic generic decorator is this: public class UsesAnyServiceDecorator<TAnyService> : IUsesAnyService<TAnyService> { public IUsesAnyService<TAnyService> Inner { get; } public UsesAnyServiceDecorator(IUsesAnyService<TAnyService> inner) { Inner = inner; } public void UseTheService(TAnyService service) { throw new NotImplementedException(); } } And the code to register it shouldn't be too much of a surprise: var container = new Container(); container.RegisterType(typeof(UsesAnyService<>), typeof(IUsesAnyService<>)); container.RegisterDecorator(typeof(UsesAnyServiceDecorator<>), typeof(IUsesAnyService<>)); var result = container.Resolve<IUsesAnyService<MyService>>(); var decorator = Assert.IsType<UsesAnyServiceDecorator<MyService>>(result); Assert.IsType<UsesAnyService<MyService>>(decorator.Inner); Tip Enumerables of open generics can also be decorated in a similar way to the previous example. Just register multiple IService<> registrations, then one or more open generic decorators as normal - then an IEnumerable<IService<Foo>> will produce an enumerable with each element correctly decorated. Mixing Open Generic and Closed Decorators Note This is new in v1.2 after this issue was fixed. Given a type Foo<T> : IFoo<T> which will be resolved by interface, e.g: IFoo<Bar> , there are two ways in which we can decorate it: By registering a decorator for IFoo<Bar> By registering a decorator for the open generic IFoo<> Resolver allows you to mix both approaches, so that you can have one or more catch-all decorators for the open generic, as well as decorators for specific closed versions of that generic. When Resolver produces the underlying instance, it will be decorated with each decorator that applies for the type: var container = new Container(); container.RegisterType(typeof(UsesAnyService<>), typeof(IUsesAnyService<>)); container.RegisterDecorator(typeof(UsesAnyServiceDecorator<>), typeof(IUsesAnyService<>)); // this decorator only kicks in when resolving IUsesAnyService<MyService2> container.RegisterDecorator<UsesMyService2Decorator, IUsesAnyService<MyService2>>(); // will be decorated twice var redecorated = container.Resolve<IUsesAnyService<MyService2>>(); // but this will be decorated once var decorated = container.Resolve<IUsesAnyService<MyService1>>(); Assert.IsType<UsesMyService2Decorator>(redecorated); Assert.IsType<UsesAnyServiceDecorator<MyService2>>( ((UsesMyService2Decorator)redecorated).Inner); // but the IUsesAnyService<MyService1> will only be decorated once Assert.IsType<UsesAnyServiceDecorator<MyService1>>(decorated); In the above example, we create a registration for the interface IUsesAnyService<> , and then two decorators: the first also for IUsesAnyService<> and a second which only applies to IUsesAnyService<MyService2> . We then resolve two instances - an IUsesAnyService<MyService2> , which is decorated twice, and an instance of IUsesAnyService<MyService1> , which is decorated only once. Ordering of Open and Closed Generic Decorators When mixing open and closed generic decorators, the decorators are always applied in the order they are registered, regardless of whether the decorator is registered against the closed or open generic. So if you register decorators for the following types: IFoo<> IFoo<Bar> IFoo<> An instance of IFoo<Bar> will be decorated by all three in that same order, whereas an instance of IFoo<Baz> will only be decorated by decorators 1 and 3, in that order. The following example demonstrates the IFoo<Bar> scenario, for completeness: var container = new Container(); container.RegisterType(typeof(UsesAnyService<>), typeof(IUsesAnyService<>)); container.RegisterDecorator(typeof(UsesAnyServiceDecorator<>), typeof(IUsesAnyService<>)); //register the special decorator for IUsesAnyService<MyService2> again container.RegisterDecorator<UsesMyService2Decorator, IUsesAnyService<MyService2>>(); container.RegisterDecorator(typeof(UsesAnyServiceDecorator2<>), typeof(IUsesAnyService<>)); var reredecorated = Assert.IsType<UsesAnyServiceDecorator2<MyService2>>( container.Resolve<IUsesAnyService<MyService2>>()); var redecorated = Assert.IsType<UsesMyService2Decorator>(reredecorated.Inner); var decorated = Assert.IsType<UsesAnyServiceDecorator<MyService2>>(redecorated.Inner); Next steps Read about Rezolver's other implementation of decoration - decorator delegates ."
  },
  "api/Rezolver.ConstructorBinding.html": {
    "href": "api/Rezolver.ConstructorBinding.html",
    "title": "Class ConstructorBinding | Rezolver IOC",
    "keywords": "Class ConstructorBinding Represents a binding specifically to a class constructor, optionally with an additional set of MemberBindings to be used to initialise a new instance's properties or fields directly. Inheritance Object MethodBinding ConstructorBinding Inherited Members MethodBinding.Method MethodBinding.BoundArguments System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class ConstructorBinding : MethodBinding Constructors | Improve this Doc View Source ConstructorBinding(ConstructorInfo, ParameterBinding[], MemberBinding[]) Initializes a new instance of the ConstructorBinding class. Declaration public ConstructorBinding(ConstructorInfo constructor, ParameterBinding[] boundArgs = null, MemberBinding[] memberBindings = null) Parameters Type Name Description ConstructorInfo constructor The constructor to be used . ParameterBinding [] boundArgs Optional. The bound arguments. Can be null or empty. MemberBinding [] memberBindings Optional. The bindings for the members of the new instance created by the constructor. Fields | Improve this Doc View Source NoBoundMembers An empty array of MemberBinding objects used to represent a constructor binding with no bound members. The MemberBindings property will be set to this if the constructor is called with a null memberBindings argument. Declaration public static MemberBinding[] NoBoundMembers Field Value Type Description MemberBinding [] Properties | Improve this Doc View Source Constructor Gets the constructor to be invoked. Note that this simply returns the base Method property cast to ConstructorInfo . Declaration public ConstructorInfo Constructor { get; } Property Value Type Description ConstructorInfo The constructor. | Improve this Doc View Source MemberBindings Gets the member bindings to be applied to the new instance created by the Constructor Declaration public MemberBinding[] MemberBindings { get; } Property Value Type Description MemberBinding [] The member bindings. Remarks Member bindings represent the inline initialisation of writable properties or fields immediately after constructing a new instance of a type. See Also MethodBinding"
  },
  "api/Rezolver.Configuration.Configure.html": {
    "href": "api/Rezolver.Configuration.Configure.html",
    "title": "Class Configure | Rezolver IOC",
    "keywords": "Class Configure Provides factory methods for the Configure<TOption> generic class for when you need to create a configuration object for a specific option outside of the functionality provided by the ConfigureOption<TOption>(CombinedTargetContainerConfig, TOption) function and its various overloads. Inheritance Object Configure Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Configuration Assembly : Rezolver.dll Syntax public static class Configure Methods | Improve this Doc View Source Option<TOption>(TOption, Type) Wraps the Configure(TOption, Type) constructor. Declaration public static Configure<TOption> Option<TOption>(TOption value, Type serviceType = null)where TOption : class Parameters Type Name Description TOption value The value that the option is to be set to. Type serviceType If the option is to be configured for a specific type of service in the target container, pass it here. Returns Type Description Configure <TOption> A new Configure<TOption> instance Type Parameters Name Description TOption The type of option to be set. | Improve this Doc View Source Option<TOption>(Func<ITargetContainer, Type, TOption>, Type) Wraps the Configure(Func<ITargetContainer, Type, TOption>, Type) . Declaration public static Configure<TOption> Option<TOption>(Func<ITargetContainer, Type, TOption> optionFactory, Type serviceType = null)where TOption : class Parameters Type Name Description System.Func < ITargetContainer , Type , TOption> optionFactory A callback that will be used to obtain the option value to be set. Type serviceType If the option is to be configured for a specific type of service in the target container, pass it here. Returns Type Description Configure <TOption> A new Configure<TOption> instance Type Parameters Name Description TOption The type of option to be set | Improve this Doc View Source Option<TOption, TService>(TOption) Wraps the Configure(TOption, Type) constructor, passing TService as the argument to the serviceType parameter. Declaration public static Configure<TOption> Option<TOption, TService>(TOption value)where TOption : class Parameters Type Name Description TOption value The value the option is to be set to. Returns Type Description Configure <TOption> A new Configure<TOption> instance Type Parameters Name Description TOption The type of option to be set TService The type of service against which the option will be set. | Improve this Doc View Source Option<TOption, TService>(Func<ITargetContainer, Type, TOption>) Wraps the Configure(Func<ITargetContainer, Type, TOption>, Type) constructor, passing TService as the argument to the serviceType parameter. Declaration public static Configure<TOption> Option<TOption, TService>(Func<ITargetContainer, Type, TOption> optionFactory)where TOption : class Parameters Type Name Description System.Func < ITargetContainer , Type , TOption> optionFactory A callback that will be used to obtain the option value to be set. Returns Type Description Configure <TOption> A new Configure<TOption> instance Type Parameters Name Description TOption The type of option to be set TService The type of service against which the option will be set."
  },
  "api/Rezolver.Compilation.Expressions.UnscopedTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.UnscopedTargetBuilder.html",
    "title": "Class UnscopedTargetBuilder | Rezolver IOC",
    "keywords": "Class UnscopedTargetBuilder Builder for the UnscopedTarget . Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < UnscopedTarget > UnscopedTargetBuilder Implements IExpressionBuilder < UnscopedTarget > IExpressionBuilder Inherited Members ExpressionBuilderBase<UnscopedTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<UnscopedTarget>.IExpressionBuilder<UnscopedTarget>.Build(UnscopedTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<UnscopedTarget>.CanBuild(ITarget) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class UnscopedTargetBuilder : ExpressionBuilderBase<UnscopedTarget>, IExpressionBuilder<UnscopedTarget>, IExpressionBuilder Methods | Improve this Doc View Source ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) overrides the base method to block all automatic scoping code from the expression being built. Declaration protected override Expression ApplyScoping(Expression builtExpression, ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description Expression builtExpression ITarget target IExpressionCompileContext context IExpressionCompiler compiler Returns Type Description Expression Overrides ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) | Improve this Doc View Source Build(UnscopedTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(UnscopedTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description UnscopedTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.UnscopedTarget>.Build(Rezolver.Targets.UnscopedTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Implements IExpressionBuilder<TTarget> IExpressionBuilder"
  },
  "api/Rezolver.Compilation.Expressions.ObjectTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ObjectTargetBuilder.html",
    "title": "Class ObjectTargetBuilder | Rezolver IOC",
    "keywords": "Class ObjectTargetBuilder An IExpressionBuilder specialised to build expressions for the ObjectTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ObjectTarget > ObjectTargetBuilder Implements IExpressionBuilder < ObjectTarget > IExpressionBuilder Inherited Members ExpressionBuilderBase<ObjectTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ObjectTarget>.IExpressionBuilder<ObjectTarget>.Build(ObjectTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ObjectTarget>.CanBuild(ITarget) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class ObjectTargetBuilder : ExpressionBuilderBase<ObjectTarget>, IExpressionBuilder<ObjectTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ObjectTarget, IExpressionCompileContext, IExpressionCompiler) returns a ConstantExpression wrapped around the Value reference. Declaration protected override Expression Build(ObjectTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ObjectTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ObjectTarget>.Build(Rezolver.Targets.ObjectTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Exceptions Type Condition NotImplementedException Implements IExpressionBuilder<TTarget> IExpressionBuilder"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionCompilerBuildExtensions.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionCompilerBuildExtensions.html",
    "title": "Class ExpressionCompilerBuildExtensions | Rezolver IOC",
    "keywords": "Class ExpressionCompilerBuildExtensions Extensions for IExpressionCompiler . Inheritance Object ExpressionCompilerBuildExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public static class ExpressionCompilerBuildExtensions Methods | Improve this Doc View Source BuildResolveLambda(IExpressionCompiler, ITarget, IExpressionCompileContext) This method is a shortcut for building a lambda expression directly from an ITarget . It calls Build(ITarget, IExpressionCompileContext) and passes the result to BuildResolveLambda(Expression, IExpressionCompileContext) , which should yield an optimised lambda expression for the expression produced from the target which can then be compiled and used as the factory for that target. Declaration public static Expression<Func<IResolveContext, object>> BuildResolveLambda(this IExpressionCompiler compiler, ITarget target, IExpressionCompileContext context) Parameters Type Name Description IExpressionCompiler compiler The compiler. ITarget target The target. IExpressionCompileContext context The current compilation context. Returns Type Description System.Linq.Expressions.Expression < System.Func < IResolveContext , Object >>"
  },
  "api/Rezolver.Compilation.Expressions.DefaultTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.DefaultTargetBuilder.html",
    "title": "Class DefaultTargetBuilder | Rezolver IOC",
    "keywords": "Class DefaultTargetBuilder An IExpressionBuilder specialised for building the expression for the DefaultTarget target. Essentially, it just calls System.Linq.Expressions.Expression.Default(System.Type) for the DeclaredType . Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < DefaultTarget > DefaultTargetBuilder Implements IExpressionBuilder < DefaultTarget > IExpressionBuilder Inherited Members ExpressionBuilderBase<DefaultTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DefaultTarget>.IExpressionBuilder<DefaultTarget>.Build(DefaultTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DefaultTarget>.CanBuild(ITarget) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class DefaultTargetBuilder : ExpressionBuilderBase<DefaultTarget>, IExpressionBuilder<DefaultTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(DefaultTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target for the given ICompileContext Declaration protected override Expression Build(DefaultTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description DefaultTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.DefaultTarget>.Build(Rezolver.Targets.DefaultTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Implements IExpressionBuilder<TTarget> IExpressionBuilder"
  },
  "api/Rezolver.BindSpecificMembersBehaviour.html": {
    "href": "api/Rezolver.BindSpecificMembersBehaviour.html",
    "title": "Class BindSpecificMembersBehaviour | Rezolver IOC",
    "keywords": "Class BindSpecificMembersBehaviour Inheritance Object BindAllMembersBehaviour BindSpecificMembersBehaviour Implements IMemberBindingBehaviour Inherited Members BindAllMembersBehaviour.GetMemberBindings(ICompileContext, Type) BindAllMembersBehaviour.BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) BindAllMembersBehaviour.BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) BindAllMembersBehaviour.GetBindableFields(ICompileContext, Type) BindAllMembersBehaviour.GetBindableProperties(ICompileContext, Type) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class BindSpecificMembersBehaviour : BindAllMembersBehaviour, IMemberBindingBehaviour Constructors | Improve this Doc View Source BindSpecificMembersBehaviour(IEnumerable<MemberBinding>) Declaration public BindSpecificMembersBehaviour(IEnumerable<MemberBinding> memberBindings) Parameters Type Name Description System.Collections.Generic.IEnumerable < MemberBinding > memberBindings | Improve this Doc View Source BindSpecificMembersBehaviour(IEnumerable<MemberInfo>) Declaration public BindSpecificMembersBehaviour(IEnumerable<MemberInfo> members) Parameters Type Name Description System.Collections.Generic.IEnumerable < MemberInfo > members Methods | Improve this Doc View Source CreateBinding(ICompileContext, Type, FieldInfo) Declaration protected override MemberBinding CreateBinding(ICompileContext context, Type type, FieldInfo field) Parameters Type Name Description ICompileContext context Type type FieldInfo field Returns Type Description MemberBinding Overrides BindAllMembersBehaviour.CreateBinding(ICompileContext, Type, FieldInfo) | Improve this Doc View Source CreateBinding(ICompileContext, Type, PropertyInfo) Declaration protected override MemberBinding CreateBinding(ICompileContext context, Type type, PropertyInfo prop) Parameters Type Name Description ICompileContext context Type type PropertyInfo prop Returns Type Description MemberBinding Overrides BindAllMembersBehaviour.CreateBinding(ICompileContext, Type, PropertyInfo) | Improve this Doc View Source ShouldBind(FieldInfo) Declaration protected override bool ShouldBind(FieldInfo fi) Parameters Type Name Description FieldInfo fi Returns Type Description Boolean Overrides BindAllMembersBehaviour.ShouldBind(FieldInfo) | Improve this Doc View Source ShouldBind(PropertyInfo) Declaration protected override bool ShouldBind(PropertyInfo pi) Parameters Type Name Description PropertyInfo pi Returns Type Description Boolean Overrides BindAllMembersBehaviour.ShouldBind(PropertyInfo) Implements IMemberBindingBehaviour"
  },
  "api/Rezolver.BindNoMembersBehaviour.html": {
    "href": "api/Rezolver.BindNoMembersBehaviour.html",
    "title": "Class BindNoMembersBehaviour | Rezolver IOC",
    "keywords": "Class BindNoMembersBehaviour This is the default IMemberBindingBehaviour which doesn't bind any members. It's a singleton accessible only via the BindNone static property. Inheritance Object BindNoMembersBehaviour Implements IMemberBindingBehaviour Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public sealed class BindNoMembersBehaviour : IMemberBindingBehaviour Methods | Improve this Doc View Source GetMemberBindings(ICompileContext, Type) Implementation of GetMemberBindings(ICompileContext, Type) Always returns an empty array. Declaration public MemberBinding[] GetMemberBindings(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context Type type Returns Type Description MemberBinding [] Implements IMemberBindingBehaviour"
  },
  "api/Rezolver.Events.html": {
    "href": "api/Rezolver.Events.html",
    "title": "Namespace Rezolver.Events | Rezolver IOC",
    "keywords": "Namespace Rezolver.Events Classes TargetContainerRegisteredEvent TargetContainerRegisteredEventArgs TargetRegisteredEvent An event fired from an ITargetContainer when a Target registration is added to the target container against a particular ServiceType . TargetRegisteredEventArgs"
  },
  "api/Rezolver.Events.TargetRegisteredEventArgs.html": {
    "href": "api/Rezolver.Events.TargetRegisteredEventArgs.html",
    "title": "Class TargetRegisteredEventArgs | Rezolver IOC",
    "keywords": "Class TargetRegisteredEventArgs Inheritance Object EventArgs TargetRegisteredEventArgs Inherited Members EventArgs.Empty System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Events Assembly : Rezolver.dll Syntax public class TargetRegisteredEventArgs : EventArgs Constructors | Improve this Doc View Source TargetRegisteredEventArgs(ITarget, Type) Declaration public TargetRegisteredEventArgs(ITarget target, Type type) Parameters Type Name Description ITarget target Type type Properties | Improve this Doc View Source Target Declaration public ITarget Target { get; } Property Value Type Description ITarget | Improve this Doc View Source Type Declaration public Type Type { get; } Property Value Type Description Type"
  },
  "api/Rezolver.Configuration.OptionDependentConfig-1.html": {
    "href": "api/Rezolver.Configuration.OptionDependentConfig-1.html",
    "title": "Class OptionDependentConfig<TOption> | Rezolver IOC",
    "keywords": "Class OptionDependentConfig<TOption> Abstract base class for an ITargetContainerConfig that is dependent upon a particular type of option having been set in an ITargetContainer before being able to Configure(IRootTargetContainer) that target container. Inheritance Object OptionDependentConfig<TOption> InjectArrays InjectCollections InjectEnumerables InjectLists OptionDependentConfig<T, TOption> Implements ITargetContainerConfig IDependant Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Configuration Assembly : Rezolver.dll Syntax public abstract class OptionDependentConfig<TOption> : ITargetContainerConfig, IDependant where TOption : class Type Parameters Name Description TOption The type of option upon which this config object depends. The default dependency created and returned by this class' implementation of Dependencies will actually be dependent upon the config type ITargetContainerConfig<T> , which is the standard contract expected by a configuration object that configures a aprticular option. Remarks If you are developing an ITargetContainerConfig that you want to be configurable via the use of a single option type (see the extension methods in the OptionsTargetContainerExtensions class), then inheriting from this abstract class instead of directly implementing ITargetContainerConfig and IDependant is a good idea. The default implementation of Dependencies will return a single dependency on the type ITargetContainerConfig<T> specialised for the option type TOption . You can also specify that the dependency is not required in cases where an option has a reasonable default value - thus allowing applications to omit any up-front configuration for that option except where absolutely necessary. The InjectEnumerables config inherits from this class - passing EnableEnumerableInjection as TOption , with the constructor marking the dependency as optional. This ensures that it is executed after the option has been configured by any ITargetContainerConfig<T> objects specialised for the option type. Constructors | Improve this Doc View Source OptionDependentConfig(Boolean) Constructs a new instance of the type OptionDependentConfig<TOption> which starts off with a required or optional dependency (controlled by the argument passed optionConfigurationRequired parameter) Declaration public OptionDependentConfig(bool optionConfigurationRequired) Parameters Type Name Description Boolean optionConfigurationRequired Properties | Improve this Doc View Source Dependencies The base implementation returns an enumerable containing a single dependency on the type ITargetContainerConfig<T> specialised for the type TOption . Declaration public virtual IEnumerable<DependencyMetadata> Dependencies { get; } Property Value Type Description System.Collections.Generic.IEnumerable < DependencyMetadata > Methods | Improve this Doc View Source Configure(IRootTargetContainer) Abstract implementation of the ITargetContainerConfig interface Declaration public abstract void Configure(IRootTargetContainer targets) Parameters Type Name Description IRootTargetContainer targets Implements ITargetContainerConfig IDependant Extension Methods DependantExtensions.GetDependencies<T, TDependency>(T, IEnumerable<TDependency>) DependantExtensions.CreateTypeDependency<TDependency>(IDependant, Boolean) DependantExtensions.CreateObjectDependency<TDependency>(IDependant, TDependency, Boolean)"
  },
  "api/Rezolver.AliasTargetContainerExtensions.html": {
    "href": "api/Rezolver.AliasTargetContainerExtensions.html",
    "title": "Class AliasTargetContainerExtensions | Rezolver IOC",
    "keywords": "Class AliasTargetContainerExtensions Contains extension methods for ITargetContainer to create targets which alias others by different types. Inheritance Object AliasTargetContainerExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class AliasTargetContainerExtensions Methods | Improve this Doc View Source RegisterAlias(ITargetContainer, Type, Type) Registers an alias for one type to another type. The created entry will effectively represent a second Resolve call into the container for the aliased type. Declaration public static void RegisterAlias(this ITargetContainer targetContainer, Type aliasType, Type originalType) Parameters Type Name Description ITargetContainer targetContainer The builder in which the alias is to be registered Type aliasType The type to be registered as an alias Type originalType The type being aliased. Remarks Use this when it's important that a given target type is always served through the same compiled target, even when the consumer expects it to be of a different type. A very common scenario is when you have a singleton instance of the originalType , and need to serve that same instance for aliasType . If you register the same singleton for both types, you get two separate singletons for each type, whereas if you create an alias, both will be served by the same alias. | Improve this Doc View Source RegisterAlias<TAlias, TOriginal>(ITargetContainer) Generic version of RegisterAlias(ITargetContainer, Type, Type) , see that method for more. Declaration public static void RegisterAlias<TAlias, TOriginal>(this ITargetContainer targetContainer) Parameters Type Name Description ITargetContainer targetContainer The target container in which the alias is to be registered Type Parameters Name Description TAlias Type being registered as an alias to another type TOriginal The target type of the alias."
  },
  "api/Rezolver.Targets.SingletonTarget.html": {
    "href": "api/Rezolver.Targets.SingletonTarget.html",
    "title": "Class SingletonTarget | Rezolver IOC",
    "keywords": "Class SingletonTarget A target which applies the singleton pattern to any ITarget . The inner target is available from the InnerTarget property. Inheritance Object TargetBase SingletonTarget Implements ITarget Inherited Members TargetBase.Id TargetBase.UseFallback TargetBase.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Targets Assembly : Rezolver.dll Syntax public class SingletonTarget : TargetBase, ITarget Constructors | Improve this Doc View Source SingletonTarget(ITarget) Constructs a new instance of the SingletonTarget class. Declaration public SingletonTarget(ITarget innerTarget) Parameters Type Name Description ITarget innerTarget The target whose result (when compiled) is to be used as the singleton instance. Properties | Improve this Doc View Source DeclaredType Override of DeclaredType - always returns the DeclaredType of the InnerTarget Declaration public override Type DeclaredType { get; } Property Value Type Description Type The type of the declared. Overrides TargetBase.DeclaredType | Improve this Doc View Source InnerTarget Gets the inner target for this singleton. Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget | Improve this Doc View Source ScopeBehaviour Always returns Explicit . Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour Overrides TargetBase.ScopeBehaviour | Improve this Doc View Source ScopePreference Always returns Root Declaration public override ScopePreference ScopePreference { get; } Property Value Type Description ScopePreference Overrides TargetBase.ScopePreference Methods | Improve this Doc View Source SupportsType(Type) Called to check whether a target can create an expression that builds an instance of the given type . The base implementation always passes the call on to the InnerTarget Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type Required Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) Implements ITarget Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget)"
  },
  "api/Rezolver.Targets.ScopedTarget.html": {
    "href": "api/Rezolver.Targets.ScopedTarget.html",
    "title": "Class ScopedTarget | Rezolver IOC",
    "keywords": "Class ScopedTarget A target that produces or fetches a single instance of an object within a lifetime scope. Inheritance Object TargetBase ScopedTarget Implements ITarget Inherited Members TargetBase.Id TargetBase.UseFallback TargetBase.ScopePreference TargetBase.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Targets Assembly : Rezolver.dll Syntax public class ScopedTarget : TargetBase, ITarget Remarks Scopes in Rezolver operate much the same as they do in any IOC framework, but use of them is always entirely optional. When a scope is active for a given Resolve(IResolveContext) operation, most objects which are returned from those operations will implicitly be scoped to whichever scope is active when the objects are resolved. Implicitly scoped objects are only disposed of when their containing scope is disposed, and you can have an unlimited number of instances of implicitly scoped objects per scope. This target is used to scope the object produced by a target explicitly to a scope, and to ensure that only one instance of that object is produced per scope. Such objects are also not inherited between parent scopes and child scopes. Constructors | Improve this Doc View Source ScopedTarget(ITarget) Initializes a new instance of the ScopedTarget class. Declaration public ScopedTarget(ITarget innerTarget) Parameters Type Name Description ITarget innerTarget Required. The inner target. Properties | Improve this Doc View Source DeclaredType Gets the declared type of object that is constructed by this target. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType Remarks Always forwards the call on to InnerTarget | Improve this Doc View Source InnerTarget Gets the inner target whose result (when compiled) will be scoped to the active scope. Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget The inner target. | Improve this Doc View Source ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour Methods | Improve this Doc View Source SupportsType(Type) Called to check whether a target can create an expression that builds an instance of the given type . Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type Required Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) Remarks Always forwards the call on the InnerTarget Implements ITarget Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget)"
  },
  "api/Rezolver.Targets.ResolvedTarget.html": {
    "href": "api/Rezolver.Targets.ResolvedTarget.html",
    "title": "Class ResolvedTarget | Rezolver IOC",
    "keywords": "Class ResolvedTarget Represents a target that is rezolved statically at compile time via the ICompileContext , or dynamically (at 'resolve time') from the IContainer that is attached to the current IResolveContext when Resolve(IResolveContext) is called. This is the most common way that we bind constructor parameters, for example - i.e. 'I want an IService instance - go get it'. Inheritance Object TargetBase ResolvedTarget Implements ITarget Inherited Members TargetBase.Id TargetBase.UseFallback TargetBase.ScopePreference TargetBase.SupportsType(Type) TargetBase.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Targets Assembly : Rezolver.dll Syntax public class ResolvedTarget : TargetBase, ITarget Remarks Represents an object that will be resolved from the container when its ICompiledTarget is executed, or when the target is used perhaps by another ITarget (e.g. - a ConstructorTarget with a constructor parameter bound to one of these). So, in essence, a ResolvedTarget represents an automatic call to a container's Resolve(IResolveContext) method, for the DeclaredType . In practise - an ITargetCompiler might take advantage of the fact that, during compilation, targets can be discovered directly from the ICompileContext that is passed to CompileTarget(ITarget, ICompileContext) by leveraging its ITargetContainer implementation. Indeed - the expressions compiler uses this to avoid repeated recursion into the Resolve method of the container, instead choosing to compile all the expressions for all targets required for an operation into one dynamically built method - which results in very fast execution times for all resolve operations. Not only this, but the behaviour can be extended still further by realising that a Container on which a resolve operation is invoked might not be the same container for which this ResolvedTarget was first compiled. In this case - it's possible that the other container has alternative registrations for a given service type which the application expects to take precedence over those which were originally resolved when compilation took place. The expressions compiler, again, detects this - allowing compiled code from a root container to detect an 'overriding' container and to dynamically resolve a different dependency in this situation. Constructors | Improve this Doc View Source ResolvedTarget(Type, ITarget) Creates a new ResolvedTarget for the given type which will attempt to resolve a value at compile time and/or resolve-time and, if it can't, will either use the fallbackTarget or will throw an exception. Declaration public ResolvedTarget(Type type, ITarget fallbackTarget = null) Parameters Type Name Description Type type Required. The type to be resolved ITarget fallbackTarget Optional. The target to be used if the value cannot be resolved at either compile time or resolve-time. An ArgumentException is thrown if this target's SupportsType(Type) function returns false when called with the type . Properties | Improve this Doc View Source DeclaredType The type that is to be resolved from the container at resolve-time. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source FallbackTarget Gets the target that this ResolvedTarget will fallback to if a satisfactory target cannot be found at compile time or resolve-time. Declaration public ITarget FallbackTarget { get; } Property Value Type Description ITarget Remarks The UseFallback property is also used to determine whether this will be used. If the target resolved from the ICompileContext has its UseFallback property set to true, and this property is non-null for this target, then this target will be used. Note also that extension containers such as OverridingContainer also have the ability to override the use of this fallback if they successfully resolve the type. | Improve this Doc View Source ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour Methods | Improve this Doc View Source Bind(ICompileContext) Attempts to obtain the target that this ResolvedTarget resolves to for the given ICompileContext . This function should be used by ITargetCompiler implementations when producing the ICompiledTarget for this instance, who wish to perform some form of up-front optimisations. Declaration public virtual ITarget Bind(ICompileContext context) Parameters Type Name Description ICompileContext context The context from which a target is to be resolved. Returns Type Description ITarget The target resolved by this target - could be the FallbackTarget , could be null. Remarks The target that is returned depends both on the context passed and also whether a FallbackTarget has been provided to this target. Implements ITarget Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget)"
  },
  "api/Rezolver.Targets.ProjectionTarget.html": {
    "href": "api/Rezolver.Targets.ProjectionTarget.html",
    "title": "Class ProjectionTarget | Rezolver IOC",
    "keywords": "Class ProjectionTarget Inheritance Object TargetBase ProjectionTarget Implements ITarget Inherited Members TargetBase.Id TargetBase.UseFallback TargetBase.ScopeBehaviour TargetBase.ScopePreference TargetBase.SupportsType(Type) TargetBase.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Targets Assembly : Rezolver.dll Syntax public class ProjectionTarget : TargetBase, ITarget Constructors | Improve this Doc View Source ProjectionTarget(ITarget, ITarget, Type, Type, Type) Declaration public ProjectionTarget(ITarget inputTarget, ITarget outputTarget, Type inputType, Type outputType, Type implementationType) Parameters Type Name Description ITarget inputTarget ITarget outputTarget Type inputType Type outputType Type implementationType Properties | Improve this Doc View Source DeclaredType Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source ImplementationType Declaration public Type ImplementationType { get; } Property Value Type Description Type | Improve this Doc View Source InputTarget Declaration public ITarget InputTarget { get; } Property Value Type Description ITarget | Improve this Doc View Source InputType Declaration public Type InputType { get; } Property Value Type Description Type | Improve this Doc View Source OutputTarget Declaration public ITarget OutputTarget { get; } Property Value Type Description ITarget | Improve this Doc View Source OutputType Declaration public Type OutputType { get; } Property Value Type Description Type Implements ITarget Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget)"
  },
  "api/Rezolver.ScopedTargetContainerExtensions.html": {
    "href": "api/Rezolver.ScopedTargetContainerExtensions.html",
    "title": "Class ScopedTargetContainerExtensions | Rezolver IOC",
    "keywords": "Class ScopedTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for registering constructor-injected types whose lifetimes are slaved to that of a parent IScopedContainer . All of the extension methods ultimately create a ScopedTarget Inheritance Object ScopedTargetContainerExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class ScopedTargetContainerExtensions Methods | Improve this Doc View Source RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) Registers an explicitly instance of objectType (optionally for the service type serviceType ) to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(IResolveContext) is first called. Declaration public static void RegisterScoped(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. Type objectType The type of the object that is to be constructed when resolved. Type serviceType Optional. The type against which the registration will be performed, if different from objectType . objectType must be compatible with this type, if it's provided. IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on the targetContainer . Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the ForType(Type, IMemberBindingBehaviour) static method, wrapping it with a ScopedTarget and then registering it against the type serviceType or objectType . | Improve this Doc View Source RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) Registers an explicitly scoped instance of TObject to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(IResolveContext) is first called. Declaration public static void RegisterScoped<TObject>(this ITargetContainer targetContainer, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on the targetContainer . Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the ForType<T>(IMemberBindingBehaviour) static method, wrapping it with a ScopedTarget and registering it. | Improve this Doc View Source RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) Registers an explicitly scoped instance of TObject for the service type TService to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(IResolveContext) is first called. Declaration public static void RegisterScoped<TObject, TService>(this ITargetContainer targetContainer, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on the targetContainer . Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. TService The type against which the registration will be performed. TObject must be compatible with this type. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the ForType<T>(IMemberBindingBehaviour) static method, wrapping it with a ScopedTarget and then registering it against the type TService ."
  },
  "api/Rezolver.OptionsTargetContainerExtensions.html": {
    "href": "api/Rezolver.OptionsTargetContainerExtensions.html",
    "title": "Class OptionsTargetContainerExtensions | Rezolver IOC",
    "keywords": "Class OptionsTargetContainerExtensions Contains extension methods for getting and setting container options which are used to control the behaviour, chiefly, of the various well-known ITargetContainer implementations. Inheritance Object OptionsTargetContainerExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class OptionsTargetContainerExtensions Remarks Options are different to target container behaviours ( ITargetContainerConfig ) in that options are actively read by the various ITargetContainer -related types throughout the Rezolver framework to control how certain standard functionality operates. The ITargetContainerConfig , however, can be used both to configure those options and to add extra registrations (both ITarget and, more commonly, other ITargetContainer s via the RegisterContainer(Type, ITargetContainer) method). The automatic building of System.Collections.Generic.IEnumerable<T> sequences from all the targets registered for a type, for example, is enabled by attaching the InjectEnumerables to the target container. Whereas, the ability to actually register more than one target for a particular service in the first place is controlled by the AllowMultiple option. Types of options Ultimately an option can be of any type, but most of the built-in options use the ContainerOption<TOption> type to wrap simple types ( Boolean , String , Int32 and so on) as a human-readably named type that differentiates that option from others of the same underlying value type. Note that the phrase 'value type' there doesn't mean that all options must be literal value types (i.e. ValueType ). Rezolver has several built-in option types - including AllowMultiple , EnableEnumerableInjection , EnableContravariance plus many more. These use the ContainerOption<TOption> type to enable reading and writing simple boolean-like option values which switch behaviour on and off. In addition, the ConstructorTarget and GenericConstructorTarget classes use the options API to discover IMemberBindingBehaviour objects to use when deciding whether to bind properties and/or fields when creating new objects. So you really can use anything you want as an option. Methods | Improve this Doc View Source GetOption<TOption>(ITargetContainer, TOption) Gets a globally-defined option of the type TOption from the targets target container, returning the default if the option has not been explicitly set. Declaration public static TOption GetOption<TOption>(this ITargetContainer targets, TOption default = null)where TOption : class Parameters Type Name Description ITargetContainer targets Required. The target container from which the option is to be read. TOption default The default value to return if the option has not been set. Returns Type Description TOption An option value which was either previously set, or the default if not Type Parameters Name Description TOption The type of option to retrieve | Improve this Doc View Source GetOption<TOption>(ITargetContainer, Type, TOption) Gets an option either specific to the serviceType , or a global option (if EnableGlobalOptions is enabled), of the type TOption from the targets target container, returning the default if the option has not been explicitly set. Declaration public static TOption GetOption<TOption>(this ITargetContainer targets, Type serviceType, TOption default = null)where TOption : class Parameters Type Name Description ITargetContainer targets Required. The target container from which the option is to be read. Type serviceType A type for which the option is to be retrieved. Note that the default behaviour is to search for an option which is specific to this service, and then to search for more generally-defined options. See the remarks section for more. TOption default The default value to return if the option has not been set. Returns Type Description TOption An option value which was either previously set, or the default if not Type Parameters Name Description TOption The type of option to retrieve Remarks Options are frequently used to control how a Rezolver container interprets registrations. Take, for example, the AllowMultiple option - which is used to control whether a target container accepts multiple registrations for a given type. When defined globally (i.e. without a service type) it determines whether multiple registrations can be performed for all types. However, it can also be defined on a per-service basis - so, for example, if you want to restrict an application only to register one target for a particular service - e.g. IMyApplication - then you can set the AllowMultiple option to false specifically against that type, and multiple registrations will result in a runtime error. When searching for service-specific options, generics are automatically processed in descending order of specificity - i.e. IFoo<Bar> is more specific than IFoo<> - so you can set options for a specific closed generic, or its open generic. Global Fallback In the absence of a service-specific option, a globally-defined option will instead be used if the EnableGlobalOptions option is set to true for the targets target container. By default, this is enabled. | Improve this Doc View Source GetOption<TOption, TService>(ITargetContainer, TOption) Generic equivalent of GetOption<TOption>(ITargetContainer, Type, TOption) . See documentation on that method for more. Declaration public static TOption GetOption<TOption, TService>(this ITargetContainer targets, TOption default = null)where TOption : class Parameters Type Name Description ITargetContainer targets That target container from which the option is to be read. TOption default The default value to be returned if the option is not set. Returns Type Description TOption An option value which was either previously set, or the default if not Type Parameters Name Description TOption The type of option to retrieve TService The service type for which the option is to be retrieved | Improve this Doc View Source GetOptions<TOption>(ITargetContainer) Gets all globally-defined options of the type TOption from the targets target container, returning an empty enumerable if none have been set. Declaration public static IEnumerable<TOption> GetOptions<TOption>(this ITargetContainer targets)where TOption : class Parameters Type Name Description ITargetContainer targets Required. The target container from which the options are to be read. Returns Type Description System.Collections.Generic.IEnumerable <TOption> An enumerable of the type TOption containing zero or more options that have been set. Type Parameters Name Description TOption The type of option to retrieve | Improve this Doc View Source GetOptions<TOption>(ITargetContainer, Type) Get all options of the type TOption which have been set for the service type serviceType or any of its derivatives. Globally-defined options will also be included in the results unless the EnableGlobalOptions option has been set to false on the targets target container. Declaration public static IEnumerable<TOption> GetOptions<TOption>(this ITargetContainer targets, Type serviceType)where TOption : class Parameters Type Name Description ITargetContainer targets Required. The target container from which the options are to be read. Type serviceType Required. The service type for which options are to be retrieved. Returns Type Description System.Collections.Generic.IEnumerable <TOption> An enumerable of the type TOption containing zero or more options that have been set. Type Parameters Name Description TOption The type of option to be retrieved | Improve this Doc View Source GetOptions<TOption, TService>(ITargetContainer) Generic version of the GetOptions<TOption>(ITargetContainer, Type) method. See the documentation on that method for more. Declaration public static IEnumerable<TOption> GetOptions<TOption, TService>(this ITargetContainer targets)where TOption : class Parameters Type Name Description ITargetContainer targets Required. The target container from which the options are to be read. Returns Type Description System.Collections.Generic.IEnumerable <TOption> An enumerable of the type TOption containing zero or more options that have been set. Type Parameters Name Description TOption The type of option to be retrieved TService The service type for which options are to be retrieved. | Improve this Doc View Source SetOption<TOption>(ITargetContainer, TOption) Sets the passed option into the targets target container. The value can later be retrieved through a call to GetOption<TOption>(ITargetContainer, TOption) or one of its overloads. Declaration public static ITargetContainer SetOption<TOption>(this ITargetContainer targets, TOption option)where TOption : class Parameters Type Name Description ITargetContainer targets The target container into which the option will be set. TOption option The option value to be set Returns Type Description ITargetContainer The target container on which the method is called, to enable method chaining. Type Parameters Name Description TOption The type of option to be set. | Improve this Doc View Source SetOption<TOption>(ITargetContainer, TOption, Type) Sets the passed option into the targets target container, associating it with the given serviceType . The value can later be retrieved through a call to GetOption<TOption, TService>(ITargetContainer, TOption) or GetOption<TOption>(ITargetContainer, Type, TOption) , passing the same type, or a derived type. Declaration public static ITargetContainer SetOption<TOption>(this ITargetContainer targets, TOption option, Type serviceType)where TOption : class Parameters Type Name Description ITargetContainer targets The target container into which the option will be set. TOption option The option value to be set Type serviceType The type against which the option is to be set. It's called 'serviceType' because the majority of the time, you will used this method and its generic overload to customise behaviour for specific types. If null , then it's equivalent to calling SetOption<TOption>(ITargetContainer, TOption) . Returns Type Description ITargetContainer The target container on which the method is called, to enable method chaining. Type Parameters Name Description TOption The type of option to be set. | Improve this Doc View Source SetOption<TOption, TService>(ITargetContainer, TOption) Sets the passed option into the targets target container, associating it with the given TService . The value can later be retrieved through a call to GetOption<TOption, TService>(ITargetContainer, TOption) or GetOption<TOption>(ITargetContainer, Type, TOption) , passing the same type, or a derived type. Declaration public static ITargetContainer SetOption<TOption, TService>(this ITargetContainer targets, TOption option)where TOption : class Parameters Type Name Description ITargetContainer targets The target container into which the option will be set. TOption option The option value to be set Returns Type Description ITargetContainer The target container on which the method is called, to enable method chaining. Type Parameters Name Description TOption The type of option to be set. TService The type against which the option is to be set."
  },
  "api/Rezolver.Options.ContainerOption-1.html": {
    "href": "api/Rezolver.Options.ContainerOption-1.html",
    "title": "Class ContainerOption<TOption> | Rezolver IOC",
    "keywords": "Class ContainerOption<TOption> A suggested base class to use for custom container options to be read/written through the OptionsTargetContainerExtensions extension methods. The type of the option value is the argument to the TOption type parameter. Options must currently be objects - the ability to use callbacks to get options might be added at a future date. Inheritance Object ContainerOption<TOption> AllowMultiple EnableArrayInjection EnableCollectionInjection EnableContravariance EnableEnumerableCovariance EnableEnumerableInjection EnableGlobalOptions EnableListInjection FetchAllMatchingGenerics LazyEnumerables Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Options Assembly : Rezolver.dll Syntax public class ContainerOption<TOption> Type Parameters Name Description TOption The underlying option value type - e.g. Boolean , String , Uri or whatever Remarks This type is creatable only through inheritance. Options in Rezolver are achieved by using registrations in the ITargetContainer that is to be configured (and, in turn, which might then configure any IContainer s built from that target container). Since options often take the form of primitive types - e.g Boolean , String etc - this means it's impossible to register multiple options which control different things which have the same underlying type if we registered them directly. This class is offered as a way around this. Options (e.g. AllowMultiple ) are derived from this type, with the argument to the TOption type parameter set to the underlying type of the option value. Thus - each distinct option is a different type, which then means that an ITargetContainer can distinguish between them. Note: Whilst Rezolver uses this type for most of its configurable options, the options API implemented by the extension methods (e.g. GetOption<TOption>(ITargetContainer, TOption) or SetOption<TOption>(ITargetContainer, TOption) ) do not require you to use it. Constructors | Improve this Doc View Source ContainerOption() Inheritance constructor. Declaration protected ContainerOption() Properties | Improve this Doc View Source Value The underlying value wrapped by this option. Declaration public TOption Value { get; protected set; } Property Value Type Description TOption Methods | Improve this Doc View Source ToString() Provides a textual representation of the value of this option and its underlying type. Declaration public override string ToString() Returns Type Description String A string in the form \"{Value} ({typeof(TOption)})\" Overrides System.Object.ToString() Operators | Improve this Doc View Source Implicit(ContainerOption<TOption> to TOption) Implicit casting operator to convert to the option value type from an instance of ContainerOption<TOption> . All derived types are encouraged to have a similar casting operator from TOption to ContainerOption<TOption> (for example, see EnableEnumerableInjection ). Declaration public static implicit operator TOption(ContainerOption<TOption> option) Parameters Type Name Description ContainerOption <TOption> option The option object to be cast to TOption (by reading its Value property). Note that if this is null , then the return value will be the default for TOption Returns Type Description TOption"
  },
  "api/Rezolver.Options.AllowMultiple.html": {
    "href": "api/Rezolver.Options.AllowMultiple.html",
    "title": "Class AllowMultiple | Rezolver IOC",
    "keywords": "Class AllowMultiple A Boolean option that controls whether an ITargetContainer accepts multiple registered targets for the same underlying type. This option can be applied globally or on a per-service basis - but must be set before any potentially affected registrations are performed. The Default (unset) is equivalent to true Inheritance Object ContainerOption < Boolean > AllowMultiple Inherited Members ContainerOption<Boolean>.Value ContainerOption<Boolean>.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Options Assembly : Rezolver.dll Syntax public class AllowMultiple : ContainerOption<bool> Properties | Improve this Doc View Source Default The default value for this option if not configured. Equivalent to true . Declaration public static AllowMultiple Default { get; } Property Value Type Description AllowMultiple Operators | Improve this Doc View Source Implicit(Boolean to AllowMultiple) Implicit conversion operator to this option type from Boolean , which simplifies setting this option with a simple true or false value. Declaration public static implicit operator AllowMultiple(bool value) Parameters Type Name Description Boolean value Returns Type Description AllowMultiple"
  },
  "api/Rezolver.ListMemberBinding.html": {
    "href": "api/Rezolver.ListMemberBinding.html",
    "title": "Class ListMemberBinding | Rezolver IOC",
    "keywords": "Class ListMemberBinding Represents a binding (i.e. like that produced by IMemberBindingBehaviour ) to a property via dynamic collection initialiser. Inheritance Object MemberBinding ListMemberBinding Inherited Members MemberBinding.None MemberBinding.Member MemberBinding.Target MemberBinding.MemberType System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class ListMemberBinding : MemberBinding Constructors | Improve this Doc View Source ListMemberBinding(MemberInfo, ITarget, Type, MethodInfo) Declaration public ListMemberBinding(MemberInfo member, ITarget target, Type elementType, MethodInfo addMethod) Parameters Type Name Description MemberInfo member ITarget target Type elementType MethodInfo addMethod Properties | Improve this Doc View Source AddMethod Declaration public MethodInfo AddMethod { get; } Property Value Type Description MethodInfo | Improve this Doc View Source ElementType Declaration public Type ElementType { get; } Property Value Type Description Type"
  },
  "api/Rezolver.ITargetContainerTypeResolver.html": {
    "href": "api/Rezolver.ITargetContainerTypeResolver.html",
    "title": "Interface ITargetContainerTypeResolver | Rezolver IOC",
    "keywords": "Interface ITargetContainerTypeResolver An interface used by TargetContainer (via the options API) to identify the container type for targets with a specific DeclaredType . Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface ITargetContainerTypeResolver Methods | Improve this Doc View Source GetContainerType(Type) For operations such as Fetch(Type) and FetchContainer(Type) , the type requested might sometimes need to be redirected to another for the purposes of fetching the correct ITargetContainer for a given type of service. If this method returns a non-null type, then the calling container will use that type instead of the original one passed when trying to locate a container for the service type. Declaration Type GetContainerType(Type serviceType) Parameters Type Name Description Type serviceType The service type (equal to the DeclaredType of any ITarget objects that might have been registered). Returns Type Description Type A type that should be used to look up a container, if different from the serviceType , otherwise null ."
  },
  "api/Rezolver.Targets.ExpressionTarget.html": {
    "href": "api/Rezolver.Targets.ExpressionTarget.html",
    "title": "Class ExpressionTarget | Rezolver IOC",
    "keywords": "Class ExpressionTarget A generic target for all expressions not explicitly supported by a particular target. Enables more complex behaviours to be registered and used with the more formal ITarget implementations. Inheritance Object TargetBase ExpressionTarget Implements ITarget Inherited Members TargetBase.Id TargetBase.UseFallback TargetBase.ScopeBehaviour TargetBase.ScopePreference TargetBase.SupportsType(Type) TargetBase.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Targets Assembly : Rezolver.dll Syntax public class ExpressionTarget : TargetBase, ITarget Remarks Note to compiler implementers: This class can be used to represent simple expressions such as constants, constructor calls and so on; but can also contain whole lambda expressions with parameters. In the latter case, expression parameters are expected to receive injected arguments and, therefore, some rewriting of the expression is likely to be required. Constructors | Improve this Doc View Source ExpressionTarget(Func<ICompileContext, Expression>, Type) Initializes a new instance of the ExpressionTarget class. Declaration public ExpressionTarget(Func<ICompileContext, Expression> expressionFactory, Type declaredType) Parameters Type Name Description System.Func < ICompileContext , Expression > expressionFactory Required. The factory delegate that a compiler should call to get the expression to use when compiling this target. Type declaredType Required. Static type of all expressions that will be returned by expressionFactory . | Improve this Doc View Source ExpressionTarget(Expression, Type) Initializes a new instance of the ExpressionTarget class. Declaration public ExpressionTarget(Expression expression, Type declaredType = null) Parameters Type Name Description Expression expression Required. The static expression which should be used by compilers. Type declaredType Declared type of the target to be created (used when registering without an explicit type or when this target is used as a value inside another target). Remarks declaredType will automatically be determined if not provided by examining the type of the expression . For lambdas, the type will be derived from the Type of the lambda's body. For all other expressions, the type is taken directly from the Type property of the expression itself. Properties | Improve this Doc View Source DeclaredType Gets the type of Expression or the type that all expressions returned by the ExpressionFactory are expected to be equal to. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source Expression Gets the static expression represented by this target - if null , then a factory is being used to produce the expression, which is available from the ExpressionFactory property. Declaration public Expression Expression { get; } Property Value Type Description Expression | Improve this Doc View Source ExpressionFactory Gets a factory which will be executed to obtain an expression given a particular ICompileContext . If null , then a static expression will be used instead and is available from the Expression property. Declaration public Func<ICompileContext, Expression> ExpressionFactory { get; } Property Value Type Description System.Func < ICompileContext , Expression > Implements ITarget Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget)"
  },
  "api/Rezolver.Targets.EnumerableTarget.html": {
    "href": "api/Rezolver.Targets.EnumerableTarget.html",
    "title": "Class EnumerableTarget | Rezolver IOC",
    "keywords": "Class EnumerableTarget A specialised target for creating instances of System.Collections.Generic.IEnumerable<T> Inheritance Object TargetBase EnumerableTarget Implements ITarget System.Collections.Generic.IEnumerable < ITarget > IEnumerable Inherited Members TargetBase.Id TargetBase.ScopeBehaviour TargetBase.ScopePreference TargetBase.SupportsType(Type) TargetBase.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Targets Assembly : Rezolver.dll Syntax public class EnumerableTarget : TargetBase, ITarget, IEnumerable<ITarget>, IEnumerable Constructors | Improve this Doc View Source EnumerableTarget(IEnumerable<ITarget>, Type) Creates a new instance of EnumerableTarget Declaration public EnumerableTarget(IEnumerable<ITarget> targets, Type elementType) Parameters Type Name Description System.Collections.Generic.IEnumerable < ITarget > targets Required. Will be set into the Targets property. All elements must be non-null and must support the elementType (verified by calling the SupportsType(Type) method. Type elementType Required. Will be set into the ElementType property. Must be a concrete type - that is, it must not be an open generic. Properties | Improve this Doc View Source DeclaredType Always returns a concrete version of the System.Collections.Generic.IEnumerable<T> interface type, with T equal to ElementType Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source ElementType The element type of the enumerable (i.e. the ' T ' in System.Collections.Generic.IEnumerable<T> ) Declaration public Type ElementType { get; } Property Value Type Description Type | Improve this Doc View Source Targets The targets whose objects will be included in the enumerable Declaration public IEnumerable<ITarget> Targets { get; } Property Value Type Description System.Collections.Generic.IEnumerable < ITarget > | Improve this Doc View Source UseFallback Returns true if Targets is empty, otherwise false . Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides TargetBase.UseFallback Methods | Improve this Doc View Source GetEnumerator() Implementation of System.Collections.Generic.IEnumerable<T>.GetEnumerator() (through the Targets property). Declaration public IEnumerator<ITarget> GetEnumerator() Returns Type Description System.Collections.Generic.IEnumerator < ITarget > Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Implementation of System.Collections.IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description IEnumerator Implements ITarget System.Collections.Generic.IEnumerable<T> IEnumerable Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget)"
  },
  "api/Rezolver.Sdk.DependencyMetadataCollection.html": {
    "href": "api/Rezolver.Sdk.DependencyMetadataCollection.html",
    "title": "Class DependencyMetadataCollection | Rezolver IOC",
    "keywords": "Class DependencyMetadataCollection A collection of DependencyMetadata objects. An IDependant contains one of these collections in order to store the dependencies that it has on other objects. Inheritance Object DependencyMetadataCollection Implements System.Collections.Generic.IEnumerable < DependencyMetadata > IEnumerable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Sdk Assembly : Rezolver.dll Syntax public class DependencyMetadataCollection : IEnumerable<DependencyMetadata>, IEnumerable Methods | Improve this Doc View Source Add(DependencyMetadata) Adds a dependency to this collection. Declaration public void Add(DependencyMetadata dependency) Parameters Type Name Description DependencyMetadata dependency Required. The dependency to be added. | Improve this Doc View Source AddRange(IEnumerable<DependencyMetadata>) Adds multiple dependencies to the collection. Declaration public void AddRange(IEnumerable<DependencyMetadata> dependencies) Parameters Type Name Description System.Collections.Generic.IEnumerable < DependencyMetadata > dependencies | Improve this Doc View Source GetEnumerator() Implementation of System.Collections.Generic.IEnumerable<T>.GetEnumerator() - returns an enumerator which enumerates all the DependencyMetadata objects in the collection. Declaration public IEnumerator<DependencyMetadata> GetEnumerator() Returns Type Description System.Collections.Generic.IEnumerator < DependencyMetadata > Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Implementation System.Collections.IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description IEnumerator Implements System.Collections.Generic.IEnumerable<T> IEnumerable Extension Methods DependencyEnumerableExtensions.GetDependencies<T>(IEnumerable<DependencyMetadata>, IEnumerable<T>)"
  },
  "api/Rezolver.Sdk.DependencyMetadata.html": {
    "href": "api/Rezolver.Sdk.DependencyMetadata.html",
    "title": "Class DependencyMetadata | Rezolver IOC",
    "keywords": "Class DependencyMetadata Represents a dependency from an IDependant on one or more other objects in a collection. Note that the current implementations of this class are internal and can only be created through the various methods in the DependantExtensions class. Inheritance Object DependencyMetadata Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Sdk Assembly : Rezolver.dll Syntax public abstract class DependencyMetadata Constructors | Improve this Doc View Source DependencyMetadata(IDependant, Boolean) Creates a new instance of the DependencyMetadata class. Declaration public DependencyMetadata(IDependant owner, bool required) Parameters Type Name Description IDependant owner Boolean required Properties | Improve this Doc View Source Owner The IDependant to which this dependency belongs. Declaration protected IDependant Owner { get; } Property Value Type Description IDependant | Improve this Doc View Source Required true if the dependency is essential to the Owner , false if it's optional. Declaration protected bool Required { get; } Property Value Type Description Boolean Remarks When a DependantCollection<T> sorts its contents by dependency, all objects will be sorted after their dependencies, regardless of whether they're required or not. The difference between a required dependency and an optional one is that if a required dependency fails to match all the objects it expects when GetDependencies<T>(IEnumerable<T>) is called, an exception will occur. Methods | Improve this Doc View Source GetDependencies<T>(IEnumerable<T>) Called to select the dependencies which match this dependency metadata from the objects passed. Declaration public abstract IEnumerable<T> GetDependencies<T>(IEnumerable<T> objects)where T : class Parameters Type Name Description System.Collections.Generic.IEnumerable <T> objects Required. The objects which are to be searched for dependencies which match this dependency metadata. Returns Type Description System.Collections.Generic.IEnumerable <T> A filtered enumerable containing any objects from objects which match this dependency metadata. Type Parameters Name Description T Type type of objects from which dependencies are sought. Exceptions Type Condition DependencyException Most commonly thrown if a required dependency is not present in objects , but other reasons are possible. Basically - if you get one of these, then there's something wrong with the objects which prevents dependencies from being obtained by this dependency metadata."
  },
  "api/Rezolver.Runtime.EagerEnumerable-1.html": {
    "href": "api/Rezolver.Runtime.EagerEnumerable-1.html",
    "title": "Class EagerEnumerable<T> | Rezolver IOC",
    "keywords": "Class EagerEnumerable<T> Direct implementation of System.Collections.Generic.IEnumerable<T> for eagerly loaded enumerables when LazyEnumerables has been disabled either globally, or for a specific enumerable's element type. Rezolver uses this type instead of an array to prevent casting and modifying the contents of the enumerable. Inheritance Object EagerEnumerable<T> Implements System.Collections.Generic.IEnumerable <T> IEnumerable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Runtime Assembly : Rezolver.dll Syntax public class EagerEnumerable<T> : IEnumerable<T>, IEnumerable Type Parameters Name Description T Remarks See the remarks section on LazyEnumerable<T> for more about lazy and eager enumerables. Constructors | Improve this Doc View Source EagerEnumerable(T[]) Constructs a new instance of EagerEnumerable<T> Declaration public EagerEnumerable(T[] items) Parameters Type Name Description T[] items Methods | Improve this Doc View Source GetEnumerator() Implementation of System.Collections.Generic.IEnumerable<T>.GetEnumerator() Declaration public IEnumerator<T> GetEnumerator() Returns Type Description System.Collections.Generic.IEnumerator <T> Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Implementation of System.Collections.IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description IEnumerator Implements System.Collections.Generic.IEnumerable<T> IEnumerable"
  },
  "api/Rezolver.RootTargetContainerExtensions.html": {
    "href": "api/Rezolver.RootTargetContainerExtensions.html",
    "title": "Class RootTargetContainerExtensions | Rezolver IOC",
    "keywords": "Class RootTargetContainerExtensions Inheritance Object RootTargetContainerExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class RootTargetContainerExtensions Methods | Improve this Doc View Source RegisterProjection(IRootTargetContainer, Type, Type) Declaration public static void RegisterProjection(this IRootTargetContainer targets, Type fromService, Type toService) Parameters Type Name Description IRootTargetContainer targets Type fromService Type toService | Improve this Doc View Source RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, ITarget>) Declaration public static void RegisterProjection(this IRootTargetContainer targets, Type fromType, Type toType, Func<IRootTargetContainer, ITarget, ITarget> implementationTargetFactory) Parameters Type Name Description IRootTargetContainer targets Type fromType Type toType System.Func < IRootTargetContainer , ITarget , ITarget > implementationTargetFactory | Improve this Doc View Source RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, Type>) Declaration public static void RegisterProjection(this IRootTargetContainer targets, Type fromType, Type toType, Func<IRootTargetContainer, ITarget, Type> implementationTypeSelector) Parameters Type Name Description IRootTargetContainer targets Type fromType Type toType System.Func < IRootTargetContainer , ITarget , Type > implementationTypeSelector | Improve this Doc View Source RegisterProjection(IRootTargetContainer, Type, Type, Type) Declaration public static void RegisterProjection(this IRootTargetContainer targets, Type fromType, Type toType, Type implementationType) Parameters Type Name Description IRootTargetContainer targets Type fromType Type toType Type implementationType | Improve this Doc View Source RegisterProjection<TFrom, TTo>(IRootTargetContainer) Registers an enumerable projection that will create an enumerable of type TTo from elements of an input enumerable of type TFrom using constructor injection to create each instance of TTo . The same as calling RegisterProjection(IRootTargetContainer, Type, Type, Type) with TTo used as the argument to both TTo and TImplementation type parameters. Declaration public static void RegisterProjection<TFrom, TTo>(this IRootTargetContainer targets) Parameters Type Name Description IRootTargetContainer targets Type Parameters Name Description TFrom The type of the enumerable that provides the source of the projection TTo The type of the enumerable that will be the output of the projection | Improve this Doc View Source RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, ITarget>) Declaration public static void RegisterProjection<TFrom, TTo>(this IRootTargetContainer targets, Func<IRootTargetContainer, ITarget, ITarget> implementationTargetFactory) Parameters Type Name Description IRootTargetContainer targets System.Func < IRootTargetContainer , ITarget , ITarget > implementationTargetFactory Type Parameters Name Description TFrom TTo | Improve this Doc View Source RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, Type>) Declaration public static void RegisterProjection<TFrom, TTo>(this IRootTargetContainer targets, Func<IRootTargetContainer, ITarget, Type> implementationTypeSelector) Parameters Type Name Description IRootTargetContainer targets System.Func < IRootTargetContainer , ITarget , Type > implementationTypeSelector Type Parameters Name Description TFrom TTo | Improve this Doc View Source RegisterProjection<TFrom, TTo, TImplementation>(IRootTargetContainer) Registers an enumerable projection that will create an enumerable of type TTo from elements of an input enumerable of type TFrom using constructor injection to create each instance of TImplementation . Declaration public static void RegisterProjection<TFrom, TTo, TImplementation>(this IRootTargetContainer targets)where TImplementation : TTo Parameters Type Name Description IRootTargetContainer targets Type Parameters Name Description TFrom The type of the enumerable that provides the source of the projection TTo The type of the enumerable that will be the output of the projection TImplementation The type to be created for each element. Remarks This is like hot-wiring the Linq Select<TSource, TResult>(IEnumerable<TSource>, Func<TSource, TResult>) directly into the container. Typically each instance of the implementation type TImplementation will require an instance of type TFrom to be passed into its constructor - the framework takes care of passing the individual elements in for each instance of TImplementation that it creates."
  },
  "api/Microsoft.Extensions.DependencyInjection.RezolverServiceCollectionExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.RezolverServiceCollectionExtensions.html",
    "title": "Class RezolverServiceCollectionExtensions | Rezolver IOC",
    "keywords": "Class RezolverServiceCollectionExtensions Rezolver interop extension methods for the IServiceCollection class in Microsoft.Extensions.DependencyInjection Inheritance Object RezolverServiceCollectionExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.Extensions.DependencyInjection Assembly : Rezolver.Microsoft.Extensions.DependencyInjection.dll Syntax public static class RezolverServiceCollectionExtensions Methods | Improve this Doc View Source CreateRezolverContainer(IServiceCollection) Creates a new default ScopedContainer and registers the services in services as targets. Declaration public static IContainer CreateRezolverContainer(this IServiceCollection services) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceCollection services The services to be registered. Returns Type Description IContainer An IContainer instance Remarks The LazyEnumerables option (is set to false by this method, because v2.0 of .Net Core 2 seems to expect all enumerables to be eagerly loaded - getting clarification on this from the team at https://github.com/aspnet/DependencyInjection/issues/589 Exceptions Type Condition ArgumentNullException If services is null. | Improve this Doc View Source RegisterTargets(IServiceCollection, ITargetContainer) Registers services in services as targets in the passed targetContainer Declaration public static void RegisterTargets(this IServiceCollection services, ITargetContainer targetContainer) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceCollection services The services to be registered. ITargetContainer targetContainer The target container that is to receive the new registrations. Remarks This extension method just uses the Populate(ITargetContainer, IServiceCollection) method also found in this library. Exceptions Type Condition ArgumentNullException If either services or targetContainer are null."
  },
  "api/Rezolver.Targets.UnscopedTarget.html": {
    "href": "api/Rezolver.Targets.UnscopedTarget.html",
    "title": "Class UnscopedTarget | Rezolver IOC",
    "keywords": "Class UnscopedTarget Wraps another target to force scoping to be ignored for the object that it produces, regardless of whether that object is IDisposable or otherwise has its own scoping behaviour. Inheritance Object TargetBase UnscopedTarget Implements ITarget Inherited Members TargetBase.Id TargetBase.ScopePreference TargetBase.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Targets Assembly : Rezolver.dll Syntax public class UnscopedTarget : TargetBase, ITarget Constructors | Improve this Doc View Source UnscopedTarget(ITarget) Initializes a new instance of the UnscopedTarget class. Declaration public UnscopedTarget(ITarget inner) Parameters Type Name Description ITarget inner Required - the inner target. Properties | Improve this Doc View Source DeclaredType Gets the declared type of object that is constructed by this target - always forwards the call to the Inner target. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source Inner Gets the inner target whose scoping rules are to be stripped by this target. Declaration public ITarget Inner { get; } Property Value Type Description ITarget | Improve this Doc View Source ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour Overrides TargetBase.ScopeBehaviour | Improve this Doc View Source UseFallback Implementation of UseFallback Always forwards the call to Inner target. Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides TargetBase.UseFallback Methods | Improve this Doc View Source SupportsType(Type) Always forward the call to the Inner target's implementation. Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type The type. Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) Implements ITarget Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget)"
  },
  "api/Rezolver.Targets.TargetBase.html": {
    "href": "api/Rezolver.Targets.TargetBase.html",
    "title": "Class TargetBase | Rezolver IOC",
    "keywords": "Class TargetBase Abstract base class, suggested as a starting point for implementations of ITarget . Inheritance Object TargetBase ChangeTypeTarget ConstructorTarget DecoratorTarget DefaultTarget DelegateTarget EnumerableTarget ExpressionTarget GenericConstructorTarget ListTarget ObjectTarget OptionalParameterTarget ProjectionTarget ResolvedTarget ScopedTarget SingletonTarget UnscopedTarget Implements ITarget Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Targets Assembly : Rezolver.dll Syntax public abstract class TargetBase : ITarget Properties | Improve this Doc View Source DeclaredType Gets the declared type of object that is constructed by this target. Declaration public abstract Type DeclaredType { get; } Property Value Type Description Type | Improve this Doc View Source Id Implementation of Id . Unique Id for this target. Always initialised to a new Guid using NewGuid() Declaration public Guid Id { get; } Property Value Type Description Guid | Improve this Doc View Source ScopeBehaviour Gets the scoping behaviour for instances that will ultimately be produced by this target. Declaration public virtual ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Remarks Base implementation always returns Implicit . | Improve this Doc View Source ScopePreference Get the preferred scope in which an object produced from this target should be tracked. Declaration public virtual ScopePreference ScopePreference { get; } Property Value Type Description ScopePreference Remarks Base implementation always returns Current | Improve this Doc View Source UseFallback Implementation of UseFallback Base version always returns false . Declaration public virtual bool UseFallback { get; } Property Value Type Description Boolean Methods | Improve this Doc View Source SupportsType(Type) Implementation of SupportsType(Type) . Returns a boolean indicating whether the target is able to produce an instance of, or an instance that is compatible with, the passed type . Declaration public virtual bool SupportsType(Type type) Parameters Type Name Description Type type The type. Returns Type Description Boolean Remarks It is strongly suggested that you use this method to check whether the target can construct an instance of a given type rather than performing any type checking yourself on the DeclaredType , because an ITarget might be able to support a much wider range of types other than just those which are directly compatible with its DeclaredType . For example, the GenericConstructorTarget is statically bound to an open generic, so therefore traditional type checks on the DeclaredType do not work. That class' implementation of this method, however, contains the complex logic necessary to determine if the open generic can be closed into a generic type which is compatible with the given type . Implementations of ITargetCompiler should always consult this function in their implementation of CompileTarget(ITarget, ICompileContext) to determine if the target is compatible with the TargetType of the CompileContext | Improve this Doc View Source ToString() Returns a string similar to \"<[TargetType], DeclaredType=[DeclaredType]>\" Declaration public override string ToString() Returns Type Description String Overrides System.Object.ToString() Implements ITarget Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget)"
  },
  "api/Rezolver.Targets.DecoratorTarget.html": {
    "href": "api/Rezolver.Targets.DecoratorTarget.html",
    "title": "Class DecoratorTarget | Rezolver IOC",
    "keywords": "Class DecoratorTarget Represents the action of implementing a common DecoratedType by decorating one instance (produced by DecoratedTarget ) with another ( InnerTarget ). NOTE - You shouldn't register or otherwise create instances of this target unless you absolutely know what you're doing. Rather, decorators should be registered using the extension method RegisterDecorator<TDecorator, TDecorated>(IRootTargetContainer) or its non-generic alternative because the target needs a DecoratingTargetContainer to work properly (the creation of which is automatically handled by these extension methods). Inheritance Object TargetBase DecoratorTarget Implements ITarget Inherited Members TargetBase.Id TargetBase.UseFallback TargetBase.ScopeBehaviour TargetBase.ScopePreference TargetBase.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Targets Assembly : Rezolver.dll Syntax public class DecoratorTarget : TargetBase, ITarget Constructors | Improve this Doc View Source DecoratorTarget(ITarget, ITarget, Type) Constructs a new instance of the DecoratorTarget type when the target that create the decorator is already known. Declaration public DecoratorTarget(ITarget decoratorTarget, ITarget decoratedTarget, Type decoratedType) Parameters Type Name Description ITarget decoratorTarget ITarget decoratedTarget Type decoratedType Properties | Improve this Doc View Source DeclaredType The type of object returned by the decorator target Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source DecoratedTarget Gets the target whose instance will be wrapped (decorated) by the one produced by InnerTarget . Declaration public ITarget DecoratedTarget { get; } Property Value Type Description ITarget | Improve this Doc View Source DecoratedType Gets the underlying type (e.g. a common service interface or base) that is being implemented by decoration. Declaration public Type DecoratedType { get; } Property Value Type Description Type | Improve this Doc View Source InnerTarget Gets the target which will create an instance of the decorator Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget Methods | Improve this Doc View Source SupportsType(Type) Overrides SupportsType(Type) to forward the call to InnerTarget . Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type The type which is to be checked. Returns Type Description Boolean true if the type is compatible with the object created by InnerTarget , false if not. Overrides TargetBase.SupportsType(Type) Implements ITarget Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) See Also TargetBase"
  },
  "api/Rezolver.Targets.ConstructorTarget.html": {
    "href": "api/Rezolver.Targets.ConstructorTarget.html",
    "title": "Class ConstructorTarget | Rezolver IOC",
    "keywords": "Class ConstructorTarget A target that binds to a type's constructor with zero or more arguments supplied by other ITarget s and, optionally binding to the new instance's writeable properties. The target supports en explicitly supplied constructor, as well as just-in-time lookups for the best available constructor based on the available services and/or any named arguments which might been provided up front. Inheritance Object TargetBase ConstructorTarget Implements ITarget Inherited Members TargetBase.Id TargetBase.UseFallback TargetBase.ScopeBehaviour TargetBase.ScopePreference TargetBase.SupportsType(Type) TargetBase.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Targets Assembly : Rezolver.dll Syntax public class ConstructorTarget : TargetBase, ITarget Remarks Although you can create this target directly through the Rezolver.Targets.ConstructorTarget.#ctor(System.Type,System.Reflection.ConstructorInfo,Rezolver.IMemberBindingBehaviour,Rezolver.ParameterBinding[],System.Collections.Generic.IDictionary{System.String,Rezolver.ITarget}) constructor, you're more likely to create it through factory methods such as ForType<T>(IMemberBindingBehaviour) or, more likely still, extension methods such as RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) during your application's container setup phase. To compile this target, an ITargetCompiler should first call the Bind(ICompileContext) method, which will select the correct constructor to be bound based on the original arguments passed to the target when it was built, and the other registrations in the ITargetContainer that's active when compilation occurs. Constructors | Improve this Doc View Source ConstructorTarget(ConstructorInfo, ParameterBinding[], IMemberBindingBehaviour) Initializes a new instance of the ConstructorTarget class bound in advance to a specific constructor. Declaration public ConstructorTarget(ConstructorInfo ctor, ParameterBinding[] parameterBindings = null, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ConstructorInfo ctor Required - the constructor that is to be bound. The DeclaredType of the new instance will be set to the DeclaringType of this object. ParameterBinding [] parameterBindings Optional. Specific bindings for the parameters of the given ctor which should be used during code generation. Note that this array can contain fewer or more entries than there are parameters on the ctor . Any missing bindings will be automatically generated when Bind(ICompileContext) is called. IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance. If not provided, then the Bind(ICompileContext) method will attempt to obtain one via the options API from the ICompileContext - and if one is still not available, then no member binding will be performed. | Improve this Doc View Source ConstructorTarget(Type, IDictionary<String, ITarget>, IMemberBindingBehaviour) Initializes a just-in-time-bound instance of the ConstructorTarget class which must be bound to the best constructor at compile-time by calling the Bind(ICompileContext) method. Declaration public ConstructorTarget(Type type, IDictionary<string, ITarget> namedArgs = null, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description Type type Required. The type whose constructor is to bound. System.Collections.Generic.IDictionary < String , ITarget > namedArgs Optional. The named arguments which will be passed to, and used to find, the best-matched constructor. These are taken into account when the constructor is sought - with the constructor containing the most matched parameters matched being selected. IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance. If not provided, then the Bind(ICompileContext) method will attempt to obtain one via the options API from the ICompileContext - and if one is still not available, then no member binding will be performed. Remarks To compile this target, a ITargetCompiler first calls the Bind(ICompileContext) method to discover the constructor to be executed, along with the final set of arguments to be provided to it (see ConstructorBinding ). The best available constructor is defined as the constructor with the most parameters for which arguments can be resolved from the ICompileContext at compile-time to the fewest number of ITarget objects whose UseFallback is false. An extension point will be provided in the future which will allow the constructor resolution process to be overriden Properties | Improve this Doc View Source Ctor Can be null. Gets the constructor that this target is bound to, if it was known when the target was created. Declaration public ConstructorInfo Ctor { get; } Property Value Type Description ConstructorInfo Remarks ConstructorTargets can be bound to a particular constructor in advance, or they can search for a best-match constructor at the point where Bind(ICompileContext) is called. This property will only be set ultimately if it was passed to the ConstructorTarget(ConstructorInfo, ParameterBinding[], IMemberBindingBehaviour) constructor, possibly by a factory method like ForConstructor(ConstructorInfo, IDictionary<String, ITarget>, IMemberBindingBehaviour) is captured within the expression. | Improve this Doc View Source DeclaredType Implementation of DeclaredType . Always equal to the type whose constructor will be bound by this target. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source MemberBindingBehaviour Gets the member binding behaviour to be used when Bind(ICompileContext) is called. If null , then the binding behaviour will be resolved from ICompileContext passed to the Bind(ICompileContext) method, via the Options API. Declaration public IMemberBindingBehaviour MemberBindingBehaviour { get; } Property Value Type Description IMemberBindingBehaviour Remarks The container default IMemberBindingBehaviour can be configured by setting it as an option using the SetOption<TOption>(ITargetContainer, TOption) extension method - passing an instance of member binding behaviour to be used as the default. The global default, unconfigured, behaviour is not to inject any members ( BindNone ) | Improve this Doc View Source NamedArgs Named arguments (as ITarget objects) to be supplied to the object on construction, also aiding the search for a constructor. This equivalent to the way that languages such as C# can bind to overloaded functions based solely on named arguments. Declaration public IReadOnlyDictionary<string, ITarget> NamedArgs { get; } Property Value Type Description System.Collections.Generic.IReadOnlyDictionary < String , ITarget > Remarks Note the difference between this and ParameterBindings - this property might be used when the constructor is not known in advance, whereas ParameterBindings is used when it is. | Improve this Doc View Source ParameterBindings If this target was created with a specific constructor then this might contain argument bindings for that constructor's parameters. Declaration public IReadOnlyList<ParameterBinding> ParameterBindings { get; } Property Value Type Description System.Collections.Generic.IReadOnlyList < ParameterBinding > Remarks This is not the same as NamedArgs - as is noted by the documentation on that property. This property is for when the constructor is known in advance and when certain parameters are to be bound with specific arguments; whereas NamedArgs is for when the constructor is not known. Methods | Improve this Doc View Source Bind(ICompileContext) Gets the ConstructorBinding for the DeclaredType using the targets available in the context for dependency lookup. The constructor is either resolved by checking available targets for the best match, or is pre-selected on construction ( Ctor will be non-null in this case). Declaration public ConstructorBinding Bind(ICompileContext context) Parameters Type Name Description ICompileContext context The current compilation context. Returns Type Description ConstructorBinding Remarks All implementations of ITargetCompiler should first use this method to find the constructor to be called, and the arguments that are to be supplied to it. This method also builds a list of MemberBinding s for properties or fields on the type which are to be set with values from the container after construction. The exact behaviour of this is controlled by the behaviour set on the MemberBindingBehaviour property, or, if null then the method attempts to resolve an IMemberBindingBehaviour from the Container of the IResolveContext set on the ResolveContext of the passed context . Exceptions Type Condition AmbiguousMatchException If more than one constructor can be bound with an equal amount of all-resolved arguments or default arguments. InvalidOperationException If no sutiable constructors can be found. Implements ITarget Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget)"
  },
  "api/Rezolver.Sdk.DependencyException.html": {
    "href": "api/Rezolver.Sdk.DependencyException.html",
    "title": "Class DependencyException | Rezolver IOC",
    "keywords": "Class DependencyException This exception is related to the IDependant functionality used by Rezolver. It is raised when two objects dependn on each other, or if a required dependency is missing from the collection passed to a DependencyMetadata object's GetDependencies<T>(IEnumerable<T>) method. Inheritance Object Exception DependencyException Implements ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Sdk Assembly : Rezolver.dll Syntax [Serializable] public sealed class DependencyException : Exception, ISerializable Remarks Creation of this exception is currently kept internal Constructors | Improve this Doc View Source DependencyException(SerializationInfo, StreamingContext) Required constructor for Serialization Declaration protected DependencyException(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context Implements ISerializable"
  },
  "api/Rezolver.Sdk.DependencyEnumerableExtensions.html": {
    "href": "api/Rezolver.Sdk.DependencyEnumerableExtensions.html",
    "title": "Class DependencyEnumerableExtensions | Rezolver IOC",
    "keywords": "Class DependencyEnumerableExtensions Extensions for IEnumerable<DependencyMetadata> Inheritance Object DependencyEnumerableExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Sdk Assembly : Rezolver.dll Syntax public static class DependencyEnumerableExtensions Methods | Improve this Doc View Source GetDependencies<T>(IEnumerable<DependencyMetadata>, IEnumerable<T>) Identifies the objects that match the dependencies in this collection. Declaration public static IEnumerable<T> GetDependencies<T>(this IEnumerable<DependencyMetadata> metadata, IEnumerable<T> objects)where T : class Parameters Type Name Description System.Collections.Generic.IEnumerable < DependencyMetadata > metadata The dependency metadata which describes a set of dependencies System.Collections.Generic.IEnumerable <T> objects The objects from which dependencies are to be identified. Returns Type Description System.Collections.Generic.IEnumerable <T> An enumerable containing the objects (selected from objects ) which match the dependencies in this collection. If there are no dependency matches, the enumerable will be empty. Type Parameters Name Description T"
  },
  "api/Rezolver.RegisterTypeTargetContainerExtensions.html": {
    "href": "api/Rezolver.RegisterTypeTargetContainerExtensions.html",
    "title": "Class RegisterTypeTargetContainerExtensions | Rezolver IOC",
    "keywords": "Class RegisterTypeTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for the simplest cases of registering ConstructorTarget and GenericConstructorTarget targets. Inheritance Object RegisterTypeTargetContainerExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class RegisterTypeTargetContainerExtensions Methods | Improve this Doc View Source RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) Registers the type objectType (optionally for the service type serviceType ) to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(IResolveContext) is first called. Declaration public static void RegisterType(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. Type objectType The type of the object that is to be constructed when resolved. Type serviceType Optional. The type against which the registration will be performed, if different from objectType . objectType must be compatible with this type, if it's provided. IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on the targetContainer . Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the ForType(Type, IMemberBindingBehaviour) static method and then registering it against the type serviceType or objectType . | Improve this Doc View Source RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) Registers the type TObject to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(IResolveContext) is first called. Declaration public static void RegisterType<TObject>(this ITargetContainer targetContainer, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on the targetContainer . Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. Also doubles up as the type to be used for the registration itself. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the ForType<T>(IMemberBindingBehaviour) static method and then registering it. | Improve this Doc View Source RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) Register the type TObject to be created by the container via constructor injection, with an IMemberBindingBehaviour that's built from an IMemberBindingBehaviourBuilder<TInstance> that's configure by a callback you provide. Declaration public static void RegisterType<TObject>(this ITargetContainer targets, Action<IMemberBindingBehaviourBuilder<TObject>> configureMemberBinding) Parameters Type Name Description ITargetContainer targets The target container on which the registration is to be performed. System.Action < IMemberBindingBehaviourBuilder <TObject>> configureMemberBinding A callback that will be invoked with a new IMemberBindingBehaviourBuilder<TInstance> object that you can use to configure a custom member binding behaviour for the type TObject . The BuildBehaviour() method will be called after executing your callback to obtain the final IMemberBindingBehaviour . Type Parameters Name Description TObject The type to be registered and created. | Improve this Doc View Source RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) Registers the type TObject for the service type TService to be created by an IContainer via constructor injection. The registration will auto-bind a constructor based on the services available in the ITargetContainer and IContainer available at the time Resolve(IResolveContext) is first called. Declaration public static void RegisterType<TObject, TService>(this ITargetContainer targetContainer, IMemberBindingBehaviour memberBinding = null)where TObject : TService Parameters Type Name Description ITargetContainer targetContainer The target container on which the registration is to be performed. IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on the targetContainer . Type Parameters Name Description TObject The type of the object that is to be constructed when resolved. TService The type against which the registration will be performed. TObject must be compatible with this type. Remarks This is equivalent to creating either a ConstructorTarget or GenericConstructorTarget via the ForType<T>(IMemberBindingBehaviour) static method and then registering it against the type TService . | Improve this Doc View Source RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) Same as the RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) method, except this creates a registration for TService that will be implemented by instances of the type TObject , created via constructor injection. Declaration public static void RegisterType<TObject, TService>(this ITargetContainer targets, Action<IMemberBindingBehaviourBuilder<TObject>> configureMemberBinding)where TObject : TService Parameters Type Name Description ITargetContainer targets The target container on which the registration is to be performed. System.Action < IMemberBindingBehaviourBuilder <TObject>> configureMemberBinding A callback that will be invoked with a new IMemberBindingBehaviourBuilder<TInstance> object that you can use to configure a custom member binding behaviour for the type TObject . The BuildBehaviour() method will be called after executing your callback to obtain the final IMemberBindingBehaviour . Type Parameters Name Description TObject TService"
  },
  "api/Rezolver.Options.EnableCollectionInjection.html": {
    "href": "api/Rezolver.Options.EnableCollectionInjection.html",
    "title": "Class EnableCollectionInjection | Rezolver IOC",
    "keywords": "Class EnableCollectionInjection Boolean option which, if configured before the InjectCollections configuration is applied, will control whether automatic injection of ReadOnlyCollection<T> (and related interfaces - see the documentation on that type for more) will be enabled. The Default is equivalent to true . Inheritance Object ContainerOption < Boolean > EnableCollectionInjection Inherited Members ContainerOption<Boolean>.Value ContainerOption<Boolean>.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Options Assembly : Rezolver.dll Syntax public class EnableCollectionInjection : ContainerOption<bool> Remarks The injection behaviour controlled by this option most commonly piggybacks off of the behaviour that's enabled by the InjectEnumerables configuration. However, although this option is therefore related to the EnableEnumerableInjection option, the two are independent. If you disable automatic enumerable injection, it does not automatically disable automatic list injection. Properties | Improve this Doc View Source Default The Default setting for the EnableCollectionInjection option - evaluates to true Declaration public static EnableCollectionInjection Default { get; } Property Value Type Description EnableCollectionInjection Operators | Improve this Doc View Source Implicit(Boolean to EnableCollectionInjection) Convenience operator for treating booleans as EnableCollectionInjection option values. Declaration public static implicit operator EnableCollectionInjection(bool value) Parameters Type Name Description Boolean value Returns Type Description EnableCollectionInjection See Also InjectLists EnableEnumerableInjection InjectEnumerables"
  },
  "api/Rezolver.Options.EnableArrayInjection.html": {
    "href": "api/Rezolver.Options.EnableArrayInjection.html",
    "title": "Class EnableArrayInjection | Rezolver IOC",
    "keywords": "Class EnableArrayInjection Controls whether Rezolver's built-in array injection (which is also dependent upon the built-in IEnumerable injection) is enabled. If not defined the Default is equivalent to true . Inheritance Object ContainerOption < Boolean > EnableArrayInjection Inherited Members ContainerOption<Boolean>.Value ContainerOption<Boolean>.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Options Assembly : Rezolver.dll Syntax public class EnableArrayInjection : ContainerOption<bool> Properties | Improve this Doc View Source Default The default value for this option - equivalent to true Declaration public static EnableArrayInjection Default { get; } Property Value Type Description EnableArrayInjection Operators | Improve this Doc View Source Implicit(Boolean to EnableArrayInjection) Convenience conversion operator to EnableArrayInjection from Boolean Declaration public static implicit operator EnableArrayInjection(bool value) Parameters Type Name Description Boolean value The value to be wrapped as an EnableArrayInjection option value Returns Type Description EnableArrayInjection"
  },
  "api/Rezolver.ITargetContainerConfig.html": {
    "href": "api/Rezolver.ITargetContainerConfig.html",
    "title": "Interface ITargetContainerConfig | Rezolver IOC",
    "keywords": "Interface ITargetContainerConfig A configuration callback for instances of IRootTargetContainer . Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface ITargetContainerConfig Remarks Clearly, this callback interface can be used to perform any action on an IRootTargetContainer , but the intention is to use it either to pre-register targets or target containers for specific types, or to set options on a target container. The automatic injection of enumerables, for example, is enabled by applying the InjectEnumerables to a target container. Different target containers also have their own statically available default configuration collections, of the type CombinedTargetContainerConfig , which also implements this interface by applying multiple configurations to a target container - providing an easy way to combine multiple configurations as one. The most commonly used and modified of these is the DefaultConfig collection. Methods | Improve this Doc View Source Configure(IRootTargetContainer) Called to apply this configuration to the given rootTargets . Declaration void Configure(IRootTargetContainer rootTargets) Parameters Type Name Description IRootTargetContainer rootTargets The target container to which the configuration is to be applied - will not be null when called by the framework. See Also DefaultConfig CombinedTargetContainerConfig InjectEnumerables InjectResolveContext"
  },
  "api/Rezolver.ITargetContainerConfig-1.html": {
    "href": "api/Rezolver.ITargetContainerConfig-1.html",
    "title": "Interface ITargetContainerConfig<T> | Rezolver IOC",
    "keywords": "Interface ITargetContainerConfig<T> Marker interface for an ITargetContainerConfig which is responsible for configuring a specific type of object/behaviour/service/option. (Determined by T ). Inherited Members ITargetContainerConfig.Configure(IRootTargetContainer) Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface ITargetContainerConfig<T> : ITargetContainerConfig Type Parameters Name Description T Implementation-dependent. Type of object that is configured/set/registered by this config. Remarks As with IContainerConfig<T> , this marker interface is included specifically to provide a convenient way to express dependencies for configuration objects which depend on, or which must be configured after, others of a specific type. The type parameter is completely free-form - it could be a specific service type, an option type (see Configure<TOption> ), or something else entirely. Use of this interface is entirely optional; and you'll only implement it yourself (as with ITargetContainerConfig ) if you are extending Rezolver. See Also IContainerConfig <T>"
  },
  "api/Rezolver.IContainerScope.html": {
    "href": "api/Rezolver.IContainerScope.html",
    "title": "Interface IContainerScope | Rezolver IOC",
    "keywords": "Interface IContainerScope This is an IContainer -like object (resolving functionality is provided through the extension methods in the ContainerScopeResolveExtensions class) which provides lifetime scoping for disposable objects, and scoped singleton functionality for any object. Implementations of this interface must, in their implementation of IScopeFactory , create a child scope of this scope. Inherited Members System.IDisposable.Dispose() System.IServiceProvider.GetService(System.Type) IScopeFactory.CreateScope() Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface IContainerScope : IDisposable, IServiceProvider, IScopeFactory Properties | Improve this Doc View Source Container The container that this scope is tied to. All standard resolve operations should be made against this container to begin with. Declaration IContainer Container { get; } Property Value Type Description IContainer | Improve this Doc View Source Parent If this scope has a parent scope, this is it. Declaration IContainerScope Parent { get; } Property Value Type Description IContainerScope Methods | Improve this Doc View Source ChildScopeDisposed(IContainerScope) Called by child scopes when they are disposed to notify the parent that they will no longer need to be disposed of when the parent is disposed. Declaration void ChildScopeDisposed(IContainerScope child) Parameters Type Name Description IContainerScope child Remarks This is an infrastructure method and not something you would usually need to call unless you are implementing lower-level functionality. | Improve this Doc View Source Resolve(IResolveContext, Guid, Func<IResolveContext, Object>, ScopeBehaviour) Execute the given object factory within this scope. Depending on the scoping behaviour passed, the object will either be resolved directly from the scope (i.e. existing objects contained within it) or obtained by executing the factory and optionally tracking the object if it's IDisposable . Declaration object Resolve(IResolveContext context, Guid targetId, Func<IResolveContext, object> factory, ScopeBehaviour behaviour) Parameters Type Name Description IResolveContext context The resolve context - please note that the container that's present on this is the actual container that should be used to resolve objects. Guid targetId Id of the target that 'sources' this object; used to mark the object in the scope. System.Func < IResolveContext , Object > factory The factory to be executed ScopeBehaviour behaviour The scope behaviour that the factory should be executed with. Returns Type Description Object Remarks This function is the primary workhorse of all scopes and is primarily an infrastructure method supporting targets and compiled targets - i.e. not a method that an application should be calling. Extension Methods ContainerScopeExtensions.GetRootScope(IContainerScope) ContainerScopeResolveExtensions.Resolve<TResult>(IContainerScope) ContainerScopeResolveExtensions.Resolve(IContainerScope, Type) ContainerScopeResolveExtensions.ResolveMany(IContainerScope, Type) ContainerScopeResolveExtensions.ResolveMany<TObject>(IContainerScope) See Also IScopeFactory IDisposable IServiceProvider"
  },
  "api/Rezolver.IContainerConfig.html": {
    "href": "api/Rezolver.IContainerConfig.html",
    "title": "Interface IContainerConfig | Rezolver IOC",
    "keywords": "Interface IContainerConfig A configuration callback for instances of IContainer (which also use ITargetContainer as the source of their registrations). Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface IContainerConfig Remarks While similar to ITargetContainerConfig , this is specifically used for new container instances - since some configuration (setting of options etc) only applies to IContainer and not ITargetContainer . A configuration instance can be passed to any of the provided Container -derived types on construction (see the Container(IRootTargetContainer, IContainerConfig) constructor). If one is not passed then the DefaultConfig is used. The built-in config implementations register services or set options in the target container passed to Configure(IContainer, IRootTargetContainer) . Methods | Improve this Doc View Source Configure(IContainer, IRootTargetContainer) Performs the configuration represented by this insteance on the container and its targets . Declaration void Configure(IContainer container, IRootTargetContainer targets) Parameters Type Name Description IContainer container The container to which the configuration is to be applied. IRootTargetContainer targets The ITargetContainer that is being used by the container for its registrations and options. See Also ITargetContainerConfig ExpressionCompilation OverridingEnumerables"
  },
  "api/Rezolver.CovariantTypeIndex.html": {
    "href": "api/Rezolver.CovariantTypeIndex.html",
    "title": "Class CovariantTypeIndex | Rezolver IOC",
    "keywords": "Class CovariantTypeIndex Implementation of ICovariantTypeIndex used internally by TargetContainer and OverridingTargetContainer in their implementation of the same interface. Inheritance Object CovariantTypeIndex Implements ICovariantTypeIndex Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class CovariantTypeIndex : ICovariantTypeIndex Methods | Improve this Doc View Source AddKnownType(Type) Implementation of AddKnownType(Type) Declaration public void AddKnownType(Type serviceType) Parameters Type Name Description Type serviceType | Improve this Doc View Source GetKnownCompatibleTypes(Type) Implementatino of GetKnownCompatibleTypes(Type) Declaration public IEnumerable<Type> GetKnownCompatibleTypes(Type serviceType) Parameters Type Name Description Type serviceType Returns Type Description System.Collections.Generic.IEnumerable < Type > | Improve this Doc View Source GetKnownCovariantTypes(Type) Implementation of GetKnownCovariantTypes(Type) Declaration public IEnumerable<Type> GetKnownCovariantTypes(Type serviceType) Parameters Type Name Description Type serviceType Returns Type Description System.Collections.Generic.IEnumerable < Type > Implements ICovariantTypeIndex"
  },
  "api/Rezolver.BindPublicPropertiesBehaviour.html": {
    "href": "api/Rezolver.BindPublicPropertiesBehaviour.html",
    "title": "Class BindPublicPropertiesBehaviour | Rezolver IOC",
    "keywords": "Class BindPublicPropertiesBehaviour An IMemberBindingBehaviour which binds all non-indexer publicly writeable instance properties on new instances to services from the container. Inheritance Object BindAllMembersBehaviour BindPublicPropertiesBehaviour Implements IMemberBindingBehaviour Inherited Members BindAllMembersBehaviour.GetMemberBindings(ICompileContext, Type) BindAllMembersBehaviour.BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) BindAllMembersBehaviour.BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) BindAllMembersBehaviour.CreateBinding(ICompileContext, Type, FieldInfo) BindAllMembersBehaviour.CreateBinding(ICompileContext, Type, PropertyInfo) BindAllMembersBehaviour.GetBindableProperties(ICompileContext, Type) BindAllMembersBehaviour.ShouldBind(PropertyInfo) BindAllMembersBehaviour.ShouldBind(FieldInfo) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class BindPublicPropertiesBehaviour : BindAllMembersBehaviour, IMemberBindingBehaviour Constructors | Improve this Doc View Source BindPublicPropertiesBehaviour() Creates a new instance of the BindPublicPropertiesBehaviour class Can only be created by Rezolver or through inheritance. Declaration protected BindPublicPropertiesBehaviour() Methods | Improve this Doc View Source GetBindableFields(ICompileContext, Type) Overrides the base class to avoid returning any fields. Declaration protected override sealed IEnumerable<FieldInfo> GetBindableFields(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The compile context Type type The type to be bound. Returns Type Description System.Collections.Generic.IEnumerable < FieldInfo > Always returns an empty System.Collections.Generic.IEnumerable<T> Overrides BindAllMembersBehaviour.GetBindableFields(ICompileContext, Type) Implements IMemberBindingBehaviour"
  },
  "api/Microsoft.AspNetCore.Hosting.RezolverServiceProviderWebHostBuilderExtensions.html": {
    "href": "api/Microsoft.AspNetCore.Hosting.RezolverServiceProviderWebHostBuilderExtensions.html",
    "title": "Class RezolverServiceProviderWebHostBuilderExtensions | Rezolver IOC",
    "keywords": "Class RezolverServiceProviderWebHostBuilderExtensions Provides core functionality to web applications using Asp.Net Core to inject Rezolver containers into the application at the web hosting level, rather than while the application's startup phase is executing. Inheritance Object RezolverServiceProviderWebHostBuilderExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Microsoft.AspNetCore.Hosting Assembly : Rezolver.Microsoft.AspNetCore.Hosting.dll Syntax public static class RezolverServiceProviderWebHostBuilderExtensions Methods | Improve this Doc View Source UseRezolver(IWebHostBuilder, Action<RezolverOptions>) Configures the builder so that the standard Rezolver container will be used as the DI for the web host produced by the builder, with an optional configuration callback for a RezolverOptions instance that is used to customise the behaviour of the container. Declaration public static IWebHostBuilder UseRezolver(this IWebHostBuilder builder, Action<RezolverOptions> configureRezolverOptions = null) Parameters Type Name Description Microsoft.AspNetCore.Hosting.IWebHostBuilder builder The builder. System.Action < RezolverOptions > configureRezolverOptions Optional. Configuration callback to be applied to the RezolverOptions instance that configures the ITargetContainer and IContainer creation process. Note - in order for this to be applied, your application will also need to call the Microsoft.Extensions.DependencyInjection.OptionsServiceCollectionExtensions.AddOptions(Microsoft.Extensions.DependencyInjection.IServiceCollection) extension method (usually in your application's ConfigureServices method). Returns Type Description Microsoft.AspNetCore.Hosting.IWebHostBuilder"
  },
  "docs/nuget-packages/index.html": {
    "href": "docs/nuget-packages/index.html",
    "title": "Rezolver Nuget Packages | Rezolver IOC",
    "keywords": "Rezolver Nuget Packages Rezolver is primarily distributed as a suite of Nuget packages whose functionality stacks one on top of another. Depending on the level of functionality you require, there should be a Nuget package which contains only the code you need, with the main package ( Rezolver ) being the root dependency for all. All the core nuget packages support the .NetStandard 1.1 profile (don't know what this is? Learn more ), .Net 4.5.1 and .Net 4.6. Note Where a package has a dependency on a third party package (such as Newtonsoft's Json.Net or .Net Core's Microsoft.Extensions.DependencyInjection packages), then we try to maintain full support for the same frameworks and profiles that those packages support. List of packages Rezolver Rezolver.Microsoft.Extensions.DependencyInjection Rezolver.Microsoft.AspNetCore.Hosting"
  },
  "docs/lifetimes/transient.html": {
    "href": "docs/lifetimes/transient.html",
    "title": "Transient Objects | Rezolver IOC",
    "keywords": "Transient Objects Most registrations performed on an ITargetContainer will result in transient objects being created when the Resolve method of an IContainer is called. Ultimately, the transience of an object is determined by the ITarget that is registered against the type that's requested from the container. Some of these targets create inherently transient objects, whilst some inherit or expressly control the lifetimee of other targets. The following table summarises this: ITarget implementation Transient? Notes ChangeTypeTarget Inherited Target doesn't create anything, only changes the type of another target's result, therefore it inherits that target's lifetime. ConstructorTarget Yes * DecoratorTarget Yes It's not currently possible to directly control the lifetime of a decorator - only the object it decorates. DefaultTarget No Default values are cached per-type, therefore even value type defaults are technically singletons. DelegateTarget Depends on the delegate The delegate is always executed, so the transience of the object it returns depends on the delegate's logic. ExpressionTarget Depends on the expression Like DelegateTarget , the expression itself determines the lifetime of the object produced. GenericConstructorTarget Yes Same as ConstructorTarget . ListTarget Yes ObjectTarget No * OptionalParameterTarget No Only used to bind optional constructor parameters to their default values ResolvedTarget Depends This target represents an explicit instruction to resolve an object/value from the container - therefore the lifetime of the object produced depends on the lifetime of the registration which ultimately gets resolved. ScopedTarget No This target is responsible for Rezolver's implementation of scoped objects . SingletonTarget No This target is responsible for Rezolver's implementation of singleton objects . * UnscopedTarget Inherited This target is used to strip explicit or implicit scoping behaviour from another target. * Denotes a target which is used indirectly by other registrations and not generally used directly by applications There's no need for any further examples for transient objects, as most of the examples throughout this documentation (see the constructor injection documentation for example) use the targets which are marked as transient in the above table. Next steps Head over to the singletons topic to read about how to use the SingletonTarget to see how to turn any target into a singleton."
  },
  "docs/lifetimes/singleton.html": {
    "href": "docs/lifetimes/singleton.html",
    "title": "Singletons | Rezolver IOC",
    "keywords": "Singletons Rezolver's implementation of singletons has three entry points: The RegisterSingleton overload, which offers a shortcut to registering a type via the ConstructorTarget or GenericConstructorTarget (see the construction injection topic for more) as a singleton. The Singleton extension method, which creates a new SingletonTarget that wraps the target on which it is called, converting it into a singleton. The SingletonTarget(ITarget) constructor The SingletonTarget enforces a lock around its inner target so that its first result is cached and then returned for each subsequent Resolve operation. Note At the moment, the lifetime of a singleton is tied to the lifetime of the SingletonTarget itself. If you only ever have one container, or if you have multiple containers but use different targets for singletons of the same type, apply across the whole AppDomain , then you won't enounter any issues. But if you create multiple containers from the same ITargetContainer , then you will find that singletons will be shared between them. In the future (v1.2), singletons will be unique to each container - meaning that the same registration in two different containers would yield two different singletons. Examples Tip As with many of the other examples throughout this guide, you'll find the code for these tests in the test/Rezolver.Examples tests project. Constructor Injection If you are using the RegisterType overload, you can swap it for the RegisterSingleton overload to register a singleton for constructor injection: var container = new Container(); // The RegisterSingleton overload is like the RegisterType // overload, it creates a ConstructorTarget/GenericConstructorTarget // and wraps it in a SingletonTarget container.RegisterSingleton<MyService, IMyService>(); var result1 = container.Resolve<IMyService>(); var result2 = container.Resolve<IMyService>(); Assert.Same(result1, result2); Constructor Injection (via Singleton extension) If you need to use some of the more advanced constructor injection functionality, such as named argument binding , or specific ConstructorInfo binding , then you can't use the RegisterSingleton overload - because that creates the ConstructorTarget or GenericConstructorTarget for you. Instead, you will create it yourself and then wrap a SingletonTarget around it - using either its SingletonTarget(ITarget) constructor, or the Singleton ITarget extension method. Note The SingletonTarget inherits its DeclaredType from its inner target - so a singleton will always be compatible with whatever type its inner target is compatible with. This example is derived from the named argument binding constructor injection example mentioned above, except the RequiresIMyServiceAndDateTime type is registered as a singleton via the Singleton ITarget extension method: // This time, because we're binding to a specific constructor with named // arguments, we have to create a ConstructorTarget manually and then // convert it to a Singleton with the .Singleton() extension method var container = new Container(); container.RegisterType<MyService, IMyService>(); container.Register( Target.ForType<RequiresIMyServiceAndDateTime>(new { startDate = Target.ForObject(DateTime.UtcNow.AddDays(1)) } ).Singleton()); // //<-- Singleton created here var result1 = container.Resolve<RequiresIMyServiceAndDateTime>(); var result2 = container.Resolve<RequiresIMyServiceAndDateTime>(); Assert.Same(result1, result2); Open Generics When you register an open generic (via generic constructor injection ) as a singleton, then one singleton is created for each concrete generic type: var container = new Container(); // note - UsesAnyService<> doesn't have any dependencies container.RegisterSingleton(typeof(UsesAnyService<>), typeof(IUsesAnyService<>)); var result1a = container.Resolve<IUsesAnyService<MyService1>>(); var result1b = container.Resolve<IUsesAnyService<MyService1>>(); var result2a = container.Resolve<IUsesAnyService<MyService2>>(); var result2b = container.Resolve<IUsesAnyService<MyService2>>(); Assert.Same(result1a, result1b); Assert.Same(result2a, result2b); Factory Delegates Building on the factory delegate documentation , we can also register delegates as singletons, too: var container = new Container(); // Incremented by the delegate registered below int counter = 0; container.Register( Target.ForDelegate(() => ++counter).Singleton() ); var result1 = container.Resolve<int>(); var result2 = container.Resolve<int>(); Assert.Equal(counter, result1); Assert.Equal(result1, result2); Note Clearly this is not a real-world example - but intended to be as illustrative as possible of the effects of converting a delegate into a singleton: the delegate will be executed just the once. Expressions If you're registering expressions in your container then you won't be surprised to learn you can also register these as singletons. By now, you should pretty much already be able to guess how! This example is similar to the delegate example above, in that we have a counter variable which is being (pre)incremented by an expression, with its result returned whenever we resolve an int . In itself this poses an additional challenge because such an expression cannot be written as a compile-time lambda (assignments are not allowed). So in this case we have a type which holds a mutable counter: public class CounterHolder { public int Counter { get; set; } } We register that as a singleton (so the counter is shared) and then build an expression by hand to return the result of pre-incrementing it and writing the value back to the counter holder. This example also shows another way to leverage Rezolver's ability to inject arguments into your expressions, by supplying a hand-built LambdaExpression with Parameters : // Similar to the delegate example above, // but we're injecting an instance which holds the counter // so we can use a PreIncrementAssign UnaryExpression, which you // can't do in compiler-built lambda expressions. // In any case, you can't change the value of a lifted local in // an expression, because it's lifted as a constant. var container = new Container(); container.RegisterSingleton<CounterHolder>(); // expression below is equivalent to: // (CounterHolder c) => ++c.Counter var counterHolderParam = Expression.Parameter(typeof(CounterHolder)); container.Register( new ExpressionTarget(Expression.Lambda( Expression.PreIncrementAssign( Expression.Property(counterHolderParam, \"Counter\") ), counterHolderParam )).Singleton() ); // get the singleton CounterHolder and change its counter to 10 var counterHolder = container.Resolve<CounterHolder>(); counterHolder.Counter = 10; // now resolve two ints via the expression which would, if // the expression wasn't registered as a singleton, increment // the counterHolder.Counter property twice var result1 = container.Resolve<int>(); var result2 = container.Resolve<int>(); // counterHolder's Counter should have been incremented only once Assert.Equal(counterHolder.Counter, result1); Assert.Equal(result1, result2); Mixing Transient and Singleton Rezolver allows you to mix singletons and transients in a single object graph, since an individual registration controls its own lifetime. First, we have a transient object with dependencies on objects registered as singletons (the most common case): Note The RequiresMyServices type and other related types shown here are introduced in the constructor injection topic. var container = new Container(); container.RegisterType<RequiresMyServices>(); container.RegisterSingleton<MyService1>(); container.RegisterSingleton<MyService2>(); container.RegisterSingleton<MyService3>(); var service1 = container.Resolve<MyService1>(); var service2 = container.Resolve<MyService2>(); var service3 = container.Resolve<MyService3>(); var dependant1 = container.Resolve<RequiresMyServices>(); var dependant2 = container.Resolve<RequiresMyServices>(); Assert.NotSame(dependant1, dependant2); Assert.Same(service1, dependant1.Service1); Assert.Same(service2, dependant1.Service2); Assert.Same(service3, dependant1.Service3); Assert.Same(dependant1.Service1, dependant2.Service1); Assert.Same(dependant1.Service2, dependant2.Service2); Assert.Same(dependant1.Service3, dependant2.Service3); Then, the same types, but this time the RequiresMyServices type is registered as a singleton, with the three dependency types registered as transient: var container = new Container(); container.RegisterSingleton<RequiresMyServices>(); container.RegisterType<MyService1>(); container.RegisterType<MyService2>(); container.RegisterType<MyService3>(); var service1 = container.Resolve<MyService1>(); var service2 = container.Resolve<MyService2>(); var service3 = container.Resolve<MyService3>(); var dependant1 = container.Resolve<RequiresMyServices>(); var dependant2 = container.Resolve<RequiresMyServices>(); Assert.Same(dependant1, dependant2); Assert.NotSame(service1, dependant1.Service1); Assert.NotSame(service2, dependant1.Service2); Assert.NotSame(service3, dependant1.Service3); Singletons in Enumerables Building on the examples shown in the enumerables documentation , you can register a singleton among a collection of services which are later resolved or injected as an enumerable of that service: var container = new Container(); container.RegisterType<MyService1, IMyService>(); container.RegisterSingleton<MyService2, IMyService>(); container.RegisterType<MyService3, IMyService>(); var result1 = container.Resolve<IEnumerable<IMyService>>().ToArray(); var result2 = container.Resolve<IEnumerable<IMyService>>().ToArray(); Assert.NotSame(result1[0], result2[0]); Assert.Same(result1[1], result2[1]); Assert.NotSame(result1[2], result2[2]); Note At present, the enumerable itself is always a new instance, even if every element within it is a singleton. There is currently no way to force an enumerable to be a singleton, however this ability might be added at a later date. If, however, you inject the enumerable as a dependency of a singleton, then it will behave as you would expect. Decorating Singletons The decorator documentation show many permutations of Rezolver's support for the decorator pattern. As the documentation for transient objects mentions, it's not (currently) possible to control the lifetime of the decorators themselves, because they are always transient. However, as you would expect, if the original registration for the decorated type is a singleton, then each decorator instance that is created by the container will receive the same non-decorated service instance: // See the notes on the decorators topic for why we have to // create a TargetContainer for registrations in this example. var targets = new TargetContainer(); targets.RegisterSingleton<MyService1, IMyService>(); targets.RegisterDecorator<MyServiceDecorator1, IMyService>(); var container = new Container(targets); var decorator1 = Assert.IsType<MyServiceDecorator1>(container.Resolve<IMyService>()); var decorator2 = Assert.IsType<MyServiceDecorator1>(container.Resolve<IMyService>()); Assert.Same(decorator1.Inner, decorator2.Inner); Wrapping up (and next steps) The key takeaway from this is that you can convert any of the targets in the Rezolver.Targets namespace into a singleton simply by wrapping a SingletonTarget around it. Clearly, there are some targets to which you shouldn't do this (the ScopedTarget and the SingletonTarget itself, for instance!) although, right now, Rezolver doesn't prevent you from doing so. You should now take a look at how explicitly scoped objects are supported by Rezolver. You might also want to see how singletons behave inside an IContainerScope - which is part of the container scopes documentation."
  },
  "docs/create-and-use-a-container.html": {
    "href": "docs/create-and-use-a-container.html",
    "title": "Creating and using a container | Rezolver IOC",
    "keywords": "Creating and using a container Using Rezolver is the same as with all other IOC containers: Create and configure the root container Register the services which your application needs Resolve services from the container All of this setup is ultimately conducted through just a few primary types, which we'll take a brief look at now. Core types For all the built-in container types, Rezolver splits registration and resolving responsibilities between two interfaces: ITargetContainer Note You'll notice that the constructors for the Container and ScopedContainer types (see next) actually accept an instance of IRootTargetContainer . This is a new interface added in v1.3.2 which marks a target container as a 'top-level' one - and supports functionality such as covariance . IRootTargetContainer also implies the ITargetContainer interface. This interface describes a registry of ITarget objects, keyed by type, describing the type of object that is to be created (and how) when a given type is requested. It is through this interface that you setup your container with registrations, which are then later used when resolving objects. Tip The primary implementation of this interface that you will use in your application is TargetContainer - either created implicitly by the framework or explicitly in your own code. IContainer This is the interface through which we resolve objects. The interface does not expose any registration mechanisms at all (even if the classes providing the 'standard' implementations all do) - only the ability to request objects from the container. This interface does not mandate that a container has an IRootTargetContainer , it's simply the case that all the provided implementations which we will discuss in the rest of this documentation do use that interface as the source of their service registrations. Tip The primary implementation of this interface is ContainerBase , an abstract class which also implements the ITargetContainer interface by wrapping around the Targets property that it exposes. As a consumer of Rezolver, however, you will be using the Container and ScopedContainer classes most of the time - which derive most of their functionality from this abstract class. Creating a container There are numerous ways to create an IContainer instance. The easiest, from the point of view of registering services and then resolving them, is to create an instance of the Container type. Or, if you want your root container to act as a global lifetime scope for explicitly scoped objects then you can also use ScopedContainer : // create a standard non-scoping container var container = new Container(); // or create a scoped container: var container = new ScopedContainer(); All code samples assume you have added a using statement ( imports in VB) for the Rezolver namespace. Once you have a local reference to either of these classes, you can start registering services via the container's ITargetContainer implementation, and resolving objects from it. Registering services As mentioned above, with our default implementations of IContainer , registration of services ultimately means adding targets to the container's Targets target container, associating them with service types which we will later resolve. The core registration method for this is the Register method, which accepts an ITarget and an optional type against which the registration is to be made. Here's an example where we register the type Foo to be created whenever an instance of IFoo is requested, directly via a container's own implementation of ITargetContainer : var container = new Container(); container.RegisterType<Foo, IFoo>(); Or, if you create a dedicated ITargetContainer that you specifically want the Container to use, only a small change is required: var targets = new TargetContainer(); targets.RegisterType<Foo, IFoo>(); var container = new Container(targets); Tip The RegisterType overload instructs the container to build an instance via constructor injection . There's too many types of registrations to cover in a few sub headings here for this - the service registration topic has more detail, with links to all the other different types of registration you can perform. Moreover, you can browse the different topics from the table of contents on the left (or top on mobile). Resolving services Resolving objects from your container is done through the Resolve method which, you'll notice, accepts an IResolveContext as its single parameter, and returns an Object . Again, if you're familiar with IOC containers then you're probably wondering where your strongly-typed Resolve<TService>() method is! Well, fear not. As with the many extension methods available on ITargetContainer , the IContainer interface (through which all resolving of objects is done) has extension methods to provide a more traditional IOC API, and these are found on the ContainerResolveExtensions static class. The one you'll use most frequently, of course, is the Resolve<TObject>(IContainer) method, which provides the aforementioned Resolve<TService>() API. So, assuming we have the container that we've been using up till now, we would resolve an instance of MyService simply by doing one of the following: MyService service = container.Resolve<MyService>(); //or MyServiceBase service = container.Resolve<MyServiceBase>(); //or IMyService service = container.Resolve<IMyService>(); Note The IResolveContext interface captures the context of a call to the Resolve method, tracking the container on which the call is originally made, whether there is an IContainerScope active for the call, and other things besides. You will rarely use it directly in application code unless you are extending Rezolver. These Resolve extension methods create the IResolveContext for a given operation on your behalf, so you never have to worry about it. Assuming the container can locate the service registration for the type you request, it will fetch/produce an instance of the associated object type according to the behaviour described by the ITarget which we previously registered. If no registration is found, then an InvalidOperationException is raised by the container. Tip IContainer also implements the System.IServiceProvider interface from the .Net framework, which requires that missing services yield a null result instead of throwing an exception. CanResolve/TryResolve Sometimes you might want to attempt to resolve an object from the container, but not have an exception raised if it cannot be found. In this case you can use the TryResolve method, which returns the object via an out parameter and returns a bool indicating whether the operation succeeds. Naturally, as with the Resolve operation, this method has a generic overload ( TryResolve<TObject>(IContainer, out TObject) ) to avoid the need for a temporary Object reference: MyService result; bool success = container.TryResolve(out result); //success == true or false depending on registrations. Similarly we can also introspect a container to find out if it can resolve an instance of a given type by using the CanResolve method. This method also has friendly overloads via extension methods (e.g. CanResolve<TObject>(IContainer) )): bool canResolve = container.CanResolve<MyService>(); Container Configurations and Options For those looking to customise or extend Rezolver, many of the types are overridable. However, the ITargetContainer and IContainer implementations mentioned above also use another mechanism that provides extensibility without having to subclass them. Note This is an advanced topic and not one that you should have to worry about most of the time. The examples in this guide will highlight where you can use the functionality described below - this section is intended to be a high-level overview only. There are two primary types of container configuration in Rezolver: Target container configuration (via implementations of ITargetContainerConfig ) Container configuration (via implementations of IContainerConfig ) Both are very similar in that they define a method called Configure (see ITargetContainerConfig.Configure and IContainerConfig.Configure ) to which is passed an ITargetContainer and, in the case of IContainerConfig , also an IContainer . Implementations of the interfaces can add/modify service registrations which are then used either directly by the container, or which provide more advanced registration functionality. For example, Rezolver's automatic enumerable injection is enabled by the InjectEnumerables configuration when it configures an ITargetContainer . This configuration is actually applied to all instances of TargetContainer by default (via the DefaultConfig configuration collection) - but you can also control whether enumerable injection is enabled without having to remove the configuration from that collection, as is shown in the last enumerable example . There is much more to be covered about configuration and options. For now - use them where this guide shows you can (e.g. to control contravariance or member binding behaviour etc), and if you want to be able to control something else this way, and can't, then just open an issue on Github. Next Steps Read up on how to register services in the container . Alternatively, if you haven't already, take a look Rezolver's understanding of object lifetimes ."
  },
  "docs/benchmarks.html": {
    "href": "docs/benchmarks.html",
    "title": "Rezolver Benchmarks | Rezolver IOC",
    "keywords": "Rezolver Benchmarks Note Daniel Palme has now integrated Rezolver into his benchmarks as standard, so now you can evaluate it's performance independently of our own tests shown here. He regularly updates this blog post with in depth comments and analysis on his latest results. The current status of Rezolver's performance is 'Average', which is fair, because of the results of the Child Container tests, which we are working on improving. Benchmarking an IOC container obviously has pitfalls. In a web environment, for example, it's highly unlikely you'll hit the kind of traffic levels required for your choice of container to have a noticeable impact on speed. But, that said, speed is still important - especially with something as fundamental as an object which is taking control of how you create your objects! In any case, if you're reading this then you're a developer - which means you're probably interested in how fast Rezolver stacks up against your previous favourite container ;) Methodology Over on GitHub Daniel Palme has, for a while now, been maintaining a benchmarking suite for IOC containers - called IOCPerformance . In addition to our own performance analysis, this program offers an easy way to stress test the Rezolver containers both on their own, but also against other popular containers. The tests include singletons, transients, objects which require a mixture of these, complex objects which require lots of nested dependencies, resolving enumerables and child containers, and does provide a reasonably thorough examination of a container's features in addition to its performance. Excluding Rezolver and the 'No' container, which the baseline, there are 31 containers now being stress-tested by this application, with the list growing. Notes Rezolver performs very well across the board, however where it suffers is in benchmarks which constantly destroy and recreate containers. In particular, the performance in the 'Child Containers' benchmark is particularly poor - caused by the fact that there's an overhead on the first Resolve call to a container, as that's when it compiles the associated ICompiledTarget for that service. Because of the way this benchmark is performed, it means that Rezolver spends most of its time dynamically compiling the same delegates. A solution is in the pipeline for this, which will be implemented once we've implemented another compiler that's based entirely on reflection and late-bound delegates instead of dynamically constructed expression trees. When this is done and merged with the current expression-tree based compiler, the performance of child containers will improve drastically. As the other benchmarks show, however, Rezolver's normal-use performance is up there with the best which, when coupled with its extensibility and featureset, should make it a decent contender for any new project."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "Rezolver API reference | Rezolver IOC",
    "keywords": "Rezolver API reference Looking for documentation on individual classes or methods in the Rezolver project? You've come to the right place! Crucial types to look at are: TargetContainer (implements ITargetContainer ): Stores ITarget instances, and is the main class you'll use for your 'registration' phase. Container (implements IContainer ): The standard, non-scoped, container you'll use in your composition root - you can create child scopes from this by calling its implementation of CreateScope() , which returns instances of IContainerScope . This class uses an ITargetContainer for its registrations, which you can supply construction if required. ScopedContainer - A disposable IContainer that also acts as a 'root' scope."
  },
  "docs/lifetimes/scoped.html": {
    "href": "docs/lifetimes/scoped.html",
    "title": "Scoped Objects | Rezolver IOC",
    "keywords": "Scoped Objects If you've been reading through this section in order, then you're probably already familiar with the purpose of a scoped object. If you haven't already, then its suggested you read the singletons topic (because the way you create scoped registrations is fundamentally identical), then the container scopes topic so that you know how to create a scope and what you can expect from it. A scoped object is a singleton enforced at the scope level The ScopeBehaviour of an ITarget that creates a scoped object will be set to Explicit . Although often used with objects that support the IDisposable interface; any object can be registered as 'scoped' Any target can be made to produce a scoped object by wrapping it with a ScopedTarget (either through its constructor or via the Scoped extension method) You can also register scoped types (i.e. a shortcut for creating a ConstructorTarget or GenericConstructorTarget which is then wrapped in a ScopedTarget ) with the RegisterScoped extension methods. Apart from the fact that a scoped object limits itself to one-per-scope (and one registration can, therefore, produce multiple instances across multiple scopes), the big difference between it and a singleton is that a scope must be available when you resolve an instance. Examples We don't need many examples to show scoped objects in action. You can apply the ScopedTarget to all the same targets to which the SingletonTarget can be applied, so some of the more exotic examples from the singletons topic are not repeated here, but with the examples we do have, you should have enough to adapt those into creating scoped objects. Finally, all the behaviour shown regarding IDisposables and scopes works the same for these explicitly scoped objects as they do for transient object. Note In all these examples, we will use the ScopedContainer so that we always have a scope available even if we don't create one. Basic example using (var container = new ScopedContainer()) { container.RegisterScoped<MyService, IMyService>(); var result1 = container.Resolve<IMyService>(); var result2 = container.Resolve<IMyService>(); Assert.Same(result1, result2); } Different scope = a different object This example shows how different instances are returned for different scopes for the same registration: using(var container = new ScopedContainer()) { container.RegisterScoped<MyService, IMyService>(); var result1 = container.Resolve<IMyService>(); IMyService result2; using(var scope = container.CreateScope()) { result2 = scope.Resolve<IMyService>(); Assert.NotSame(result1, result2); } } Wrapping up And that's it for lifetimes, return to the topic homepage if you need more information."
  },
  "docs/lifetimes/index.html": {
    "href": "docs/lifetimes/index.html",
    "title": "Object Lifetimes | Rezolver IOC",
    "keywords": "Object Lifetimes As with most IOC containers, Rezolver understands three primary lifetimes for the objects it produces, including support for automatic disposal of IDisposable objects when an IContainerScope is used. Transient Objects This is what's ultimately produced by a Rezolver IContainer most of the time - a transient object is created when needed and thrown away when no longer required. It's the same as using new to create an instance inside a function and then allowing it to go out of scope when that function returns. Read more about transient objects . Singletons Most developers will be familiar with the singleton pattern - an object created only once per process (often created lazily - i.e. on demand) and which is frequently accessed via static accessors or similar. Specifically, an application will usually enforce rules at the code level to ensure that it's impossible to create more than one instance of the type. Rezolver lets you change any registration into a singleton by simply wrapping an ITarget inside a SingletonTarget . Read more about singletons . Scoped Objects Unsurprisingly, understanding scoped objects requires an understanding of scopes. At its most fundamental level, a scope is simply a disposable 'bag' of objects which is created at the start of a particular process (e.g when a web request is received, or when a job is pulled off a job queue) and which is then disposed when that process completes. Most IOC containers refer to these as lifetime scopes ( note: 'container scopes' in Rezolver, implemented by the IContainerScope interface ) and they are most often used (but not exclusively) to track objects that implement the IDisposable interface in order that they can be disposed without the developer explicitly having to do so themselves - often because the developer can never really be sure that she has definitely finished with that object. But the presence of a scope at the point where an object is produced/obtained by the container does not automatically mean that that object is itself 'scoped'. Indeed, transients and singletons can be used inside a scope in exactly the same way as outside. Instead, a scoped object has a special lifetime behaviour such that it behaves like a singleton, except you get one instance per scope instead of one per-process. A scoped object also requires a scope to be available in order for it to be resolved. Scopes are also hierarchical - one scope can contain zero or more other child scopes whose scoped objects are independent of each other (and those of the parent) - but each child scope will be disposed when the parent scope is disposed. Rezolver allows you to change any registration into a scoped object by wrapping an ITarget inside a ScopedTarget . Read more about container scopes (particularly if you will be using IDisposable objects in your application). Read more about scoped objects ."
  },
  "docs/lifetimes/container-scopes.html": {
    "href": "docs/lifetimes/container-scopes.html",
    "title": "Container Scopes | Rezolver IOC",
    "keywords": "Container Scopes Before we start looking at scoped objects , we should first look at how Rezolver's IContainerScope interface, and its implementations, are used to implement lifetime scoping. What's the purpose of a scope? A scope is a disposable object whose main purpose, as mentioned in the introduction to this section , is to track and dispose any IDisposable objects produced by the container through that scope. This is necessary, or at least desirable, because the IOC container takes control of both how and when your objects are created and, more importantly, they are more often than not created purely to be passed as dependencies into other objects via dependency injection (via, for example, constructor parameters). This means that the .Net developer's preferred pattern of working with disposable objects (at least in C#), namely: using(var disposable = new MyDisposable()) { //use disposable } is no longer possible. Not only that, but there's the issue of who is responsible for disposing of a given object, especially if it has been used as a dependency of more than one other object. The scope offers a way to simplify this problem by taking ownership of those disposables for you. All you need to do is to create the scope, and then dispose of it when you no longer need the objects it produced. Creating a Container Scope If you've used other IOC containers, then you'll probably already have guessed how to create a new scope. Formally, the IScopeFactory interface is how you create a scope - through its CreateScope method. The interface is implemented by: IContainer IContainerScope (because scopes are hierarchical) IResolveContext In the example code, therefore, you will see a lot of this: var container = new Container(); // perform registrations using(var scope = container.CreateScope()) { } Scope Behaviours Different targets (see the Rezolver.Targets namespace) exhibit different scoping behaviours - that is, how the object produced by the target should be tracked within a scope when resolved. At present * , this is determined by the ScopeBehaviour enumeration, which has three values: Implicit - The object should be passively tracked within an enclosing scope (if present) when it is created if, and only if, it is IDisposable . Each and every instance will be tracked, and none of those instances will be reused. When the scope is disposed, all objects that were tracked will also be disposed. Explicit - The object requires an enclosing scope to be present when created, and only one instance of the object should be created per scope. If the object is IDisposable then it, too, will be disposed when the scope is disposed. None - The object does not interact with a scope and, if it's IDisposable , then it must be explicitly disposed by application code. * In the future, the enumeration might be replaced with a type and static instances whose names are the same as those listed here, so that scoping behaviour can be abstracted and, therefore, made more extensible The behaviour of an ITarget can be read through its ScopeBehaviour property - which is read only and is, for most targets, defaulted to Implicit . Indeed, most implementations of the interface do not allow you to control this behaviour. One exception that does, however, is the ObjectTarget - which defaults to None because you supply the instance when you create the target, therefore it's assumed you will also take responsibility for disposing it, if it's IDisposable . If you want Rezolver to dispose of it for you, then you can pass a different behaviour when you create the target. Note The only other scope behaviour that you should pass to an ObjectTarget is Explicit , because there's only ever one instance. If you use Implicit , then a scope will end up tracking the same instance multiple times, creating unnecessary entries in its internal tracking arrays, and the object's Dispose method will end up being called multiple times. Using Explicit There is only one target whose ScopeBehaviour is set to Explicit - the ScopedTarget . This target is used in the same way that we use the SingletonTarget (as described in the singletons documentation in this section ) - you wrap another target with it, and it then ensures that only one instance per-scope is ever produced from the target. Explicitly scoped objects are covered exclusively in the next topic in this section but before we head on over to that topic, we will go through a few examples which involve the Implicit behaviour - i.e, the default for most types of registration, to see how 'normal' objects interact with scopes. Examples For these examples, we're using this type: public class DisposableType : IDisposable { public bool Disposed { get; private set; } public void Dispose() { if (Disposed) throw new ObjectDisposedException(nameof(DisposableType)); Disposed = true; } } Note that the type throws an exception if attempts are made to dispose of it multiple times - this is a feature of the tests which drive the examples, as we want to prevent unnecessary Dispose() calls as much as possible. We're also using this trivial type for examples where we resolve the disposable as a dependency: public class RequiresDisposableType { public DisposableType Disposable { get; } public RequiresDisposableType(DisposableType disposable) { Disposable = disposable; } } Implicitly scoped transient disposable First we look at the simplest case - we create a Container from which we obtain a new scope through which we then resolve an instance of a disposable object. When we dispose the scope, the object should also be disposed: var container = new Container(); container.RegisterType<DisposableType>(); DisposableType result; using(var scope = container.CreateScope()) { result = scope.Resolve<DisposableType>(); } Assert.True(result.Disposed); Nested child scopes This time, the container is building the same type, but we're using child scopes - checking that each child scope only disposes of the objects resolved within it: var container = new Container(); container.RegisterType<DisposableType>(); DisposableType rootResult; using(var rootScope = container.CreateScope()) { rootResult = rootScope.Resolve<DisposableType>(); DisposableType childResult; using (var childScope = rootScope.CreateScope()) { childResult = childScope.Resolve<DisposableType>(); DisposableType grandChildResult; using(var grandChildScope = childScope.CreateScope()) { grandChildResult = grandChildScope.Resolve<DisposableType>(); } Assert.True(grandChildResult.Disposed); Assert.False(childResult.Disposed); Assert.False(rootResult.Disposed); } Assert.True(childResult.Disposed); Assert.False(rootResult.Disposed); } Assert.True(rootResult.Disposed); Disposable Dependencies All the examples so far demonstrate disposable objects being resolved directly via a scope. What if a disposable object is instead created as a dependency of another? var container = new Container(); container.RegisterType<RequiresDisposableType>(); container.RegisterType<DisposableType>(); RequiresDisposableType result; using(var scope = container.CreateScope()) { result = scope.Resolve<RequiresDisposableType>(); } Assert.True(result.Disposable.Disposed); Tip Remember - the scope tracks all IDisposable objects it creates - so it doesn't matter whether an object is created directly for a Resolve operation or purely as a dependency for another object - it will be disposed by the scope that owns it. Disposable Singletons On the subject of ownership - a singleton has special rules regarding the scope it wants to belong to. The singleton could be constructed at any time, inside any scope, but as we know from the singletons documentation , the object itself must remain available as long as the container itself is available. As a result, singletons must ensure that they are disposed by the root-most scope (i.e. one which does not have a parent): // In this example we use the disposable ScopedContainer, which // supports all the same functionality as 'Container' except it // also has its own scope, and is therefore disposable. DisposableType result; using (var container = new ScopedContainer()) { container.RegisterSingleton<DisposableType>(); using (var scope = container.CreateScope()) { // singletons force tracking in the // rootmost scope of a scope hierarchy result = scope.Resolve<DisposableType>(); } Assert.False(result.Disposed); } Assert.True(result.Disposed); Important As the example shows, if you are using disposable singletons, then you should always use ScopedContainer as your application's container instead of Container . It supports exactly the same functionality shown in all the examples on this site, but it also has it's own scope which will automatically become the default root for your application, thus ensuring that any singletons will be disposed only when you dispose of the ScopedContainer . Mixing lifetimes and scopes The previous example throws up a slight problem: what happens when a singleton depends on a non-singleton disposable; and vice versa? Transient depending on a Singleton When a transient object depends on a singleton disposable, then (regardless of whether the transient is Disposable too) nothing changes, the singleton is still tracked in the root-most scope, and is not disposed until that scope is disposed - there is no difference to the singleton example shown above. Singleton depending on a Transient Note This didn't work properly prior to v1.2. If you are still using v1.1, then consider upgrading to the latest package If the roles are reversed and a singleton takes a dependency on a transient IDisposable , then that transient (and any other dependencies) will also be tracked in the root scope, so that it remains usable for the lifetime of the singleton: var container = new Container(); container.RegisterSingleton<RequiresDisposableType>(); container.RegisterType<DisposableType>(); RequiresDisposableType result; using (var scope = container.CreateScope()) { using (var childScope = scope.CreateScope()) { result = childScope.Resolve<RequiresDisposableType>(); } Assert.False(result.Disposable.Disposed); } Assert.True(result.Disposable.Disposed); In short - an object's lifetime is determined by the longest lifetime of any object that 'owns' that object. Next steps Learn how to create per-scope singletons with scoped objects ."
  },
  "docs/enumerables/lazy-vs-eager.html": {
    "href": "docs/enumerables/lazy-vs-eager.html",
    "title": "Lazy vs. Eager Enumerables | Rezolver IOC",
    "keywords": "Lazy vs. Eager Enumerables As described in the main enumerables topic , Rezolver builds lazy enumerables by default, but can also generate eager enumerables. This topic describes the difference between the two and also shows how you can configure your container to build enumerables differently for different types. Background What is a Lazy enumerable? A lazy enumerable is simply one which produces results as you enumerate it rather than being backed by an array or collection which already contains the objects. As an example, the .Net function Range function generates a lazy enumerable which, when enumerated, provides a range of n integer values starting from a given lower bound: // an enumerable which starts at 0 and keeps returning values up to, and including, 9 var enumerable = Enumerable.Range(0, 10); // an enumerable which starts at 100 and keeps returning values up to, and including, 199 var enumerable2 = Enumerable.Range(100, 100); When you foreach these enumerables (or call the .GetEnumerator() ) function, these lazy enumerables will continue generating new results (via the IEnumerator<int>.MoveNext implementation) until n results have been returned. Crucially, if you then foreach these enumerables a second time, you will get a new sequence - with the code that generates each result being executed again each time. The side effect of this being that if you do something like this: var enumerable = Enumerable.Range(0, 10).Select(i => new Foo(i)); foreach(var o in enumerable) { } //and then a second time foreach(var o in enumerable) { } The objects produced by the Select method are always new instances whenever you enumerate - so in the above example 20 new instances of Foo are created - not 10. What is an eager enumerable? Typically, an eager enumerable is one which has been created from a data structure which already contains all the objects which will be enumerated. The simplest example of this being an array: var a = new[] { new Foo(), new Foo(), new Foo() }; foreach(var o in a) { } // enumerating the same instances again foreach(var o in a) { } In this case, all the objects produced by the enumerable are already in memory, and the enumerator is merely walking an array, linked list or whatever. Tip Most .Net developers will already be familiar with the idea of 'realising' an enumerable to force it to become 'eager', using the ToArray or ToList extension methods. These functions simply enumerate their input enumerable once, storing the results into an array/list or similar structure. Examples Lazy enumerable To demonstrate Rezolver's default behaviour of creating lazy enumerables, we'll get it to construct an enumerable of the first of these two (contrived) classes: public class CallsYouBackOnCreate { public CallsYouBackOnCreate(Action<CallsYouBackOnCreate> callback) { callback(this); } } public class CallsYouBackOnCreate2 { public CallsYouBackOnCreate2(Action<CallsYouBackOnCreate2> callback) { callback(this); } } The example registers an Action<CallsYouBackOnCreate> callback, in addition to three entries for the CallsYouBackOnCreate type, which increments a local counter - meaning that we can monitor how many times the constructor for that type is called. var container = new Container(); var instanceCounter = 0; // ensures we get an enumerable with three items container.RegisterType<CallsYouBackOnCreate>(); container.RegisterType<CallsYouBackOnCreate>(); container.RegisterType<CallsYouBackOnCreate>(); container.RegisterObject<Action<CallsYouBackOnCreate>>( o => ++instanceCounter); var items = container.ResolveMany<CallsYouBackOnCreate>(); // start by asserting that no instances have been created yet Assert.Equal(0, instanceCounter); var lastCounter = instanceCounter; foreach(var item in items) { // every time we move next, a new item should be created, // which, in turn, fires the delegate which increments the // counter Assert.Equal(lastCounter + 1, instanceCounter); lastCounter = instanceCounter; } // more importantly - if we enumerate it again, then the // objects are created again foreach (var item in items) { Assert.Equal(lastCounter + 1, instanceCounter); lastCounter = instanceCounter; } There are a few takeaways from this example: Immediately after resolving an instance of the enumerable, we assert that no instances of CallsYouBackOnCreate have been created The two foreach loops verify that each instance produced from the enumerable is created just-in-time The instances produced by the enumerable are not retained by the underlying enumerator. New instances are being created every time enumeration occurs. In the context of this example, clearly it seems odd that we'd want an enumerable that keeps generating new instances every time we enumerate it. In the real-world, however, most of the time we inject enumerables, the receiving object will enumerate once. Equally, if the receiver does expect to enumerate multiple times and wants to guarantee that only the correct number of items will ever be produced exactly once, then a simple .ToArray() call will do the trick. Eager enumerable (global) As with many other Rezolver behaviours, lazy/eager enumerable creation is controlled by an option which can be set on an ITargetContainer either globally (which affects all enumerables) or on a per-type basis (see next). The option that controls this behaviour is LazyEnumerables - which of course has a Default value of true (thus when it's not explicitly set on a target container, lazy enumerables are enabled). This example is very similar to the lazy enumerable example above - but this time we're going to disable all lazy enumerables on the ITargetContainer which underpins the container: var container = new Container(); var instanceCounter = 0; // set this option to disable lazy enumerables globally container.SetOption<Options.LazyEnumerables>(false); container.RegisterType<CallsYouBackOnCreate>(); container.RegisterType<CallsYouBackOnCreate>(); container.RegisterType<CallsYouBackOnCreate>(); container.RegisterObject<Action<CallsYouBackOnCreate>>( o => ++instanceCounter); var items = container.ResolveMany<CallsYouBackOnCreate>(); // this time all instances will be created immediately. Assert.Equal(3, instanceCounter); // and we'll just assert that the instance count never changes foreach(var item in items) { Assert.Equal(3, instanceCounter); } foreach (var item in items) { Assert.Equal(3, instanceCounter); } In contrast to the previous example, then, note that all the instances within the enumerable are created as soon as the container returns it to the caller (or injects it as a constructor/delegate argument) - and also note that the number of instances created doesn't change on repeated enumerations. Warning Do not confuse this behaviour with that of a singleton. If we were to fetch two eager enumerables from the container, then both would create their instances up-front, independent of each other. Eager enumerable (per-service) Obviously, being able to switch all enumerables to eager is likely to be a bit of a sledgehammer in many cases. So Rezolver also lets you control the production of lazy or eager enumerables on a per-type basis. To do this, when setting the LazyEnumerables options to false , you also include the type of service whose enumerables are to be affected (see the SetOption overload for more): // for this test we'll drop the two foreach loops and just use .ToArray() var container = new Container(); var instanceCounter1 = 0; var instanceCounter2 = 0; // set this option to disable lazy enumerables only for // the type 'CallsYouBackOnCreate2' container.SetOption<Options.LazyEnumerables, CallsYouBackOnCreate2>(false); container.RegisterType<CallsYouBackOnCreate>(); container.RegisterType<CallsYouBackOnCreate>(); container.RegisterType<CallsYouBackOnCreate>(); container.RegisterObject<Action<CallsYouBackOnCreate>>( o => ++instanceCounter1); container.RegisterType<CallsYouBackOnCreate2>(); container.RegisterType<CallsYouBackOnCreate2>(); container.RegisterType<CallsYouBackOnCreate2>(); container.RegisterObject<Action<CallsYouBackOnCreate2>>( o => ++instanceCounter2); // will be lazy var items1 = container.ResolveMany<CallsYouBackOnCreate>(); Assert.Equal(0, instanceCounter1); // will be eager var items2 = container.ResolveMany<CallsYouBackOnCreate2>(); Assert.Equal(3, instanceCounter2); var array1a = items1.ToArray(); var array1b = items1.ToArray(); var array2a = items2.ToArray(); var array2b = items2.ToArray(); Assert.Equal(6, instanceCounter1); Assert.Equal(3, instanceCounter2); Tip Remember - per-service options can also be defined for open generics and for common bases or interfaces of a given type. This means you can set it for BaseClass and it will apply to any type derived from it (unless you also set it specifically for that derived type). Equally, setting it for the open generic IGeneric<> will apply to any closed generic built from it (again - unless you expressly set it differently for that closed generic). Tip Although it should be obvious by now - you can very easily invert the lazy enumerable behaviour to opt-in instead of opt-out by setting the LazyEnumerables to false globally, which then allows you to set it to true for specific services. Benefits of being lazy The reasons why Rezolver defaults to lazy enumerables are the same as why you'd use them in any .Net project: Lazy enumerables are generally faster to create than an eager enumerable containing the same results, because typically the enumerable just wraps a function. The eager version of the same enumerable will still use that function to produce the instances, but must also execute it and capture the results on creation. Lazy enumerables generally have a lower memory overhead. The pathological case (and, admittedly, not necessarily relevant in the IOC world) is an enumerable that produces a theoretically infinite series. Such enumerables can clearly never be evaluated eagerly, because they require more storage than the machine (or in most theories of reality, the universe itself!) has available. The more realistic case is where you might have 100s of registrations for a given type, all the implementations of which consume big chunks of memory - creating an eager enumerable of these will instantly grab a chunk of memory for those instances, whereas a lazily evaluated enumerable would not. That said, there are of course reasons why you'd still want to use an eager enumerable. Perhaps the objects are singletons and/or are 'hard' to create - in which case you might as well expend a bit of extra effort up front to create them so you don't have to do it later. Back to the root enumerables documentation"
  },
  "api/Rezolver.ITarget.html": {
    "href": "api/Rezolver.ITarget.html",
    "title": "Interface ITarget | Rezolver IOC",
    "keywords": "Interface ITarget Represents an action to be performed in order to obtain an object to satisfy a call to Resolve(IResolveContext) , when the standard implementations of IContainer are used (e.g. Container ). Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface ITarget Remarks As mentioned in the summary, the role of this interface is largely determined by the framework's own standard implementations of the IContainer interface - all of which use an ITargetContainer to store service registrations which, when Resolve(IResolveContext) is called, is queried to obtain one or more targets which will have been registered for the requested type. After obtaining a target, an ITargetCompiler is then used to compile the target(s) into an ICompiledTarget whose GetObject(IResolveContext) method will ultimately then be called to 'resolve' the instance. The role of the target, then, is to act as a description of the action that is to be performed by that compiled target that is built from it. The interface doesn't describe the type of target in hand - it only provides the core data required to query the static type of the target (the type of object that the target will produce) and to determine compatibility with a request for a particular type. The framework's many implementations of this interface - e.g. ConstructorTarget , SingletonTarget , ResolvedTarget plus many others - then define the behaviour and any additional data required in order for a compiler to produce an ICompiledTarget which matches the target's intent. E.g, the ConstructorTarget , which represents creating a new instance via a constructor, provides all the necessary information to bind to the correct constructor (including parameter bindings etc) - and the compiler's job is to translate that into an ICompiledTarget which executes that constructor, returning the result. Properties | Improve this Doc View Source DeclaredType Gets the static type of the object produced from this target. For example, if this target represents executing a constructor on a type, then this property should equal the type to which that constructor belongs. Declaration Type DeclaredType { get; } Property Value Type Description Type | Improve this Doc View Source Id Unique Id for this target Declaration Guid Id { get; } Property Value Type Description Guid | Improve this Doc View Source ScopeBehaviour Gets the scoping behaviour for instances that will ultimately be produced by this target. Declaration ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. | Improve this Doc View Source ScopePreference Get the preferred scope in which an object produced from this target should be tracked. Declaration ScopePreference ScopePreference { get; } Property Value Type Description ScopePreference | Improve this Doc View Source UseFallback If true , then the consumer should consider falling back to a more suitable target if available, as the object produced from this target is most likely a default of some kind - e.g. empty enumerable, default parameter value. Declaration bool UseFallback { get; } Property Value Type Description Boolean Methods | Improve this Doc View Source SupportsType(Type) Returns a boolean indicating whether the target is able to produce an instance of, or an instance that is compatible with, the passed type . Declaration bool SupportsType(Type type) Parameters Type Name Description Type type The type. Returns Type Description Boolean true if type is supported, false otherwise. Remarks It is strongly suggested that you use this method to check whether the target can construct an instance of a given type rather than performing any type checking yourself on the DeclaredType , because an ITarget might be able to support a much wider range of types other than just those which are directly compatible with its DeclaredType . For example, the GenericConstructorTarget is statically bound to an open generic, so therefore traditional type checks on the DeclaredType do not work. That class' implementation of this method, however, contains the complex logic necessary to determine if the open generic can be closed into a generic type which is compatible with the given type . Implementations of ITargetCompiler should always consult this function in their implementation of CompileTarget(ITarget, ICompileContext) to determine if the target is compatible with the TargetType of the CompileContext Please note that any type that's a generic type definition will always yield a false result, because it's impossible to build an instance of an open generic type. Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget)"
  },
  "api/Rezolver.ICompiledTarget.html": {
    "href": "api/Rezolver.ICompiledTarget.html",
    "title": "Interface ICompiledTarget | Rezolver IOC",
    "keywords": "Interface ICompiledTarget Provides an abstraction for creating objects based on a given IResolveContext - this is the ultimate target of all Resolve(IResolveContext) calls in the standard container implementations within the Rezolver framework. Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface ICompiledTarget Remarks In the standard implementations of IContainer (e.g. Container ), a ITargetCompiler creates instances of this from ITarget s which are registered in an ITargetContainer . When the container is then called upon to resolve an instance of a particular type, the ICompiledTarget is first obtained, and then the responsibility for creating the object is delegated to its GetObject(IResolveContext) method. Properties | Improve this Doc View Source SourceTarget Gets the ITarget from which this compiled target was produced Declaration ITarget SourceTarget { get; } Property Value Type Description ITarget Methods | Improve this Doc View Source GetObject(IResolveContext) Called to get/create an object, potentially using the passed context to resolve additional dependencies (via its Container ), or interact with any lifetime scope which is 'active' for that request (through Scope ). Declaration object GetObject(IResolveContext context) Parameters Type Name Description IResolveContext context The current rezolve context. Returns Type Description Object The object that is constructed. The return value can legitimately be null. Exceptions Type Condition InvalidOperationException If the target fails to create the object Exception Any other application-level exception could be raised by this operation Extension Methods UnresolvedICompiledTargetExtensions.IsUnresolved(ICompiledTarget)"
  },
  "api/Rezolver.SingletonTargetContainerExtensions.html": {
    "href": "api/Rezolver.SingletonTargetContainerExtensions.html",
    "title": "Class SingletonTargetContainerExtensions | Rezolver IOC",
    "keywords": "Class SingletonTargetContainerExtensions Extension methods for the ITargetContainer interface which simplify the registration of singletons. Inheritance Object SingletonTargetContainerExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class SingletonTargetContainerExtensions Methods | Improve this Doc View Source RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) Registers the type objectType as a singleton ( SingletonTarget ) in the target container, either for the same service type, or for the service type passed to the serviceType parameter (if provided). The instance will be built automatically with constructor injection by leveraging either the ConstructorTarget or GenericConstructorTarget , depending on whether objectType is a generic type or not. Declaration public static void RegisterSingleton(this ITargetContainer targetContainer, Type objectType, Type serviceType = null, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registrations will be made. Type objectType Required. The type of object to be created. Type serviceType Optional. The type against which the target will be registered in the targetContainer IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on the targetContainer . | Improve this Doc View Source RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) Registers the type TObject as a singleton ( SingletonTarget ) in the target container. The instance will be built automatically with constructor injection by leveraging either the ConstructorTarget or GenericConstructorTarget , depending on whether TObject is a generic type or not. Declaration public static void RegisterSingleton<TObject>(this ITargetContainer targetContainer, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registrations will be made. IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on the targetContainer . Type Parameters Name Description TObject The type to be created, and the type against which the registration will be made | Improve this Doc View Source RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) Registers the type TObject as a singleton ( SingletonTarget ) in the target container for the service type TService . The instance will be built automatically with constructor injection by leveraging either the ConstructorTarget or GenericConstructorTarget , depending on whether TObject is a generic type or not. Declaration public static void RegisterSingleton<TObject, TService>(this ITargetContainer targetContainer, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registrations will be made. IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on the targetContainer . Type Parameters Name Description TObject The type of object to be created. TService The type against which the target will be registered in the targetContainer"
  },
  "api/Rezolver.Sdk.html": {
    "href": "api/Rezolver.Sdk.html",
    "title": "Namespace Rezolver.Sdk | Rezolver IOC",
    "keywords": "Namespace Rezolver.Sdk Classes Dependant Simple base class for implementations of IDependant - the Dependencies property is implemented explictly. DependantCollection<T> A collection of objects in which one or more objects can be dependent on others in the same collection (via the IDependant interface). DependantExtensions Extension methods for the IDependant interface DependencyEnumerableExtensions Extensions for IEnumerable<DependencyMetadata> DependencyException This exception is related to the IDependant functionality used by Rezolver. It is raised when two objects dependn on each other, or if a required dependency is missing from the collection passed to a DependencyMetadata object's GetDependencies<T>(IEnumerable<T>) method. DependencyMetadata Represents a dependency from an IDependant on one or more other objects in a collection. Note that the current implementations of this class are internal and can only be created through the various methods in the DependantExtensions class. DependencyMetadataCollection A collection of DependencyMetadata objects. An IDependant contains one of these collections in order to store the dependencies that it has on other objects. Interfaces IDependant Interface for an object that is dependent upon other objects IMutableDependant Interface for an IDependant whose dependencies are described by a DependencyMetadataCollection (and which are, therefore, mutable)."
  },
  "api/Rezolver.Sdk.DependantExtensions.html": {
    "href": "api/Rezolver.Sdk.DependantExtensions.html",
    "title": "Class DependantExtensions | Rezolver IOC",
    "keywords": "Class DependantExtensions Extension methods for the IDependant interface Inheritance Object DependantExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Sdk Assembly : Rezolver.dll Syntax public static class DependantExtensions Methods | Improve this Doc View Source After<T, TDependency>(T, TDependency) Adds an optional dependency from the object on which this is called to dep . If the object dep is present in the input collection when dependencies are resolved, then it will be identified. Declaration public static T After<T, TDependency>(this T obj, TDependency dep)where T : IMutableDependant where TDependency : class Parameters Type Name Description T obj The object to which a dependency is to be added. TDependency dep The object upon which obj is optionally dependent. Returns Type Description T The object on which the method is called. Type Parameters Name Description T The type of object on which this is called. TDependency The type for the dependency being added. | Improve this Doc View Source After<T, TDependency>(T, IEnumerable<TDependency>) Adds an optional dependency from the object on which this is called to all the objects in deps . Any objects in deps which are present in the input collection when dependencies are resolved will be identified as dependencies. None of them will be required. Declaration public static T After<T, TDependency>(this T obj, IEnumerable<TDependency> deps)where T : IMutableDependant where TDependency : class Parameters Type Name Description T obj The object to which a dependency is to be added. System.Collections.Generic.IEnumerable <TDependency> deps The objects upon which obj is optionally dependent. Returns Type Description T The object on which the method is called. Type Parameters Name Description T The type of object on which this is called. TDependency The type for the dependency being added. | Improve this Doc View Source AfterAny<T>(T, Type) Adds an optional dependency from the object on which this is called to any object of the type dependencyType . Use this when only the type of the dependency is known, but the specific instance is not important. Declaration public static T AfterAny<T>(this T obj, Type dependencyType)where T : IMutableDependant Parameters Type Name Description T obj The object to which a dependency is to be added. Type dependencyType The type for the dependency being added. Returns Type Description T The object on which the method is called. Type Parameters Name Description T The type of object on which this is called. | Improve this Doc View Source CreateObjectDependency<TDependency>(IDependant, TDependency, Boolean) Creates a dependency for the object which this method is invoked to a specific instance of a particular type - either required or optional. Declaration public static DependencyMetadata CreateObjectDependency<TDependency>(this IDependant obj, TDependency dependency, bool required = true)where TDependency : class Parameters Type Name Description IDependant obj The dependant object for which the dependency is to be created. TDependency dependency The object that will be the target of the dependency. Boolean required true to make the dependency required; false to make it optional. Returns Type Description DependencyMetadata A new DependencyMetadata object representing a dependency from obj to the object dependency . Type Parameters Name Description TDependency The type of the object that will be the target of the dependency. Remarks As with CreateTypeDependency<TDependency>(IDependant, Boolean) , this method creates a new DependencyMetadata object and returns it, as opposed to the methods Requires<T, TDependency>(T, TDependency) or After<T, TDependency>(T, TDependency) , which create and add the dependency directly to an IMutableDependant object. This method is used most often by IDependant objects (i.e. those with read-only dependencies) which have a fixed set of required or optional dependencies that are known at construction-time. | Improve this Doc View Source CreateTypeDependency<TDependency>(IDependant, Boolean) Creates a dependency for the object on which this method is invoked to objects of a particular type - either required or optional. Declaration public static DependencyMetadata CreateTypeDependency<TDependency>(this IDependant obj, bool required = true)where TDependency : class Parameters Type Name Description IDependant obj The dependant object for which the dependency is to be created. Boolean required true to make the dependency required; false to make it optional. Returns Type Description DependencyMetadata A new DependencyMetadata object representing a dependency from obj to objects of type TDependency . Type Parameters Name Description TDependency The type of objects that will be the target of the dependency. Remarks As with CreateObjectDependency<TDependency>(IDependant, TDependency, Boolean) , this method creates a new DependencyMetadata object and returns it, as opposed to the methods RequiresAny<T>(T, Type) or AfterAny<T>(T, Type) , which create and add the dependency directly to an IMutableDependant object. This method is used most often by IDependant objects (i.e. those with read-only dependencies) which have a fixed set of required or optional dependencies that are known at construction-time. | Improve this Doc View Source GetDependencies<T, TDependency>(T, IEnumerable<TDependency>) Shortcut method for resolving the dependencies for an IDependant from a set of objects. All the method does is forward the call to the GetDependencies<T>(IEnumerable<DependencyMetadata>, IEnumerable<T>) method of the DependencyMetadataCollection belonging to the passed IDependant - obj Declaration public static IEnumerable<TDependency> GetDependencies<T, TDependency>(this T obj, IEnumerable<TDependency> objects)where T : IDependant where TDependency : class Parameters Type Name Description T obj Required - the object whose dependencies are to be resolved. System.Collections.Generic.IEnumerable <TDependency> objects Required - the range of objects from which dependencies are to be located. Generally speaking, it's typical for obj to be a member of this range. Returns Type Description System.Collections.Generic.IEnumerable <TDependency> Type Parameters Name Description T The type of object on which the method was called. TDependency The common dependency type | Improve this Doc View Source Requires<T, TDependency>(T, TDependency) Adds a required dependency from the object on which this is called to dep The object dep must be present in the input collection when dependencies are resolved. Declaration public static T Requires<T, TDependency>(this T obj, TDependency dep)where T : IMutableDependant where TDependency : class Parameters Type Name Description T obj The object to which a dependency is to be added. TDependency dep The object upon which obj is dependent. Returns Type Description T The object on which the method is called. Type Parameters Name Description T The type of object on which this is called. TDependency The type for the dependency being added. | Improve this Doc View Source Requires<T, TDependency>(T, IEnumerable<TDependency>) Adds a required dependency from the object on which this is called to all the objects in deps Every object in deps must be present in the input collection when dependencies are resolved. Declaration public static T Requires<T, TDependency>(this T obj, IEnumerable<TDependency> deps)where T : IMutableDependant where TDependency : class Parameters Type Name Description T obj The object to which a dependency is to be added. System.Collections.Generic.IEnumerable <TDependency> deps The objects upon which obj is dependent. Returns Type Description T The object on which the method is called. Type Parameters Name Description T The type of object on which this is called. TDependency The type for the dependency being added. | Improve this Doc View Source RequiresAny<T>(T, Type) Adds a required dependency from the object on which this is called to at least one object of the type dependencyType . Use this when only the type of the dependency is known, but the specific instance is not important. Declaration public static T RequiresAny<T>(this T obj, Type dependencyType)where T : IMutableDependant Parameters Type Name Description T obj The object to which a dependency is to be added. Type dependencyType The type of objects upon which the object is dependent. Returns Type Description T The object on which the method is called. Type Parameters Name Description T The type of object on which this is called."
  },
  "api/Rezolver.Sdk.DependantCollection-1.html": {
    "href": "api/Rezolver.Sdk.DependantCollection-1.html",
    "title": "Class DependantCollection<T> | Rezolver IOC",
    "keywords": "Class DependantCollection<T> A collection of objects in which one or more objects can be dependent on others in the same collection (via the IDependant interface). Inheritance Object DependantCollection<T> CombinedContainerConfig CombinedTargetContainerConfig Implements System.Collections.Generic.IList <T> System.Collections.Generic.ICollection <T> System.Collections.Generic.IEnumerable <T> IEnumerable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Sdk Assembly : Rezolver.dll Syntax public class DependantCollection<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable where T : class Type Parameters Name Description T The type of object in the collection Remarks To iterate the collection in order of least dependant to most dependant, enumerate the result of the Ordered function - which uses a typical DAG topological sort to organise the objects by least dependent to most dependent. In order for this to work - one or more objects in the collection must implement the IDependant interface. Constructors | Improve this Doc View Source DependantCollection() Constructs a new empty DependantCollection<T> instance Declaration public DependantCollection() | Improve this Doc View Source DependantCollection(T[]) Provides a convenient way to initialise a DependantCollection<T> using a variable argument list. Declaration public DependantCollection(params T[] dependants) Parameters Type Name Description T[] dependants The items to be added to the collection on construction. | Improve this Doc View Source DependantCollection(IEnumerable<T>) Constructs a new DependantCollection<T> with the passed range of objects as the initial set. Declaration public DependantCollection(IEnumerable<T> range) Parameters Type Name Description System.Collections.Generic.IEnumerable <T> range The items to be added to the collection on construction. If null, then the collection simply starts off empty. Properties | Improve this Doc View Source Count Implementation of Count Declaration public int Count { get; } Property Value Type Description Int32 | Improve this Doc View Source IsReadOnly Implementation of IsReadOnly Declaration public bool IsReadOnly { get; } Property Value Type Description Boolean | Improve this Doc View Source Item[Int32] Implementation of System.Collections.Generic.IList<T>.Item[System.Int32] Declaration public T this[int index] { get; set; } Parameters Type Name Description Int32 index Index of the item to be read or written. Property Value Type Description T | Improve this Doc View Source Ordered Gets an enumerable which will return the items in the collection in order of least dependent to most dependent. Therefore, if item 1 depends on item 2, this enumerable will return item 2 first, followed by item 1. Items which have no dependencies within the same collection will be sorted earlier in the collection. The sort is stable with respect to the order in which items are added; so equally dependant objects will retain their original order. Declaration public IEnumerable<T> Ordered { get; } Property Value Type Description System.Collections.Generic.IEnumerable <T> Methods | Improve this Doc View Source Add(T) Implementation of System.Collections.Generic.ICollection<T>.Add(T) Declaration public void Add(T item) Parameters Type Name Description T item Required. The item to be added to the collection. | Improve this Doc View Source AddAll(T[]) Alternative to AddAll(IEnumerable<T>) which allows you to pass individual items as arguments Declaration public void AddAll(params T[] items) Parameters Type Name Description T[] items The items to be added | Improve this Doc View Source AddAll(IEnumerable<T>) Adds all the passed items to the collection. Declaration public void AddAll(IEnumerable<T> range) Parameters Type Name Description System.Collections.Generic.IEnumerable <T> range Required - the items to be added. None of the items can be null | Improve this Doc View Source Clear() Implementation of System.Collections.Generic.ICollection<T>.Clear() . Empties the collection. Declaration public void Clear() | Improve this Doc View Source Clone<TDerived>() Creates a new instance of the collection type TDerived whose items are cloned from this collection's items. Declaration protected TDerived Clone<TDerived>()where TDerived : DependantCollection<T>, new () Returns Type Description TDerived A new instance of the type TDerived whose items are cloned from this collection. Type Parameters Name Description TDerived The type of collection to be created from this one. | Improve this Doc View Source Contains(T) Implementation of System.Collections.Generic.ICollection<T>.Contains(T) . Returns a boolean indicating whether the passed item is found in the collection. Declaration public bool Contains(T item) Parameters Type Name Description T item The item to be checked. Returns Type Description Boolean | Improve this Doc View Source CopyTo(T[], Int32) Implementation of System.Collections.Generic.ICollection<T>.CopyTo(T[], System.Int32) . Declaration public void CopyTo(T[] array, int arrayIndex) Parameters Type Name Description T[] array The target array into which the collection will be copied. Int32 arrayIndex The starting index in the array | Improve this Doc View Source GetEnumerator() Implementation of System.Collections.Generic.IEnumerable<T>.GetEnumerator() Declaration public IEnumerator<T> GetEnumerator() Returns Type Description System.Collections.Generic.IEnumerator <T> | Improve this Doc View Source IndexOf(T) Implementation of System.Collections.Generic.IList<T>.IndexOf(T) . Declaration public int IndexOf(T item) Parameters Type Name Description T item The item whose index in the collection is to be returned. Returns Type Description Int32 | Improve this Doc View Source Insert(Int32, T) Inserts the passed item at the given index in the collection Declaration public void Insert(int index, T item) Parameters Type Name Description Int32 index The index at which the new item is to be inserted. T item Required. The item to be inserted. | Improve this Doc View Source Remove(T) Implementation of System.Collections.Generic.ICollection<T>.Remove(T) Declaration public bool Remove(T item) Parameters Type Name Description T item The item to be removed. Returns Type Description Boolean | Improve this Doc View Source RemoveAll(IEnumerable<T>) Removes all the items from the collection that can be found within it. Declaration public bool RemoveAll(IEnumerable<T> items) Parameters Type Name Description System.Collections.Generic.IEnumerable <T> items Required. The items to be removed. Returns Type Description Boolean true if all items were removed (note - if items is empty this is also the case); false otherwise. | Improve this Doc View Source RemoveAt(Int32) Implementation of System.Collections.Generic.IList<T>.RemoveAt(System.Int32) Declaration public void RemoveAt(int index) Parameters Type Name Description Int32 index The index of the item to be removed. | Improve this Doc View Source Replace(T, T) Replaces the original object with the passed replacement object, if original is found within the collection. The original object is returned if it is found and the replacement operation succeeds. Declaration public T Replace(T original, T replacement) Parameters Type Name Description T original Required. The object to be replaced. T replacement Required. The replacement object. Returns Type Description T | Improve this Doc View Source ReplaceAnyOrAdd<TOriginal>(T) Replaces any objects of the type TOriginal with the single object passed for the replacement argument. Note - the replacement will be inserted at the first index at which a matching object was found. If none is found, then the replacement will be added to the end of the collection. Declaration public void ReplaceAnyOrAdd<TOriginal>(T replacement)where TOriginal : T Parameters Type Name Description T replacement The object to be added to the collection at the position where the first object of the type TOriginal is found. Note that all will still be removed. Type Parameters Name Description TOriginal The type of object to be removed. Note that any object equal to, derived from, or which implements the type will be removed. | Improve this Doc View Source ReplaceAnyOrAdd<TOriginal>(Func<IEnumerable<T>, T>) Replaces any objects of the type TOriginal with a single object obtained by calling the replacementCallback callback. Note - the replacement will be inserted at the first index at which a matching object was found. If none is found, then the replacement will be added to the end of the collection. Declaration public void ReplaceAnyOrAdd<TOriginal>(Func<IEnumerable<T>, T> replacementCallback)where TOriginal : T Parameters Type Name Description System.Func < System.Collections.Generic.IEnumerable <T>, T> replacementCallback Callback to be executed to get the object that will replace any existing entries of the given type. The callback will be passed an enumerable containing any existing entries. Note that this enumerable will never be null, but might be empty. Type Parameters Name Description TOriginal The type of object to be removed. Note that any object whose type is equal to, derived from, or which implements the type will be removed. | Improve this Doc View Source ReplaceOrAdd(T, T) Replaces the original with the replacement , or adds the replacement to the end of the collection if the original does not exist. Declaration public void ReplaceOrAdd(T original, T replacement) Parameters Type Name Description T original The item to be replaced. If found, it will be swapped with the replacement . T replacement The item to be swapped with original or added to the end of the collection if the original can't be found. Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Implementation of System.Collections.IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description IEnumerator Implements System.Collections.Generic.IList<T> System.Collections.Generic.ICollection<T> System.Collections.Generic.IEnumerable<T> IEnumerable"
  },
  "api/Rezolver.RezolverOptions.html": {
    "href": "api/Rezolver.RezolverOptions.html",
    "title": "Class RezolverOptions | Rezolver IOC",
    "keywords": "Class RezolverOptions Options for using Rezolver as the DI container for Asp.Net Core web applications. Inheritance Object RezolverOptions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.Microsoft.AspNetCore.Hosting.dll Syntax public class RezolverOptions Constructors | Improve this Doc View Source RezolverOptions() Creates a new instance of the RezolverOptions class. Declaration public RezolverOptions() Properties | Improve this Doc View Source ContainerConfig The IContainerConfig to be used to initialise the IContainer for the application. Can be used to control the compiler used to translate ITarget registrations into ICompiledTarget objects. Declaration public CombinedContainerConfig ContainerConfig { get; set; } Property Value Type Description CombinedContainerConfig Remarks This is always cloned from the DefaultConfig using the Clone() method. | Improve this Doc View Source TargetContainerConfig The ITargetContainerConfig to be used to initialise the ITargetContainer for the application. Declaration public CombinedTargetContainerConfig TargetContainerConfig { get; set; } Property Value Type Description CombinedTargetContainerConfig Remarks This is always cloned from the DefaultConfig using the Clone() method."
  },
  "api/Rezolver.ResolveContext.html": {
    "href": "api/Rezolver.ResolveContext.html",
    "title": "Class ResolveContext | Rezolver IOC",
    "keywords": "Class ResolveContext Standard implementation of IResolveContext Inheritance Object ResolveContext Implements IResolveContext IScopeFactory Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver Assembly : Rezolver.dll Syntax public class ResolveContext : IResolveContext, IScopeFactory Constructors | Improve this Doc View Source ResolveContext(IContainer, Type) Initializes a new instance of the ResolveContext class. Declaration public ResolveContext(IContainer container, Type requestedType) Parameters Type Name Description IContainer container The container. Type requestedType The type of object to be resolved from the container. | Improve this Doc View Source ResolveContext(IContainerScope, Type) Initializes a new instance of the ResolveContext class from the given scope. The Container is inherited from the scope's Container . Declaration public ResolveContext(IContainerScope scope, Type requestedType) Parameters Type Name Description IContainerScope scope The scope. Type requestedType The of object to be resolved from the container. Properties | Improve this Doc View Source Container The container for this context. Declaration public IContainer Container { get; } Property Value Type Description IContainer Remarks This is the container which received the original call to Resolve(IResolveContext) , but is not necessarily the same container that will eventually end up resolving the object. | Improve this Doc View Source Previous A reference to the context from which this one was created. Declaration public IResolveContext Previous { get; } Property Value Type Description IResolveContext | Improve this Doc View Source RequestedType Gets the type being requested from the container. Declaration public Type RequestedType { get; } Property Value Type Description Type | Improve this Doc View Source Scope Gets the scope that's active for all calls for this context. Declaration public IContainerScope Scope { get; } Property Value Type Description IContainerScope The scope. Methods | Improve this Doc View Source CreateScope() Creates a new scope either through the Scope or, if that's null, then the Container . Declaration public IContainerScope CreateScope() Returns Type Description IContainerScope Remarks This interface implementation is present for when an object wants to be able to inject a scope factory in order to create child scopes which are correctly parented either to another active scope or the container. | Improve this Doc View Source New(Type, IContainer, IContainerScope) Creates a new context from this one, typically with at least one of the properties changed according to the parameters you pass. Note that if none of the parameters are provided; or if none of the parameters have different values from those already on the properties of the context, then the method can return the same instance on which it is called. Declaration public IResolveContext New(Type newRequestedType = null, IContainer newContainer = null, IContainerScope newScope = null) Parameters Type Name Description Type newRequestedType Optional - a new type to be resolved. If a new context is created, then its RequestedType will be inherited from this context, unless a non-null type is passed to this parameter. IContainer newContainer Optional - a new container to be used for the new context. If a new context is created, then its Container will be inherited from this context unless a non-null container is passed to this parameter. IContainerScope newScope Optional - a new scope to be used for the new context. If a new context is created, then its Scope will be inherited from this context unless a non-null container is passed to this parameter. Note the implication: once a context has a non-null Scope , it's not possible to create a new, child, context which has a null scope. Returns Type Description IResolveContext | Improve this Doc View Source Resolve(Type) Resolves a new instance of a different type from the same scope/container that originally received the current Resolve operation. Declaration public object Resolve(Type newRequestedType) Parameters Type Name Description Type newRequestedType New type to be resolved. Returns Type Description Object Remarks Use this method, or the generic equivalent, to resolve dependency services in a factory or expression. If a scope is active then it will be honoured. | Improve this Doc View Source Resolve<TResult>() Resolves a new instance of a different type from the same scope/container that originally received the current Resolve operation. Declaration public TResult Resolve<TResult>() Returns Type Description TResult Type Parameters Name Description TResult New type to be resolved. Remarks Use this method, or the non-generic equivalent, to resolve dependency services in a factory or expression. If a scope is active then it will be honoured. | Improve this Doc View Source ToString() Returns a String that represents this instance. Declaration public override string ToString() Returns Type Description String Overrides System.Object.ToString() | Improve this Doc View Source TryResolve(Type, out Object) Mirror of the TryResolve(IResolveContext, out Object) method which works directly off this resolve context - taking into account the current Container and Scope Declaration public bool TryResolve(Type newRequestedType, out object result) Parameters Type Name Description Type newRequestedType The type to be resolved. Object result Receives the result of a successful resolve operation. Returns Type Description Boolean A boolean indicating whether the operation was successful. Remarks Use this method, or the non-generic equivalent, to resolve dependency services in a factory or expression. If a scope is active then it will be honoured. | Improve this Doc View Source TryResolve<TResult>(out TResult) Generic equivalent of TryResolve(Type, out Object) Declaration public bool TryResolve<TResult>(out TResult result) Parameters Type Name Description TResult result Receives the result of a successful resolve operation. Returns Type Description Boolean A boolean indicating whether the operation was successful. Type Parameters Name Description TResult The type to be resolved. Implements IResolveContext IScopeFactory"
  },
  "api/Rezolver.Options.FetchAllMatchingGenerics.html": {
    "href": "api/Rezolver.Options.FetchAllMatchingGenerics.html",
    "title": "Class FetchAllMatchingGenerics | Rezolver IOC",
    "keywords": "Class FetchAllMatchingGenerics A boolean option for target containers that controls which registrations will be returned when FetchAll(Type) is called with a closed generic type, when using the built in target containers. This ultimately affects the objects that are materialised in automatically generated enumerables (when the InjectEnumerables is enabled - which it is, by default) when the element type is itself a generic type. Inheritance Object ContainerOption < Boolean > FetchAllMatchingGenerics Inherited Members ContainerOption<Boolean>.Value ContainerOption<Boolean>.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Options Assembly : Rezolver.dll Syntax public class FetchAllMatchingGenerics : ContainerOption<bool> Remarks This option is primarily used to control the GenericTargetContainer and the targets it returns from its implementation of FetchAll(Type) where the input type is a closed generic. When true (the Default ), all targets which match both the closed generic and which have been registered for all applicable open generics will be returned. When false then the function will return only the first matching group of targets sharing a common matching type. So, if there are five registered against the open generic, and one against the closed generic; then the one will 'beat' the five. Properties | Improve this Doc View Source Default The default value for the FetchAllMatchingGenerics option - equivalent to true . Declaration public static FetchAllMatchingGenerics Default { get; } Property Value Type Description FetchAllMatchingGenerics Operators | Improve this Doc View Source Implicit(Boolean to FetchAllMatchingGenerics) Implicit conversion operator to FetchAllMatchingGenerics from Boolean to simplify reading and writing the option as a boolean. Declaration public static implicit operator FetchAllMatchingGenerics(bool value) Parameters Type Name Description Boolean value Returns Type Description FetchAllMatchingGenerics"
  },
  "api/Rezolver.Options.EnableListInjection.html": {
    "href": "api/Rezolver.Options.EnableListInjection.html",
    "title": "Class EnableListInjection | Rezolver IOC",
    "keywords": "Class EnableListInjection Boolean option which, if configured before the InjectLists configuration is applied, will control whether automatic injection of List<T> (and related interfaces - see the documentation on that type for more) will be enabled. The Default is equivalent to true . Inheritance Object ContainerOption < Boolean > EnableListInjection Inherited Members ContainerOption<Boolean>.Value ContainerOption<Boolean>.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Options Assembly : Rezolver.dll Syntax public class EnableListInjection : ContainerOption<bool> Remarks The injection behaviour controlled by this option most commonly piggybacks off of the behaviour that's enabled by the InjectEnumerables configuration. However, although this option is therefore related to the EnableEnumerableInjection option, the two are independent. If you disable automatic enumerable injection, it does not automatically disable automatic list injection. Properties | Improve this Doc View Source Default Default value for this option, equivalent to true Declaration public static EnableListInjection Default { get; } Property Value Type Description EnableListInjection Operators | Improve this Doc View Source Implicit(Boolean to EnableListInjection) Convenience operator for creating an instance of this option from a boolean. Declaration public static implicit operator EnableListInjection(bool value) Parameters Type Name Description Boolean value Returns Type Description EnableListInjection See Also InjectLists EnableEnumerableInjection InjectEnumerables"
  },
  "api/Rezolver.MemberBindingBuilder-2.html": {
    "href": "api/Rezolver.MemberBindingBuilder-2.html",
    "title": "Class MemberBindingBuilder<TInstance, TMember> | Rezolver IOC",
    "keywords": "Class MemberBindingBuilder<TInstance, TMember> Builds individual MemberBinding objects for the MemberBindingBehaviourBuilder<TInstance> class. Created through the Bind<TMember>(Expression<Func<TInstance, TMember>>) . Inheritance Object MemberBindingBuilder<TInstance, TMember> Implements IMemberBindingBehaviourBuilder <TInstance> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class MemberBindingBuilder<TInstance, TMember> : IMemberBindingBuilder, IMemberBindingBehaviourBuilder<TInstance> Type Parameters Name Description TInstance The type of object whose member is to be bound during construction by the container. TMember The type of the member that is to be bound. Remarks The class also implements the IMemberBindingBehaviourBuilder<TInstance> Properties | Improve this Doc View Source Member The member that will be bound by the MemberBinding Declaration public MemberInfo Member { get; } Property Value Type Description MemberInfo | Improve this Doc View Source Parent The builder that this belongs to Declaration public IMemberBindingBehaviourBuilder<TInstance> Parent { get; } Property Value Type Description IMemberBindingBehaviourBuilder <TInstance> Methods | Improve this Doc View Source AsCollection() Explicitly sets the member to be bound as a collection initialiser - i.e. instead of resolving an instance of the member type, Rezolver will resolve an enumerable of an element type, which is then added to the collection after construction using a publicly available Add method on the member type. Use this when a member is of a type which satisfies the usual requirements for collection initialisation, but is read/write (since collection initialisation only kicks in automatically for read-only collection properties). The element type of the collection will be determined from the type's implementation of System.Collections.Generic.IEnumerable<T> Declaration public IMemberBindingBehaviourBuilder<TInstance> AsCollection() Returns Type Description IMemberBindingBehaviourBuilder <TInstance> The bindings builder, in order that another member binding can be created and configured. | Improve this Doc View Source AsCollection(ITarget[]) Explicitly sets the member to be bound as a collection initialiser using the targets passed in the elementTargets argument. Declaration public IMemberBindingBehaviourBuilder<TInstance> AsCollection(params ITarget[] elementTargets) Parameters Type Name Description ITarget [] elementTargets Returns Type Description IMemberBindingBehaviourBuilder <TInstance> | Improve this Doc View Source AsCollection(Type) Non-generic version of the AsCollection<TElement>() method. Declaration public IMemberBindingBehaviourBuilder<TInstance> AsCollection(Type elementType) Parameters Type Name Description Type elementType The element type of the enumerable that will be used to initialise the collection represented by the member. Returns Type Description IMemberBindingBehaviourBuilder <TInstance> The bindings builder, in order that another member binding can be created and configured. | Improve this Doc View Source AsCollection(Type[]) This binds a collection member to an enumerable whose elements are resolved at resolve-time via the types provided. In effect, multiple resolve operations are performed and the results are then fed into the collection. Declaration public IMemberBindingBehaviourBuilder<TInstance> AsCollection(params Type[] elementTypes) Parameters Type Name Description Type [] elementTypes The types of each individual element Returns Type Description IMemberBindingBehaviourBuilder <TInstance> | Improve this Doc View Source AsCollection<TElement>() Explicitly sets the member to be bound as a collection initialiser - i.e. instead of resolving an instance of the member type, Rezolver will resolve an enumerable of the type TElement , which is then added to the collection after construction using a publicly available Add method on the member type. Use this when a member is of a type which satisfies the usual requirements for collection initialisation, but is read/write (since collection initialisation only kicks in automatically for read-only collection properties. Or when you want to fill a collection with elements of a particular type. Declaration public IMemberBindingBehaviourBuilder<TInstance> AsCollection<TElement>() Returns Type Description IMemberBindingBehaviourBuilder <TInstance> The bindings builder, in order that another member binding can be created and configured. Type Parameters Name Description TElement The element type of the enumerable that will be used to initialise the collection represented by the member. | Improve this Doc View Source Bind<TNextMember>(Expression<Func<TInstance, TNextMember>>) Called to commence building a binding for another member belonging to the type TInstance . Declaration public MemberBindingBuilder<TInstance, TNextMember> Bind<TNextMember>(Expression<Func<TInstance, TNextMember>> memberBindingExpression) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func <TInstance, TNextMember>> memberBindingExpression An expression that represents reading the member to be bound. The body of the expression must be a MemberExpression with the Type of the Expression equal to TInstance . Returns Type Description MemberBindingBuilder <TInstance, TNextMember> A builder that can be used to customise the binding for the member represented by the expression memberBindingExpression Type Parameters Name Description TNextMember Type of the member represented by the expression memberBindingExpression . | Improve this Doc View Source BuildBehaviour() Creates the IMemberBindingBehaviour represented by the current set of bindings Declaration public IMemberBindingBehaviour BuildBehaviour() Returns Type Description IMemberBindingBehaviour | Improve this Doc View Source ToObject(TMember) Sets the binding for the member to a constant service - equivalent to calling ToTarget(ITarget) with an ObjectTarget Declaration public IMemberBindingBehaviourBuilder<TInstance> ToObject(TMember obj) Parameters Type Name Description TMember obj The value to be bound to the member Returns Type Description IMemberBindingBehaviourBuilder <TInstance> | Improve this Doc View Source ToTarget(ITarget) Sets the binding for the member to a particular target. Declaration public IMemberBindingBehaviourBuilder<TInstance> ToTarget(ITarget target) Parameters Type Name Description ITarget target The target that is to be used to bind the member. Returns Type Description IMemberBindingBehaviourBuilder <TInstance> The bindings builder, in order that another member binding can be created and configured. | Improve this Doc View Source ToType(Type) Sets the binding for the member to a particular type - so when the member is bound, an instance of type is resolved. Declaration public IMemberBindingBehaviourBuilder<TInstance> ToType(Type type) Parameters Type Name Description Type type The type to be resolved. Returns Type Description IMemberBindingBehaviourBuilder <TInstance> The bindings builder, in order that another member binding can be created and configured. | Improve this Doc View Source ToType<TTarget>() Sets the binding for the member to a particular type - so when the member is bound, an instance of TTarget is resolved. Declaration public IMemberBindingBehaviourBuilder<TInstance> ToType<TTarget>()where TTarget : TMember Returns Type Description IMemberBindingBehaviourBuilder <TInstance> The bindings builder, in order that another member binding can be created and configured. Type Parameters Name Description TTarget The type to be resolved. Implements IMemberBindingBehaviourBuilder<TInstance>"
  },
  "api/Rezolver.MemberBindingBehaviourBuilder-1.html": {
    "href": "api/Rezolver.MemberBindingBehaviourBuilder-1.html",
    "title": "Class MemberBindingBehaviourBuilder<TInstance> | Rezolver IOC",
    "keywords": "Class MemberBindingBehaviourBuilder<TInstance> Class for building custom IMemberBindingBehaviour for instances of TInstance , default implementation of IMemberBindingBehaviourBuilder<TInstance> . Inheritance Object MemberBindingBehaviourBuilder<TInstance> Implements IMemberBindingBehaviourBuilder <TInstance> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class MemberBindingBehaviourBuilder<TInstance> : IMemberBindingBehaviourBuilder<TInstance> Type Parameters Name Description TInstance Remarks To create custom bindings for individual members, use the Bind<TMember>(Expression<Func<TInstance, TMember>>) method to create a MemberBindingBuilder<TInstance, TMember> which contains methods for controlling how a property or field will be bound. Calls to that class will return an IMemberBindingBehaviourBuilder<TInstance> which then allow you to chain further member customisations via a fluent API. You can't create an instance of this class directly - the framework creates an instance for you, either returning it (in the case of For<TInstance>() ) or passing it as an argument to a callback (in the case of Methods | Improve this Doc View Source Bind<TMember>(Expression<Func<TInstance, TMember>>) Marks a member of the type TInstance to be bound. The returned MemberBindingBuilder<TInstance, TMember> can be used to customise the binding; and/or it can be used to continue marking other members to be bound. Declaration public MemberBindingBuilder<TInstance, TMember> Bind<TMember>(Expression<Func<TInstance, TMember>> memberBindingExpression) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func <TInstance, TMember>> memberBindingExpression An expression that represents reading the member to be bound. The body of the expression must be a MemberExpression with the Type of the Expression equal to TInstance . Returns Type Description MemberBindingBuilder <TInstance, TMember> A builder that can be used to customise the binding for the member represented by the expression memberBindingExpression Type Parameters Name Description TMember Type of the member represented by the expression memberBindingExpression . | Improve this Doc View Source BuildBehaviour() Implementation of BuildBehaviour() . Creates a new member binding behaviour that can, for example, be passed to a ConstructorTarget or other . Declaration public IMemberBindingBehaviour BuildBehaviour() Returns Type Description IMemberBindingBehaviour A new IMemberBindingBehaviour which will bind only the members which you've identified with one or more calls to the Bind<TMember>(Expression<Func<TInstance, TMember>>) method of this or the IMemberBindingBehaviourBuilder<TInstance> returned by the MemberBindingBuilder<TInstance, TMember> returned by the Bind method. Implements IMemberBindingBehaviourBuilder<TInstance>"
  },
  "api/Rezolver.IResolveContext.html": {
    "href": "api/Rezolver.IResolveContext.html",
    "title": "Interface IResolveContext | Rezolver IOC",
    "keywords": "Interface IResolveContext Captures the state for a call to Resolve(IResolveContext) (or TryResolve(IResolveContext, out Object) ), including the container on which the operation is invoked, any IScopedContainer that might be active for the call (if different), and the type that is being resolved from the IContainer . Inherited Members IScopeFactory.CreateScope() Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface IResolveContext : IScopeFactory Remarks The context implements IScopeFactory and correctly handles whether a new child scope should be created either from the Scope or the Container . Properties | Improve this Doc View Source Container The container for this context. Declaration IContainer Container { get; } Property Value Type Description IContainer Remarks This is the container which received the original call to Resolve(IResolveContext) , but is not necessarily the same container that will eventually end up resolving the object. | Improve this Doc View Source Previous Gets the IResolveContext from which this context was created, if any. Declaration IResolveContext Previous { get; } Property Value Type Description IResolveContext | Improve this Doc View Source RequestedType Gets the type being requested from the container via a call to its Resolve(IResolveContext) (or similar) method(s). Declaration Type RequestedType { get; } Property Value Type Description Type Remarks During any given Resolve(IResolveContext) (or similar) operation, this type will not necessarily equal the type being constructed at that time. For example, if you inject the context into a constructor (enabled by default via the InjectResolveContext configuration) and instrospect it, this type will only equal a service against which that type is registered if that object is being created directly for that resolve operation. If it is being created in order to be injected into another object, then this property is more likely to equal that type's registered service type. | Improve this Doc View Source Scope Gets the scope that's active for all calls for this context. Declaration IContainerScope Scope { get; } Property Value Type Description IContainerScope The scope. Methods | Improve this Doc View Source New(Type, IContainer, IContainerScope) Creates a new context from this one, typically with at least one of the properties changed according to the parameters you pass. Note that if none of the parameters are provided; or if none of the parameters have different values from those already on the properties of the context, then the method can return the same instance on which it is called. Declaration IResolveContext New(Type newRequestedType = null, IContainer newContainer = null, IContainerScope newScope = null) Parameters Type Name Description Type newRequestedType Optional - a new type to be resolved. If a new context is created, then its RequestedType will be inherited from this context, unless a non-null type is passed to this parameter. IContainer newContainer Optional - a new container to be used for the new context. If a new context is created, then its Container will be inherited from this context unless a non-null container is passed to this parameter. IContainerScope newScope Optional - a new scope to be used for the new context. If a new context is created, then its Scope will be inherited from this context unless a non-null container is passed to this parameter. Note the implication: once a context has a non-null Scope , it's not possible to create a new, child, context which has a null scope. Returns Type Description IResolveContext | Improve this Doc View Source Resolve(Type) Resolves a new instance of a different type from the same scope/container that originally received the current Resolve operation. Declaration object Resolve(Type newRequestedType) Parameters Type Name Description Type newRequestedType New type to be resolved. Returns Type Description Object Remarks Use this method, or the generic equivalent, to resolve dependency services in a factory or expression using the same container that's serving the current resolve operation. If a scope is active then it will be honoured. | Improve this Doc View Source Resolve<TResult>() Resolves a new instance of a different type from the same scope/container that originally received the current Resolve operation. This is a deliberate mirror of the same method on IContainer . Declaration TResult Resolve<TResult>() Returns Type Description TResult Type Parameters Name Description TResult New type to be resolved. Remarks Use this method, or the non-generic equivalent, to resolve dependency services in a factory or expression. If a scope is active then it will be honoured. | Improve this Doc View Source TryResolve(Type, out Object) Mirror of the TryResolve(IResolveContext, out Object) method which works directly off this resolve context - taking into account the current Container and Scope Declaration bool TryResolve(Type newRequestedType, out object result) Parameters Type Name Description Type newRequestedType The type to be resolved. Object result Receives the result of a successful resolve operation. Returns Type Description Boolean A boolean indicating whether the operation was successful. Remarks Use this method, or the non-generic equivalent, to resolve dependency services in a factory or expression. If a scope is active then it will be honoured. | Improve this Doc View Source TryResolve<TResult>(out TResult) Generic equivalent of TryResolve(Type, out Object) Declaration bool TryResolve<TResult>(out TResult result) Parameters Type Name Description TResult result Receives the result of a successful resolve operation. Returns Type Description Boolean A boolean indicating whether the operation was successful. Type Parameters Name Description TResult The type to be resolved."
  },
  "api/Rezolver.Events.TargetRegisteredEvent.html": {
    "href": "api/Rezolver.Events.TargetRegisteredEvent.html",
    "title": "Class TargetRegisteredEvent | Rezolver IOC",
    "keywords": "Class TargetRegisteredEvent An event fired from an ITargetContainer when a Target registration is added to the target container against a particular ServiceType . Inheritance Object TargetRegisteredEvent Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Events Assembly : Rezolver.dll Syntax public sealed class TargetRegisteredEvent Remarks To receive notifications of this event from your root ITargetContainer , add a handler with the Rezolver.TargetContainerEventExtensions.RegisterEventHandler``1(Rezolver.ITargetContainer,Rezolver.ITargetContainerEventHandler{``0}) extension method. Note that if you're using the TargetContainer type as your root target container (the default for container types like Container and ScopedContainer ), then you only need to subscribe to its event and you will receive notifications for all targets added to it, or any of its child container types. Constructors | Improve this Doc View Source TargetRegisteredEvent(ITarget, Type) Creates a new instance of the TargetRegisteredEvent type Declaration public TargetRegisteredEvent(ITarget target, Type serviceType) Parameters Type Name Description ITarget target Required. The target that was registered Type serviceType Required. The service type against which the target was registered. Properties | Improve this Doc View Source ServiceType The service type against which the Target was registered. Declaration public Type ServiceType { get; } Property Value Type Description Type | Improve this Doc View Source Target The target that was registered. Declaration public ITarget Target { get; } Property Value Type Description ITarget"
  },
  "api/Rezolver.Events.TargetContainerRegisteredEventArgs.html": {
    "href": "api/Rezolver.Events.TargetContainerRegisteredEventArgs.html",
    "title": "Class TargetContainerRegisteredEventArgs | Rezolver IOC",
    "keywords": "Class TargetContainerRegisteredEventArgs Inheritance Object EventArgs TargetContainerRegisteredEventArgs Inherited Members EventArgs.Empty System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Events Assembly : Rezolver.dll Syntax public class TargetContainerRegisteredEventArgs : EventArgs Constructors | Improve this Doc View Source TargetContainerRegisteredEventArgs(ITargetContainer, Type) Declaration public TargetContainerRegisteredEventArgs(ITargetContainer container, Type type) Parameters Type Name Description ITargetContainer container Type type Properties | Improve this Doc View Source Container Declaration public ITargetContainer Container { get; } Property Value Type Description ITargetContainer | Improve this Doc View Source Type Declaration public Type Type { get; } Property Value Type Description Type"
  },
  "api/Rezolver.ContainerScopeExtensions.html": {
    "href": "api/Rezolver.ContainerScopeExtensions.html",
    "title": "Class ContainerScopeExtensions | Rezolver IOC",
    "keywords": "Class ContainerScopeExtensions Standard extensions for the IContainerScope Inheritance Object ContainerScopeExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class ContainerScopeExtensions Methods | Improve this Doc View Source GetRootScope(IContainerScope) Gets the root-most scope for the scope on which this method is called. Note that the result is calculated by walking up the tree of Parent scopes until one is reached that does not have a parent. Declaration public static IContainerScope GetRootScope(this IContainerScope scope) Parameters Type Name Description IContainerScope scope The scope. Returns Type Description IContainerScope Exceptions Type Condition ArgumentNullException If scope is null"
  },
  "api/Rezolver.Configuration.InjectLists.html": {
    "href": "api/Rezolver.Configuration.InjectLists.html",
    "title": "Class InjectLists | Rezolver IOC",
    "keywords": "Class InjectLists This configuration will enable automatic injection of List<T> , System.Collections.Generic.IList<T> and System.Collections.Generic.IReadOnlyList<T> when applied to an ITargetContainer , so long as there aren't already registrations for those types . Inheritance Object OptionDependentConfig < EnableListInjection > InjectLists Implements ITargetContainerConfig IDependant Inherited Members OptionDependentConfig<EnableListInjection>.Dependencies System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Configuration Assembly : Rezolver.dll Syntax public class InjectLists : OptionDependentConfig<EnableListInjection>, ITargetContainerConfig, IDependant Remarks If this configuration is added to a CombinedTargetContainerConfig , it can be disabled by adding another configuration to set the EnableListInjection option to false - typically via the ConfigureOption<TOption>(CombinedTargetContainerConfig, TOption) method (note - the order that the configs are added doesn't matter). The underlying behaviour relies on registrations of System.Collections.Generic.IEnumerable<T> to be present when the constructor for the list type is bound, as it expects to bind to the List<T>(IEnumerable<T>) constructor. The easiest way to achieve this is also to ensure that the InjectEnumerables configuration is enabled (which it is, by default) - which guarantees that any System.Collections.Generic.IEnumerable<T> can be resolved - even if empty. Properties | Improve this Doc View Source Instance The one and only instance of InjectLists Declaration public static InjectLists Instance { get; } Property Value Type Description InjectLists Methods | Improve this Doc View Source Configure(IRootTargetContainer) Configures the passed targets to enable auto injection of List<T> , System.Collections.Generic.IList<T> and System.Collections.Generic.IReadOnlyList<T> by registering a GenericConstructorTarget for List<T> for all three types - so long as none of them already have a registration. Declaration public override void Configure(IRootTargetContainer targets) Parameters Type Name Description IRootTargetContainer targets Overrides Rezolver.Configuration.OptionDependentConfig<Rezolver.Options.EnableListInjection>.Configure(Rezolver.IRootTargetContainer) Implements ITargetContainerConfig IDependant Extension Methods DependantExtensions.GetDependencies<T, TDependency>(T, IEnumerable<TDependency>) DependantExtensions.CreateTypeDependency<TDependency>(IDependant, Boolean) DependantExtensions.CreateObjectDependency<TDependency>(IDependant, TDependency, Boolean) See Also EnableListInjection InjectEnumerables"
  },
  "api/Rezolver.Compilation.TargetCompilerExtensions.html": {
    "href": "api/Rezolver.Compilation.TargetCompilerExtensions.html",
    "title": "Class TargetCompilerExtensions | Rezolver IOC",
    "keywords": "Class TargetCompilerExtensions Extensions for the ITargetCompiler interface. Inheritance Object TargetCompilerExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation Assembly : Rezolver.dll Syntax public static class TargetCompilerExtensions Methods | Improve this Doc View Source CompileTarget(ITargetCompiler, ITarget, IResolveContext, ITargetContainer) Compiles the target by calling the CompileTarget(ITarget, ICompileContext) method of the passed compiler , passing an ICompileContext created first by calling its CreateContext(IResolveContext, ITargetContainer) method. Declaration public static ICompiledTarget CompileTarget(this ITargetCompiler compiler, ITarget target, IResolveContext resolveContext, ITargetContainer targets) Parameters Type Name Description ITargetCompiler compiler Required. The compiler which will carry out the compilation ITarget target Required. The target to be compiled. IResolveContext resolveContext Required. The current IResolveContext - since all compilation is usually performed in response to a call to Resolve(IResolveContext) or TryResolve(IResolveContext, out Object) . ITargetContainer targets Required. The ITargetContainer which contains all the registrations which might be required by the target to obtain all its dependencies when the returned ICompiledTarget is executed. Returns Type Description ICompiledTarget A compiled target representing the passed target , ready to be executed to obtain an object which satisfies the RequestedType in the resolveContext . Remarks This is typically called specifically for the root object that is to be resolved from a container, hence the RequestedType will match the type for which the target is to be compiled. Compilers must, however, always use the TargetType to determine the type to be built for, because if one object requires another, then compilers do not keep creating new resolve contexts for each compilation, only new compile contexts for the same resolve context."
  },
  "api/Rezolver.Compilation.Expressions.RezolvedTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.RezolvedTargetBuilder.html",
    "title": "Class RezolvedTargetBuilder | Rezolver IOC",
    "keywords": "Class RezolvedTargetBuilder An IExpressionBuilder specialised for building the expression for the ResolvedTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ResolvedTarget > RezolvedTargetBuilder Implements IExpressionBuilder < ResolvedTarget > IExpressionBuilder Inherited Members ExpressionBuilderBase<ResolvedTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ResolvedTarget>.IExpressionBuilder<ResolvedTarget>.Build(ResolvedTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ResolvedTarget>.CanBuild(ITarget) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class RezolvedTargetBuilder : ExpressionBuilderBase<ResolvedTarget>, IExpressionBuilder<ResolvedTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ResolvedTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(ResolvedTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ResolvedTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ResolvedTarget>.Build(Rezolver.Targets.ResolvedTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Exceptions Type Condition InvalidOperationException Implements IExpressionBuilder<TTarget> IExpressionBuilder"
  },
  "api/Rezolver.Compilation.Expressions.IExpressionBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.IExpressionBuilder.html",
    "title": "Interface IExpressionBuilder | Rezolver IOC",
    "keywords": "Interface IExpressionBuilder The interface for an object that produces expressions (which can be compiled to delegates) from ITarget instances. Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public interface IExpressionBuilder Methods | Improve this Doc View Source Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the specified target. Declaration Expression Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler = null) Parameters Type Name Description ITarget target The target for which an expression is to be built IExpressionCompileContext context The compilation context. IExpressionCompiler compiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the builder should attempt to fetch the compiler from the context; or throw an exception if it is required but not provided and cannot be resolved fromm the context. Returns Type Description Expression Remarks When invoked by the ExpressionCompiler class, the compiler parameter will always be provided. | Improve this Doc View Source CanBuild(ITarget) Determines whether this instance can build an expression for the specified target. Declaration bool CanBuild(ITarget target) Parameters Type Name Description ITarget target The target. Returns Type Description Boolean"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionBuilderBase.Methods.html",
    "title": "Class ExpressionBuilderBase.Methods | Rezolver IOC",
    "keywords": "Class ExpressionBuilderBase.Methods Provides access to a set of MethodInfo objects for common functions required by code produced from ITarget s. Also contains some factory methods for building expressions which bind to those methods. Inheritance Object ExpressionBuilderBase.Methods Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax protected static class Methods Properties | Improve this Doc View Source ICompiledTarget_GetObject_Method Gets a MethodInfo for the GetObject(IResolveContext) method. Declaration public static MethodInfo ICompiledTarget_GetObject_Method { get; } Property Value Type Description MethodInfo | Improve this Doc View Source IContainer_CanResolve_Method Get a MethodInfo for the CanResolve(IResolveContext) method Declaration public static MethodInfo IContainer_CanResolve_Method { get; } Property Value Type Description MethodInfo | Improve this Doc View Source IContainer_Resolve_Method Gets a MethodInfo for the Resolve(IResolveContext) method Declaration public static MethodInfo IContainer_Resolve_Method { get; } Property Value Type Description MethodInfo | Improve this Doc View Source IContainerScope_GetRootScope_Method Gets a MethodInfo for the GetRootScope(IContainerScope) extension method. Declaration public static MethodInfo IContainerScope_GetRootScope_Method { get; } Property Value Type Description MethodInfo | Improve this Doc View Source IContainerScope_Resolve_Method Gets a MethodInfo object for the method for help in generating scope-interfacing code. Declaration public static MethodInfo IContainerScope_Resolve_Method { get; } Property Value Type Description MethodInfo | Improve this Doc View Source IDirectTarget_GetValue_Method Gets a MethodInfo for the Rezolver.IDirectTarget.GetValue method. Declaration public static MethodInfo IDirectTarget_GetValue_Method { get; } Property Value Type Description MethodInfo | Improve this Doc View Source IResolveContext_New_Method Gets a MethodInfo object for the New(Type, IContainer, IContainerScope) method Declaration public static MethodInfo IResolveContext_New_Method { get; } Property Value Type Description MethodInfo The type of the resolve context create new method. | Improve this Doc View Source ResolveContextExtensions_Resolve_Method Gets a MethodInfo for the extension method. Declaration public static MethodInfo ResolveContextExtensions_Resolve_Method { get; } Property Value Type Description MethodInfo Methods | Improve this Doc View Source CallIContainer_CanResolve(Expression, Expression) Emits a MethodCallExpression which represents calling the CanResolve(IResolveContext) method with the given context argument. Declaration public static MethodCallExpression CallIContainer_CanResolve(Expression container, Expression context) Parameters Type Name Description Expression container An expression representing the container on which the method will be called Expression context An expression representing the argument to the context parameter Returns Type Description MethodCallExpression | Improve this Doc View Source CallIContainer_Resolve(Expression, Expression) Emits a MethodCallExpression which represents calling the Resolve(IResolveContext) method with the given context argument. Declaration public static MethodCallExpression CallIContainer_Resolve(Expression container, Expression context) Parameters Type Name Description Expression container An expression representing the container on which the method will be called Expression context An expression representing the argument to the context parameter Returns Type Description MethodCallExpression | Improve this Doc View Source CallResolveContext_New(Expression, Expression, Expression, Expression) Emits a MethodCallExpression which represents calling the New(Type, IContainer, IContainerScope) method with the given arguments. Declaration public static MethodCallExpression CallResolveContext_New(Expression resolveContext, Expression newRequestedType = null, Expression newContainer = null, Expression newScope = null) Parameters Type Name Description Expression resolveContext An expression representing the context on which the method will be called Expression newRequestedType An expression representing the argument to the newRequestedType parameter Expression newContainer An expression representing the argument to the newContainer parameter Expression newScope An expression representing the argument to the newScope parameter Returns Type Description MethodCallExpression"
  },
  "api/Rezolver.Compilation.Expressions.ChangeTypeTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ChangeTypeTargetBuilder.html",
    "title": "Class ChangeTypeTargetBuilder | Rezolver IOC",
    "keywords": "Class ChangeTypeTargetBuilder Implementation of IExpressionBuilder specialised to build expressions for the ChangeTypeTarget This always produces a conversion expression (i.e. cast or box/unbox) Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ChangeTypeTarget > ChangeTypeTargetBuilder Implements IExpressionBuilder < ChangeTypeTarget > IExpressionBuilder Inherited Members ExpressionBuilderBase<ChangeTypeTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ChangeTypeTarget>.IExpressionBuilder<ChangeTypeTarget>.Build(ChangeTypeTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ChangeTypeTarget>.CanBuild(ITarget) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class ChangeTypeTargetBuilder : ExpressionBuilderBase<ChangeTypeTarget>, IExpressionBuilder<ChangeTypeTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ChangeTypeTarget, IExpressionCompileContext, IExpressionCompiler) Builds the conversion expression represented by the target Declaration protected override Expression Build(ChangeTypeTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ChangeTypeTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ChangeTypeTarget>.Build(Rezolver.Targets.ChangeTypeTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Implements IExpressionBuilder<TTarget> IExpressionBuilder"
  },
  "api/Microsoft.AspNetCore.Hosting.html": {
    "href": "api/Microsoft.AspNetCore.Hosting.html",
    "title": "Namespace Microsoft.AspNetCore.Hosting | Rezolver IOC",
    "keywords": "Namespace Microsoft.AspNetCore.Hosting Classes RezolverServiceProviderWebHostBuilderExtensions Provides core functionality to web applications using Asp.Net Core to inject Rezolver containers into the application at the web hosting level, rather than while the application's startup phase is executing."
  },
  "api/Rezolver.Targets.ListTarget.html": {
    "href": "api/Rezolver.Targets.ListTarget.html",
    "title": "Class ListTarget | Rezolver IOC",
    "keywords": "Class ListTarget This target produces arrays ( AsArray = true ) or lists ( AsArray = false ) whose individual items are built by ITarget instances. Inheritance Object TargetBase ListTarget Implements ITarget Inherited Members TargetBase.Id TargetBase.ScopeBehaviour TargetBase.ScopePreference TargetBase.SupportsType(Type) TargetBase.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Targets Assembly : Rezolver.dll Syntax public class ListTarget : TargetBase, ITarget Remarks The element type you feed on construction determines the type of array or the generic argument to List<T>. Each of the rezolve targets that you then pass must support that type. Constructors | Improve this Doc View Source ListTarget(Type, IEnumerable<ITarget>, Boolean) Initializes a new instance of the ListTarget class. Declaration public ListTarget(Type elementType, IEnumerable<ITarget> items, bool asArray = false) Parameters Type Name Description Type elementType Required. Type of the elements in the array or list. System.Collections.Generic.IEnumerable < ITarget > items Required. The targets that will create each the individual items. Boolean asArray A boolean indicating whether the target will build an array ( true ) or a list ( false ). Exceptions Type Condition ArgumentNullException elementType or items ArgumentException All targets in the items enumerable must be non-null;items or All targets in the items enumerable must support the element type elementType Properties | Improve this Doc View Source AsArray Gets a value indicating whether the target will build an array ( true ) or a list ( false ). Declaration public bool AsArray { get; } Property Value Type Description Boolean | Improve this Doc View Source DeclaredType Implementation of the abstract property from the base. This will always return either a type equal to an array of ElementType , or List<T> with ElementType as the generic parameter. This is controlled by the AsArray property. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source ElementType Gets the declared type of each element in the array or list that will be constructed. The DeclaredType returned by this instance will either be ElementType[] or List<ElementType> depending on the value of AsArray . Declaration public Type ElementType { get; } Property Value Type Description Type The declared type of each element. | Improve this Doc View Source Items Gets the rezolve targets that will build each individual item in the resulting list or array. Declaration public IEnumerable<ITarget> Items { get; } Property Value Type Description System.Collections.Generic.IEnumerable < ITarget > The items. | Improve this Doc View Source ListConstructor Gets the list constructor to be invoked when AsArray is false. Declaration public ConstructorInfo ListConstructor { get; } Property Value Type Description ConstructorInfo The list constructor. Exceptions Type Condition InvalidOperationException Since this target is configured to build an array, getting the ListConstructor is not a valid operation. | Improve this Doc View Source UseFallback Returns true if the Items enumerable is empty. Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides TargetBase.UseFallback Implements ITarget Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget)"
  },
  "api/Rezolver.Targets.GenericConstructorTarget.html": {
    "href": "api/Rezolver.Targets.GenericConstructorTarget.html",
    "title": "Class GenericConstructorTarget | Rezolver IOC",
    "keywords": "Class GenericConstructorTarget Equivalent of ConstructorTarget but for open generic types. So, this will handle the open generic MyType<,>, for example, whereas ConstructorTarget would handle the closed type MyType<int, string>. Inheritance Object TargetBase GenericConstructorTarget Implements ITarget Inherited Members TargetBase.Id TargetBase.UseFallback TargetBase.ScopeBehaviour TargetBase.ScopePreference TargetBase.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Targets Assembly : Rezolver.dll Syntax public class GenericConstructorTarget : TargetBase, ITarget Constructors | Improve this Doc View Source GenericConstructorTarget(ConstructorInfo, IMemberBindingBehaviour) Constructs a new instance of the GenericConstructorTarget type. Declaration public GenericConstructorTarget(ConstructorInfo genericConstructor, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ConstructorInfo genericConstructor Required. The constructor on a generic type definition that will be used for each concrete generic instance produced by this target. Must be a member of a generic type definition that is neither an abstract class or interface. IMemberBindingBehaviour memberBinding Optional. Provides an explicit member injection behaviour to be used when creating the instance. If not provided, then the Bind(ICompileContext) method will attempt to obtain one via the options API from the ICompileContext - and if one is still not available, then no member binding will be performed. | Improve this Doc View Source GenericConstructorTarget(Type, IMemberBindingBehaviour) Constructs a new instance of the GenericConstructorTarget for the given open generic type, which will utilise the optional memberBinding when it constructs its ConstructorTarget when Bind(ICompileContext) is called. Declaration public GenericConstructorTarget(Type genericType, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description Type genericType Required. The type of the object that is to be built (open generic of course) IMemberBindingBehaviour memberBinding Optional. Provides an explicit member injection behaviour to be used when creating the instance. If not provided, then the Bind(ICompileContext) method will attempt to obtain one via the options API from the ICompileContext - and if one is still not available, then no member binding will be performed. Properties | Improve this Doc View Source DeclaredType Implementation of the abstract base property. Will return the unbound generic type passed to this object on construction. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source GenericType Gets the generic type definition from which generic types are to be built and instances of which will be constructed. Declaration public Type GenericType { get; } Property Value Type Description Type | Improve this Doc View Source GenericTypeConstructor If supplied on construction, then this is a constructor declared on the GenericType which is to be used for every instance that is created. Declaration public ConstructorInfo GenericTypeConstructor { get; } Property Value Type Description ConstructorInfo Remarks When set, the GenericType is derived from the DeclaringType of this reference. | Improve this Doc View Source MemberBindingBehaviour Gets the member binding behaviour to be used when creating an instance. The rules for this are the same as for MemberBindingBehaviour . Declaration public IMemberBindingBehaviour MemberBindingBehaviour { get; } Property Value Type Description IMemberBindingBehaviour Methods | Improve this Doc View Source Bind(ICompileContext) Obtains an ITarget (usually a ConstructorTarget ) which will create an instance of a generic type (whose definition is equal to GenericType ) with generic arguments set correctly according to the TargetType of the context . Declaration public ITarget Bind(ICompileContext context) Parameters Type Name Description ICompileContext context The context. Returns Type Description ITarget Remarks The process of binding a requested type to the concrete type can be very complex, when inheritance chains and interface implementation maps are taken into account. At the simplest end of the spectrum, if GenericType is MyGeneric<> and the context 's TargetType is MyGeneric<int> , then this function merely has to insert the int type as the generic parameter to the MyGeneric<> type definition, bake a new type and create an auto-bound ConstructorTarget . Consider what happens, however, when the inheritance chain is more complex: interface IMyInterfaceCore<T, U> { } class MyBaseClass<T, U> : IMyInterfaceCore<U, T> { } class MyDerivedClass<T, U> : MyBaseClass<U, T> { } A GenericConstructorTarget bound to the generic type definition MyDerivedClass<,> can create instances not only of any generic type based on that definition, but also any generic type based on the definitions of either it's immediate base, or that base's interface. In order to do so, however, the parameters must be mapped between the generic type definitions so that if an instance of MyBaseClass<string, int> is requested, then an instance of MyDerivedClass<int, string> (note the arguments are reversed) is actually created. Similarly, if an instance of IMyInterface<string, int> is requested, we actually need to create an instance of MyDerivedClass<string, int> - because the generic arguments are reversed first through the base class inheritance, and then again by the base class' implementation of the interface. Note that a GenericConstructorTarget can only bind to the context's target type if there is enough information in order to deduce the generic type arguments for GenericType . This means, in general, that the requested type will almost always need to be a generic type with at least as many type arguments as the GenericType . | Improve this Doc View Source MapType(Type) Maps the DeclaredType open generic type to the targetType . Examine the Success of the result to check whether the result was successful. Declaration public GenericTypeMapping MapType(Type targetType) Parameters Type Name Description Type targetType Type of the target. Returns Type Description GenericTypeMapping | Improve this Doc View Source SupportsType(Type) Override - introduces additional logic to cope with generic types not generally supported by the majority of other targets. This uses the MapType(Type) function to determine success, but only checks the Success flag. As a result, this method will return true if an open generic base or interface of DeclaredType Declaration public override bool SupportsType(Type type) Parameters Type Name Description Type type Returns Type Description Boolean Overrides TargetBase.SupportsType(Type) Implements ITarget Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget) See Also TargetBase"
  },
  "api/Rezolver.Sdk.IMutableDependant.html": {
    "href": "api/Rezolver.Sdk.IMutableDependant.html",
    "title": "Interface IMutableDependant | Rezolver IOC",
    "keywords": "Interface IMutableDependant Interface for an IDependant whose dependencies are described by a DependencyMetadataCollection (and which are, therefore, mutable). Namespace : Rezolver.Sdk Assembly : Rezolver.dll Syntax public interface IMutableDependant : IDependant Properties | Improve this Doc View Source Dependencies A collection through which dependencies can be added and removed, as well as read. Declaration DependencyMetadataCollection Dependencies { get; } Property Value Type Description DependencyMetadataCollection Remarks The DependantExtensions extension methods leverage this property to provide a clean interface for adding different types of dependencies to dependant objects. Extension Methods DependantExtensions.Requires<T, TDependency>(T, TDependency) DependantExtensions.Requires<T, TDependency>(T, IEnumerable<TDependency>) DependantExtensions.RequiresAny<T>(T, Type) DependantExtensions.After<T, TDependency>(T, TDependency) DependantExtensions.After<T, TDependency>(T, IEnumerable<TDependency>) DependantExtensions.AfterAny<T>(T, Type) DependantExtensions.GetDependencies<T, TDependency>(T, IEnumerable<TDependency>) DependantExtensions.CreateTypeDependency<TDependency>(IDependant, Boolean) DependantExtensions.CreateObjectDependency<TDependency>(IDependant, TDependency, Boolean)"
  },
  "api/Rezolver.Sdk.IDependant.html": {
    "href": "api/Rezolver.Sdk.IDependant.html",
    "title": "Interface IDependant | Rezolver IOC",
    "keywords": "Interface IDependant Interface for an object that is dependent upon other objects Namespace : Rezolver.Sdk Assembly : Rezolver.dll Syntax public interface IDependant Properties | Improve this Doc View Source Dependencies Contains all dependency metadata for this object. Declaration IEnumerable<DependencyMetadata> Dependencies { get; } Property Value Type Description System.Collections.Generic.IEnumerable < DependencyMetadata > Extension Methods DependantExtensions.GetDependencies<T, TDependency>(T, IEnumerable<TDependency>) DependantExtensions.CreateTypeDependency<TDependency>(IDependant, Boolean) DependantExtensions.CreateObjectDependency<TDependency>(IDependant, TDependency, Boolean)"
  },
  "api/Rezolver.Runtime.LazyEnumerable-1.html": {
    "href": "api/Rezolver.Runtime.LazyEnumerable-1.html",
    "title": "Class LazyEnumerable<T> | Rezolver IOC",
    "keywords": "Class LazyEnumerable<T> Can be used as an implementation of System.Collections.Generic.IEnumerable<T> when injecting enumerables from one or more registered targets. Inheritance Object LazyEnumerable<T> Implements System.Collections.Generic.IEnumerable <T> IEnumerable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Runtime Assembly : Rezolver.dll Syntax public class LazyEnumerable<T> : IEnumerable<T>, IEnumerable Type Parameters Name Description T The type of object enumerated by the enumerable. Remarks Objects are not expected to take a dependency on this type - but System.Collections.Generic.IEnumerable<T> . The default compiler, ExpressionCompiler , constructs an instance of this when building an EnumerableTarget (via the EnumerableTargetBuilder expression builder). Lazy vs Eager enumerables The default enumerable produced by Rezolver containers is lazily evaluated - via this type. You can disable this entirely (i.e. switching to eagerly loaded enumerables implemented via the EagerEnumerable<T> type) by setting the LazyEnumerables option to false in the underlying ITargetContainer used by the container. You can also switch to eagerly loaded enumerables on a per-type basis - by setting the LazyEnumerables option to false against the specific type of enumerable you want to be eagerly loaded - e.g. for an eagerly loaded System.Collections.Generic.IEnumerable<T> of type String , then you would set the LazyEnumerables to false for the type IEnumerable<string> Constructors | Improve this Doc View Source LazyEnumerable(IResolveContext, IEnumerable<Func<IResolveContext, Object>>) Creates a new LazyEnumerable<T> instance. Declaration public LazyEnumerable(IResolveContext context, IEnumerable<Func<IResolveContext, object>> factories) Parameters Type Name Description IResolveContext context System.Collections.Generic.IEnumerable < System.Func < IResolveContext , Object >> factories Methods | Improve this Doc View Source GetEnumerator() Implementation of System.Collections.Generic.IEnumerable<T>.GetEnumerator() Declaration public IEnumerator<T> GetEnumerator() Returns Type Description System.Collections.Generic.IEnumerator <T> Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Implementation of System.Collections.IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description IEnumerator Implements System.Collections.Generic.IEnumerable<T> IEnumerable See Also EagerEnumerable <T>"
  },
  "api/Rezolver.Runtime.GenericTypeMapping.html": {
    "href": "api/Rezolver.Runtime.GenericTypeMapping.html",
    "title": "Class GenericTypeMapping | Rezolver IOC",
    "keywords": "Class GenericTypeMapping Result returned from the MapType(Type) function. Represents various levels of success - from a completely incompatible mapping ( Success = false ), or a successful mapping from an open generic type to a closed generic type which can then be constructed ( Success = true and IsFullyBound = true ) or, a successful mapping from an open generic type to another open generic type ( Success = true but IsFullyBound = false ). This mapping is then used by both the SupportsType(Type) and Bind(ICompileContext) functions. Only fully bound mappings are supported by Bind(ICompileContext) , whereas SupportsType(Type) will return true so long as the Success is true. The caller, therefore, must ensure it is aware of the difference between open and closed generics. Inheritance Object GenericTypeMapping Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Runtime Assembly : Rezolver.dll Syntax public class GenericTypeMapping Properties | Improve this Doc View Source BindErrorMessage Gets a string describing the reason why the type could not be mapped. Can be used for exceptions, etc. Note that this can be set even if Success is true - because mappings exist between open generic types so that a target's SupportsType(Type) returns true , but the Bind(ICompileContext) function throws an exception for the same type, since you can't create an instance of an open generic. Declaration public string BindErrorMessage { get; } Property Value Type Description String The binding error message. | Improve this Doc View Source Constructor If a specific constructor is to be used, then this is it. Declaration public ConstructorInfo Constructor { get; } Property Value Type Description ConstructorInfo | Improve this Doc View Source IsFullyBound If true, then the Type is a fully closed generic type that can be constructed (and therefore would be successfully bound by the Bind(ICompileContext) method, which uses the MapType(Type) method). If this is false but Success is true , then while the target is technically compatible with the requested type, you can't create an instance. The target will, however, be able to mapped to a closed generic type based on the same Type . Declaration public bool IsFullyBound { get; } Property Value Type Description Boolean | Improve this Doc View Source RequestedType The type requested for mapping. If this is an open generic, then the best result for this mapping will be that Success is true and IsFullyBound is false . Declaration public Type RequestedType { get; } Property Value Type Description Type | Improve this Doc View Source Success Gets a value indicating whether the DeclaredType of the GenericConstructorTarget was successfully mapped to the requested type. If so, and IsFullyBound is true , then an instance of Type will be compatible with the type that was requested. If IsFullyBound is false , then you can't create an instance of Type because it's an open generic - but you will be able to bind the same target to a closed generic of the same Type . Declaration public bool Success { get; } Property Value Type Description Boolean true if success; otherwise, false . | Improve this Doc View Source Type If Success = true , gets the generic type to be used for the RequestedType . Note that this could be either an open or closed generic - the IsFullyBound offers a quick means by which to determine this. If IsFullyBound is true , then the mapping will succeed when encountered by the Bind(ICompileContext) method. Declaration public Type Type { get; } Property Value Type Description Type The type."
  },
  "api/Rezolver.Options.EnableGlobalOptions.html": {
    "href": "api/Rezolver.Options.EnableGlobalOptions.html",
    "title": "Class EnableGlobalOptions | Rezolver IOC",
    "keywords": "Class EnableGlobalOptions A Boolean container option which controls whether per-service options will fall back to a global option if not explicitly set. The Default (unconfigured) is true . Inheritance Object ContainerOption < Boolean > EnableGlobalOptions Inherited Members ContainerOption<Boolean>.Value ContainerOption<Boolean>.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Options Assembly : Rezolver.dll Syntax public class EnableGlobalOptions : ContainerOption<bool> Properties | Improve this Doc View Source Default The default value for this option if not configured. Equivalent to true . Declaration public static EnableGlobalOptions Default { get; } Property Value Type Description EnableGlobalOptions Operators | Improve this Doc View Source Implicit(Boolean to EnableGlobalOptions) Implicit casting operator from Boolean which simplifies setting this option with a simple true or false . Declaration public static implicit operator EnableGlobalOptions(bool value) Parameters Type Name Description Boolean value The boolean value to be stored in the returned instance. Returns Type Description EnableGlobalOptions"
  },
  "api/Rezolver.MSDIITargetContainerExtensions.html": {
    "href": "api/Rezolver.MSDIITargetContainerExtensions.html",
    "title": "Class MSDIITargetContainerExtensions | Rezolver IOC",
    "keywords": "Class MSDIITargetContainerExtensions Provides the Populate(ITargetContainer, IServiceCollection) extension method which allows easy importing of all registrations in an IServiceCollection from Microsoft.Extensions.DependencyInjection into a Rezolver ITargetContainer . Inheritance Object MSDIITargetContainerExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.Microsoft.Extensions.DependencyInjection.dll Syntax public static class MSDIITargetContainerExtensions Methods | Improve this Doc View Source Populate(ITargetContainer, IServiceCollection) Translates all registrations in services into registered targets in targets . Declaration public static void Populate(this ITargetContainer targets, IServiceCollection services) Parameters Type Name Description ITargetContainer targets The target container into which the registrations will be added Microsoft.Extensions.DependencyInjection.IServiceCollection services The service collection to be registered"
  },
  "api/Rezolver.MethodBinding.html": {
    "href": "api/Rezolver.MethodBinding.html",
    "title": "Class MethodBinding | Rezolver IOC",
    "keywords": "Class MethodBinding Represents a binding to a method whose arguments will be supplied by ITarget instances. Inheritance Object MethodBinding ConstructorBinding Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class MethodBinding Constructors | Improve this Doc View Source MethodBinding(MethodBase, ParameterBinding[]) Initializes a new instance of the MethodBinding class. Declaration public MethodBinding(MethodBase method, ParameterBinding[] boundArgs = null) Parameters Type Name Description MethodBase method The method. ParameterBinding [] boundArgs Optional. The bound arguments. Can be null or empty. Properties | Improve this Doc View Source BoundArguments Gets the argument bindings for the method call. Never null but can be empty. Declaration public ParameterBinding[] BoundArguments { get; } Property Value Type Description ParameterBinding [] The bound arguments. | Improve this Doc View Source Method Gets the method to be invoked. Declaration public MethodBase Method { get; } Property Value Type Description MethodBase The method."
  },
  "api/Rezolver.IContainerConfig-1.html": {
    "href": "api/Rezolver.IContainerConfig-1.html",
    "title": "Interface IContainerConfig<T> | Rezolver IOC",
    "keywords": "Interface IContainerConfig<T> Marker interface for an ITargetContainerConfig which is responsible for configuring a specific type of object/behaviour/service/option for IContainer instances. (Determined by T ). Inherited Members IContainerConfig.Configure(IContainer, IRootTargetContainer) Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface IContainerConfig<T> : IContainerConfig Type Parameters Name Description T Implementation-dependent. The type of option or service used by the container that is configured by this configuration object. Remarks As with ITargetContainerConfig<T> , this marker interface is included specifically to provide a convenient way to expression dependencies for container-related configuration objects which depend on, or which must be configured after, others of a specific type. The type parameter is completely free-form - it could be a specific service type, an option type, or something else entirely. Use of this interface is entirely optional; and you'll only implement it yourself (as with IContainerConfig ) if you are extending Rezolver."
  },
  "api/Rezolver.IContainer.html": {
    "href": "api/Rezolver.IContainer.html",
    "title": "Interface IContainer | Rezolver IOC",
    "keywords": "Interface IContainer The primary IOC container interface in the Rezolver framework. Inherited Members IScopeFactory.CreateScope() System.IServiceProvider.GetService(System.Type) Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface IContainer : IScopeFactory, IServiceProvider Remarks Instances of objects (typically known as 'services' in IOC-speak) are resolved via the Resolve(IResolveContext) or TryResolve(IResolveContext, out Object) methods. You can introspect the container to check in advance whether a given type can be resolved through the CanResolve(IResolveContext) method. Lifetime scoping (where IDisposable objects are created within a scope and destroyed when that scope is destroyed) can be achieved by obtaining a new scope through the object's implementatio of the CreateScope() method; although a container might also implement the IScopedContainer interface, in which case the container itself is a lifetime scope. Many of the functions which accept a IResolveContext also have alternatives (in the form of extension methods) in the ContainerResolveExtensions class. If you're looking for the 'traditional' IOC container methods (e.g. Resolve<TObject>(IContainer) , that's where you'll find them. Note that while the standard implementation of this interface supplied by the framework ( ContainerBase and its derivatives) all utilitise the ITargetContainer to actually locate registrations for types which are ultimately requested from the container; the interface doesn't actually mandate that pattern. Methods | Improve this Doc View Source CanResolve(IResolveContext) Returns true if a resolve operation for the given context will succeed. If you're going to be calling Resolve(IResolveContext) immediately afterwards, consider using the TryResolve(IResolveContext, out Object) method instead, which allows you to check and obtain the result at the same time. Declaration bool CanResolve(IResolveContext context) Parameters Type Name Description IResolveContext context The resolve context. Returns Type Description Boolean true if this instance can resolve a type for the specified context; otherwise, false . | Improve this Doc View Source GetCompiledTarget(IResolveContext) Fetches the ICompiledTarget for the given context, whose GetObject(IResolveContext) method would ultimately be called if the same context was passed to Resolve(IResolveContext) or TryResolve(IResolveContext, out Object) . Declaration ICompiledTarget GetCompiledTarget(IResolveContext context) Parameters Type Name Description IResolveContext context The context. Returns Type Description ICompiledTarget Remarks This is not typically a method that you're likely to use as the consumer of an IContainer . It's more typically used by implementations of ITargetCompiler or implementations of IContainer when communicating with other containers. As such, its use at an application level is limited. | Improve this Doc View Source Resolve(IResolveContext) Called to resolve a reference to an object for the given context (which provides the RequestedType of the object that is required, among other things). Declaration object Resolve(IResolveContext context) Parameters Type Name Description IResolveContext context The context. Returns Type Description Object The resolved object, if successful. Exceptions Type Condition InvalidOperationException If the requested type cannot be resolved. | Improve this Doc View Source TryResolve(IResolveContext, out Object) Merges the CanResolve(IResolveContext) and Resolve(IResolveContext) operations into one operation. Declaration bool TryResolve(IResolveContext context, out object result) Parameters Type Name Description IResolveContext context The context. Object result Receives the resultant resolved object if the operation succeeds. Returns Type Description Boolean true if the operation succeeded (the resolved object will be set into the result parameter); false otherwise. Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.ResolveMany(IContainer, Type) ContainerResolveExtensions.ResolveMany<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer)"
  },
  "api/Rezolver.ContainerScope.html": {
    "href": "api/Rezolver.ContainerScope.html",
    "title": "Class ContainerScope | Rezolver IOC",
    "keywords": "Class ContainerScope Standard implementation of the IContainerScope interface. Inheritance Object ContainerScope Implements IContainerScope IDisposable IServiceProvider IScopeFactory Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class ContainerScope : IContainerScope, IDisposable, IServiceProvider, IScopeFactory Constructors | Improve this Doc View Source ContainerScope(IContainer) Creates a new root scope tied to the given container Declaration public ContainerScope(IContainer container) Parameters Type Name Description IContainer container | Improve this Doc View Source ContainerScope(IContainerScope, IContainer) Creates a new container that is a child of another. The Container will be inherited from the parentScope by default, unless it's overriden by containerOverride . Declaration public ContainerScope(IContainerScope parentScope, IContainer containerOverride = null) Parameters Type Name Description IContainerScope parentScope Required - the parent scope IContainer containerOverride Optional - the container which should be used for resolve operations executed against this scope (note - all the resolve methods are declared as extension methods which mirror those present on IContainer . Properties | Improve this Doc View Source Container The container that this scope is tied to. All standard resolve operations should be made against this container. Declaration public IContainer Container { get; } Property Value Type Description IContainer The container. | Improve this Doc View Source Disposed Gets a value indicating whether this ContainerScope is disposed. Declaration public bool Disposed { get; } Property Value Type Description Boolean true if disposed; otherwise, false . | Improve this Doc View Source Parent If this scope has a parent scope, this is it. Declaration public IContainerScope Parent { get; } Property Value Type Description IContainerScope The parent. Methods | Improve this Doc View Source ChildScopeDisposed(IContainerScope) Called by child scopes when they are disposed to notify the parent that they will no longer need to be disposed of when the parent is disposed. Declaration public void ChildScopeDisposed(IContainerScope child) Parameters Type Name Description IContainerScope child The child. Remarks This is an infrastructure method and not something you would usually need to call. It's exposed for developers who are extending the container scoping functionality only. | Improve this Doc View Source CreateScope() Called to create a child scope from this scope. The implementation adds the new scope to a private collection so that it can dispose of the new child if it is not already disposed. Declaration public IContainerScope CreateScope() Returns Type Description IContainerScope | Improve this Doc View Source Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() | Improve this Doc View Source Dispose(Boolean) Releases unmanaged and - optionally - managed resources. Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description Boolean disposing true to release both managed and unmanaged resources; false to release only unmanaged resources. Explicit Interface Implementations | Improve this Doc View Source IContainerScope.Resolve(IResolveContext, Guid, Func<IResolveContext, Object>, ScopeBehaviour) Declaration object IContainerScope.Resolve(IResolveContext context, Guid targetId, Func<IResolveContext, object> factory, ScopeBehaviour behaviour) Parameters Type Name Description IResolveContext context Guid targetId System.Func < IResolveContext , Object > factory ScopeBehaviour behaviour Returns Type Description Object | Improve this Doc View Source IServiceProvider.GetService(Type) Declaration object IServiceProvider.GetService(Type serviceType) Parameters Type Name Description Type serviceType Returns Type Description Object Implements IContainerScope IDisposable IServiceProvider IScopeFactory Extension Methods ContainerScopeExtensions.GetRootScope(IContainerScope) ContainerScopeResolveExtensions.Resolve<TResult>(IContainerScope) ContainerScopeResolveExtensions.Resolve(IContainerScope, Type) ContainerScopeResolveExtensions.ResolveMany(IContainerScope, Type) ContainerScopeResolveExtensions.ResolveMany<TObject>(IContainerScope) See Also IContainerScope"
  },
  "api/Rezolver.ContainerResolveExtensions.html": {
    "href": "api/Rezolver.ContainerResolveExtensions.html",
    "title": "Class ContainerResolveExtensions | Rezolver IOC",
    "keywords": "Class ContainerResolveExtensions Extension methods for IContainer which provide shortcuts for the Resolve(IResolveContext) operation. Inheritance Object ContainerResolveExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class ContainerResolveExtensions Methods | Improve this Doc View Source CanResolve(IContainer, Type) Determines whether this instance can resolve the specified type - wrapper for CanResolve(IResolveContext) Declaration public static bool CanResolve(this IContainer container, Type type) Parameters Type Name Description IContainer container The container. Type type The type. Returns Type Description Boolean | Improve this Doc View Source CanResolve<TObject>(IContainer) Determines whether this instance can resolve the specified container - wrapper for CanResolve(IResolveContext) Declaration public static bool CanResolve<TObject>(this IContainer container) Parameters Type Name Description IContainer container The container. Returns Type Description Boolean Type Parameters Name Description TObject The type to be checked.. | Improve this Doc View Source Resolve(IContainer, Type) Resolves an object of the given type Declaration public static object Resolve(this IContainer container, Type type) Parameters Type Name Description IContainer container The container. Type type The type to be resolved. Returns Type Description Object An instance of the type . | Improve this Doc View Source Resolve<TObject>(IContainer) Resolves an object of type TObject Declaration public static TObject Resolve<TObject>(this IContainer container) Parameters Type Name Description IContainer container The container. Returns Type Description TObject An instance of TObject . Type Parameters Name Description TObject The type to be resolved. | Improve this Doc View Source ResolveMany(IContainer, Type) Shortcut for resolving an IEnumerable of objects of a given type. Declaration public static IEnumerable ResolveMany(this IContainer container, Type type) Parameters Type Name Description IContainer container The container. Type type The type of objects you want to retrieve Returns Type Description IEnumerable An enumerable (possibly empty) containing the objects which were resolved. | Improve this Doc View Source ResolveMany<TObject>(IContainer) Shortcut for resolving an IEnumerable of TObject Declaration public static IEnumerable<TObject> ResolveMany<TObject>(this IContainer container) Parameters Type Name Description IContainer container The container. Returns Type Description System.Collections.Generic.IEnumerable <TObject> An enumerable (possibly empty) containing the objects which were resolved. Type Parameters Name Description TObject The type of objects expected in the enumerable | Improve this Doc View Source TryResolve(IContainer, Type, out Object) The same as the Resolve method with the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve(this IContainer container, Type type, out object result) Parameters Type Name Description IContainer container The container. Type type The type to be resolved. Object result Received the value, or a reference to the instance, that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Remarks For more detail on the type parameter, see Resolve(IContainer, Type) overloads | Improve this Doc View Source TryResolve<TObject>(IContainer, out TObject) The same as the generic Resolve method the same core parameter types, except this will not throw exceptions if the resolve operation fails - instead it returns a boolean indicating success or failure, returning the created object (if successful) in the result parameter. Declaration public static bool TryResolve<TObject>(this IContainer container, out TObject result) Parameters Type Name Description IContainer container The container. TObject result Receives the object that is resolved if the operation is successful. Returns Type Description Boolean true if the object was resolved, false otherwise. Type Parameters Name Description TObject The type to be resolved."
  },
  "api/Rezolver.Configuration.InjectArrays.html": {
    "href": "api/Rezolver.Configuration.InjectArrays.html",
    "title": "Class InjectArrays | Rezolver IOC",
    "keywords": "Class InjectArrays Configuration (enabled by default in the DefaultConfig configuration collection) which enables the automatic injection of arrays by converting automatically injected enumerables into array instances via the ToArray<TSource>(IEnumerable<TSource>) method from Linq. Inheritance Object OptionDependentConfig < EnableArrayInjection > InjectArrays Implements ITargetContainerConfig IDependant Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Configuration Assembly : Rezolver.dll Syntax public class InjectArrays : OptionDependentConfig<EnableArrayInjection>, ITargetContainerConfig, IDependant Remarks Note that this configuration requires that the InjectEnumerables configuration is also applied. Properties | Improve this Doc View Source Dependencies Overrides the OptionDependentConfig<TOption> implementation to include a required dependency on the InjectEnumerables configuration. Declaration public override IEnumerable<DependencyMetadata> Dependencies { get; } Property Value Type Description System.Collections.Generic.IEnumerable < DependencyMetadata > Overrides Rezolver.Configuration.OptionDependentConfig<Rezolver.Options.EnableArrayInjection>.Dependencies | Improve this Doc View Source Instance The one and only instance of the InjectArrays configuration object Declaration public static InjectArrays Instance { get; } Property Value Type Description InjectArrays Methods | Improve this Doc View Source Configure(IRootTargetContainer) Implements the Configure(IRootTargetContainer) abstract method by configuring the passed targets so it can produce targets for any array type, regardless of whether a single object has been registered for the array's element type. After enabling, the ability to register specific targets for concrete array types will still be present. Declaration public override void Configure(IRootTargetContainer targets) Parameters Type Name Description IRootTargetContainer targets Overrides Rezolver.Configuration.OptionDependentConfig<Rezolver.Options.EnableArrayInjection>.Configure(Rezolver.IRootTargetContainer) Implements ITargetContainerConfig IDependant Extension Methods DependantExtensions.GetDependencies<T, TDependency>(T, IEnumerable<TDependency>) DependantExtensions.CreateTypeDependency<TDependency>(IDependant, Boolean) DependantExtensions.CreateObjectDependency<TDependency>(IDependant, TDependency, Boolean)"
  },
  "api/Rezolver.Compilation.Expressions.ProjectionTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ProjectionTargetBuilder.html",
    "title": "Class ProjectionTargetBuilder | Rezolver IOC",
    "keywords": "Class ProjectionTargetBuilder Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ProjectionTarget > ProjectionTargetBuilder Implements IExpressionBuilder < ProjectionTarget > IExpressionBuilder Inherited Members ExpressionBuilderBase<ProjectionTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ProjectionTarget>.IExpressionBuilder<ProjectionTarget>.Build(ProjectionTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ProjectionTarget>.CanBuild(ITarget) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class ProjectionTargetBuilder : ExpressionBuilderBase<ProjectionTarget>, IExpressionBuilder<ProjectionTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ProjectionTarget, IExpressionCompileContext, IExpressionCompiler) Declaration protected override Expression Build(ProjectionTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ProjectionTarget target IExpressionCompileContext context IExpressionCompiler compiler Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ProjectionTarget>.Build(Rezolver.Targets.ProjectionTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Implements IExpressionBuilder<TTarget> IExpressionBuilder"
  },
  "api/Rezolver.Compilation.Expressions.GenericConstructorTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.GenericConstructorTargetBuilder.html",
    "title": "Class GenericConstructorTargetBuilder | Rezolver IOC",
    "keywords": "Class GenericConstructorTargetBuilder An IExpressionBuilder specialised for building expressions for GenericConstructorTarget targets. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < GenericConstructorTarget > GenericConstructorTargetBuilder Implements IExpressionBuilder < GenericConstructorTarget > IExpressionBuilder Inherited Members ExpressionBuilderBase<GenericConstructorTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<GenericConstructorTarget>.IExpressionBuilder<GenericConstructorTarget>.Build(GenericConstructorTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<GenericConstructorTarget>.CanBuild(ITarget) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class GenericConstructorTargetBuilder : ExpressionBuilderBase<GenericConstructorTarget>, IExpressionBuilder<GenericConstructorTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(GenericConstructorTarget, IExpressionCompileContext, IExpressionCompiler) Obtains the bound target for the target passed (by calling Bind(ICompileContext) , and passes it to the compiler to have an expression built for it. Declaration protected override Expression Build(GenericConstructorTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description GenericConstructorTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.GenericConstructorTarget>.Build(Rezolver.Targets.GenericConstructorTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Implements IExpressionBuilder<TTarget> IExpressionBuilder"
  },
  "api/Rezolver.Compilation.Expressions.EnumerableTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.EnumerableTargetBuilder.html",
    "title": "Class EnumerableTargetBuilder | Rezolver IOC",
    "keywords": "Class EnumerableTargetBuilder An implementation of ExpressionBuilderBase<TTarget> specialised for the target type EnumerableTarget . Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < EnumerableTarget > EnumerableTargetBuilder Implements IExpressionBuilder < EnumerableTarget > IExpressionBuilder Inherited Members ExpressionBuilderBase<EnumerableTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<EnumerableTarget>.IExpressionBuilder<EnumerableTarget>.Build(EnumerableTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<EnumerableTarget>.CanBuild(ITarget) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class EnumerableTargetBuilder : ExpressionBuilderBase<EnumerableTarget>, IExpressionBuilder<EnumerableTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(EnumerableTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression which represents an instance of System.Collections.Generic.IEnumerable<T> whose elements are created by the Targets of the passed target . Declaration protected override Expression Build(EnumerableTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description EnumerableTarget target The target for which an expression is to be built. IExpressionCompileContext context The current compilation context. IExpressionCompiler compiler The compiler to use when building expressions for child targets. Returns Type Description Expression An expression which can be compiled into a delegate that, when executed, will create an instance of the enumerable represented by target Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.EnumerableTarget>.Build(Rezolver.Targets.EnumerableTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Remarks The compiler is capable of producing both lazy-loaded and eager-loaded enumerables, which can be controlled via target container options. Lazy vs Eager loading The option LazyEnumerables is read from the context for the ElementType of the target . If it is equivalent to true (the Default ), then a lazily-loaded enumerable is constructed which will create new instances of each object in the enumerable each time it is enumerated. If the option is instead equivalent to false , then all instances will be created in advance, and an already-materialised enumerable is constructed. Implements IExpressionBuilder<TTarget> IExpressionBuilder"
  },
  "api/Rezolver.Compilation.Expressions.CompiledTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.CompiledTargetBuilder.html",
    "title": "Class CompiledTargetBuilder | Rezolver IOC",
    "keywords": "Class CompiledTargetBuilder Special compiler for ITarget instances which are also ICompiledTarget instances. This build is only used when no 'better' builder is available for the target's type. So, the ObjectTargetBuilder will be used for ObjectTarget instead of this one, even though that class also implements ICompiledTarget . Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ICompiledTarget > CompiledTargetBuilder Implements IExpressionBuilder < ICompiledTarget > IExpressionBuilder Inherited Members ExpressionBuilderBase<ICompiledTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ICompiledTarget>.IExpressionBuilder<ICompiledTarget>.Build(ICompiledTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ICompiledTarget>.CanBuild(ITarget) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class CompiledTargetBuilder : ExpressionBuilderBase<ICompiledTarget>, IExpressionBuilder<ICompiledTarget>, IExpressionBuilder Remarks This builder creates an expression which explicitly calls the GetObject(IResolveContext) method of the target, with an IResolveContext which naturally flows from the one created for the wider resolve call to the container. Methods | Improve this Doc View Source Build(ICompiledTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression which calls the GetObject(IResolveContext) of the passed target Declaration protected override Expression Build(ICompiledTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ICompiledTarget target The target whose GetObject(IResolveContext) method is to be called by the expression that is returned from this builder. IExpressionCompileContext context The compilation context IExpressionCompiler compiler The compiler for which the expression is being built. Returns Type Description Expression The created expression. Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.ICompiledTarget>.Build(Rezolver.ICompiledTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Implements IExpressionBuilder<TTarget> IExpressionBuilder"
  },
  "api/Rezolver.CombinedContainerConfigExtensions.html": {
    "href": "api/Rezolver.CombinedContainerConfigExtensions.html",
    "title": "Class CombinedContainerConfigExtensions | Rezolver IOC",
    "keywords": "Class CombinedContainerConfigExtensions Contains extension methods for the CombinedContainerConfig class which simplify the process of adding and replacing IContainerConfig objects which set options and register well-known container services. Inheritance Object CombinedContainerConfigExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class CombinedContainerConfigExtensions Methods | Improve this Doc View Source UseCompiler(CombinedContainerConfig, IContainerConfig<ITargetCompiler>) Replaces any existing IContainerConfig<T> with the passed configuration - thus ensuring that any IContainer objects which are initialised with the config collection will use whichever compiler that is configured when the configuration's Configure(IContainer, IRootTargetContainer) method is called. Declaration public static CombinedContainerConfig UseCompiler(this CombinedContainerConfig collection, IContainerConfig<ITargetCompiler> configuration) Parameters Type Name Description CombinedContainerConfig collection IContainerConfig < ITargetCompiler > configuration Returns Type Description CombinedContainerConfig | Improve this Doc View Source UseExpressionCompiler(CombinedContainerConfig) Replaces any existing IContainerConfig<T> in the collection with the Instance from ExpressionCompilation so that any container to which the config collection will be applied will use the ExpressionCompiler . Declaration public static CombinedContainerConfig UseExpressionCompiler(this CombinedContainerConfig combined) Parameters Type Name Description CombinedContainerConfig combined The collection to which the behaviour is to be added. Returns Type Description CombinedContainerConfig The collection on which the operation is called, to allow chaining of further calls."
  },
  "api/Rezolver.ContainerScopeResolveExtensions.html": {
    "href": "api/Rezolver.ContainerScopeResolveExtensions.html",
    "title": "Class ContainerScopeResolveExtensions | Rezolver IOC",
    "keywords": "Class ContainerScopeResolveExtensions Extensions for IContainerScope so that instances of that interface present a similar set of functionality to IContainer . Inheritance Object ContainerScopeResolveExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class ContainerScopeResolveExtensions Methods | Improve this Doc View Source Resolve(IContainerScope, Type) Non-generic variant of the Resolve<TResult>(IContainerScope) extension method. Declaration public static object Resolve(this IContainerScope scope, Type requestedType) Parameters Type Name Description IContainerScope scope The scope. Type requestedType Type of object required. Returns Type Description Object Exceptions Type Condition ArgumentNullException | Improve this Doc View Source Resolve<TResult>(IContainerScope) Resolves an object through the scope's Container Declaration public static TResult Resolve<TResult>(this IContainerScope scope) Parameters Type Name Description IContainerScope scope The active scope within which the call is to be made. Returns Type Description TResult Type Parameters Name Description TResult The type of object required. Remarks Resolving an object via a scope does not guarantee that it will be tracked. Ultimately, it's up to the behaviour of the individual underlying targets to determine whether they should interact with the scope. Indeed, all this extension method does is to forward the method call on to the Container of the given scope, ensuring that the scope is set on the IResolveContext that is passed to its Resolve(IResolveContext) method. | Improve this Doc View Source ResolveMany(IContainerScope, Type) Equivalent of ResolveMany(IContainer, Type) but for scopes. Declaration public static IEnumerable ResolveMany(this IContainerScope scope, Type type) Parameters Type Name Description IContainerScope scope The scope from which objects are to be resolved. Type type The type of object desired in the enumerable. Returns Type Description IEnumerable An enumerable (possibly empty) containing all the objects that could be resolve of type type | Improve this Doc View Source ResolveMany<TObject>(IContainerScope) Equivalent of ResolveMany<TObject>(IContainer) but for scopes. Declaration public static IEnumerable<TObject> ResolveMany<TObject>(this IContainerScope scope) Parameters Type Name Description IContainerScope scope The scope from which objects are to be resolved. Returns Type Description System.Collections.Generic.IEnumerable <TObject> An enumerable (possibly empty) containing all the objects that could be resolved of type TObject Type Parameters Name Description TObject The type of object desired in the enumerable."
  },
  "api/Rezolver.Configuration.OptionDependentConfig-2.html": {
    "href": "api/Rezolver.Configuration.OptionDependentConfig-2.html",
    "title": "Class OptionDependentConfig<T, TOption> | Rezolver IOC",
    "keywords": "Class OptionDependentConfig<T, TOption> Extension to the OptionDependentConfig<TOption> generic which can be used by config types which also want to target a specific type for configuration ( T ) Inheritance Object OptionDependentConfig <TOption> OptionDependentConfig<T, TOption> Implements IDependant ITargetContainerConfig <T> ITargetContainerConfig Inherited Members OptionDependentConfig<TOption>.Dependencies OptionDependentConfig<TOption>.Configure(IRootTargetContainer) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Configuration Assembly : Rezolver.dll Syntax public abstract class OptionDependentConfig<T, TOption> : OptionDependentConfig<TOption>, IDependant, ITargetContainerConfig<T>, ITargetContainerConfig where TOption : class Type Parameters Name Description T The type of service/behaviour/option being configured TOption The type of option upon which this config object depends. The default dependency created and returned by this class' implementation of Dependencies will actually be dependent upon the config type ITargetContainerConfig<T> , which is the standard contract expected by a configuration object that configures a particular option. Constructors | Improve this Doc View Source OptionDependentConfig(Boolean) Constructs a new instance of the type OptionDependentConfig<T, TOption> which starts off with a required or optional dependency (controlled by the argument passed optionConfigurationRequired parameter) Declaration public OptionDependentConfig(bool optionConfigurationRequired) Parameters Type Name Description Boolean optionConfigurationRequired Implements IDependant ITargetContainerConfig<T> ITargetContainerConfig Extension Methods DependantExtensions.GetDependencies<T, TDependency>(T, IEnumerable<TDependency>) DependantExtensions.CreateTypeDependency<TDependency>(IDependant, Boolean) DependantExtensions.CreateObjectDependency<TDependency>(IDependant, TDependency, Boolean)"
  },
  "api/Rezolver.Compilation.Expressions.SingletonTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.SingletonTargetBuilder.html",
    "title": "Class SingletonTargetBuilder | Rezolver IOC",
    "keywords": "Class SingletonTargetBuilder An IExpressionBuilder specialised for the building the expression for a SingletonTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < SingletonTarget > SingletonTargetBuilder Implements IExpressionBuilder < SingletonTarget > IExpressionBuilder Inherited Members ExpressionBuilderBase<SingletonTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<SingletonTarget>.IExpressionBuilder<SingletonTarget>.Build(SingletonTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<SingletonTarget>.CanBuild(ITarget) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class SingletonTargetBuilder : ExpressionBuilderBase<SingletonTarget>, IExpressionBuilder<SingletonTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(SingletonTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(SingletonTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description SingletonTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.SingletonTarget>.Build(Rezolver.Targets.SingletonTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Implements IExpressionBuilder<TTarget> IExpressionBuilder"
  },
  "api/Rezolver.Compilation.Expressions.ListTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ListTargetBuilder.html",
    "title": "Class ListTargetBuilder | Rezolver IOC",
    "keywords": "Class ListTargetBuilder An IExpressionBuilder specialised for building expressions for the ListTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ListTarget > ListTargetBuilder Implements IExpressionBuilder < ListTarget > IExpressionBuilder Inherited Members ExpressionBuilderBase<ListTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ListTarget>.IExpressionBuilder<ListTarget>.Build(ListTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ListTarget>.CanBuild(ITarget) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class ListTargetBuilder : ExpressionBuilderBase<ListTarget>, IExpressionBuilder<ListTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ListTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression which either represents creating an array or a list of objects using an enumerable of targets from the target 's Items . The target's AsArray flag is used to determine which expression to build. Declaration protected override Expression Build(ListTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ListTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ListTarget>.Build(Rezolver.Targets.ListTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Implements IExpressionBuilder<TTarget> IExpressionBuilder"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionCompiler.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionCompiler.html",
    "title": "Class ExpressionCompiler | Rezolver IOC",
    "keywords": "Class ExpressionCompiler Implementation of the ITargetCompiler interface which produces ICompiledTarget objects by building and compiling expression trees from the ITarget objects which are registered. Inheritance Object ExpressionCompiler Implements IExpressionCompiler ITargetCompiler Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class ExpressionCompiler : IExpressionCompiler, ITargetCompiler Remarks Use of this compiler by a container is enabled by applying the ExpressionCompilation Instance to the container either on construction (for example, via the Container(IRootTargetContainer, IContainerConfig) constructor) or via the DefaultConfig - which currently configures this compiler by default anyway. This class works by directly resolving IExpressionBuilder instances which can build an expression for a given ITarget from the IExpressionCompileContext . Typically, this is done by searching for an IExpressionBuilder<TTarget> where 'TTarget' is equal to the runtime type of the target - e.g. ConstructorTarget . If one cannot be found, it will then search for an IExpressionBuilder whose CanBuild(ITarget) function returns true for the given target. With a correctly configured target container this should resolve to an instance of the ConstructorTargetBuilder class, which implements IExpressionBuilder<ConstructorTarget> . As such, the compiler can be extended to support extra target types and its existing expression builders can be replaced for customised behaviour because they are all resolved from the ITargetContainer underpinning a particular CompileContext . There is a caveat for this, however: you cannot use the traditional targets ( ConstructorTarget etc) to extend the compiler because they need to be compiled in order to work - which would cause an infinite recursion. Therefore, the targets which are registered as expression builders must directly implement either the IExpressionBuilder<TTarget> or IExpressionBuilder interfaces; or implement the ICompiledTarget interface and produce an instance of those interfaces when GetObject(IResolveContext) is called on them. Because of this requirement, the most common way to register an expression builder is to register an instance inside an ObjectTarget against the correct type, because that class does implement ICompiledTarget in addition to ITarget . Using this pattern, it's important that an expression builder is completely threadsafe and recursion safe (since one target's compilation might depend on the compilation of another of the same type). Properties | Improve this Doc View Source Default Gets the default expression compiler. It's this that the ExpressionCompilation registers. Declaration public static ExpressionCompiler Default { get; } Property Value Type Description ExpressionCompiler Methods | Improve this Doc View Source Build(ITarget, IExpressionCompileContext) Called to build an expression for the specified target for the given IExpressionCompileContext - implementation of the Build(ITarget, IExpressionCompileContext) method. Declaration public Expression Build(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target for which an expression is to be built IExpressionCompileContext context The compilation context. Returns Type Description Expression Remarks This implementation attempts to resolve an IExpressionBuilder<TTarget> (with TTarget\" equal to the runtime type of the target ) or IExpressionBuilder whose CanBuild(ITarget) function returns true for the given target and context. If that lookup fails, then an ArgumentException is raised. If the lookup succeeds, then the builder's Build(ITarget, IExpressionCompileContext, IExpressionCompiler) function is called, and the expression it produces is returned. Exceptions Type Condition ArgumentException If the compiler is unable to resolve an IExpressionBuilder from the context for the target | Improve this Doc View Source BuildCompiledTargetForLambda(ITarget, Expression<Func<IResolveContext, Object>>) Creates an ICompiledTarget from the finalised lambda expression which was previously built for a target. Declaration protected virtual ICompiledTarget BuildCompiledTargetForLambda(ITarget target, Expression<Func<IResolveContext, object>> lambda) Parameters Type Name Description ITarget target The ITarget from which the passed lambda was built System.Linq.Expressions.Expression < System.Func < IResolveContext , Object >> lambda The lambda expression representing the code to be executed in order to get the underlying object which will be resolved. Typically, this is fed directly from the BuildResolveLambda(Expression, IExpressionCompileContext) implementation. Returns Type Description ICompiledTarget | Improve this Doc View Source BuildResolveLambda(Expression, IExpressionCompileContext) Takes the unoptimised expression built for a target and optimises it and turns it into a lambda expression ready to be compiled into an ICompiledTarget . Declaration public virtual Expression<Func<IResolveContext, object>> BuildResolveLambda(Expression expression, IExpressionCompileContext context) Parameters Type Name Description Expression expression The expression. IExpressionCompileContext context The context. Returns Type Description System.Linq.Expressions.Expression < System.Func < IResolveContext , Object >> | Improve this Doc View Source CompileTarget(ITarget, ICompileContext) Create the ICompiledTarget for the given target using the context to inform the type of object that is to be built, and for compile-time dependency resolution. Declaration public ICompiledTarget CompileTarget(ITarget target, ICompileContext context) Parameters Type Name Description ITarget target Required. The target to be compiled. ICompileContext context Required. The current compilation context. Returns Type Description ICompiledTarget Exceptions Type Condition ArgumentException context must be an instance of IExpressionCompileContext | Improve this Doc View Source CreateContext(IResolveContext, ITargetContainer) Implementation of CreateContext(IResolveContext, ITargetContainer) Declaration public ICompileContext CreateContext(IResolveContext resolveContext, ITargetContainer targets) Parameters Type Name Description IResolveContext resolveContext ITargetContainer targets Returns Type Description ICompileContext | Improve this Doc View Source ResolveBuilder(ITarget, IExpressionCompileContext) Resolves an expression builder that can build the given target for the given compile context. Or Returns null if no builder can be found. Declaration public virtual IExpressionBuilder ResolveBuilder(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context The context. Returns Type Description IExpressionBuilder Remarks The function builds a list of all the types in the hierarchy represented by the type of the target and, for each of those types which are compatible with ITarget , it looks for an IExpressionBuilder<TTarget> which is specialised for that type. If no compatible builder is found, then it attempts to find a general purpose IExpressionBuilder which can build the type. Implements IExpressionCompiler ITargetCompiler Extension Methods TargetCompilerExtensions.CompileTarget(ITargetCompiler, ITarget, IResolveContext, ITargetContainer) ExpressionCompilerBuildExtensions.BuildResolveLambda(IExpressionCompiler, ITarget, IExpressionCompileContext) See Also IExpressionCompiler ITargetCompiler"
  },
  "api/Rezolver.CombinedTargetContainerConfigExtensions.html": {
    "href": "api/Rezolver.CombinedTargetContainerConfigExtensions.html",
    "title": "Class CombinedTargetContainerConfigExtensions | Rezolver IOC",
    "keywords": "Class CombinedTargetContainerConfigExtensions Extensions for pre-configuring options in an ITargetContainer via a CombinedContainerConfig , such as the one exposed by DefaultConfig . Inheritance Object CombinedTargetContainerConfigExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class CombinedTargetContainerConfigExtensions Methods | Improve this Doc View Source ConfigureOption<TOption>(CombinedTargetContainerConfig, TOption) Adds a Configure<TOption> callback to the configuration, which will set the passed optionValue option in the ITargetContainer to which the config is later applied. Declaration public static CombinedTargetContainerConfig ConfigureOption<TOption>(this CombinedTargetContainerConfig config, TOption optionValue)where TOption : class Parameters Type Name Description CombinedTargetContainerConfig config The combined config to which the configuration callback will be added. TOption optionValue The value of the option that is to be set when config is applied to an ITargetContainer via its implementation of Configure(IRootTargetContainer) Returns Type Description CombinedTargetContainerConfig The config object, for method chaining. Type Parameters Name Description TOption The type of option to be set | Improve this Doc View Source ConfigureOption<TOption>(CombinedTargetContainerConfig, Func<ITargetContainer, TOption>) Adds a Configure<TOption> callback to the configuration, which will set the option value returned by the optionValueFactory in the ITargetContainer to which the config is applied. Declaration public static CombinedTargetContainerConfig ConfigureOption<TOption>(this CombinedTargetContainerConfig config, Func<ITargetContainer, TOption> optionValueFactory)where TOption : class Parameters Type Name Description CombinedTargetContainerConfig config The combined config to which the configuration callback will be added. System.Func < ITargetContainer , TOption> optionValueFactory A callback which returns value of the option that is to be set when config is applied to an ITargetContainer via its implementation of Configure(IRootTargetContainer) . The callback will be passed the target container being configured at that time. Returns Type Description CombinedTargetContainerConfig The config object, for method chaining. Type Parameters Name Description TOption The type of option to be set | Improve this Doc View Source ConfigureOption<TOption>(CombinedTargetContainerConfig, Type, TOption) Adds a Configure<TOption> callback to the configuration, which will set the passed optionValue option for the service type serviceType in the ITargetContainer to which the config is later applied. Declaration public static CombinedTargetContainerConfig ConfigureOption<TOption>(this CombinedTargetContainerConfig config, Type serviceType, TOption optionValue)where TOption : class Parameters Type Name Description CombinedTargetContainerConfig config The combined config to which the configuration callback will be added. Type serviceType The service type for which the option is to be set. Use of this is option-dependent - i.e. some options are read in a service-specific way and some aren't. Passing null is equivalent to calling ConfigureOption<TOption>(CombinedTargetContainerConfig, TOption) . TOption optionValue The value of the option that is to be set when config is applied to an ITargetContainer via its implementation of Configure(IRootTargetContainer) Returns Type Description CombinedTargetContainerConfig The config object, for method chaining. Type Parameters Name Description TOption The type of option to be set. | Improve this Doc View Source ConfigureOption<TOption>(CombinedTargetContainerConfig, Type, Func<ITargetContainer, Type, TOption>) Adds a Configure<TOption> callback to the configuration, which will set the option value returned by the optionValueFactory for the service type serviceType in the ITargetContainer to which the config is applied. Declaration public static CombinedTargetContainerConfig ConfigureOption<TOption>(this CombinedTargetContainerConfig config, Type serviceType, Func<ITargetContainer, Type, TOption> optionValueFactory)where TOption : class Parameters Type Name Description CombinedTargetContainerConfig config The combined config to which the configuration callback will be added. Type serviceType The service type for which the option is to be set. Use of this is option-dependent - i.e. some options are read in a service-specific way and some aren't. Passing null is equivalent to calling ConfigureOption<TOption>(CombinedTargetContainerConfig, Type, Func<ITargetContainer, Type, TOption>) . System.Func < ITargetContainer , Type , TOption> optionValueFactory A callback which returns value of the option that is to be set when config is applied to an ITargetContainer via its implementation of Configure(IRootTargetContainer) . The callback will be passed the target container being configured at that time, and a Type equal to serviceType . Returns Type Description CombinedTargetContainerConfig The config object, for method chaining. Type Parameters Name Description TOption The type of option to be set. | Improve this Doc View Source ConfigureOption<TOption, TService>(CombinedTargetContainerConfig, TOption) Adds a Configure<TOption> callback to the configuration, which will set the passed optionValue option for the service type TService in the ITargetContainer to which the config is later applied. Declaration public static CombinedTargetContainerConfig ConfigureOption<TOption, TService>(this CombinedTargetContainerConfig config, TOption optionValue)where TOption : class Parameters Type Name Description CombinedTargetContainerConfig config The combined config to which the configuration callback will be added. TOption optionValue The value of the option that is to be set when config is applied to an ITargetContainer via its implementation of Configure(IRootTargetContainer) Returns Type Description CombinedTargetContainerConfig The config object, for method chaining. Type Parameters Name Description TOption The type of option to be set. TService The service type for which the option is to be set. Use of this is option-dependent - i.e. some options are read in a service-specific way and some aren't. | Improve this Doc View Source ConfigureOption<TOption, TService>(CombinedTargetContainerConfig, Func<ITargetContainer, Type, TOption>) Adds a Configure<TOption> callback to the configuration, which will set the option value returned by the optionValueFactory for the service type TService in the ITargetContainer to which the config is applied. Declaration public static CombinedTargetContainerConfig ConfigureOption<TOption, TService>(this CombinedTargetContainerConfig config, Func<ITargetContainer, Type, TOption> optionValueFactory)where TOption : class Parameters Type Name Description CombinedTargetContainerConfig config The combined config to which the configuration callback will be added. System.Func < ITargetContainer , Type , TOption> optionValueFactory A callback which returns value of the option that is to be set when config is applied to an ITargetContainer via its implementation of Configure(IRootTargetContainer) . The callback will be passed the target container being configured at that time, and a Type equal to TService . Returns Type Description CombinedTargetContainerConfig The config object, for method chaining. Type Parameters Name Description TOption The type of option to be set. TService The service type for which the option is to be set. Use of this is option-dependent - i.e. some options are read in a service-specific way and some aren't."
  },
  "api/Rezolver.Configuration.InjectResolveContext.html": {
    "href": "api/Rezolver.Configuration.InjectResolveContext.html",
    "title": "Class InjectResolveContext | Rezolver IOC",
    "keywords": "Class InjectResolveContext An ITargetContainerConfig that enables automatic resolving of the IResolveContext created for a Resolve(IResolveContext) operation. Inheritance Object InjectResolveContext Implements ITargetContainerConfig Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Configuration Assembly : Rezolver.dll Syntax public sealed class InjectResolveContext : ITargetContainerConfig Remarks The implementation registers a special internal target type which implements ICompiledTarget simply by returning the context passed to its GetObject(IResolveContext) method Properties | Improve this Doc View Source Instance The one and only instance of InjectResolveContext Declaration public static InjectResolveContext Instance { get; } Property Value Type Description InjectResolveContext Methods | Improve this Doc View Source Configure(IRootTargetContainer) Attaches this behaviour to the target container, adding a registration to the targets for the type IResolveContext . Note - if the targets already has a registration for IResolveContext , then the behaviour DOES NOT overwrite it. Declaration public void Configure(IRootTargetContainer targets) Parameters Type Name Description IRootTargetContainer targets Implements ITargetContainerConfig"
  },
  "api/Rezolver.Compilation.UnresolvedTypeCompiledTarget.html": {
    "href": "api/Rezolver.Compilation.UnresolvedTypeCompiledTarget.html",
    "title": "Class UnresolvedTypeCompiledTarget | Rezolver IOC",
    "keywords": "Class UnresolvedTypeCompiledTarget An ICompiledTarget that can be used when a type could not be resolved. Implementations of both GetObject(IResolveContext) and SourceTarget will throw an exception if called/read. Inheritance Object UnresolvedTypeCompiledTarget Implements ICompiledTarget Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation Assembly : Rezolver.dll Syntax public class UnresolvedTypeCompiledTarget : ICompiledTarget Remarks Use of this class is encouraged when an IContainer cannot resolve a type. Instead of checking the compiled target for a null, an instance of this can be returned in its place, but its only when the GetObject(IResolveContext) method is executed that an exception occurs. This is particularly useful when using classes such as OverridingContainer , which allow dependencies that do not exist in the base container to be fulfilled by the overriding container instead: by delaying the throwing of exceptions until the resolve operation occurs, we are able to provide that override capability. Constructors | Improve this Doc View Source UnresolvedTypeCompiledTarget(Type) Creates a new instance of the UnresolvedTypeCompiledTarget class Declaration public UnresolvedTypeCompiledTarget(Type requestedType) Parameters Type Name Description Type requestedType Required. The type that was requested, and which subsequently could not be resolved. Properties | Improve this Doc View Source SourceTarget Implementation of SourceTarget Declaration public ITarget SourceTarget { get; } Property Value Type Description ITarget Remarks Always throws an InvalidOperationException Methods | Improve this Doc View Source GetObject(IResolveContext) Implementation of GetObject(IResolveContext) Declaration public object GetObject(IResolveContext context) Parameters Type Name Description IResolveContext context The current IResolveContext Returns Type Description Object Always throws an InvalidOperationException Implements ICompiledTarget Extension Methods UnresolvedICompiledTargetExtensions.IsUnresolved(ICompiledTarget)"
  },
  "api/Rezolver.Compilation.Expressions.SharedExpressionKey.html": {
    "href": "api/Rezolver.Compilation.Expressions.SharedExpressionKey.html",
    "title": "Class SharedExpressionKey | Rezolver IOC",
    "keywords": "Class SharedExpressionKey Key for a shared expression used during expression tree generation. As a consumer of this library, you are unlikely ever to need to use it. Inheritance Object SharedExpressionKey Implements System.IEquatable < SharedExpressionKey > Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class SharedExpressionKey : IEquatable<SharedExpressionKey> Constructors | Improve this Doc View Source SharedExpressionKey(Type, String, Type) Initializes a new instance of the SharedExpressionKey class. Declaration public SharedExpressionKey(Type targetType, string name, Type requestingType = null) Parameters Type Name Description Type targetType Required. Eventual runtime type of the object produced by the expression that will be cached using this key. String name Required. The name used for storing and retrieving expressions cached with this key. Type requestingType The type (e.g. the runtime type of an ITarget implementation) whose compilation requires the cached expression. Properties | Improve this Doc View Source Name Gets the name used for expressions that are cached using this key. Declaration public string Name { get; } Property Value Type Description String The name. | Improve this Doc View Source RequestingType Gets the type that registered the shared expression Declaration public Type RequestingType { get; } Property Value Type Description Type | Improve this Doc View Source TargetType The intended type of the expression that is cached by this key. Declaration public Type TargetType { get; } Property Value Type Description Type Methods | Improve this Doc View Source Equals(SharedExpressionKey) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(SharedExpressionKey other) Parameters Type Name Description SharedExpressionKey other An object to compare with this object. Returns Type Description Boolean true if the current object is equal to the other parameter; otherwise, false. | Improve this Doc View Source Equals(Object) Determines whether the specified Object is equal to this instance. Declaration public override bool Equals(object obj) Parameters Type Name Description Object obj The object to compare with the current object. Returns Type Description Boolean true if the specified Object is equal to this instance; otherwise, false . Overrides System.Object.Equals(System.Object) | Improve this Doc View Source GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description Int32 A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. Overrides System.Object.GetHashCode() Implements System.IEquatable<T>"
  },
  "api/Rezolver.Compilation.Expressions.IExpressionCompiler.html": {
    "href": "api/Rezolver.Compilation.Expressions.IExpressionCompiler.html",
    "title": "Interface IExpressionCompiler | Rezolver IOC",
    "keywords": "Interface IExpressionCompiler Interface for an object which is responsible for coordinating the production of expressions for targets during the compilation phase. Objects implementing this are expected to be implementations of ITargetCompiler ; this library provides the one implementation, too: ExpressionCompiler . Inherited Members ITargetCompiler.CompileTarget(ITarget, ICompileContext) ITargetCompiler.CreateContext(IResolveContext, ITargetContainer) Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public interface IExpressionCompiler : ITargetCompiler Remarks All expressions are built to be called from the GetObject(IResolveContext) function which, in turn, is typically called in response to a container's Resolve(IResolveContext) function being called. Note that the Build(ITarget, IExpressionCompileContext) method declared here is effectively an analogue to the Build(ITarget, IExpressionCompileContext, IExpressionCompiler) . Indeed, the default implementation resolves IExpressionBuilder instances to delegate the building of expressions. Methods | Improve this Doc View Source Build(ITarget, IExpressionCompileContext) Gets an unoptimised expression containing the logic required to create or fetch an instance of the target 's DeclaredType when invoked for a particular IResolveContext . Use this method if you want the raw expression for a target (possibly when integrating it into your own expressions during custom compilation). Declaration Expression Build(ITarget target, IExpressionCompileContext context) Parameters Type Name Description ITarget target The target. IExpressionCompileContext context Contains the supporting expressions (shared locals, shared expressions, ResolveContext expression etc) that have been used in the generation of the expression. Returns Type Description Expression Remarks If you want to build the optimised code for the passed target, you should use the BuildResolveLambda(IExpressionCompiler, ITarget, IExpressionCompileContext) extension method, which uses this method and then passes the result to the BuildResolveLambda(Expression, IExpressionCompileContext) function also defined on this interface. | Improve this Doc View Source BuildResolveLambda(Expression, IExpressionCompileContext) This function optimises and prepares an expression that's (most likely) previously been produced by the Build(ITarget, IExpressionCompileContext) function into a lambda expression which can be compiled into a delegate and executed; or quoted inside another expression as a callback. The ResolveContextParameterExpression of the context will be used to define the single parameter for the lambda that is created. Declaration Expression<Func<IResolveContext, object>> BuildResolveLambda(Expression targetExpression, IExpressionCompileContext context) Parameters Type Name Description Expression targetExpression Expression to be optimised and used as the body of the lambda. Any expression produced by the Build(ITarget, IExpressionCompileContext) method must be compatible with this. IExpressionCompileContext context Contains the supporting expressions (shared locals, shared expressions, ResolveContext expression etc) that have been used in the generation of the expression. Returns Type Description System.Linq.Expressions.Expression < System.Func < IResolveContext , Object >> A lambda expression which, when compiled and executed, will produce an object consistent with the ITarget from which the code was produced. Extension Methods TargetCompilerExtensions.CompileTarget(ITargetCompiler, ITarget, IResolveContext, ITargetContainer) ExpressionCompilerBuildExtensions.BuildResolveLambda(IExpressionCompiler, ITarget, IExpressionCompileContext)"
  },
  "api/Rezolver.Compilation.Expressions.DecoratorTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.DecoratorTargetBuilder.html",
    "title": "Class DecoratorTargetBuilder | Rezolver IOC",
    "keywords": "Class DecoratorTargetBuilder Specialised builder for DecoratorTarget targets. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < DecoratorTarget > DecoratorTargetBuilder Implements IExpressionBuilder < DecoratorTarget > IExpressionBuilder Inherited Members ExpressionBuilderBase<DecoratorTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DecoratorTarget>.IExpressionBuilder<DecoratorTarget>.Build(DecoratorTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DecoratorTarget>.CanBuild(ITarget) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class DecoratorTargetBuilder : ExpressionBuilderBase<DecoratorTarget>, IExpressionBuilder<DecoratorTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(DecoratorTarget, IExpressionCompileContext, IExpressionCompiler) Creates a new compilation context, registers the target's DecoratedTarget into it as the correct target for the DecoratedType , and then builds the expression for the InnerTarget (which is typically a constructor target). Declaration protected override Expression Build(DecoratorTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description DecoratorTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.DecoratorTarget>.Build(Rezolver.Targets.DecoratorTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Implements IExpressionBuilder<TTarget> IExpressionBuilder"
  },
  "api/Rezolver.Compilation.CompileStackEntry.html": {
    "href": "api/Rezolver.Compilation.CompileStackEntry.html",
    "title": "Class CompileStackEntry | Rezolver IOC",
    "keywords": "Class CompileStackEntry Represents an entry in the compilation stack of a ICompileContext , recording both a target that is being compiled, and the type for which it is being compiled. Inheritance Object CompileStackEntry Implements System.IEquatable < CompileStackEntry > Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation Assembly : Rezolver.dll Syntax public class CompileStackEntry : IEquatable<CompileStackEntry> Constructors | Improve this Doc View Source CompileStackEntry(ITarget, Type) Initializes a new instance of the CompileStackEntry class. Declaration public CompileStackEntry(ITarget target, Type targetType) Parameters Type Name Description ITarget target The target being compiled. Type targetType Type for which the target is being compiled. Properties | Improve this Doc View Source Target Gets the target being compiled. Declaration public ITarget Target { get; } Property Value Type Description ITarget | Improve this Doc View Source TargetType Gets the type for which the target is being compiled. Declaration public Type TargetType { get; } Property Value Type Description Type Methods | Improve this Doc View Source Equals(CompileStackEntry) Indicates whether the current object is equal to another object of the same type. Declaration public bool Equals(CompileStackEntry other) Parameters Type Name Description CompileStackEntry other An object to compare with this object. Returns Type Description Boolean Remarks Equality is defined as both the Target and the TargetType being equal between this instance and the other instance. | Improve this Doc View Source Equals(Object) Determines whether the specified Object is equal to this instance. Declaration public override bool Equals(object obj) Parameters Type Name Description Object obj The object to compare with the current object. Returns Type Description Boolean Overrides System.Object.Equals(System.Object) | Improve this Doc View Source GetHashCode() Returns a hash code for this instance. Declaration public override int GetHashCode() Returns Type Description Int32 Overrides System.Object.GetHashCode() Implements System.IEquatable<T>"
  },
  "api/Rezolver.CombinedContainerConfig.html": {
    "href": "api/Rezolver.CombinedContainerConfig.html",
    "title": "Class CombinedContainerConfig | Rezolver IOC",
    "keywords": "Class CombinedContainerConfig An IContainerConfig which contains zero or or more other IContainerConfig objects. Behaviours can depend on other behaviours, and this collection ensures that they are applied in the correct order. Inheritance Object DependantCollection < IContainerConfig > CombinedContainerConfig Implements System.Collections.Generic.IList < IContainerConfig > System.Collections.Generic.ICollection < IContainerConfig > System.Collections.Generic.IEnumerable < IContainerConfig > IEnumerable IContainerConfig Inherited Members DependantCollection<IContainerConfig>.Ordered DependantCollection<IContainerConfig>.Clone<TDerived>() DependantCollection<IContainerConfig>.Replace(IContainerConfig, IContainerConfig) DependantCollection<IContainerConfig>.ReplaceOrAdd(IContainerConfig, IContainerConfig) DependantCollection<IContainerConfig>.ReplaceAnyOrAdd<TOriginal>(IContainerConfig) DependantCollection<IContainerConfig>.ReplaceAnyOrAdd<TOriginal>(Func<IEnumerable<IContainerConfig>, IContainerConfig>) DependantCollection<IContainerConfig>.Item[Int32] DependantCollection<IContainerConfig>.Count DependantCollection<IContainerConfig>.IsReadOnly DependantCollection<IContainerConfig>.Clear() DependantCollection<IContainerConfig>.Contains(IContainerConfig) DependantCollection<IContainerConfig>.CopyTo(IContainerConfig[], Int32) DependantCollection<IContainerConfig>.GetEnumerator() DependantCollection<IContainerConfig>.IndexOf(IContainerConfig) DependantCollection<IContainerConfig>.Insert(Int32, IContainerConfig) DependantCollection<IContainerConfig>.Remove(IContainerConfig) DependantCollection<IContainerConfig>.RemoveAt(Int32) DependantCollection<IContainerConfig>.Add(IContainerConfig) DependantCollection<IContainerConfig>.AddAll(IEnumerable<IContainerConfig>) DependantCollection<IContainerConfig>.AddAll(IContainerConfig[]) DependantCollection<IContainerConfig>.RemoveAll(IEnumerable<IContainerConfig>) DependantCollection<IContainerConfig>.IEnumerable.GetEnumerator() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class CombinedContainerConfig : DependantCollection<IContainerConfig>, IList<IContainerConfig>, ICollection<IContainerConfig>, IEnumerable<IContainerConfig>, IEnumerable, IContainerConfig Constructors | Improve this Doc View Source CombinedContainerConfig() Constructs a new instance of the CombinedContainerConfig type Declaration public CombinedContainerConfig() | Improve this Doc View Source CombinedContainerConfig(CombinedContainerConfig) Constructs a new instance of the CombinedContainerConfig class by cloning an existing one. Declaration public CombinedContainerConfig(CombinedContainerConfig collection) Parameters Type Name Description CombinedContainerConfig collection The collection whose elements are to be copied. If null, then the collection is initialised empty. | Improve this Doc View Source CombinedContainerConfig(IContainerConfig[]) Constructs a new instance of the CombinedContainerConfig type, using the passed behaviours enumerable to seed the underlying collection. Declaration public CombinedContainerConfig(params IContainerConfig[] behaviours) Parameters Type Name Description IContainerConfig [] behaviours The behaviours to be added to the collection on construction. | Improve this Doc View Source CombinedContainerConfig(IEnumerable<IContainerConfig>) Constructs a new instance of the CombinedContainerConfig type, using the passed behaviours enumerable to seed the underlying collection. Declaration public CombinedContainerConfig(IEnumerable<IContainerConfig> behaviours) Parameters Type Name Description System.Collections.Generic.IEnumerable < IContainerConfig > behaviours The behaviours to be added to the collection on construction. Methods | Improve this Doc View Source Clone() Clones the configuration in this instance into a new instance of the CombinedContainerConfig type. Declaration public CombinedContainerConfig Clone() Returns Type Description CombinedContainerConfig | Improve this Doc View Source Configure(IContainer, IRootTargetContainer) Applies the behaviours in this collection to the passed container and targets . Declaration public void Configure(IContainer container, IRootTargetContainer targets) Parameters Type Name Description IContainer container The container to which the behaviours are being attached. IRootTargetContainer targets The target container used by the container for its registrations. Remarks The implementation runs through each behaviour that has been added to the collection, in dependency order, calling its Configure(IContainer, IRootTargetContainer) method. Implements System.Collections.Generic.IList<T> System.Collections.Generic.ICollection<T> System.Collections.Generic.IEnumerable<T> IEnumerable IContainerConfig Extension Methods CombinedContainerConfigExtensions.UseExpressionCompiler(CombinedContainerConfig) CombinedContainerConfigExtensions.UseCompiler(CombinedContainerConfig, IContainerConfig<ITargetCompiler>) See Also CombinedTargetContainerConfig"
  },
  "api/Rezolver.BindAllMembersBehaviour.html": {
    "href": "api/Rezolver.BindAllMembersBehaviour.html",
    "title": "Class BindAllMembersBehaviour | Rezolver IOC",
    "keywords": "Class BindAllMembersBehaviour This implementation of IMemberBindingBehaviour binds all publicly writable properties and public fields to values obtained from the container. Inheritance Object BindAllMembersBehaviour BindPublicFieldsBehaviour BindPublicPropertiesBehaviour BindSpecificMembersBehaviour Implements IMemberBindingBehaviour Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class BindAllMembersBehaviour : IMemberBindingBehaviour Remarks This is a stateless singleton accessible through the BindAll static property. The class also serves as a good starting point for any custom binding behaviours you might need - as there are numerous virtual methods which allow you to change which fields and/or properties are selected for binding, as well as how those bindings are created. The default behaviour is to bind each member to a new ResolvedTarget whose DeclaredType is set to the member's type. Constructors | Improve this Doc View Source BindAllMembersBehaviour() Constructs a new instance of the BindAllMembersBehaviour class. Can only be created by Rezolver or through inheritance. Declaration protected BindAllMembersBehaviour() Methods | Improve this Doc View Source BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) Called by GetMemberBindings(ICompileContext, Type) - iterates through the fields , calling CreateBinding(ICompileContext, Type, FieldInfo) for each, and those which are non-null. Declaration protected virtual IEnumerable<MemberBinding> BindFields(ICompileContext context, Type type, IEnumerable<FieldInfo> fields) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. System.Collections.Generic.IEnumerable < FieldInfo > fields The fields for which bindings are to be created. This is fed by the function GetBindableFields(ICompileContext, Type) Returns Type Description System.Collections.Generic.IEnumerable < MemberBinding > | Improve this Doc View Source BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) Called by GetMemberBindings(ICompileContext, Type) - iterates through the properties , calling CreateBinding(ICompileContext, Type, PropertyInfo) for each, and those which are non-null. Declaration protected virtual IEnumerable<MemberBinding> BindProperties(ICompileContext context, Type type, IEnumerable<PropertyInfo> properties) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. System.Collections.Generic.IEnumerable < PropertyInfo > properties The properties for which bindings are to be created. This is fed by the function GetBindableProperties(ICompileContext, Type) Returns Type Description System.Collections.Generic.IEnumerable < MemberBinding > An enumerable of MemberBinding objects representing the bindings to be used for each bindable property in properties . | Improve this Doc View Source CreateBinding(ICompileContext, Type, FieldInfo) Creates a binding for the given field. Called by GetMemberBindings(ICompileContext, Type) Declaration protected virtual MemberBinding CreateBinding(ICompileContext context, Type type, FieldInfo field) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. FieldInfo field The field for which a binding is to be created. Returns Type Description MemberBinding Remarks Override this method to customise the binding that is create for the given field, or to prevent the binding from being created at all(return null if you want to abort binding the field). The base implementation simply creates a new MemberBinding whose Target is set to a new ResolvedTarget for the type FieldType - thus causing the field to be assigned a value resolved from the container when the instance is created. | Improve this Doc View Source CreateBinding(ICompileContext, Type, PropertyInfo) Creates a binding for the given property. Called by GetMemberBindings(ICompileContext, Type) Declaration protected virtual MemberBinding CreateBinding(ICompileContext context, Type type, PropertyInfo prop) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. PropertyInfo prop The property for which a binding is to be created. Returns Type Description MemberBinding Remarks Override this method to customise the binding that is create for the given property, or to prevent the binding from being created at all(return null if you want to abort binding the property). The base will create a MemberBinding for publicly writable properties; and a ListMemberBinding for publicly readable properties which follow the rules for types supporting .Net's collection initialisers https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers#collection-initializers | Improve this Doc View Source GetBindableFields(ICompileContext, Type) Gets the bindable fields on the type . Used by GetMemberBindings(ICompileContext, Type) and passed to the BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) method. Declaration protected virtual IEnumerable<FieldInfo> GetBindableFields(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. Returns Type Description System.Collections.Generic.IEnumerable < FieldInfo > Remarks Override this method to filter the fields which can be bound. The base implementation returns all public instance fields declared on the type . | Improve this Doc View Source GetBindableProperties(ICompileContext, Type) Gets the bindable properties on the type . Used by GetMemberBindings(ICompileContext, Type) and passed to the BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) method. Declaration protected virtual IEnumerable<PropertyInfo> GetBindableProperties(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. Returns Type Description System.Collections.Generic.IEnumerable < PropertyInfo > Remarks Override this method to filter the properties which can be bound. The base implementation returns all non-indexer instance properties which have publicly accessible 'set' accessors. | Improve this Doc View Source GetMemberBindings(ICompileContext, Type) Implementation of GetMemberBindings(ICompileContext, Type) . Declaration public virtual MemberBinding[] GetMemberBindings(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The current compilation context. Type type The type whose members are to be bound. Returns Type Description MemberBinding [] Remarks The base implementation calls GetBindableProperties(ICompileContext, Type) , passing the resultant enumerable to the BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) function; it also does the same thing with GetBindableFields(ICompileContext, Type) and BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) - concatenating the two enumerables together and returning the result as an array of MemberBinding objects. | Improve this Doc View Source ShouldBind(FieldInfo) Declaration protected virtual bool ShouldBind(FieldInfo fi) Parameters Type Name Description FieldInfo fi Returns Type Description Boolean | Improve this Doc View Source ShouldBind(PropertyInfo) Used by default by the GetBindableProperties(ICompileContext, Type) method to filter all instance properties on a type which can be bound. Returns true if the property does not have an index and is either publicly writable, or is a bindable collection type. The latter follows the same rules as .Net collection initialisers, described here https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers#collection-initializers Declaration protected virtual bool ShouldBind(PropertyInfo pi) Parameters Type Name Description PropertyInfo pi Returns Type Description Boolean Implements IMemberBindingBehaviour See Also IMemberBindingBehaviour"
  },
  "api/Rezolver.UnresolvedICompiledTargetExtensions.html": {
    "href": "api/Rezolver.UnresolvedICompiledTargetExtensions.html",
    "title": "Class UnresolvedICompiledTargetExtensions | Rezolver IOC",
    "keywords": "Class UnresolvedICompiledTargetExtensions Contains an extension to test the validity of ICompiledTarget objects. Inheritance Object UnresolvedICompiledTargetExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class UnresolvedICompiledTargetExtensions Methods | Improve this Doc View Source IsUnresolved(ICompiledTarget) Returns true if compiledTarget is an UnresolvedTypeCompiledTarget (and therefore the associated could not be resolved). Declaration public static bool IsUnresolved(this ICompiledTarget compiledTarget) Parameters Type Name Description ICompiledTarget compiledTarget Required. The compiled target to be checked. Returns Type Description Boolean"
  },
  "api/Rezolver.TargetTypeSelector.html": {
    "href": "api/Rezolver.TargetTypeSelector.html",
    "title": "Class TargetTypeSelector | Rezolver IOC",
    "keywords": "Class TargetTypeSelector Given a type, this produces an enumerable of all types to be sought from an ITargetContainer whose targets might produce a compatible instance. In particular, this class is responsible for handling generic type matching, including variance. Inheritance Object TargetTypeSelector Implements System.Collections.Generic.IEnumerable < Type > IEnumerable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class TargetTypeSelector : IEnumerable<Type>, IEnumerable Remarks It's highly unlikely that you will ever need to use this type directly in an application. It's public because it could be useful to developers of components which extend Rezolver. Internally, the GenericTargetContainer uses this exclusively to perform searches for compatible target types if a requested type is generic. Constructors | Improve this Doc View Source TargetTypeSelector(Type, IRootTargetContainer) Creates a new instance of the TargetTypeSelector type for the given type . Declaration public TargetTypeSelector(Type type, IRootTargetContainer rootTargets = null) Parameters Type Name Description Type type The type for which a list of search types is to be produced. IRootTargetContainer rootTargets The root target container Properties | Improve this Doc View Source RootTargets The root-most ITargetContainer containing registrations to be sought, and the source of any configuration options. Declaration public IRootTargetContainer RootTargets { get; } Property Value Type Description IRootTargetContainer | Improve this Doc View Source Type The type for which compatible targets are sought. Declaration public Type Type { get; } Property Value Type Description Type Methods | Improve this Doc View Source GetEnumerator() Implementation of System.Collections.Generic.IEnumerable<T>.GetEnumerator() Declaration public IEnumerator<Type> GetEnumerator() Returns Type Description System.Collections.Generic.IEnumerator < Type > Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description IEnumerator Implements System.Collections.Generic.IEnumerable<T> IEnumerable"
  },
  "api/Rezolver.Targets.html": {
    "href": "api/Rezolver.Targets.html",
    "title": "Namespace Rezolver.Targets | Rezolver IOC",
    "keywords": "Namespace Rezolver.Targets Classes ChangeTypeTarget This target is specifically used for explicitly casting the result of one target to another type. Its use is rare, since the framework already caters for downcasting the result of targets to base types. ConstructorTarget A target that binds to a type's constructor with zero or more arguments supplied by other ITarget s and, optionally binding to the new instance's writeable properties. The target supports en explicitly supplied constructor, as well as just-in-time lookups for the best available constructor based on the available services and/or any named arguments which might been provided up front. DecoratorTarget Represents the action of implementing a common DecoratedType by decorating one instance (produced by DecoratedTarget ) with another ( InnerTarget ). NOTE - You shouldn't register or otherwise create instances of this target unless you absolutely know what you're doing. Rather, decorators should be registered using the extension method RegisterDecorator<TDecorator, TDecorated>(IRootTargetContainer) or its non-generic alternative because the target needs a DecoratingTargetContainer to work properly (the creation of which is automatically handled by these extension methods). DefaultTarget A target that simply creates a default instance of a given type. I.e. the same as doing default(type) in C#. DelegateTarget An ITarget which resolve objects by executing a delegate with argument injection. EnumerableTarget A specialised target for creating instances of System.Collections.Generic.IEnumerable<T> ExpressionTarget A generic target for all expressions not explicitly supported by a particular target. Enables more complex behaviours to be registered and used with the more formal ITarget implementations. GenericConstructorTarget Equivalent of ConstructorTarget but for open generic types. So, this will handle the open generic MyType<,>, for example, whereas ConstructorTarget would handle the closed type MyType<int, string>. ListTarget This target produces arrays ( AsArray = true ) or lists ( AsArray = false ) whose individual items are built by ITarget instances. ObjectTarget Implements ITarget by wrapping a single instance that's already been constructed by application code. OptionalParameterTarget Used specifically when binding arguments to method parameters when a parameter is optional and its default value is to be used when binding to it. It is highly unlikely you'll ever create one of these directly. ProjectionTarget ResolvedTarget Represents a target that is rezolved statically at compile time via the ICompileContext , or dynamically (at 'resolve time') from the IContainer that is attached to the current IResolveContext when Resolve(IResolveContext) is called. This is the most common way that we bind constructor parameters, for example - i.e. 'I want an IService instance - go get it'. ScopedTarget A target that produces or fetches a single instance of an object within a lifetime scope. SingletonTarget A target which applies the singleton pattern to any ITarget . The inner target is available from the InnerTarget property. TargetBase Abstract base class, suggested as a starting point for implementations of ITarget . UnscopedTarget Wraps another target to force scoping to be ignored for the object that it produces, regardless of whether that object is IDisposable or otherwise has its own scoping behaviour."
  },
  "api/Rezolver.Targets.DelegateTarget.html": {
    "href": "api/Rezolver.Targets.DelegateTarget.html",
    "title": "Class DelegateTarget | Rezolver IOC",
    "keywords": "Class DelegateTarget An ITarget which resolve objects by executing a delegate with argument injection. Inheritance Object TargetBase DelegateTarget Implements ITarget Inherited Members TargetBase.Id TargetBase.UseFallback TargetBase.ScopeBehaviour TargetBase.ScopePreference TargetBase.SupportsType(Type) TargetBase.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Targets Assembly : Rezolver.dll Syntax public class DelegateTarget : TargetBase, ITarget Remarks The delegate must be non-void and can have any number of parameters. A compiler must ensure that any parameters for the Factory are automatically resolved from the container, and that a parameter of the type IResolveContext will receive the context passed to the Resolve(IResolveContext) method call for which this target is being compiled and/or executed. Constructors | Improve this Doc View Source DelegateTarget(Delegate, Type) Initializes a new instance of the DelegateTarget class. Declaration public DelegateTarget(Delegate factory, Type declaredType = null) Parameters Type Name Description Delegate factory Required - the factory delegate. Must have a return type and can take 0 or more parameters. Type declaredType Optional - type that will be set into the DeclaredType for the target; if not provided, then it will be derived from the factory 's return type Exceptions Type Condition ArgumentException If the factory represents a void delegate or if declaredType is passed but the type is not compatible with the return type of factory . ArgumentNullException If factory is null Properties | Improve this Doc View Source DeclaredType Gets the declared type of object that is constructed by this target, either set on construction or derived from the return type of the Factory Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source Factory Gets the factory delegate that will be invoked when this target is compiled and executed Declaration public Delegate Factory { get; } Property Value Type Description Delegate The factory. | Improve this Doc View Source FactoryMethod Gets the MethodInfo for the Factory delegate. Declaration public MethodInfo FactoryMethod { get; } Property Value Type Description MethodInfo Remarks Whilst this can be easily obtained from the delegate yourself (by using the GetMethodInfo(Delegate) extension method) however, this class also uses it to determine the DeclaredType of the target or whether the delegate is actually compatible with the one supplied on construction, therefore if you need to introspect the delegate, you might as well use this. Implements ITarget Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget)"
  },
  "api/Rezolver.Targets.DefaultTarget.html": {
    "href": "api/Rezolver.Targets.DefaultTarget.html",
    "title": "Class DefaultTarget | Rezolver IOC",
    "keywords": "Class DefaultTarget A target that simply creates a default instance of a given type. I.e. the same as doing default(type) in C#. Inheritance Object TargetBase DefaultTarget Implements ICompiledTarget ITarget Inherited Members TargetBase.Id TargetBase.UseFallback TargetBase.ScopePreference TargetBase.SupportsType(Type) TargetBase.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Targets Assembly : Rezolver.dll Syntax public class DefaultTarget : TargetBase, ICompiledTarget, IDirectTarget, ITarget Remarks The type also implements the ICompiledTarget interface for direct resolving. Constructors | Improve this Doc View Source DefaultTarget(Type) Initializes a new instance of the DefaultTarget class. Declaration public DefaultTarget(Type type) Parameters Type Name Description Type type The type. Properties | Improve this Doc View Source DeclaredType Always equal to the type for which the default value will be returned Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source ScopeBehaviour Override of ScopeBehaviour - always returns None . Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour | Improve this Doc View Source Value Gets the actual default value represented by this instance. Declaration public object Value { get; } Property Value Type Description Object Explicit Interface Implementations | Improve this Doc View Source ICompiledTarget.GetObject(IResolveContext) Declaration object ICompiledTarget.GetObject(IResolveContext context) Parameters Type Name Description IResolveContext context Returns Type Description Object | Improve this Doc View Source ICompiledTarget.SourceTarget Declaration ITarget ICompiledTarget.SourceTarget { get; } Returns Type Description ITarget Implements ICompiledTarget ITarget Extension Methods UnresolvedICompiledTargetExtensions.IsUnresolved(ICompiledTarget) Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget)"
  },
  "api/Rezolver.Options.EnableEnumerableCovariance.html": {
    "href": "api/Rezolver.Options.EnableEnumerableCovariance.html",
    "title": "Class EnableEnumerableCovariance | Rezolver IOC",
    "keywords": "Class EnableEnumerableCovariance Option that controls whether or not auto-injected enumerables - either globally, or for a given type - will perform covariant searches when locating targets to be included in the enumerable. The Default is equivalent to true . Inheritance Object ContainerOption < Boolean > EnableEnumerableCovariance Inherited Members ContainerOption<Boolean>.Value ContainerOption<Boolean>.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Options Assembly : Rezolver.dll Syntax public class EnableEnumerableCovariance : ContainerOption<bool> Properties | Improve this Doc View Source Default The default value for this option - equivalent to true Declaration public static EnableEnumerableCovariance Default { get; } Property Value Type Description EnableEnumerableCovariance Operators | Improve this Doc View Source Implicit(Boolean to EnableEnumerableCovariance) Convenience convserion operator from Boolean to EnableEnumerableCovariance Declaration public static implicit operator EnableEnumerableCovariance(bool value) Parameters Type Name Description Boolean value The boolean value to wrapped in a new instance of EnableEnumerableCovariance Returns Type Description EnableEnumerableCovariance"
  },
  "api/Rezolver.Options.EnableContravariance.html": {
    "href": "api/Rezolver.Options.EnableContravariance.html",
    "title": "Class EnableContravariance | Rezolver IOC",
    "keywords": "Class EnableContravariance A Boolean container options that controls whether contravariant generic parameters will be matched to registrations of bases/interfaces of the associated type. This option can be applied globally or on a per-service basis. See the remarks section for more. The Default (unset) is equivalent to true , meaning that contravariance is enabled, for all applicable types. Inheritance Object ContainerOption < Boolean > EnableContravariance Inherited Members ContainerOption<Boolean>.Value ContainerOption<Boolean>.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Options Assembly : Rezolver.dll Syntax public class EnableContravariance : ContainerOption<bool> Remarks To disable contravariance globally, you can set this option to false using the SetOption<TOption>(ITargetContainer, TOption) extension method. You can also disable contravariance for a particular interface or delegate type - either by targetting the open generic (e.g. System.Action<T> - which disables it for any type lookup for System.Action<T> ) or for a specific closed version of that generic (e.g. Action<Foo, Bar> ). Fields | Improve this Doc View Source Default Default value for this option - equivalent to true Declaration public static EnableContravariance Default Field Value Type Description EnableContravariance Operators | Improve this Doc View Source Implicit(Boolean to EnableContravariance) Implicit conversion operator from Boolean to EnableContravariance - simplifies getting and setting this option. Declaration public static implicit operator EnableContravariance(bool value) Parameters Type Name Description Boolean value Returns Type Description EnableContravariance See Also EnableGlobalOptions"
  },
  "api/Rezolver.ITargetContainerFactory.html": {
    "href": "api/Rezolver.ITargetContainerFactory.html",
    "title": "Interface ITargetContainerFactory | Rezolver IOC",
    "keywords": "Interface ITargetContainerFactory A target container option used by TargetContainer to create a new instance of an ITargetContainer to store target registrations for a specific type (or types relating to a specific type). Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface ITargetContainerFactory Methods | Improve this Doc View Source CreateContainer(Type, ITargetContainer, ITargetContainer) Creates an ITargetContainer suitable for registration in the targets parent container for targets whose DeclaredType is equal, or otherwise related, to the passed type . Declaration ITargetContainer CreateContainer(Type type, ITargetContainer targets, ITargetContainer rootTargetContainer) Parameters Type Name Description Type type A type that is, in some way, common to all targets or child target containers that will be registered in the required container. ITargetContainer targets The target container into which the returned target container will be registered. ITargetContainer rootTargetContainer The rootmost target container (ultimate ancestor of the targets target container). Returns Type Description ITargetContainer An ITargetContainer to be added to the targets into which targets will be registered. Or null if this factory doesn't handle the passed type ."
  },
  "api/Rezolver.ITargetContainerEventHandler-1.html": {
    "href": "api/Rezolver.ITargetContainerEventHandler-1.html",
    "title": "Interface ITargetContainerEventHandler<TEvent> | Rezolver IOC",
    "keywords": "Interface ITargetContainerEventHandler<TEvent> Interface for an object which handles an event of a particular type ( TEvent ) raised from an ITargetContainer . Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface ITargetContainerEventHandler<in TEvent> Type Parameters Name Description TEvent The type of event being handled. Methods | Improve this Doc View Source Handle(ITargetContainer, TEvent) Fires the event handler for the event e raised from the target container source . Declaration void Handle(ITargetContainer source, TEvent e) Parameters Type Name Description ITargetContainer source The target container which is raising the event TEvent e The event payload."
  },
  "api/Rezolver.IScopeFactory.html": {
    "href": "api/Rezolver.IScopeFactory.html",
    "title": "Interface IScopeFactory | Rezolver IOC",
    "keywords": "Interface IScopeFactory Represents an object from which a scope can be created Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface IScopeFactory Methods | Improve this Doc View Source CreateScope() Creates a new scope. If the implementing object is also a scope, then the new scope must be created as a child scope of that scope. Declaration IContainerScope CreateScope() Returns Type Description IContainerScope"
  },
  "api/Rezolver.IScopedContainer.html": {
    "href": "api/Rezolver.IScopedContainer.html",
    "title": "Interface IScopedContainer | Rezolver IOC",
    "keywords": "Interface IScopedContainer An IContainer that also has a Scope attached to it. Many applications will use such a container as the root container to use as anchors for things like scoped singletons. Inherited Members IContainer.CanResolve(IResolveContext) IContainer.Resolve(IResolveContext) IContainer.TryResolve(IResolveContext, Object) IContainer.GetCompiledTarget(IResolveContext) IScopeFactory.CreateScope() System.IServiceProvider.GetService(System.Type) System.IDisposable.Dispose() Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface IScopedContainer : IContainer, IScopeFactory, IServiceProvider, IDisposable Properties | Improve this Doc View Source Scope Gets the root scope for this scoped container. Note that this is used automatically by the container for Resolve(IResolveContext) operations where the Scope property is not already set. Declaration IContainerScope Scope { get; } Property Value Type Description IContainerScope Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.ResolveMany(IContainer, Type) ContainerResolveExtensions.ResolveMany<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) See Also IContainer IDisposable"
  },
  "api/Rezolver.ExpressionTargetContainerExtensions.html": {
    "href": "api/Rezolver.ExpressionTargetContainerExtensions.html",
    "title": "Class ExpressionTargetContainerExtensions | Rezolver IOC",
    "keywords": "Class ExpressionTargetContainerExtensions Extensions for to simplify registering expressions in an ITargetContainer . Inheritance Object ExpressionTargetContainerExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class ExpressionTargetContainerExtensions Methods | Improve this Doc View Source RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) Registers the expression in the target container Declaration public static void RegisterExpression(this ITargetContainer targetContainer, Expression expression, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targetContainer The target container in which the registration will be made. Expression expression The expression to be registered. Type declaredType Optional. The DeclaredType of the target to be created, if different from the Type of the expression (or its Body if the expression is a LambdaExpression ). Will also override the type against which the expression will be registered if provided. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the compiled expression will be tracked if the target is executed within an IContainerScope . The default is Implicit . | Improve this Doc View Source RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) Registers an ExpressionTarget built from a parameterless lambda expression which returns an instance of TResult Declaration public static void RegisterExpression<TResult>(this ITargetContainer targets, Expression<Func<TResult>> lambda, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered System.Linq.Expressions.Expression < System.Func <TResult>> lambda Required. The lambda expression which is to be compiled and executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the compiled expression will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description TResult The return type of the lambda expression. | Improve this Doc View Source RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) Registers an ExpressionTarget built from a lambda expression which takes an IResolveContext and which returns an instance of TResult Declaration public static void RegisterExpression<TResult>(this ITargetContainer targets, Expression<Func<IResolveContext, TResult>> lambda, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered System.Linq.Expressions.Expression < System.Func < IResolveContext , TResult>> lambda Required. The lambda expression which is to be compiled and executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the compiled expression will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) Registers an ExpressionTarget built from a lambda expression which takes 1 argument and which returns an instance of TResult Declaration public static void RegisterExpression<T1, TResult>(this ITargetContainer targets, Expression<Func<T1, TResult>> lambda, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered System.Linq.Expressions.Expression < System.Func <T1, TResult>> lambda Required. The lambda expression which is to be compiled and executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the compiled expression will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) Registers an ExpressionTarget built from a lambda expression which takes 2 arguments and which returns an instance of TResult Declaration public static void RegisterExpression<T1, T2, TResult>(this ITargetContainer targets, Expression<Func<T1, T2, TResult>> lambda, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered System.Linq.Expressions.Expression < System.Func <T1, T2, TResult>> lambda Required. The lambda expression which is to be compiled and executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the compiled expression will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. T2 Type of the 2nd parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) Registers an ExpressionTarget built from a lambda expression which takes 3 arguments and which returns an instance of TResult Declaration public static void RegisterExpression<T1, T2, T3, TResult>(this ITargetContainer targets, Expression<Func<T1, T2, T3, TResult>> lambda, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered System.Linq.Expressions.Expression < System.Func <T1, T2, T3, TResult>> lambda Required. The lambda expression which is to be compiled and executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the compiled expression will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. T2 Type of the 2nd parameter of the lambda expression. T3 Type of the 3rd parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) Registers an ExpressionTarget built from a lambda expression which takes 4 arguments and which returns an instance of TResult Declaration public static void RegisterExpression<T1, T2, T3, T4, TResult>(this ITargetContainer targets, Expression<Func<T1, T2, T3, T4, TResult>> lambda, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered System.Linq.Expressions.Expression < System.Func <T1, T2, T3, T4, TResult>> lambda Required. The lambda expression which is to be compiled and executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the compiled expression will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. T2 Type of the 2nd parameter of the lambda expression. T3 Type of the 3rd parameter of the lambda expression. T4 Type of the 4th parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) Registers an ExpressionTarget built from a lambda expression which takes 5 arguments and which returns an instance of TResult Declaration public static void RegisterExpression<T1, T2, T3, T4, T5, TResult>(this ITargetContainer targets, Expression<Func<T1, T2, T3, T4, T5, TResult>> lambda, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.Implicit) Parameters Type Name Description ITargetContainer targets Required. The ITargetContainer into which the newly created target will be registered System.Linq.Expressions.Expression < System.Func <T1, T2, T3, T4, T5, TResult>> lambda Required. The lambda expression which is to be compiled and executed when an instance is resolved by a container Type declaredType Optional. The DeclaredType of the target to be created if different from TResult . Also overrides the type against which the registration will be made. ScopeBehaviour scopeBehaviour Optional. Controls how the object generated from the compiled expression will be tracked if the target is executed within an IContainerScope . The default is Implicit . Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. T2 Type of the 2nd parameter of the lambda expression. T3 Type of the 3rd parameter of the lambda expression. T4 Type of the 4th parameter of the lambda expression. T5 Type of the 5th parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed"
  },
  "api/Rezolver.ExpressionFunctions.html": {
    "href": "api/Rezolver.ExpressionFunctions.html",
    "title": "Class ExpressionFunctions | Rezolver IOC",
    "keywords": "Class ExpressionFunctions This type is only used when using expressions as targets(via the ExpressionTarget type) - it's functions serve no actual purpose other than to act as hooks to create specific ITarget objects in place of static code. All the functions will throw a NotImplementedException if called at runtime. Inheritance Object ExpressionFunctions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class ExpressionFunctions Methods | Improve this Doc View Source Resolve(Type) Provides a way to emit a Resolve(Type) call to the IResolveContext which is active when an expression is compiled and executed when resolving an object. Declaration public static object Resolve(Type t) Parameters Type Name Description Type t The type to be resolved. Returns Type Description Object Exceptions Type Condition NotImplementedException Always. The method is not intended to be used outside of an expression, instead it should be rewritten either to a ResolvedTarget or another MethodCallExpression bound to the Resolve(Type) method of a IResolveContext . | Improve this Doc View Source Resolve<T>() Provides a way to emit a Resolve<TResult>() call to the IResolveContext which is active when an expression is compiled and executed when resolving an object. Declaration public static T Resolve<T>() Returns Type Description T Type Parameters Name Description T The type to be resolved. Remarks Use of this function in a Lambda expression is not required if you can add a IResolveContext parameter to the Lambda - since you can simply call its Resolve<TResult>() method in your lambda body. This is primarily provided instead for non-lambda expressions which require services from the container (e.g. if manually building a NewExpression or MethodCallExpression and you want to explicitly inject one or more constructor/method arguments). Exceptions Type Condition NotImplementedException Always. The method is not intended to be used outside of an expression, instead it should be rewritten either to a ResolvedTarget or another MethodCallExpression bound to the Resolve<TResult>() method of a IResolveContext ."
  },
  "api/Rezolver.Configuration.html": {
    "href": "api/Rezolver.Configuration.html",
    "title": "Namespace Rezolver.Configuration | Rezolver IOC",
    "keywords": "Namespace Rezolver.Configuration Classes Configure Provides factory methods for the Configure<TOption> generic class for when you need to create a configuration object for a specific option outside of the functionality provided by the ConfigureOption<TOption>(CombinedTargetContainerConfig, TOption) function and its various overloads. Configure<TOption> An ITargetContainerConfig implementation specialised for setting options in an ITargetContainer when Configure(IRootTargetContainer) is called. This class' implementation of that method is actually handled by the ConfigureOption(ITargetContainer) method. ExpressionCompilation Implementation of IContainerConfig which configures expression-based compilation for targets in containers. The implementation sets all options and registers all the targets necessary to use the expression tree-based compilation provided by the ExpressionCompiler This is included in the DefaultConfig , meaning that all containers created without a specific config will automatically be configured to use the ExpressionCompiler . InjectArrays Configuration (enabled by default in the DefaultConfig configuration collection) which enables the automatic injection of arrays by converting automatically injected enumerables into array instances via the ToArray<TSource>(IEnumerable<TSource>) method from Linq. InjectCollections Applying this configuration to an ITargetContainer will enable automatic injection of collection types such as Collection<T> , System.Collections.Generic.ICollection<T> , ReadOnlyCollection<T> and IReadOnlyCollection<T> (so long as there are no registrations for these types in the target container when the configuration is applied). Out of the box, such collections will be seeded by any objects that have been registered against the element type. InjectEnumerables An ITargetContainerConfig which enables automatic handling of fetching targets for System.Collections.Generic.IEnumerable<T> based on all the targets registered for a given T in an ITargetContainer . InjectLists This configuration will enable automatic injection of List<T> , System.Collections.Generic.IList<T> and System.Collections.Generic.IReadOnlyList<T> when applied to an ITargetContainer , so long as there aren't already registrations for those types . InjectResolveContext An ITargetContainerConfig that enables automatic resolving of the IResolveContext created for a Resolve(IResolveContext) operation. OptionDependentConfig<TOption> Abstract base class for an ITargetContainerConfig that is dependent upon a particular type of option having been set in an ITargetContainer before being able to Configure(IRootTargetContainer) that target container. OptionDependentConfig<T, TOption> Extension to the OptionDependentConfig<TOption> generic which can be used by config types which also want to target a specific type for configuration ( T ) OverridingEnumerables When applied to an OverridingContainer whose target container has been configured to enable automatically injected enumerables (via the InjectEnumerables configuration callback and the EnableEnumerableInjection option), then this will extend enumerable support in the OverridingContainer to construct enumerables made up of a combination of all services in the overriden container AND those from the overriding container."
  },
  "api/Rezolver.Configuration.OverridingEnumerables.html": {
    "href": "api/Rezolver.Configuration.OverridingEnumerables.html",
    "title": "Class OverridingEnumerables | Rezolver IOC",
    "keywords": "Class OverridingEnumerables When applied to an OverridingContainer whose target container has been configured to enable automatically injected enumerables (via the InjectEnumerables configuration callback and the EnableEnumerableInjection option), then this will extend enumerable support in the OverridingContainer to construct enumerables made up of a combination of all services in the overriden container AND those from the overriding container. Inheritance Object OverridingEnumerables Implements IContainerConfig Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Configuration Assembly : Rezolver.dll Syntax public sealed class OverridingEnumerables : IContainerConfig Remarks Note that this class is not an ITargetContainerConfig like the InjectEnumerables , instead it is an IContainerConfig because it's only relevant for instances of OverridingContainer . As such, when applied to an IContainer instance, it will only auto-attach when the container is an instance of (or derived from) OverridingContainer and if the EnableEnumerableInjection options evaluates to true when read from the ITargetContainer passed to Configure(IContainer, IRootTargetContainer) . Properties | Improve this Doc View Source Instance The one and only instance of the OverridingEnumerables Declaration public static OverridingEnumerables Instance { get; } Property Value Type Description OverridingEnumerables Methods | Improve this Doc View Source Configure(IContainer, IRootTargetContainer) If container is an OverridingContainer , and if the EnableEnumerableInjection option evaluates to true (the default) when read from targets , then enumerable handling in the container will be extended to combine the enumerables from both objects registered specifically in the container , plus also those registered in its Inner container. Declaration public void Configure(IContainer container, IRootTargetContainer targets) Parameters Type Name Description IContainer container The container to be configured. IRootTargetContainer targets The ITargetContainer which supplies the registrations for the container Implements IContainerConfig"
  },
  "api/Rezolver.Configuration.Configure-1.html": {
    "href": "api/Rezolver.Configuration.Configure-1.html",
    "title": "Class Configure<TOption> | Rezolver IOC",
    "keywords": "Class Configure<TOption> An ITargetContainerConfig implementation specialised for setting options in an ITargetContainer when Configure(IRootTargetContainer) is called. This class' implementation of that method is actually handled by the ConfigureOption(ITargetContainer) method. Inheritance Object Configure<TOption> Implements ITargetContainerConfig <TOption> ITargetContainerConfig Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Configuration Assembly : Rezolver.dll Syntax public class Configure<TOption> : ITargetContainerConfig<TOption>, ITargetContainerConfig where TOption : class Type Parameters Name Description TOption The type of option to be set. Will ultimately be passed through to the SetOption<TOption>(ITargetContainer, TOption, Type) method when the option is set. Remarks This class is most often used to modify the options which are set in the DefaultConfig of the TargetContainer class - but can, of course, be used to configure any ITargetContainer . The class implements the generic ITargetContainerConfig<T> interface, so that it's possible for other configuration objects to declare a (required or optional) dependency on anything which configures that option - so that it can ensure that those options are set beforehand. The InjectEnumerables configuration type, for example, expresses an optional dependency on an ITargetContainerConfig<T> which has a TOption type equal to EnableEnumerableInjection . Constructors | Improve this Doc View Source Configure(TOption, Type) Constructs a new instance of the Configure<TOption> class which, when Configure(IRootTargetContainer) is called with a particular ITargetContainer , will set the option to the optionValue , optionally for the given serviceType Declaration public Configure(TOption optionValue, Type serviceType = null) Parameters Type Name Description TOption optionValue The value to set the option to when the configuration is applied to the target container Type serviceType Optional - service type for which the option is to be set (use of this is option-dependent - not all options are read in a service-specific manner) | Improve this Doc View Source Configure(Func<ITargetContainer, Type, TOption>, Type) Constructs a new instance of the Configure<TOption> class which, when Configure(IRootTargetContainer) is called with a particular ITargetContainer , will set the option to the value returned by optionFactory , optionally for the given serviceType Declaration public Configure(Func<ITargetContainer, Type, TOption> optionFactory, Type serviceType = null) Parameters Type Name Description System.Func < ITargetContainer , Type , TOption> optionFactory The factory to be executed to obtain the option value Type serviceType Optional - service type for which the option is to be set (use of this is option-dependent - not all options are read in a service-specific manner) Methods | Improve this Doc View Source ConfigureOption(ITargetContainer) Sets the option value (either passed as a constant reference on construction, or obtained via a callback) in the targets target container. This is used as the implementation of Configure(IRootTargetContainer) . Declaration public void ConfigureOption(ITargetContainer targets) Parameters Type Name Description ITargetContainer targets The target container into which the option is to be set. Explicit Interface Implementations | Improve this Doc View Source ITargetContainerConfig.Configure(IRootTargetContainer) Implementation of Configure(IRootTargetContainer) - uses the ConfigureOption(ITargetContainer) method. Declaration void ITargetContainerConfig.Configure(IRootTargetContainer targets) Parameters Type Name Description IRootTargetContainer targets The target container into which the option is to be set. Implements ITargetContainerConfig<T> ITargetContainerConfig"
  },
  "api/Rezolver.Compilation.Expressions.TargetExpression.html": {
    "href": "api/Rezolver.Compilation.Expressions.TargetExpression.html",
    "title": "Class TargetExpression | Rezolver IOC",
    "keywords": "Class TargetExpression An expression which represents an ITarget , allowing a target with a particular DeclaredType to be used in place of a traditional expression. Inheritance Object Expression TargetExpression Inherited Members System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor) System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.LambdaExpression) System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.LambdaExpression) System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.LambdaExpression) System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.Block(System.Type, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.Block(System.Type, System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.Block(System.Type, System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.Block(System.Type, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget) System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget, System.Linq.Expressions.Expression, System.Type) System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget, System.Type) System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression, System.String, System.Type[], System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.Call(System.Type, System.String, System.Type[], System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Catch(System.Type, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Catch(System.Type, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo) System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.LambdaExpression) System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Type) System.Linq.Expressions.Expression.Constant(System.Object) System.Linq.Expressions.Expression.Constant(System.Object, System.Type) System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget) System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget, System.Type) System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression, System.Type) System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression, System.Type, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression, System.Type) System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression, System.Type, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo, System.Int32, System.Int32, System.Int32, System.Int32) System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.Default(System.Type) System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.LambdaExpression) System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder, System.Type, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder, System.Type, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder, System.Type, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder, System.Type, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder, System.Type, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder, System.Type, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.Empty() System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Boolean, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.LambdaExpression) System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression, System.Reflection.FieldInfo) System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression, System.String) System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression, System.Type, System.String) System.Linq.Expressions.Expression.GetActionType(System.Type[]) System.Linq.Expressions.Expression.GetDelegateType(System.Type[]) System.Linq.Expressions.Expression.GetFuncType(System.Type[]) System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget) System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget, System.Linq.Expressions.Expression, System.Type) System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget, System.Type) System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Boolean, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Boolean, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.Label() System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget) System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Label(System.String) System.Linq.Expressions.Expression.Label(System.Type) System.Linq.Expressions.Expression.Label(System.Type, System.String) System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression, System.Boolean, System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>) System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression, System.Boolean, System.Linq.Expressions.ParameterExpression[]) System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression, System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>) System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression, System.Linq.Expressions.ParameterExpression[]) System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression, System.String, System.Boolean, System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>) System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression, System.String, System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>) System.Linq.Expressions.Expression.Lambda(System.Type, System.Linq.Expressions.Expression, System.Boolean, System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>) System.Linq.Expressions.Expression.Lambda(System.Type, System.Linq.Expressions.Expression, System.Boolean, System.Linq.Expressions.ParameterExpression[]) System.Linq.Expressions.Expression.Lambda(System.Type, System.Linq.Expressions.Expression, System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>) System.Linq.Expressions.Expression.Lambda(System.Type, System.Linq.Expressions.Expression, System.Linq.Expressions.ParameterExpression[]) System.Linq.Expressions.Expression.Lambda(System.Type, System.Linq.Expressions.Expression, System.String, System.Boolean, System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>) System.Linq.Expressions.Expression.Lambda(System.Type, System.Linq.Expressions.Expression, System.String, System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>) System.Linq.Expressions.Expression.Lambda<TDelegate>(System.Linq.Expressions.Expression, System.Boolean, System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>) System.Linq.Expressions.Expression.Lambda<TDelegate>(System.Linq.Expressions.Expression, System.Boolean, System.Linq.Expressions.ParameterExpression[]) System.Linq.Expressions.Expression.Lambda<TDelegate>(System.Linq.Expressions.Expression, System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>) System.Linq.Expressions.Expression.Lambda<TDelegate>(System.Linq.Expressions.Expression, System.Linq.Expressions.ParameterExpression[]) System.Linq.Expressions.Expression.Lambda<TDelegate>(System.Linq.Expressions.Expression, System.String, System.Boolean, System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>) System.Linq.Expressions.Expression.Lambda<TDelegate>(System.Linq.Expressions.Expression, System.String, System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>) System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.LambdaExpression) System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Boolean, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Boolean, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo, System.Collections.Generic.IEnumerable<System.Linq.Expressions.ElementInit>) System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo, System.Linq.Expressions.ElementInit[]) System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo, System.Collections.Generic.IEnumerable<System.Linq.Expressions.ElementInit>) System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo, System.Linq.Expressions.ElementInit[]) System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression, System.Collections.Generic.IEnumerable<System.Linq.Expressions.ElementInit>) System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression, System.Linq.Expressions.ElementInit[]) System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression, System.Reflection.MethodInfo, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression, System.Reflection.MethodInfo, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression, System.Linq.Expressions.LabelTarget) System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression, System.Linq.Expressions.LabelTarget, System.Linq.Expressions.LabelTarget) System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Boolean, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Boolean, System.Reflection.MethodInfo, System.Linq.Expressions.LambdaExpression) System.Linq.Expressions.Expression.MakeCatchBlock(System.Type, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.MakeDynamic(System.Type, System.Runtime.CompilerServices.CallSiteBinder, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.MakeDynamic(System.Type, System.Runtime.CompilerServices.CallSiteBinder, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.MakeDynamic(System.Type, System.Runtime.CompilerServices.CallSiteBinder, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.MakeDynamic(System.Type, System.Runtime.CompilerServices.CallSiteBinder, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.MakeDynamic(System.Type, System.Runtime.CompilerServices.CallSiteBinder, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.MakeDynamic(System.Type, System.Runtime.CompilerServices.CallSiteBinder, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind, System.Linq.Expressions.LabelTarget, System.Linq.Expressions.Expression, System.Type) System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression, System.Reflection.PropertyInfo, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression, System.Reflection.MemberInfo) System.Linq.Expressions.Expression.MakeTry(System.Type, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Collections.Generic.IEnumerable<System.Linq.Expressions.CatchBlock>) System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType, System.Linq.Expressions.Expression, System.Type) System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType, System.Linq.Expressions.Expression, System.Type, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo, System.Collections.Generic.IEnumerable<System.Linq.Expressions.MemberBinding>) System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo, System.Linq.Expressions.MemberBinding[]) System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo, System.Collections.Generic.IEnumerable<System.Linq.Expressions.MemberBinding>) System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo, System.Linq.Expressions.MemberBinding[]) System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression, System.Collections.Generic.IEnumerable<System.Linq.Expressions.MemberBinding>) System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression, System.Linq.Expressions.MemberBinding[]) System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.LambdaExpression) System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.LambdaExpression) System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.LambdaExpression) System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo) System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>, System.Collections.Generic.IEnumerable<System.Reflection.MemberInfo>) System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>, System.Reflection.MemberInfo[]) System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.New(System.Type) System.Linq.Expressions.Expression.NewArrayBounds(System.Type, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.NewArrayBounds(System.Type, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.NewArrayInit(System.Type, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.NewArrayInit(System.Type, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Boolean, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.LambdaExpression) System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.Parameter(System.Type) System.Linq.Expressions.Expression.Parameter(System.Type, System.String) System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.LambdaExpression) System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression, System.Reflection.PropertyInfo) System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression, System.Reflection.PropertyInfo, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression, System.Reflection.PropertyInfo, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression, System.String) System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression, System.String, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression, System.Type, System.String) System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression, System.String) System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.ReduceAndCheck() System.Linq.Expressions.Expression.ReduceExtensions() System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Rethrow() System.Linq.Expressions.Expression.Rethrow(System.Type) System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget) System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget, System.Linq.Expressions.Expression, System.Type) System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget, System.Type) System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.LambdaExpression) System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable<System.Linq.Expressions.ParameterExpression>) System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[]) System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.LambdaExpression) System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.LambdaExpression) System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.SwitchCase[]) System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Collections.Generic.IEnumerable<System.Linq.Expressions.SwitchCase>) System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.SwitchCase[]) System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression, System.Linq.Expressions.SwitchCase[]) System.Linq.Expressions.Expression.Switch(System.Type, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Collections.Generic.IEnumerable<System.Linq.Expressions.SwitchCase>) System.Linq.Expressions.Expression.Switch(System.Type, System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Reflection.MethodInfo, System.Linq.Expressions.SwitchCase[]) System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression, System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>) System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression[]) System.Linq.Expressions.Expression.SymbolDocument(System.String) System.Linq.Expressions.Expression.SymbolDocument(System.String, System.Guid) System.Linq.Expressions.Expression.SymbolDocument(System.String, System.Guid, System.Guid) System.Linq.Expressions.Expression.SymbolDocument(System.String, System.Guid, System.Guid, System.Guid) System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression, System.Type) System.Linq.Expressions.Expression.ToString() System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression, System.Linq.Expressions.CatchBlock[]) System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression, System.Linq.Expressions.CatchBlock[]) System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression, System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.TryGetActionType(System.Type[], System.Type) System.Linq.Expressions.Expression.TryGetFuncType(System.Type[], System.Type) System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression, System.Type) System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression, System.Type) System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression, System.Type) System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression, System.Reflection.MethodInfo) System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression, System.Type) System.Linq.Expressions.Expression.Variable(System.Type) System.Linq.Expressions.Expression.Variable(System.Type, System.String) System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class TargetExpression : Expression Remarks The ExpressionTargetBuilder uses this class extensively when translating expressions into targets and back again. It's highly unlikely you'll need to use it in your code. It acts as a placeholder for targets until the point at which the expression compiler wants to build a complete expression tree for a target. Constructors | Improve this Doc View Source TargetExpression(ITarget) Initializes a new instance of the TargetExpression class. Declaration public TargetExpression(ITarget target) Parameters Type Name Description ITarget target The target. Properties | Improve this Doc View Source CanReduce Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form. Declaration public override bool CanReduce { get; } Property Value Type Description Boolean true if this instance can reduce; otherwise, false . Overrides Expression.CanReduce Remarks The implementation always returns true ; although the Reduce() methodd is not implemented. | Improve this Doc View Source NodeType Gets the node type of this Expression . Declaration public override ExpressionType NodeType { get; } Property Value Type Description ExpressionType Always returns Extension . Overrides Expression.NodeType | Improve this Doc View Source Target Gets the target whose expression will be subsituted for this TargetExpression in the final expression tree. Declaration public ITarget Target { get; } Property Value Type Description ITarget | Improve this Doc View Source Type Gets the static type of the expression that this Expression represents. Declaration public override Type Type { get; } Property Value Type Description Type Overrides Expression.Type Remarks Always returns the type referenced by the DeclaredType property of Target . Methods | Improve this Doc View Source Reduce() Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced. Declaration public override Expression Reduce() Returns Type Description Expression Overrides System.Linq.Expressions.Expression.Reduce() Exceptions Type Condition NotSupportedException RezolveTargetExpression must be rewritten as a bona-fide expression before walking the expression tree for any other purpose"
  },
  "api/Rezolver.Compilation.Expressions.OptionalParameterTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.OptionalParameterTargetBuilder.html",
    "title": "Class OptionalParameterTargetBuilder | Rezolver IOC",
    "keywords": "Class OptionalParameterTargetBuilder An IExpressionBuilder specialised for building an expression for the OptionalParameterTarget target. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < OptionalParameterTarget > OptionalParameterTargetBuilder Implements IExpressionBuilder < OptionalParameterTarget > IExpressionBuilder Inherited Members ExpressionBuilderBase<OptionalParameterTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<OptionalParameterTarget>.IExpressionBuilder<OptionalParameterTarget>.Build(OptionalParameterTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<OptionalParameterTarget>.CanBuild(ITarget) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class OptionalParameterTargetBuilder : ExpressionBuilderBase<OptionalParameterTarget>, IExpressionBuilder<OptionalParameterTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(OptionalParameterTarget, IExpressionCompileContext, IExpressionCompiler) Always returns a ConstantExpression which contains the Value . Declaration protected override Expression Build(OptionalParameterTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description OptionalParameterTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.OptionalParameterTarget>.Build(Rezolver.Targets.OptionalParameterTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Implements IExpressionBuilder<TTarget> IExpressionBuilder"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionTargetBuilder.html",
    "title": "Class ExpressionTargetBuilder | Rezolver IOC",
    "keywords": "Class ExpressionTargetBuilder An IExpressionBuilder specialised for building the expression trees for the ExpressionTarget target type. This builder takes care of all expressions, including lambdas (where additional parameters beyond the standard IResolveContext are turned into local variables with injected values), producing an expression which can be compiled by an IExpressionCompiler after a Rezolver.Compilation.Expressions.TargetExpressionRewriter has been used to expand any targets embedded in the expression. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < ExpressionTarget > ExpressionTargetBuilder Implements IExpressionBuilder < ExpressionTarget > IExpressionBuilder Inherited Members ExpressionBuilderBase<ExpressionTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ExpressionTarget>.IExpressionBuilder<ExpressionTarget>.Build(ExpressionTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<ExpressionTarget>.CanBuild(ITarget) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class ExpressionTargetBuilder : ExpressionBuilderBase<ExpressionTarget>, IExpressionBuilder<ExpressionTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(ExpressionTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression for the given target . Declaration protected override Expression Build(ExpressionTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ExpressionTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.ExpressionTarget>.Build(Rezolver.Targets.ExpressionTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Implements IExpressionBuilder<TTarget> IExpressionBuilder"
  },
  "api/Rezolver.Compilation.Expressions.DelegateTargetBuilder.html": {
    "href": "api/Rezolver.Compilation.Expressions.DelegateTargetBuilder.html",
    "title": "Class DelegateTargetBuilder | Rezolver IOC",
    "keywords": "Class DelegateTargetBuilder Specialised builder for the DelegateTarget class and all its derivatives. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase < DelegateTarget > DelegateTargetBuilder Implements IExpressionBuilder < DelegateTarget > IExpressionBuilder Inherited Members ExpressionBuilderBase<DelegateTarget>.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DelegateTarget>.IExpressionBuilder<DelegateTarget>.Build(DelegateTarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase<DelegateTarget>.CanBuild(ITarget) ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class DelegateTargetBuilder : ExpressionBuilderBase<DelegateTarget>, IExpressionBuilder<DelegateTarget>, IExpressionBuilder Methods | Improve this Doc View Source Build(DelegateTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target for the given IExpressionCompileContext Declaration protected override Expression Build(DelegateTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description DelegateTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides Rezolver.Compilation.Expressions.ExpressionBuilderBase<Rezolver.Targets.DelegateTarget>.Build(Rezolver.Targets.DelegateTarget, Rezolver.Compilation.Expressions.IExpressionCompileContext, Rezolver.Compilation.Expressions.IExpressionCompiler) Exceptions Type Condition NotImplementedException Implements IExpressionBuilder<TTarget> IExpressionBuilder"
  },
  "api/Rezolver.Compilation.ConstantCompiledTarget.html": {
    "href": "api/Rezolver.Compilation.ConstantCompiledTarget.html",
    "title": "Class ConstantCompiledTarget | Rezolver IOC",
    "keywords": "Class ConstantCompiledTarget An implementation of ICompiledTarget which simply wraps an instance and a known target. Inheritance Object ConstantCompiledTarget Implements ICompiledTarget Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation Assembly : Rezolver.dll Syntax public class ConstantCompiledTarget : ICompiledTarget Constructors | Improve this Doc View Source ConstantCompiledTarget(Object, ITarget) Constructs a new instance of the ConstantCompiledTarget Declaration public ConstantCompiledTarget(object obj, ITarget sourceTarget) Parameters Type Name Description Object obj The constant object to be returned by GetObject(IResolveContext) ITarget sourceTarget The ITarget from which this compiled target is created. Properties | Improve this Doc View Source SourceTarget The target for which this compiled target was created. Declaration public ITarget SourceTarget { get; } Property Value Type Description ITarget Methods | Improve this Doc View Source GetObject(IResolveContext) Implementation of GetObject(IResolveContext) - simply returns the target with which this instance was constructed. Declaration public object GetObject(IResolveContext context) Parameters Type Name Description IResolveContext context ignored Returns Type Description Object Implements ICompiledTarget Extension Methods UnresolvedICompiledTargetExtensions.IsUnresolved(ICompiledTarget)"
  },
  "api/Rezolver.BindPublicFieldsBehaviour.html": {
    "href": "api/Rezolver.BindPublicFieldsBehaviour.html",
    "title": "Class BindPublicFieldsBehaviour | Rezolver IOC",
    "keywords": "Class BindPublicFieldsBehaviour An IMemberBindingBehaviour which binds all public instance fields on new instances to services from the container. Inheritance Object BindAllMembersBehaviour BindPublicFieldsBehaviour Implements IMemberBindingBehaviour Inherited Members BindAllMembersBehaviour.GetMemberBindings(ICompileContext, Type) BindAllMembersBehaviour.BindFields(ICompileContext, Type, IEnumerable<FieldInfo>) BindAllMembersBehaviour.BindProperties(ICompileContext, Type, IEnumerable<PropertyInfo>) BindAllMembersBehaviour.CreateBinding(ICompileContext, Type, FieldInfo) BindAllMembersBehaviour.CreateBinding(ICompileContext, Type, PropertyInfo) BindAllMembersBehaviour.GetBindableFields(ICompileContext, Type) BindAllMembersBehaviour.ShouldBind(PropertyInfo) BindAllMembersBehaviour.ShouldBind(FieldInfo) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class BindPublicFieldsBehaviour : BindAllMembersBehaviour, IMemberBindingBehaviour Constructors | Improve this Doc View Source BindPublicFieldsBehaviour() Creates a new instance of the BindPublicFieldsBehaviour class. Can only be created by Rezolver or through inheritance. Declaration protected BindPublicFieldsBehaviour() Methods | Improve this Doc View Source GetBindableProperties(ICompileContext, Type) Overrides the base class to avoid returning any properties. Declaration protected override sealed IEnumerable<PropertyInfo> GetBindableProperties(ICompileContext context, Type type) Parameters Type Name Description ICompileContext context The compile context Type type The type to be bound. Returns Type Description System.Collections.Generic.IEnumerable < PropertyInfo > Always returns an empty System.Collections.Generic.IEnumerable<T> Overrides BindAllMembersBehaviour.GetBindableProperties(ICompileContext, Type) Implements IMemberBindingBehaviour"
  },
  "api/Microsoft.Extensions.DependencyInjection.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.html",
    "title": "Namespace Microsoft.Extensions.DependencyInjection | Rezolver IOC",
    "keywords": "Namespace Microsoft.Extensions.DependencyInjection Classes RezolverServiceCollectionExtensions Rezolver interop extension methods for the IServiceCollection class in Microsoft.Extensions.DependencyInjection RezolverServiceProviderServiceCollectionExtensions Provides the AddRezolver(IServiceCollection, Action<RezolverOptions>) extension method which adds the IServiceProviderFactory service registration for the ITargetContainer service provider builder."
  },
  "api/Rezolver.Targets.ChangeTypeTarget.html": {
    "href": "api/Rezolver.Targets.ChangeTypeTarget.html",
    "title": "Class ChangeTypeTarget | Rezolver IOC",
    "keywords": "Class ChangeTypeTarget This target is specifically used for explicitly casting the result of one target to another type. Its use is rare, since the framework already caters for downcasting the result of targets to base types. Inheritance Object TargetBase ChangeTypeTarget Implements ITarget Inherited Members TargetBase.Id TargetBase.UseFallback TargetBase.ScopePreference TargetBase.SupportsType(Type) TargetBase.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Targets Assembly : Rezolver.dll Syntax public class ChangeTypeTarget : TargetBase, ITarget Remarks A valid use of this target is when you have a SingletonTarget registered against one type, and you want the same singleton (backed by the same instance) to server another type. In this case, instead of registering the same singleton target multiple times, you can register it once for its primary type, then register one of these for the other type, with a ResolvedTarget as its inner target. When creating this target, the DeclaredType of the InnerTarget must be able to cast up or down to the DeclaredType of this target. Constructors | Improve this Doc View Source ChangeTypeTarget(ITarget, Type) Creates a new instance of the ChangeTypeTarget class. Declaration public ChangeTypeTarget(ITarget innerTarget, Type targetType) Parameters Type Name Description ITarget innerTarget Required. See InnerTarget Type targetType Required. See DeclaredType Properties | Improve this Doc View Source DeclaredType Always returns the target type that was passed in the ChangeTypeTarget(ITarget, Type) constructor. Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source InnerTarget The target whose type will be changed to DeclaredType . Declaration public ITarget InnerTarget { get; } Property Value Type Description ITarget | Improve this Doc View Source ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour Implements ITarget Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget)"
  },
  "api/Rezolver.Sdk.Dependant.html": {
    "href": "api/Rezolver.Sdk.Dependant.html",
    "title": "Class Dependant | Rezolver IOC",
    "keywords": "Class Dependant Simple base class for implementations of IDependant - the Dependencies property is implemented explictly. Inheritance Object Dependant Implements IMutableDependant IDependant Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Sdk Assembly : Rezolver.dll Syntax public class Dependant : IMutableDependant, IDependant Explicit Interface Implementations | Improve this Doc View Source IDependant.Dependencies Declaration IEnumerable<DependencyMetadata> IDependant.Dependencies { get; } Returns Type Description System.Collections.Generic.IEnumerable < DependencyMetadata > | Improve this Doc View Source IMutableDependant.Dependencies Declaration DependencyMetadataCollection IMutableDependant.Dependencies { get; } Returns Type Description DependencyMetadataCollection Implements IMutableDependant IDependant Extension Methods DependantExtensions.Requires<T, TDependency>(T, TDependency) DependantExtensions.Requires<T, TDependency>(T, IEnumerable<TDependency>) DependantExtensions.RequiresAny<T>(T, Type) DependantExtensions.After<T, TDependency>(T, TDependency) DependantExtensions.After<T, TDependency>(T, IEnumerable<TDependency>) DependantExtensions.AfterAny<T>(T, Type) DependantExtensions.GetDependencies<T, TDependency>(T, IEnumerable<TDependency>) DependantExtensions.CreateTypeDependency<TDependency>(IDependant, Boolean) DependantExtensions.CreateObjectDependency<TDependency>(IDependant, TDependency, Boolean)"
  },
  "api/Rezolver.ScopePreference.html": {
    "href": "api/Rezolver.ScopePreference.html",
    "title": "Enum ScopePreference | Rezolver IOC",
    "keywords": "Enum ScopePreference Specifies the scope that the object produced by a target should be tracked within. Namespace : Rezolver Assembly : Rezolver.dll Syntax public enum ScopePreference Fields Name Description Current The object will be tracked within the scope already set on the IResolveContext Root The object (and all its dependants) will be tracked within the root scope of the current scope set on the IResolveContext"
  },
  "api/Rezolver.ParameterBinding.html": {
    "href": "api/Rezolver.ParameterBinding.html",
    "title": "Class ParameterBinding | Rezolver IOC",
    "keywords": "Class ParameterBinding Represents a binding between a method parameter and an ITarget Inheritance Object ParameterBinding Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class ParameterBinding Constructors | Improve this Doc View Source ParameterBinding(ParameterInfo, ITarget) Constructs a new instance of the ParameterBinding class. Declaration public ParameterBinding(ParameterInfo parameter, ITarget target = null) Parameters Type Name Description ParameterInfo parameter Required - the parameter being bound ITarget target Optional - the argument supplied for the parameter. Fields | Improve this Doc View Source None Represents an empty parameter bindings array. Declaration public static readonly ParameterBinding[] None Field Value Type Description ParameterBinding [] Properties | Improve this Doc View Source IsValid Gets a boolean indicating whether the parameter binding is valid Ultimately, this returns true if Target is non-null. Declaration public bool IsValid { get; } Property Value Type Description Boolean | Improve this Doc View Source Parameter The parameter to be bound Declaration public ParameterInfo Parameter { get; } Property Value Type Description ParameterInfo | Improve this Doc View Source Target The initial target that was bound to this parameter. Declaration public ITarget Target { get; } Property Value Type Description ITarget Methods | Improve this Doc View Source BindMethod(MethodBase, ParameterBinding[]) Binds the method using explicit bindings for each parameter supplied in the suppliedBindings array, or defaults (which will be resolved from the compile or run-time container) if not present. Declaration public static ParameterBinding[] BindMethod(MethodBase method, ParameterBinding[] suppliedBindings) Parameters Type Name Description MethodBase method The method to be bound ParameterBinding [] suppliedBindings Optional. The supplied bindings for the parameters of the method. Any parameters not matched from this array will be automatically bound with default (resolved from the container). Returns Type Description ParameterBinding [] | Improve this Doc View Source BindMethod(MethodBase, IDictionary<String, ITarget>) Matches named targets in args to parameters on the passed method , creating default ParameterBinding s (which will be resolved from the compile or run-time container), for any parameters for which named targets cannot be found. Declaration public static ParameterBinding[] BindMethod(MethodBase method, IDictionary<string, ITarget> args) Parameters Type Name Description MethodBase method System.Collections.Generic.IDictionary < String , ITarget > args Returns Type Description ParameterBinding [] | Improve this Doc View Source BindOverload(MethodBase[], IDictionary<String, ITarget>, out MethodBase) Searches for a method in the methods collection whose parameters can be filled by the targets provided in the args dictionary, returning the parameter bindings, and passing out the resolved target method in resolvedMethod if found. Note - if no match can be found, or if more than one method could be bound, then an InvalidOperationException will occur. Declaration public static ParameterBinding[] BindOverload(MethodBase[] methods, IDictionary<string, ITarget> args, out MethodBase resolvedMethod) Parameters Type Name Description MethodBase [] methods The methods. System.Collections.Generic.IDictionary < String , ITarget > args The arguments. MethodBase resolvedMethod The resolved method. Returns Type Description ParameterBinding [] ParameterBinding[]. | Improve this Doc View Source BindWithRezolvedArguments(MethodBase) Creates parameter bindings for each parameter in the passed method where each value will be resolved. For any optional parameters - their default values will be used as a fallback if the ResolvedTarget cannot either resolve a target at compile time or from the IContainer at resolve-time. Declaration public static ParameterBinding[] BindWithRezolvedArguments(MethodBase method) Parameters Type Name Description MethodBase method Returns Type Description ParameterBinding [] | Improve this Doc View Source Resolve(ICompileContext) Fetch the target that would be bound to this parameter given the passed ICompileContext Declaration public virtual ITarget Resolve(ICompileContext context) Parameters Type Name Description ICompileContext context The current compile context - a new one is created for the Parameter type Returns Type Description ITarget The target that should be used for the parameter, or null if no target could be found. Note that if the returned target's UseFallback property is set to true , then it means either the parameter's default value is being used, or that the target fetched from the target container in the context is a stub (e.g. empty enumerable) Remarks During compilation - you should not use the target returned by this function as a direct part of your expression tree - you should"
  },
  "api/Rezolver.ObjectTargetContainerExtensions.html": {
    "href": "api/Rezolver.ObjectTargetContainerExtensions.html",
    "title": "Class ObjectTargetContainerExtensions | Rezolver IOC",
    "keywords": "Class ObjectTargetContainerExtensions Extensions for ITargetContainer relating to registering concrete instances via the ObjectTarget target. Inheritance Object ObjectTargetContainerExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class ObjectTargetContainerExtensions Methods | Improve this Doc View Source RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) Registers an instance to be used when resolve a particular service type via the ObjectTarget Declaration public static void RegisterObject(this ITargetContainer targetContainer, object obj, Type declaredType = null, Type serviceType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description ITargetContainer targetContainer The target container which will receive the registration. Object obj Required, but can be null . The instance that will be resolved when the service type is requested. Type declaredType Type to be set as the DeclaredType of the ObjectTarget that is created for obj , if different from the object's type. Type serviceType The service type against which this object is to be registered, if different from declaredType (or the object's type). ScopeBehaviour scopeBehaviour Sets the ScopeBehaviour for the ObjectTarget that's created Remarks null objects are implicitly treated as Object if declaredType is not passed. | Improve this Doc View Source RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) Registers an instance to be used when resolving a particular service type via the ObjectTarget target. Declaration public static void RegisterObject<T>(this ITargetContainer targetContainer, T obj, Type declaredType = null, Type serviceType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description ITargetContainer targetContainer The target container which will receive the registration. T obj The instance that will be resolved when the service type is requested. Type declaredType Type to be set as the DeclaredType of the ObjectTarget that is created for obj , if different from T . Type serviceType The service type against which this object is to be registered, if different from T . ScopeBehaviour scopeBehaviour Sets the ScopeBehaviour for the ObjectTarget that's created Type Parameters Name Description T Type of the object - will be used as the service type for registration if serviceType is not provied. Remarks By default, the DeclaredType of the ObjectTarget that is created is fixed to T - use the declaredType parameter to override this if T is a less specific type than the one for which you wish to create a registration."
  },
  "api/Rezolver.MultipleTargetContainerExtensions.html": {
    "href": "api/Rezolver.MultipleTargetContainerExtensions.html",
    "title": "Class MultipleTargetContainerExtensions | Rezolver IOC",
    "keywords": "Class MultipleTargetContainerExtensions Extensions for registering multiple targets individually and against the same type Inheritance Object MultipleTargetContainerExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class MultipleTargetContainerExtensions Methods | Improve this Doc View Source RegisterAll(ITargetContainer, ITarget[]) Performs the same operations as RegisterAll(ITargetContainer, IEnumerable<ITarget>) except via a variable number of ITarget arguments. Declaration public static void RegisterAll(this ITargetContainer targetContainer, params ITarget[] targets) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registrations are to be performed. ITarget [] targets The targets to be registered. | Improve this Doc View Source RegisterAll(ITargetContainer, IEnumerable<ITarget>) Batch-registers multiple targets against their DeclaredType . This is the same as calling Register(ITarget, Type) for each of the targets , except the type cannot be overriden from the target's DeclaredType. Declaration public static void RegisterAll(this ITargetContainer targetContainer, IEnumerable<ITarget> targets) Parameters Type Name Description ITargetContainer targetContainer The target container on which the registrations are to be performed. System.Collections.Generic.IEnumerable < ITarget > targets The targets to be registered | Improve this Doc View Source RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) Called to register multiple targets against the same type. It is the same as calling Register(ITarget, Type) multiple times with the different targets. Declaration public static void RegisterMultiple(this ITargetContainer targetContainer, IEnumerable<ITarget> targets, Type commonServiceType = null) Parameters Type Name Description ITargetContainer targetContainer The container on which the registration is to be performed. System.Collections.Generic.IEnumerable < ITarget > targets The targets to be registered - all must support a common service type (potentially passed in the commonServiceType argument. Type commonServiceType Optional - if provided, then this will be used as the common service type for registration. If not provided, then the DeclaredType of the first target will be used. Remarks If the container has the capability to create enumerables automatically (enabled by the InjectEnumerables target container behaviour - which is switched on by default) then each target will be returned when an IEnumerable of the common service type is requested."
  },
  "api/Rezolver.Targets.OptionalParameterTarget.html": {
    "href": "api/Rezolver.Targets.OptionalParameterTarget.html",
    "title": "Class OptionalParameterTarget | Rezolver IOC",
    "keywords": "Class OptionalParameterTarget Used specifically when binding arguments to method parameters when a parameter is optional and its default value is to be used when binding to it. It is highly unlikely you'll ever create one of these directly. Inheritance Object TargetBase OptionalParameterTarget Implements ITarget Inherited Members TargetBase.Id TargetBase.ScopePreference TargetBase.SupportsType(Type) TargetBase.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Targets Assembly : Rezolver.dll Syntax public class OptionalParameterTarget : TargetBase, ITarget Constructors | Improve this Doc View Source OptionalParameterTarget(ParameterInfo) Constructs a new instance of the OptionalParameterTarget class. Declaration public OptionalParameterTarget(ParameterInfo methodParameter) Parameters Type Name Description ParameterInfo methodParameter Required - parameter to which this target will be bound. Its IsOptional property must be true otherwise an ArgumentException is thrown. Properties | Improve this Doc View Source DeclaredType Always returns the ParameterType of the MethodParameter Declaration public override Type DeclaredType { get; } Property Value Type Description Type Overrides TargetBase.DeclaredType | Improve this Doc View Source MethodParameter The parameter to which this target is bound. Declaration public ParameterInfo MethodParameter { get; } Property Value Type Description ParameterInfo | Improve this Doc View Source ScopeBehaviour Always returns None Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour | Improve this Doc View Source UseFallback Always returns true, since using a default argument of a parameter is always considered to be a last-resort. Declaration public override bool UseFallback { get; } Property Value Type Description Boolean Overrides TargetBase.UseFallback | Improve this Doc View Source Value Gets the value represented by this target. This is either the default value of the MethodParameter , if applicable, or the default for the parameter type. Declaration public object Value { get; } Property Value Type Description Object The value. Implements ITarget Extension Methods Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget)"
  },
  "api/Rezolver.Targets.ObjectTarget.html": {
    "href": "api/Rezolver.Targets.ObjectTarget.html",
    "title": "Class ObjectTarget | Rezolver IOC",
    "keywords": "Class ObjectTarget Implements ITarget by wrapping a single instance that's already been constructed by application code. Inheritance Object TargetBase ObjectTarget Implements ICompiledTarget ITarget Inherited Members TargetBase.Id TargetBase.UseFallback TargetBase.SupportsType(Type) TargetBase.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Targets Assembly : Rezolver.dll Syntax public class ObjectTarget : TargetBase, ICompiledTarget, IDirectTarget, ITarget Constructors | Improve this Doc View Source ObjectTarget(Object, Type, ScopeBehaviour) Creates a new instance of the ObjectTarget class. Declaration public ObjectTarget(object obj, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description Object obj The object to be returned by this target when resolved. Type declaredType Optional. The declared type of this target, if different from the absolute type of the obj ScopeBehaviour scopeBehaviour Optional. If you want the object to be disposed by Rezolver when the root scope is disposed, then specify a behaviour other than the default. Note - the only real behaviour that makes sense for this is Explicit , since the Implicit behaviour will typically fool a scope that multiple instances are being created and, therefore, the object will be tracked multiple times by that scope. Remarks Please note - if you enable scope tracking, but the object is never resolved, then the object will not be disposed and you will need to ensure you dispose of it. Properties | Improve this Doc View Source DeclaredType Gets the declared type of object that is returned by this target. Might be different from the type of Value if explicitly defined when this target was constructed. Declaration public override Type DeclaredType { get; } Property Value Type Description Type The type of the declared. Overrides TargetBase.DeclaredType | Improve this Doc View Source ScopeBehaviour Gets the scope behaviour. Declaration public override ScopeBehaviour ScopeBehaviour { get; } Property Value Type Description ScopeBehaviour The scope behaviour. Overrides TargetBase.ScopeBehaviour | Improve this Doc View Source ScopePreference Always returns Root Declaration public override ScopePreference ScopePreference { get; } Property Value Type Description ScopePreference Overrides TargetBase.ScopePreference | Improve this Doc View Source Value Gets the value that will be exposed by expressions built by this instance. Declaration public object Value { get; } Property Value Type Description Object The value. Explicit Interface Implementations | Improve this Doc View Source ICompiledTarget.GetObject(IResolveContext) Declaration object ICompiledTarget.GetObject(IResolveContext context) Parameters Type Name Description IResolveContext context Returns Type Description Object | Improve this Doc View Source ICompiledTarget.SourceTarget Declaration ITarget ICompiledTarget.SourceTarget { get; } Returns Type Description ITarget Implements ICompiledTarget ITarget Extension Methods UnresolvedICompiledTargetExtensions.IsUnresolved(ICompiledTarget) Target.Scoped(ITarget) Target.Unscoped(ITarget) Target.Singleton(ITarget) Target.As(ITarget, Type) Target.As<T>(ITarget)"
  },
  "api/Rezolver.Target.html": {
    "href": "api/Rezolver.Target.html",
    "title": "Class Target | Rezolver IOC",
    "keywords": "Class Target Provides static factory methods (including extension methods) for creating numerous types of targets from the Rezolver.Targets namespace. Inheritance Object Target Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class Target Remarks Although most of these methods create targets of a known type (e.g. Scoped(ITarget) returns a ScopedTarget ), the methods all return ITarget to allow for changes in implementation in the future. Methods | Improve this Doc View Source As(ITarget, Type) Extension method which creates a new ChangeTypeTarget that wraps the target , changing its DeclaredType to the targetType passed. Declaration public static ITarget As(this ITarget target, Type targetType) Parameters Type Name Description ITarget target Required. The target. Type targetType Required. The new type for the target . Returns Type Description ITarget | Improve this Doc View Source As<T>(ITarget) Extension method which creates a new ChangeTypeTarget that wraps the target , changing its DeclaredType to T . Declaration public static ITarget As<T>(this ITarget target) Parameters Type Name Description ITarget target Required. The target. Returns Type Description ITarget Type Parameters Name Description T | Improve this Doc View Source ForConstructor(ConstructorInfo, IMemberBindingBehaviour) Creates a ConstructorTarget for the given constructor, or a GenericConstructorTarget if the constructor belongs to a generic type definition ('open generic type'). Declaration public static ITarget ForConstructor(ConstructorInfo constructor, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ConstructorInfo constructor Required. The constructor to be bound by the target. IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on any target container in which the target is subsequently registered. Returns Type Description ITarget | Improve this Doc View Source ForConstructor(ConstructorInfo, ParameterBinding[], IMemberBindingBehaviour) Creates a ConstructorTarget for the given constructor, or a GenericConstructorTarget if the constructor belongs to a generic type definition ('open generic type'). Declaration public static ITarget ForConstructor(ConstructorInfo constructor, ParameterBinding[] parameterBindings, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ConstructorInfo constructor Required. The constructor to be bound by the target. ParameterBinding [] parameterBindings Can be null/empty. An array of ParameterBinding objects containing targets to be bound to somme or all of the constructor parameters. Must not be supplied if constructor is a constructor belonging to an open generic type, IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on any target container in which the target is subsequently registered. Returns Type Description ITarget | Improve this Doc View Source ForConstructor(ConstructorInfo, IDictionary<String, ITarget>, IMemberBindingBehaviour) Creates a ConstructorTarget for the given constructor, or a GenericConstructorTarget if the constructor belongs to a generic type definition ('open generic type'). Declaration public static ITarget ForConstructor(ConstructorInfo constructor, IDictionary<string, ITarget> namedArgs, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ConstructorInfo constructor Required. The constructor to be bound by the target. System.Collections.Generic.IDictionary < String , ITarget > namedArgs Can be null. A dictionary of targets that are to be bound to the constructor by name and DeclaredType . Must not be supplied if constructor is a constructor belonging to an open generic type, IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on any target container in which the target is subsequently registered. Returns Type Description ITarget | Improve this Doc View Source ForConstructor(ConstructorInfo, Object, IMemberBindingBehaviour) Creates a ConstructorTarget for the given constructor, or a GenericConstructorTarget if the constructor belongs to a generic type definition ('open generic type'). Declaration public static ITarget ForConstructor(ConstructorInfo constructor, object namedArgs, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description ConstructorInfo constructor Required. The constructor to be bound by the target. Object namedArgs Optional. An object whose publicly readable members which are of the type ITarget (or a type which implements it) are to be bound to the constructor by name and DeclaredType . Must not be supplied if constructor is a constructor belonging to an open generic type, IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on any target container in which the target is subsequently registered. Returns Type Description ITarget | Improve this Doc View Source ForDelegate(Delegate, Type) A simple wrapper for the DelegateTarget(Delegate, Type) constructor. Declaration public static ITarget ForDelegate(Delegate factory, Type declaredType = null) Parameters Type Name Description Delegate factory Required, the factory delegate that is to be used to produce an object. Type declaredType Optional. If not null, then it will be used as the target's DeclaredType which, in turn, is used as the target's default registration type if not overriden when added to an ITargetContainer . If null, then the return type of the factory will be used. Returns Type Description ITarget An ITarget which represents the passed factory. | Improve this Doc View Source ForDelegate<TResult>(Func<TResult>, Type) Creates a DelegateTarget for a parameterless factory delegate which returns an instance of TResult Declaration public static ITarget ForDelegate<TResult>(Func<TResult> factory, Type declaredType = null) Parameters Type Name Description System.Func <TResult> factory Required. The factory delegate that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description TResult The type of the object produced by the factory delegate. | Improve this Doc View Source ForDelegate<TResult>(Func<IResolveContext, TResult>, Type) Creates a DelegateTarget for a factory delegate which takes an IResolveContext and which returns an instance of TResult Declaration public static ITarget ForDelegate<TResult>(Func<IResolveContext, TResult> factory, Type declaredType = null) Parameters Type Name Description System.Func < IResolveContext , TResult> factory Required. The factory delegate that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description TResult The type of the object produced by the factory delegate. Remarks All arguments to the delegate are injected from the container when executed | Improve this Doc View Source ForDelegate<T1, TResult>(Func<T1, TResult>, Type) Creates a DelegateTarget for a factory delegate which takes 1 argument and which returns an instance of TResult Declaration public static ITarget ForDelegate<T1, TResult>(Func<T1, TResult> factory, Type declaredType = null) Parameters Type Name Description System.Func <T1, TResult> factory Required. The factory delegate that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st delegate parameter TResult The type of the object produced by the factory delegate. Remarks All arguments to the delegate are injected from the container when executed | Improve this Doc View Source ForDelegate<T1, T2, TResult>(Func<T1, T2, TResult>, Type) Creates a DelegateTarget for a factory delegate which takes 2 arguments and which returns an instance of TResult Declaration public static ITarget ForDelegate<T1, T2, TResult>(Func<T1, T2, TResult> factory, Type declaredType = null) Parameters Type Name Description System.Func <T1, T2, TResult> factory Required. The factory delegate that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st delegate parameter T2 Type of the 2nd delegate parameter TResult The type of the object produced by the factory delegate. Remarks All arguments to the delegate are injected from the container when executed | Improve this Doc View Source ForDelegate<T1, T2, T3, TResult>(Func<T1, T2, T3, TResult>, Type) Creates a DelegateTarget for a factory delegate which takes 3 arguments and which returns an instance of TResult Declaration public static ITarget ForDelegate<T1, T2, T3, TResult>(Func<T1, T2, T3, TResult> factory, Type declaredType = null) Parameters Type Name Description System.Func <T1, T2, T3, TResult> factory Required. The factory delegate that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st delegate parameter T2 Type of the 2nd delegate parameter T3 Type of the 3rd delegate parameter TResult The type of the object produced by the factory delegate. Remarks All arguments to the delegate are injected from the container when executed | Improve this Doc View Source ForDelegate<T1, T2, T3, T4, TResult>(Func<T1, T2, T3, T4, TResult>, Type) Creates a DelegateTarget for a factory delegate which takes 4 arguments and which returns an instance of TResult Declaration public static ITarget ForDelegate<T1, T2, T3, T4, TResult>(Func<T1, T2, T3, T4, TResult> factory, Type declaredType = null) Parameters Type Name Description System.Func <T1, T2, T3, T4, TResult> factory Required. The factory delegate that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st delegate parameter T2 Type of the 2nd delegate parameter T3 Type of the 3rd delegate parameter T4 Type of the 4th delegate parameter TResult The type of the object produced by the factory delegate. Remarks All arguments to the delegate are injected from the container when executed | Improve this Doc View Source ForDelegate<T1, T2, T3, T4, T5, TResult>(Func<T1, T2, T3, T4, T5, TResult>, Type) Creates a DelegateTarget for a factory delegate which takes 5 arguments and which returns an instance of TResult Declaration public static ITarget ForDelegate<T1, T2, T3, T4, T5, TResult>(Func<T1, T2, T3, T4, T5, TResult> factory, Type declaredType = null) Parameters Type Name Description System.Func <T1, T2, T3, T4, T5, TResult> factory Required. The factory delegate that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st delegate parameter T2 Type of the 2nd delegate parameter T3 Type of the 3rd delegate parameter T4 Type of the 4th delegate parameter T5 Type of the 5th delegate parameter TResult The type of the object produced by the factory delegate. Remarks All arguments to the delegate are injected from the container when executed | Improve this Doc View Source ForExpression(Expression, Type) A simple wrapper for the ExpressionTarget(Expression, Type) constructor. Declaration public static ITarget ForExpression(Expression expression, Type declaredType = null) Parameters Type Name Description Expression expression Required, the expression representing the code that is to be executed in order to produce an object. Type declaredType Optional. If not null, then it will be used as the target's DeclaredType which, in turn, is used as the target's default registration type if not overriden when added to an ITargetContainer . If null, then the Type will be used, unless expression is a LambdaExpression , in which case the Type of its Body will be used. Returns Type Description ITarget An ITarget which represents the given expression; which must be compiled or otherwise translated into a runtime operation which creates/obtains an object. | Improve this Doc View Source ForExpression<TResult>(Expression<Func<TResult>>, Type) Creates an ExpressionTarget for a parameterless lambda expression which returns an instance of TResult Declaration public static ITarget ForExpression<TResult>(Expression<Func<TResult>> lambda, Type declaredType = null) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func <TResult>> lambda Required. The lambda expression that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description TResult The return type of the lambda expression. | Improve this Doc View Source ForExpression<TResult>(Expression<Func<IResolveContext, TResult>>, Type) Creates an ExpressionTarget for a lambda expression which takes an IResolveContext and which returns an instance of TResult Declaration public static ITarget ForExpression<TResult>(Expression<Func<IResolveContext, TResult>> lambda, Type declaredType = null) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func < IResolveContext , TResult>> lambda Required. The lambda expression that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source ForExpression<T1, TResult>(Expression<Func<T1, TResult>>, Type) Creates an ExpressionTarget for a lambda expression which takes 1 argument and which returns an instance of TResult Declaration public static ITarget ForExpression<T1, TResult>(Expression<Func<T1, TResult>> lambda, Type declaredType = null) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func <T1, TResult>> lambda Required. The lambda expression that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source ForExpression<T1, T2, TResult>(Expression<Func<T1, T2, TResult>>, Type) Creates an ExpressionTarget for a lambda expression which takes 2 arguments and which returns an instance of TResult Declaration public static ITarget ForExpression<T1, T2, TResult>(Expression<Func<T1, T2, TResult>> lambda, Type declaredType = null) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func <T1, T2, TResult>> lambda Required. The lambda expression that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. T2 Type of the 2nd parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source ForExpression<T1, T2, T3, TResult>(Expression<Func<T1, T2, T3, TResult>>, Type) Creates an ExpressionTarget for a lambda expression which takes 3 arguments and which returns an instance of TResult Declaration public static ITarget ForExpression<T1, T2, T3, TResult>(Expression<Func<T1, T2, T3, TResult>> lambda, Type declaredType = null) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func <T1, T2, T3, TResult>> lambda Required. The lambda expression that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. T2 Type of the 2nd parameter of the lambda expression. T3 Type of the 3rd parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source ForExpression<T1, T2, T3, T4, TResult>(Expression<Func<T1, T2, T3, T4, TResult>>, Type) Creates an ExpressionTarget for a lambda expression which takes 4 arguments and which returns an instance of TResult Declaration public static ITarget ForExpression<T1, T2, T3, T4, TResult>(Expression<Func<T1, T2, T3, T4, TResult>> lambda, Type declaredType = null) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func <T1, T2, T3, T4, TResult>> lambda Required. The lambda expression that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. T2 Type of the 2nd parameter of the lambda expression. T3 Type of the 3rd parameter of the lambda expression. T4 Type of the 4th parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source ForExpression<T1, T2, T3, T4, T5, TResult>(Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type) Creates an ExpressionTarget for a lambda expression which takes 5 arguments and which returns an instance of TResult Declaration public static ITarget ForExpression<T1, T2, T3, T4, T5, TResult>(Expression<Func<T1, T2, T3, T4, T5, TResult>> lambda, Type declaredType = null) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func <T1, T2, T3, T4, T5, TResult>> lambda Required. The lambda expression that is to be wrapped by the target. Type declaredType Optional. The DeclaredType of the target to be created, if different from TResult Returns Type Description ITarget Type Parameters Name Description T1 Type of the 1st parameter of the lambda expression. T2 Type of the 2nd parameter of the lambda expression. T3 Type of the 3rd parameter of the lambda expression. T4 Type of the 4th parameter of the lambda expression. T5 Type of the 5th parameter of the lambda expression. TResult The return type of the lambda expression. Remarks All arguments to the lambda are injected from the container when compiled and executed | Improve this Doc View Source ForObject(Object, Type, ScopeBehaviour) Creates a new ObjectTarget for the passed object whose DeclaredType will either be set to object's type (obtained by calling System.Object.GetType() or declaredType , if it is passed non-null. Declaration public static ITarget ForObject(object object, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description Object object The @object to be wrapped by the new ObjectTarget Type declaredType Optional - will be used to set the DeclaredType of the target that is created. ScopeBehaviour scopeBehaviour The scope behaviour of the target if resolved inside an IContainerScope . Returns Type Description ITarget | Improve this Doc View Source ForObject<T>(T, Type, ScopeBehaviour) Creates a new ObjectTarget for the passed object whose DeclaredType will either be set to T or declaredType , if it is passed non-null. Declaration public static ITarget ForObject<T>(T object, Type declaredType = null, ScopeBehaviour scopeBehaviour = ScopeBehaviour.None) Parameters Type Name Description T object The @object to be wrapped by the new ObjectTarget Type declaredType Optional - will be used to set the DeclaredType of the target that is created. ScopeBehaviour scopeBehaviour The scope behaviour of the target if resolved inside an IContainerScope . Returns Type Description ITarget Type Parameters Name Description T Type of the object | Improve this Doc View Source ForType(Type, IMemberBindingBehaviour) Creates a ConstructorTarget or GenericConstructorTarget for the type type . Declaration public static ITarget ForType(Type type, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description Type type The type whose constructor is to be bound by the target. IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on any target container in which the target is subsequently registered. Returns Type Description ITarget A new target for the type type Remarks If the type is a generic type definition, then a GenericConstructorTarget is created; otherwise a ConstructorTarget is created. | Improve this Doc View Source ForType(Type, IDictionary<String, ITarget>, IMemberBindingBehaviour) Creates a ConstructorTarget or GenericConstructorTarget for the type type . Declaration public static ITarget ForType(Type type, IDictionary<string, ITarget> namedArgs, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description Type type The type whose constructor is to be bound by the target. System.Collections.Generic.IDictionary < String , ITarget > namedArgs Optional. A dictionary of targets that are to be bound to the type's constructor by name and type. If type is a generic type definition, then this parameter must be null, or an ArgumentException will be thrown. IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on any target container in which the target is subsequently registered. Returns Type Description ITarget A new target for the type type Remarks If the type is a generic type definition, then a GenericConstructorTarget is created; otherwise a ConstructorTarget is created. | Improve this Doc View Source ForType(Type, Object, IMemberBindingBehaviour) Creates a ConstructorTarget or GenericConstructorTarget for the type type . Declaration public static ITarget ForType(Type type, object namedArgs, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description Type type The type whose constructor is to be bound by the target. Object namedArgs Optional. An object whose publicly readable members which are of the type ITarget (or a type which implements it) are to be bound to the type's constructor by name and DeclaredType . If type is a generic type definition, then this parameter must be null, or an ArgumentException will be thrown. IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on any target container in which the target is subsequently registered. Returns Type Description ITarget Remarks If the type is a generic type definition, then a GenericConstructorTarget is created; otherwise a ConstructorTarget is created. Examples This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a ConstructorTarget for the type 'MyType': Target.ForType(typeof(MyType), namedArguments: new { param1 = new ObjectTarget(\" Hello World\") }); | Improve this Doc View Source ForType<T>(IMemberBindingBehaviour) Creates a ConstructorTarget for the type T . Declaration public static ITarget ForType<T>(IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on any target container in which the target is subsequently registered. Returns Type Description ITarget A new target for the type T Type Parameters Name Description T The type whose constructor is to be bound by the target. | Improve this Doc View Source ForType<T>(Action<IMemberBindingBehaviourBuilder<T>>) Creates a ConstructorTarget for the type T with an IMemberBindingBehaviour built from an IMemberBindingBehaviourBuilder<TInstance> that's configured by the configureMemberBinding callback. Declaration public static ITarget ForType<T>(Action<IMemberBindingBehaviourBuilder<T>> configureMemberBinding) Parameters Type Name Description System.Action < IMemberBindingBehaviourBuilder <T>> configureMemberBinding Will be called with a new instance of IMemberBindingBehaviourBuilder<TInstance> for you to configure any member bindings you wish to add to the target. Returns Type Description ITarget A new target for the type T Type Parameters Name Description T The type of object to be created by the target | Improve this Doc View Source ForType<T>(IDictionary<String, ITarget>, IMemberBindingBehaviour) Creates a ConstructorTarget or GenericConstructorTarget for the type T . Declaration public static ITarget ForType<T>(IDictionary<string, ITarget> namedArgs, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description System.Collections.Generic.IDictionary < String , ITarget > namedArgs Can be null. A dictionary of targets that are to be bound to the type's constructor by name and DeclaredType . If T is a generic type definition, then this parameter must be null, or an ArgumentException will be thrown. IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on any target container in which the target is subsequently registered. Returns Type Description ITarget A new target for the type T Type Parameters Name Description T The type whose constructor is to be bound by the target. | Improve this Doc View Source ForType<T>(IDictionary<String, ITarget>, Action<IMemberBindingBehaviourBuilder<T>>) Same as ForType<T>(IDictionary<String, ITarget>, IMemberBindingBehaviour) except this allows you to build a custom member binding behaviour using the fluent API exposed by the IMemberBindingBehaviourBuilder<TInstance> interface Declaration public static ITarget ForType<T>(IDictionary<string, ITarget> namedArgs, Action<IMemberBindingBehaviourBuilder<T>> configureMemberBinding) Parameters Type Name Description System.Collections.Generic.IDictionary < String , ITarget > namedArgs Can be null. A dictionary of targets that are to be bound to the type's constructor by name and DeclaredType . If T is a generic type definition, then this parameter must be null, or an ArgumentException will be thrown. System.Action < IMemberBindingBehaviourBuilder <T>> configureMemberBinding Will be called with a new instance of IMemberBindingBehaviourBuilder<TInstance> for you to configure any member bindings you wish to add to the target. Returns Type Description ITarget A new target for the type T Type Parameters Name Description T The type whose constructor is to be bound by the target. | Improve this Doc View Source ForType<T>(Object, IMemberBindingBehaviour) Creates a ConstructorTarget or GenericConstructorTarget for the type T . Declaration public static ITarget ForType<T>(object namedArgs, IMemberBindingBehaviour memberBinding = null) Parameters Type Name Description Object namedArgs Optional. An object whose publicly readable members which are of the type ITarget (or a type which implements it) are to be bound to the type's constructor by name and DeclaredType . IMemberBindingBehaviour memberBinding Optional - provides an explicit member injection behaviour to be used when creating the instance, if different from the behaviour configured via options on any target container in which the target is subsequently registered. Returns Type Description ITarget A new target for the type T Type Parameters Name Description T The type whose constructor is to be bound by the created target. Examples This example shows how to provide an ObjectTarget for the parameter 'param1' when creating a ConstructorTarget for the type 'MyType': Target.ForType<MyType>(namedArguments: new { param1 = new ObjectTarget(\"Hello World\") }); | Improve this Doc View Source ForType<T>(Object, Action<IMemberBindingBehaviourBuilder<T>>) Same as ForType<T>(Object, IMemberBindingBehaviour) except this lets you build a custom IMemberBindingBehaviour using the fluent API offered by the IMemberBindingBehaviourBuilder<TInstance> interface. Declaration public static ITarget ForType<T>(object namedArgs, Action<IMemberBindingBehaviourBuilder<T>> configureMemberBinding) Parameters Type Name Description Object namedArgs Optional. An objeect whose publicly readable members which are of the type ITarget (or a type which implements it) are to be bound to the type's constructor by name and DeclaredType . System.Action < IMemberBindingBehaviourBuilder <T>> configureMemberBinding Will be called with a new instance of IMemberBindingBehaviourBuilder<TInstance> for you to configure any member bindings you wish to add to the target. Returns Type Description ITarget A new target for the type T Type Parameters Name Description T The type whose constructor is to be bound by the created target. | Improve this Doc View Source Resolved(Type, ITarget) Creates a ResolvedTarget for the given type, providing a way to call back into the container during the execution of another target. Declaration public static ITarget Resolved(Type type, ITarget fallbackTarget = null) Parameters Type Name Description Type type Required. The type to be resolved from the container. ITarget fallbackTarget Optional. If provided and the container is unable to resolve the type , then this target is used instead. Returns Type Description ITarget An ITarget . | Improve this Doc View Source Resolved<T>(ITarget) Generic version of Resolved(Type, ITarget) - creates a ResolvedTarget for the given type, providing a way to callback into the container during the execution of another target. Declaration public static ITarget Resolved<T>(ITarget fallbackTarget = null) Parameters Type Name Description ITarget fallbackTarget Optional. If provided and the container is unable to resolve the T , then this target is used instead Returns Type Description ITarget An ITarget which represents the act of resolving a particular type from the container. Type Parameters Name Description T The type to be resolved from the container. | Improve this Doc View Source Scoped(ITarget) Extension method which creates a ScopedTarget from the target on which this method is invoked. Declaration public static ITarget Scoped(this ITarget target) Parameters Type Name Description ITarget target Returns Type Description ITarget | Improve this Doc View Source Singleton(ITarget) Extension method which constructs a SingletonTarget that wraps the target on which the method is invoked. Declaration public static ITarget Singleton(this ITarget target) Parameters Type Name Description ITarget target Returns Type Description ITarget | Improve this Doc View Source Unscoped(ITarget) Extension method which creates an UnscopedTarget from the target on which this method is invoked. Declaration public static ITarget Unscoped(this ITarget target) Parameters Type Name Description ITarget target The target. Returns Type Description ITarget"
  },
  "api/Rezolver.ScopeBehaviour.html": {
    "href": "api/Rezolver.ScopeBehaviour.html",
    "title": "Enum ScopeBehaviour | Rezolver IOC",
    "keywords": "Enum ScopeBehaviour Describes different ways in which objeects interact with scopes. Namespace : Rezolver Assembly : Rezolver.dll Syntax public enum ScopeBehaviour Remarks Note: this enum might be replaced with an abstraction in the future. If so, it will not alter how regatrations are performed, but it will affect any low-level code which uses this enum directly. Fields Name Description Explicit Explicitly scoped objects act like singletons in the current scope, regardless of whether they are disposable or not. Implicit Implicitly scoped objects are only added to the scope for the purposes of disposing when the scope is disposed None The object will not be tracked in any scope, regardless of whether there is one active, or whether the object is disposable."
  },
  "api/Rezolver.Runtime.html": {
    "href": "api/Rezolver.Runtime.html",
    "title": "Namespace Rezolver.Runtime | Rezolver IOC",
    "keywords": "Namespace Rezolver.Runtime Classes EagerEnumerable<T> Direct implementation of System.Collections.Generic.IEnumerable<T> for eagerly loaded enumerables when LazyEnumerables has been disabled either globally, or for a specific enumerable's element type. Rezolver uses this type instead of an array to prevent casting and modifying the contents of the enumerable. GenericTypeMapping Result returned from the MapType(Type) function. Represents various levels of success - from a completely incompatible mapping ( Success = false ), or a successful mapping from an open generic type to a closed generic type which can then be constructed ( Success = true and IsFullyBound = true ) or, a successful mapping from an open generic type to another open generic type ( Success = true but IsFullyBound = false ). This mapping is then used by both the SupportsType(Type) and Bind(ICompileContext) functions. Only fully bound mappings are supported by Bind(ICompileContext) , whereas SupportsType(Type) will return true so long as the Success is true. The caller, therefore, must ensure it is aware of the difference between open and closed generics. LazyEnumerable<T> Can be used as an implementation of System.Collections.Generic.IEnumerable<T> when injecting enumerables from one or more registered targets."
  },
  "api/Rezolver.Options.html": {
    "href": "api/Rezolver.Options.html",
    "title": "Namespace Rezolver.Options | Rezolver IOC",
    "keywords": "Namespace Rezolver.Options Classes AllowMultiple A Boolean option that controls whether an ITargetContainer accepts multiple registered targets for the same underlying type. This option can be applied globally or on a per-service basis - but must be set before any potentially affected registrations are performed. The Default (unset) is equivalent to true ContainerOption<TOption> A suggested base class to use for custom container options to be read/written through the OptionsTargetContainerExtensions extension methods. The type of the option value is the argument to the TOption type parameter. Options must currently be objects - the ability to use callbacks to get options might be added at a future date. EnableArrayInjection Controls whether Rezolver's built-in array injection (which is also dependent upon the built-in IEnumerable injection) is enabled. If not defined the Default is equivalent to true . EnableCollectionInjection Boolean option which, if configured before the InjectCollections configuration is applied, will control whether automatic injection of ReadOnlyCollection<T> (and related interfaces - see the documentation on that type for more) will be enabled. The Default is equivalent to true . EnableContravariance A Boolean container options that controls whether contravariant generic parameters will be matched to registrations of bases/interfaces of the associated type. This option can be applied globally or on a per-service basis. See the remarks section for more. The Default (unset) is equivalent to true , meaning that contravariance is enabled, for all applicable types. EnableEnumerableCovariance Option that controls whether or not auto-injected enumerables - either globally, or for a given type - will perform covariant searches when locating targets to be included in the enumerable. The Default is equivalent to true . EnableEnumerableInjection Controls whether the DefaultConfig will enable automatically injected enumerables or not. EnableGlobalOptions A Boolean container option which controls whether per-service options will fall back to a global option if not explicitly set. The Default (unconfigured) is true . EnableListInjection Boolean option which, if configured before the InjectLists configuration is applied, will control whether automatic injection of List<T> (and related interfaces - see the documentation on that type for more) will be enabled. The Default is equivalent to true . FetchAllMatchingGenerics A boolean option for target containers that controls which registrations will be returned when FetchAll(Type) is called with a closed generic type, when using the built in target containers. This ultimately affects the objects that are materialised in automatically generated enumerables (when the InjectEnumerables is enabled - which it is, by default) when the element type is itself a generic type. LazyEnumerables Controls whether the enumerables which are automatically generated by the container, when the InjectEnumerables configuration is used and enabled, are evaluated lazily or eagerly."
  },
  "api/Rezolver.Options.LazyEnumerables.html": {
    "href": "api/Rezolver.Options.LazyEnumerables.html",
    "title": "Class LazyEnumerables | Rezolver IOC",
    "keywords": "Class LazyEnumerables Controls whether the enumerables which are automatically generated by the container, when the InjectEnumerables configuration is used and enabled, are evaluated lazily or eagerly. Inheritance Object ContainerOption < Boolean > LazyEnumerables Inherited Members ContainerOption<Boolean>.Value ContainerOption<Boolean>.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Options Assembly : Rezolver.dll Syntax public class LazyEnumerables : ContainerOption<bool> Remarks A lazily evaluated enumerable will generate new instances (if not otherwise controlled by singleton/scoped lifetimes) every time it is enumerated. Eagerly evaluted enumerables do not. Properties | Improve this Doc View Source Default The default value for this option - equivalent to true Declaration public static LazyEnumerables Default { get; } Property Value Type Description LazyEnumerables Operators | Improve this Doc View Source Implicit(Boolean to LazyEnumerables) Convenience casting operator from Boolean to LazyEnumerables to simplify integration of the option type into logic statements. Declaration public static implicit operator LazyEnumerables(bool value) Parameters Type Name Description Boolean value Returns Type Description LazyEnumerables"
  },
  "api/Rezolver.Options.EnableEnumerableInjection.html": {
    "href": "api/Rezolver.Options.EnableEnumerableInjection.html",
    "title": "Class EnableEnumerableInjection | Rezolver IOC",
    "keywords": "Class EnableEnumerableInjection Controls whether the DefaultConfig will enable automatically injected enumerables or not. Inheritance Object ContainerOption < Boolean > EnableEnumerableInjection Inherited Members ContainerOption<Boolean>.Value ContainerOption<Boolean>.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Rezolver.Options Assembly : Rezolver.dll Syntax public class EnableEnumerableInjection : ContainerOption<bool> Properties | Improve this Doc View Source Default The default value for this option - equivalent to true Declaration public static EnableEnumerableInjection Default { get; } Property Value Type Description EnableEnumerableInjection Operators | Improve this Doc View Source Implicit(Boolean to EnableEnumerableInjection) Convenience operator for creating an instance of this option from a Boolean value. Declaration public static implicit operator EnableEnumerableInjection(bool value) Parameters Type Name Description Boolean value Returns Type Description EnableEnumerableInjection"
  },
  "api/Rezolver.MemberBindingBehaviour.html": {
    "href": "api/Rezolver.MemberBindingBehaviour.html",
    "title": "Class MemberBindingBehaviour | Rezolver IOC",
    "keywords": "Class MemberBindingBehaviour Static accessor for the common member binding behaviours provided by Rezolver, also provides an entry point to build custom binding behaviours using the fluent API exposed by IMemberBindingBehaviourBuilder<TInstance> and MemberBindingBuilder<TInstance, TMember> - via the For<TInstance>() method. Inheritance Object MemberBindingBehaviour Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class MemberBindingBehaviour Remarks The ConstructorTarget and GenericConstructorTarget classes can be provided with an IMemberBindingBehaviour when created. If one is not set, then instead they will attempt to get their behaviour via the options API (see OptionsTargetContainerExtensions ) from the ITargetContainer in which they have been registered. Properties | Improve this Doc View Source BindAll A behaviour that binds all publicly writeable properties and fields on an object after construction, include all read-only properties which can be initialised as collections via a public Add method. Declaration public static IMemberBindingBehaviour BindAll { get; } Property Value Type Description IMemberBindingBehaviour Remarks The implementation is an instance of the BindAllMembersBehaviour | Improve this Doc View Source BindFields A behaviour which binds only public fields on an object after construction. Declaration public static IMemberBindingBehaviour BindFields { get; } Property Value Type Description IMemberBindingBehaviour | Improve this Doc View Source BindNone A behaviour that doesn't bind any properties or fields on an object. This is also the Declaration public static IMemberBindingBehaviour BindNone { get; } Property Value Type Description IMemberBindingBehaviour Remarks The implementation is an instance of the BindNoMembersBehaviour | Improve this Doc View Source BindProperties A behaviour which binds only publicly writeable properties, and read-only collection properties, on an object after construction. Declaration public static IMemberBindingBehaviour BindProperties { get; } Property Value Type Description IMemberBindingBehaviour Methods | Improve this Doc View Source For<TInstance>() Creates a new IMemberBindingBehaviourBuilder<TInstance> which provides a way to build your own custom binding behaviour via a fluent API. Declaration public static IMemberBindingBehaviourBuilder<TInstance> For<TInstance>() Returns Type Description IMemberBindingBehaviourBuilder <TInstance> Type Parameters Name Description TInstance The type for which you want to build a custom member binding behaviour."
  },
  "api/Rezolver.MemberBinding.html": {
    "href": "api/Rezolver.MemberBinding.html",
    "title": "Class MemberBinding | Rezolver IOC",
    "keywords": "Class MemberBinding Represents the binding of an ITarget to a property or field of a given type. Not to be confused with the type of the same name from the System.Linq.Expressions namespace, although they are technically equivalent. Inheritance Object MemberBinding ListMemberBinding Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class MemberBinding Remarks You typically don't create this type directly - instead, other targets such as ConstructorTarget will create it as needed through the use of an IMemberBindingBehaviour object. Constructors | Improve this Doc View Source MemberBinding(MemberInfo, ITarget) Initializes a new instance of the MemberBinding class. Declaration public MemberBinding(MemberInfo member, ITarget target) Parameters Type Name Description MemberInfo member The member to be bound. ITarget target The target whose value will be written to the member. | Improve this Doc View Source MemberBinding(MemberInfo, Type) Declaration public MemberBinding(MemberInfo member, Type resolveType = null) Parameters Type Name Description MemberInfo member Type resolveType Fields | Improve this Doc View Source None Empty bindings. Declaration public static readonly MemberBinding[] None Field Value Type Description MemberBinding [] Properties | Improve this Doc View Source Member Gets the member against which this binding is to be applied. Declaration public MemberInfo Member { get; } Property Value Type Description MemberInfo The member. | Improve this Doc View Source MemberType Gets the type of the Member . E.g. if the member represents a String property on the declaring type, then this will return the String type. If the member represents an integer field, this it will return the Int32 type. Declaration public Type MemberType { get; } Property Value Type Description Type The type of the member. | Improve this Doc View Source Target Gets the target whose value when resolved will be written to the Member Declaration public ITarget Target { get; } Property Value Type Description ITarget The target."
  },
  "api/Rezolver.IOptionForAnyGeneric.html": {
    "href": "api/Rezolver.IOptionForAnyGeneric.html",
    "title": "Interface IOptionForAnyGeneric | Rezolver IOC",
    "keywords": "Interface IOptionForAnyGeneric Used as a marker service type for GetOption when a service type is any generic. Allows options to be defined for any generic type instead of specific generics. Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface IOptionForAnyGeneric"
  },
  "api/Rezolver.IMemberBindingBehaviourBuilder-1.html": {
    "href": "api/Rezolver.IMemberBindingBehaviourBuilder-1.html",
    "title": "Interface IMemberBindingBehaviourBuilder<TInstance> | Rezolver IOC",
    "keywords": "Interface IMemberBindingBehaviourBuilder<TInstance> Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface IMemberBindingBehaviourBuilder<TInstance> Type Parameters Name Description TInstance Methods | Improve this Doc View Source Bind<TMember>(Expression<Func<TInstance, TMember>>) Declaration MemberBindingBuilder<TInstance, TMember> Bind<TMember>(Expression<Func<TInstance, TMember>> memberBindingExpression) Parameters Type Name Description System.Linq.Expressions.Expression < System.Func <TInstance, TMember>> memberBindingExpression Returns Type Description MemberBindingBuilder <TInstance, TMember> Type Parameters Name Description TMember | Improve this Doc View Source BuildBehaviour() Declaration IMemberBindingBehaviour BuildBehaviour() Returns Type Description IMemberBindingBehaviour"
  },
  "api/Rezolver.DecoratorTargetContainerExtensions.html": {
    "href": "api/Rezolver.DecoratorTargetContainerExtensions.html",
    "title": "Class DecoratorTargetContainerExtensions | Rezolver IOC",
    "keywords": "Class DecoratorTargetContainerExtensions Extensions for ITargetContainer which simplify the registration of decorators (via the DecoratingTargetContainer pseudo-target) Inheritance Object DecoratorTargetContainerExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class DecoratorTargetContainerExtensions Methods | Improve this Doc View Source RegisterDecorator(IRootTargetContainer, Delegate, Type) Registers a delegate to be executed every time an instance of decoratedType is produced by the container. This is ultimately the same as the RegisterDecorator<TDecorated>(IRootTargetContainer, Func<TDecorated, TDecorated>) method except this allows you to pass delegates with more parameters than the one that that overload provides. The delegate's return type must be equal to decoratedType Declaration public static void RegisterDecorator(this IRootTargetContainer targetContainer, Delegate decoratorDelegate, Type decoratedType) Parameters Type Name Description IRootTargetContainer targetContainer The container into which the decorator will be registered. Delegate decoratorDelegate The delegate to be executed every time an instance of decoratedType is produced by the container, and whose result will be used in place of the original object (which is fed into the delegate). Type decoratedType The type of object whose creation is being decorated by the delegate. | Improve this Doc View Source RegisterDecorator(IRootTargetContainer, Type, Type) Registers a decorator container which will cause all instances of decoratedType to be decorated with the type decoratorType . Any existing registrations for decoratedType will be decorated correctly, and subsequent registrations of decoratedType will also be decorated as expected. Declaration public static void RegisterDecorator(this IRootTargetContainer targetContainer, Type decoratorType, Type decoratedType) Parameters Type Name Description IRootTargetContainer targetContainer The container into which the decorator will be registered. Type decoratorType The type to be used as the decorator implementation Type decoratedType The type which will be decorated by decoratorType . | Improve this Doc View Source RegisterDecorator<TDecorated>(IRootTargetContainer, Delegate) Registers a decorator container which will cause all instances of the type TDecorated produced by the container to be intercepted and replaced by the result of calling the passed decoratorDelegate with the original instance. Declaration public static void RegisterDecorator<TDecorated>(this IRootTargetContainer targetContainer, Delegate decoratorDelegate) Parameters Type Name Description IRootTargetContainer targetContainer The container into which the decorator will be registered. Delegate decoratorDelegate The delegate to be executed every time an instance of TDecorated is produced by the container, and whose result will be used in place of the original object (which is fed into the delegate). Type Parameters Name Description TDecorated The type of object whose creation is being decorated by the delegate. Remarks Whilst this overload uses the term 'Decorator' in its name, it is of course entirely possible that the delegate won't actually create a decorating instance for the input object. As a result, it's better to think of this as decorating Rezolver's own process of getting an object, which may or may not result in a decorated instance - depending on what the delegate actually does. What this does allow, however, is decorating objects which otherwise can't be decorated by constructor injection - e.g. Arrays, delegate types, primitive objects (e.g. Int32 ) and so on. | Improve this Doc View Source RegisterDecorator<TDecorated>(IRootTargetContainer, Func<TDecorated, TDecorated>) Registers a decorator container which will cause all instances of the type TDecorated produced by the container to be intercepted and replaced by the result of calling the passed decoratorDelegate with the original instance. Declaration public static void RegisterDecorator<TDecorated>(this IRootTargetContainer targetContainer, Func<TDecorated, TDecorated> decoratorDelegate) Parameters Type Name Description IRootTargetContainer targetContainer The container into which the decorator will be registered. System.Func <TDecorated, TDecorated> decoratorDelegate The delegate to be executed every time an instance of TDecorated is produced by the container, and whose result will be used in place of the original object (which is fed into the delegate). Type Parameters Name Description TDecorated The type of object whose creation is being decorated by the delegate. Remarks Whilst this overload uses the term 'Decorator' in its name, it is of course entirely possible that the delegate won't actually create a decorating instance for the input object. As a result, it's better to think of this as decorating Rezolver's own process of getting an object, which may or may not result in a decorated instance - depending on what the delegate actually does. What this does allow, however, is decorating objects which otherwise can't be decorated by constructor injection - e.g. Arrays, delegate types, primitive objects (e.g. Int32 ) and so on. | Improve this Doc View Source RegisterDecorator<TDecorator, TDecorated>(IRootTargetContainer) Registers a decorator container which will cause all instances of TDecorated to be decorated with the type TDecorator . Any existing registrations for TDecorated will be decorated correctly, and subsequent registrations of TDecorated will also be decorated as expected. Declaration public static void RegisterDecorator<TDecorator, TDecorated>(this IRootTargetContainer targetContainer) Parameters Type Name Description IRootTargetContainer targetContainer The container into which the decorator will be registered. Type Parameters Name Description TDecorator The type to be used as the decorator implementation TDecorated The type which will be decorated by TDecorator ."
  },
  "api/Rezolver.Configuration.ExpressionCompilation.html": {
    "href": "api/Rezolver.Configuration.ExpressionCompilation.html",
    "title": "Class ExpressionCompilation | Rezolver IOC",
    "keywords": "Class ExpressionCompilation Implementation of IContainerConfig which configures expression-based compilation for targets in containers. The implementation sets all options and registers all the targets necessary to use the expression tree-based compilation provided by the ExpressionCompiler This is included in the DefaultConfig , meaning that all containers created without a specific config will automatically be configured to use the ExpressionCompiler . Inheritance Object ExpressionCompilation Implements IContainerConfig < ITargetCompiler > IContainerConfig Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Configuration Assembly : Rezolver.dll Syntax public class ExpressionCompilation : IContainerConfig<ITargetCompiler>, IContainerConfig Properties | Improve this Doc View Source Instance The one and only instance of ExpressionCompilation Declaration public static IContainerConfig<ITargetCompiler> Instance { get; } Property Value Type Description IContainerConfig < ITargetCompiler > Methods | Improve this Doc View Source Configure(IContainer, IRootTargetContainer) Implements the Configure(IContainer, IRootTargetContainer) method, registering all the targets necessary to use expression-based compilation for all the standard targets defined in the Rezolver core library. Declaration public virtual void Configure(IContainer container, IRootTargetContainer targets) Parameters Type Name Description IContainer container The container - ignored. IRootTargetContainer targets Required - the target container into which the various targets will be registered. Remarks All targets registered by this function are ObjectTarget targets backed by concrete instances of the various components (compiler etc). Implements IContainerConfig<T> IContainerConfig"
  },
  "api/Rezolver.Compilation.Expressions.RedundantConvertRewriter.html": {
    "href": "api/Rezolver.Compilation.Expressions.RedundantConvertRewriter.html",
    "title": "Class RedundantConvertRewriter | Rezolver IOC",
    "keywords": "Class RedundantConvertRewriter Removes unnecessary convert expressions from an expression. An unnecessary conversion is one where the target type is equal to, or a base of, the source type. Only boxing/unboxing conversions or upcasts are left intact. Inheritance Object ExpressionVisitor RedundantConvertRewriter Inherited Members System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection<System.Linq.Expressions.Expression>) System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression) System.Linq.Expressions.ExpressionVisitor.Visit<T>(System.Collections.ObjectModel.ReadOnlyCollection<T>, System.Func<T, T>) System.Linq.Expressions.ExpressionVisitor.VisitAndConvert<T>(T, System.String) System.Linq.Expressions.ExpressionVisitor.VisitAndConvert<T>(System.Collections.ObjectModel.ReadOnlyCollection<T>, System.String) System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression) System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression) System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock) System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression) System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression) System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression) System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression) System.Linq.Expressions.ExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression) System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit) System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression) System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression) System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression) System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression) System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression) System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget) System.Linq.Expressions.ExpressionVisitor.VisitLambda<T>(System.Linq.Expressions.Expression<T>) System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression) System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression) System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression) System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment) System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding) System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression) System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding) System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding) System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression) System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression) System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression) System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression) System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression) System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression) System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase) System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression) System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class RedundantConvertRewriter : ExpressionVisitor Methods | Improve this Doc View Source VisitUnary(UnaryExpression) Visits the children of the UnaryExpression . Declaration protected override Expression VisitUnary(UnaryExpression node) Parameters Type Name Description UnaryExpression node The expression to visit. Returns Type Description Expression Overrides System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression) See Also ExpressionVisitor"
  },
  "api/Rezolver.Compilation.Expressions.IExpressionBuilder-1.html": {
    "href": "api/Rezolver.Compilation.Expressions.IExpressionBuilder-1.html",
    "title": "Interface IExpressionBuilder<TTarget> | Rezolver IOC",
    "keywords": "Interface IExpressionBuilder<TTarget> Interface for an object that produces expressions from instances of TTarget . This is a generic extension to the IExpressionBuilder interface. Inherited Members IExpressionBuilder.CanBuild(ITarget) IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public interface IExpressionBuilder<in TTarget> : IExpressionBuilder Type Parameters Name Description TTarget The type of the target. Methods | Improve this Doc View Source Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target. Declaration Expression Build(TTarget target, IExpressionCompileContext context, IExpressionCompiler compiler = null) Parameters Type Name Description TTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the builder should attempt to fetch the compiler from the context; or throw an exception if it is required but not provided and cannot be resolved fromm the context. Returns Type Description Expression Remarks When invoked by the ExpressionCompiler class, the compiler parameter will always be provided. See Also IExpressionBuilder"
  },
  "api/Rezolver.Compilation.Expressions.ExpressionBuilderBase-1.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionBuilderBase-1.html",
    "title": "Class ExpressionBuilderBase<TTarget> | Rezolver IOC",
    "keywords": "Class ExpressionBuilderBase<TTarget> Abstract base class for implementations of IExpressionBuilder<TTarget> . Provide an implementation of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) and then register an instance in an ObjectTarget in the active container. Inheritance Object ExpressionBuilderBase ExpressionBuilderBase<TTarget> ChangeTypeTargetBuilder CompiledTargetBuilder ConstructorTargetBuilder DecoratorTargetBuilder DefaultTargetBuilder DelegateTargetBuilder EnumerableTargetBuilder ExpressionTargetBuilder GenericConstructorTargetBuilder ListTargetBuilder ObjectTargetBuilder OptionalParameterTargetBuilder ProjectionTargetBuilder RezolvedTargetBuilder ScopedTargetBuilder SingletonTargetBuilder UnscopedTargetBuilder Implements IExpressionBuilder <TTarget> IExpressionBuilder Inherited Members ExpressionBuilderBase.GetContextCompiler(IExpressionCompileContext) ExpressionBuilderBase.BuildCore(ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.ApplyScoping(Expression, ITarget, IExpressionCompileContext, IExpressionCompiler) ExpressionBuilderBase.IExpressionBuilder.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public abstract class ExpressionBuilderBase<TTarget> : ExpressionBuilderBase, IExpressionBuilder<TTarget>, IExpressionBuilder Type Parameters Name Description TTarget The type of target for which this builder can build an expression. This should ideally be a type which directly implements ITarget - however, so long as the runtime type of all the targets which are fed to it do implement it, everything is fine. Remarks This is a generic extension of the ExpressionBuilderBase class, designed to simplify the process of implementating the IExpressionBuilder<TTarget> (and, by extension, IExpressionBuilder ) interface. This is the class from which most of the built-in expression builders derive, because the ExpressionCompiler , when asked to compile an expression, attempts to resolve an IExpressionBuilder<TTarget> whose TTarget is the same type as the target that needs compiling. Inheriting from ExpressionBuilderBase is more appropriate if your builder is capable of handling multiple types of ITarget - a scenario that's much less common. Note that this class' implementation of IExpressionBuilder<TTarget> is entirely explicit and non-virtual, the same as with its base class, hence the only way to build an expression via an instance of this class without exposing the behaviour to external callers yourself is via the interface. Methods | Improve this Doc View Source Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Builds an expression from the specified target for the given ICompileContext OVerride this to implement the compilation for your target type. Declaration protected abstract Expression Build(TTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description TTarget target The target whose expression is to be built. IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression | Improve this Doc View Source Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Overrides the abstract Build(ITarget, IExpressionCompileContext, IExpressionCompiler) (and seals it from further overrides); checks that target is an instance of TTarget (throwing an ArgumentException if not) and then calls this class' Build(TTarget, IExpressionCompileContext, IExpressionCompiler) abstract function. Declaration protected override sealed Expression Build(ITarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description ITarget target The target for which an expression is to be built. Must be an instance of TTarget . IExpressionCompileContext context The compilation context. IExpressionCompiler compiler The expression compiler to be used to build any other expressions for targets which might be required by the target . Note that unlike on the interface, where this parameter is optional, this will always be provided Returns Type Description Expression Overrides ExpressionBuilderBase.Build(ITarget, IExpressionCompileContext, IExpressionCompiler) Exceptions Type Condition ArgumentException target must be an instance of { typeof(TTarget) } ArgumentException If the passed target is not an instance of TTarget | Improve this Doc View Source CanBuild(ITarget) Determines whether this instance can build an expression from the specified target. This base implementation simply checks that the type of target is compatible with the type TTarget . Declaration public override bool CanBuild(ITarget target) Parameters Type Name Description ITarget target The target. Returns Type Description Boolean Overrides ExpressionBuilderBase.CanBuild(ITarget) Explicit Interface Implementations | Improve this Doc View Source IExpressionBuilder<TTarget>.Build(TTarget, IExpressionCompileContext, IExpressionCompiler) Builds the specified target. Declaration Expression IExpressionBuilder<TTarget>.Build(TTarget target, IExpressionCompileContext context, IExpressionCompiler compiler) Parameters Type Name Description TTarget target The target. IExpressionCompileContext context The context. IExpressionCompiler compiler Optional. The compiler that's requesting the expression; and which can be used to compile other targets within the target. If not provided, then the implementation attempts to locate the context compiler using the GetContextCompiler(IExpressionCompileContext) method, and will throw an InvalidOperationException if it cannot do so. Returns Type Description Expression Exceptions Type Condition ArgumentNullException target is null or context is null InvalidOperationException compiler is null and an IExpressionCompiler couldn't be resolved for the current context (via GetContextCompiler(IExpressionCompileContext) Implements IExpressionBuilder<TTarget> IExpressionBuilder See Also IExpressionBuilder <TTarget> ExpressionBuilderBase"
  },
  "api/Rezolver.Compilation.DelegatingCompiledTarget.html": {
    "href": "api/Rezolver.Compilation.DelegatingCompiledTarget.html",
    "title": "Class DelegatingCompiledTarget | Rezolver IOC",
    "keywords": "Class DelegatingCompiledTarget A reusable implementation of ICompiledTarget for when the compiled code for an ITarget can be represented by a delegate. Inheritance Object DelegatingCompiledTarget Implements ICompiledTarget Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation Assembly : Rezolver.dll Syntax public class DelegatingCompiledTarget : ICompiledTarget Constructors | Improve this Doc View Source DelegatingCompiledTarget(Func<IResolveContext, Object>, ITarget) Creates a new instance of the DelegatingCompiledTarget class. Declaration public DelegatingCompiledTarget(Func<IResolveContext, object> callback, ITarget sourceTarget) Parameters Type Name Description System.Func < IResolveContext , Object > callback Required. The delegate to be executed when GetObject(IResolveContext) is called. ITarget sourceTarget Required. The ITarget from which this DelegatingCompiledTarget is constructed. Properties | Improve this Doc View Source SourceTarget Implementation of SourceTarget Declaration public ITarget SourceTarget { get; } Property Value Type Description ITarget Methods | Improve this Doc View Source GetObject(IResolveContext) Implementation of GetObject(IResolveContext) - simply executes the delegate passed on construction. Declaration public object GetObject(IResolveContext context) Parameters Type Name Description IResolveContext context Returns Type Description Object Implements ICompiledTarget Extension Methods UnresolvedICompiledTargetExtensions.IsUnresolved(ICompiledTarget)"
  },
  "api/Rezolver.Compilation.html": {
    "href": "api/Rezolver.Compilation.html",
    "title": "Namespace Rezolver.Compilation | Rezolver IOC",
    "keywords": "Namespace Rezolver.Compilation Classes CompileContext Core implementation of ICompileContext . A root context (i.e. where ParentContext is null ; created via the CompileContext(IResolveContext, ITargetContainer, Type) constructor) is the starting point for all shared state, such as the Container and the compilation stack. The ITargetContainer implementation is done by decorating a new OverridingTargetContainer which wraps the actual target container which contains the targets which will be compiled, so that new registrations can be added without interfering with upstream containers. Note that many of the interface members are implemented explicitly - therefore most of your interaction with this type is through its implementation of ICompileContext and ITargetContainer . CompileStackEntry Represents an entry in the compilation stack of a ICompileContext , recording both a target that is being compiled, and the type for which it is being compiled. ConstantCompiledTarget An implementation of ICompiledTarget which simply wraps an instance and a known target. DelegatingCompiledTarget A reusable implementation of ICompiledTarget for when the compiled code for an ITarget can be represented by a delegate. TargetCompilerExtensions Extensions for the ITargetCompiler interface. UnresolvedTypeCompiledTarget An ICompiledTarget that can be used when a type could not be resolved. Implementations of both GetObject(IResolveContext) and SourceTarget will throw an exception if called/read. Interfaces ICompileContext Tracks state and provides services during the compilation phase in which ITarget targets are compiled into ICompiledTarget targets, which produce actual instances of objects. Instances of this interface are created by calling the CreateContext(IResolveContext, ITargetContainer) method of the ITargetCompiler which is registered in a container. ITargetCompiler An object that produces ICompiledTarget s from ITarget s given a particular ICompileContext - for which it also acts as a factory."
  },
  "api/Rezolver.TargetListContainer.html": {
    "href": "api/Rezolver.TargetListContainer.html",
    "title": "Class TargetListContainer | Rezolver IOC",
    "keywords": "Class TargetListContainer An ITargetContainer that stores multiple targets in a list. This is not a type that you would typically use directly in your code, unless you are writing custom logic/behaviour for ITarget registration. Inheritance Object TargetListContainer Implements ITargetContainer System.Collections.Generic.IList < ITarget > System.Collections.Generic.ICollection < ITarget > System.Collections.Generic.IEnumerable < ITarget > IEnumerable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class TargetListContainer : ITargetContainer, IList<ITarget>, ICollection<ITarget>, IEnumerable<ITarget>, IEnumerable Remarks This type is not thread-safe, nor does it perform any type checking on the targets that are added to it. Constructors | Improve this Doc View Source TargetListContainer(ITargetContainer, Type, ITarget[]) Initializes a new instance of the TargetListContainer class. Declaration public TargetListContainer(ITargetContainer root, Type registeredType, params ITarget[] targets) Parameters Type Name Description ITargetContainer root The root target container in which this container is registered. Type registeredType Required - the type against which this list will be registered. ITarget [] targets Optional array of targets with which to initialise the list. Properties | Improve this Doc View Source Count Gets the number of targets which have been added to the list. Declaration public int Count { get; } Property Value Type Description Int32 The count. | Improve this Doc View Source DefaultTarget Gets the default target for this list - which will always be the last target added to the list, or null if no targets have been added yet. Declaration public ITarget DefaultTarget { get; } Property Value Type Description ITarget | Improve this Doc View Source RegisteredType Gets the type against which this list container is registered in its ITargetContainer . Declaration public Type RegisteredType { get; } Property Value Type Description Type Methods | Improve this Doc View Source Add(ITarget) Implementation of System.Collections.Generic.ICollection<T>.Add(T) Declaration public void Add(ITarget item) Parameters Type Name Description ITarget item | Improve this Doc View Source Clear() Implementation of System.Collections.Generic.ICollection<T>.Clear() Declaration public void Clear() | Improve this Doc View Source CombineWith(ITargetContainer, Type) Not supported. Declaration public virtual ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Ignored Type type Ignored. Returns Type Description ITargetContainer Exceptions Type Condition NotSupportedException Always | Improve this Doc View Source Contains(ITarget) Implementation of System.Collections.Generic.ICollection<T>.Contains(T) Declaration public bool Contains(ITarget item) Parameters Type Name Description ITarget item Returns Type Description Boolean | Improve this Doc View Source CopyTo(ITarget[], Int32) Implementation of System.Collections.Generic.ICollection<T>.CopyTo(T[], System.Int32) Declaration public void CopyTo(ITarget[] array, int arrayIndex) Parameters Type Name Description ITarget [] array Int32 arrayIndex | Improve this Doc View Source Fetch(Type) Returns the first target which supports the passed type Declaration public virtual ITarget Fetch(Type type) Parameters Type Name Description Type type The type for which a target is sought. Returns Type Description ITarget | Improve this Doc View Source FetchAll(Type) Retrieves an enumerable of all targets that have been registered to this list. Declaration public virtual IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type Ignored. Returns Type Description System.Collections.Generic.IEnumerable < ITarget > | Improve this Doc View Source FetchContainer(Type) Not supported by this target container. Declaration public ITargetContainer FetchContainer(Type type) Parameters Type Name Description Type type Returns Type Description ITargetContainer | Improve this Doc View Source GetEnumerator() Implementation of System.Collections.Generic.IEnumerable<T>.GetEnumerator() Declaration public IEnumerator<ITarget> GetEnumerator() Returns Type Description System.Collections.Generic.IEnumerator < ITarget > | Improve this Doc View Source IndexOf(ITarget) Implementation of System.Collections.Generic.IList<T>.IndexOf(T) Declaration public int IndexOf(ITarget item) Parameters Type Name Description ITarget item The item whose index is to be found Returns Type Description Int32 | Improve this Doc View Source Insert(Int32, ITarget) Implementation of System.Collections.Generic.IList<T>.Insert(System.Int32, T) Declaration public void Insert(int index, ITarget item) Parameters Type Name Description Int32 index ITarget item | Improve this Doc View Source Register(ITarget, Type) Registers the specified target into the list. Note - the target is not checked to see if it supports this list's RegisteredType . Declaration public virtual void Register(ITarget target, Type registeredType = null) Parameters Type Name Description ITarget target The target. Type registeredType Ignored. | Improve this Doc View Source RegisterContainer(Type, ITargetContainer) Not supported by this target container Declaration public void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container | Improve this Doc View Source Remove(ITarget) Implementation of System.Collections.Generic.ICollection<T>.Remove(T) Declaration public bool Remove(ITarget item) Parameters Type Name Description ITarget item Returns Type Description Boolean | Improve this Doc View Source RemoveAt(Int32) Implementation of System.Collections.Generic.IList<T>.RemoveAt(System.Int32) Declaration public void RemoveAt(int index) Parameters Type Name Description Int32 index Explicit Interface Implementations | Improve this Doc View Source ICollection<ITarget>.IsReadOnly Declaration bool ICollection<ITarget>.IsReadOnly { get; } Returns Type Description Boolean | Improve this Doc View Source IList<ITarget>.Item[Int32] Declaration ITarget IList<ITarget>.this[int index] { get; set; } Parameters Type Name Description Int32 index Returns Type Description ITarget | Improve this Doc View Source IEnumerable.GetEnumerator() Implementation of System.Collections.IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description IEnumerator Implements ITargetContainer System.Collections.Generic.IList<T> System.Collections.Generic.ICollection<T> System.Collections.Generic.IEnumerable<T> IEnumerable Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection)"
  },
  "api/Rezolver.ProjectionTargetContainer.html": {
    "href": "api/Rezolver.ProjectionTargetContainer.html",
    "title": "Class ProjectionTargetContainer | Rezolver IOC",
    "keywords": "Class ProjectionTargetContainer Implements projections of IEnumerables from one type to another Effectively, this daisy chains one enumerable into another via something similar to a Linq Select. Inheritance Object ProjectionTargetContainer Implements ITargetContainer Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class ProjectionTargetContainer : ITargetContainer Properties | Improve this Doc View Source OutputElementType Declaration public Type OutputElementType { get; } Property Value Type Description Type | Improve this Doc View Source OutputEnumerableType Declaration public Type OutputEnumerableType { get; } Property Value Type Description Type | Improve this Doc View Source Root Declaration public IRootTargetContainer Root { get; } Property Value Type Description IRootTargetContainer | Improve this Doc View Source SourceElementType Declaration public Type SourceElementType { get; } Property Value Type Description Type | Improve this Doc View Source SourceEnumerableType Declaration public Type SourceEnumerableType { get; } Property Value Type Description Type Methods | Improve this Doc View Source CombineWith(ITargetContainer, Type) Not supported Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Type type Returns Type Description ITargetContainer | Improve this Doc View Source Fetch(Type) Implementation of Fetch(Type) - always produces an EnumerableTarget which, when compiled, will produce an enumerable of OutputEnumerableType . Declaration public ITarget Fetch(Type type) Parameters Type Name Description Type type Returns Type Description ITarget | Improve this Doc View Source FetchAll(Type) Not supported Declaration public IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type Returns Type Description System.Collections.Generic.IEnumerable < ITarget > | Improve this Doc View Source FetchContainer(Type) Not supported Declaration public ITargetContainer FetchContainer(Type type) Parameters Type Name Description Type type Returns Type Description ITargetContainer | Improve this Doc View Source Register(ITarget, Type) Not supported Declaration public void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target Type serviceType | Improve this Doc View Source RegisterContainer(Type, ITargetContainer) Not supported Declaration public void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container Implements ITargetContainer Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection)"
  },
  "api/Rezolver.Container.html": {
    "href": "api/Rezolver.Container.html",
    "title": "Class Container | Rezolver IOC",
    "keywords": "Class Container The standard IOC container class in Rezolver. Inheritance Object ContainerBase CachingContainerBase Container OverridingContainer ScopedContainer Implements IContainer IScopeFactory IServiceProvider IRootTargetContainer ITargetContainer ICovariantTypeIndex Inherited Members CachingContainerBase.GetCompiledTargetVirtual(IResolveContext) ContainerBase.Targets ContainerBase.IRootTargetContainer.TargetRegistered ContainerBase.IRootTargetContainer.TargetContainerRegistered ContainerBase.Resolve(IResolveContext) ContainerBase.TryResolve(IResolveContext, Object) ContainerBase.CreateScope() ContainerBase.GetCompiledTarget(IResolveContext) ContainerBase.CanResolve(IResolveContext) ContainerBase.GetFallbackCompiledTarget(IResolveContext) ContainerBase.IServiceProvider.GetService(Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) ContainerBase.ITargetContainer.Fetch(Type) ContainerBase.ITargetContainer.FetchAll(Type) ContainerBase.ITargetContainer.CombineWith(ITargetContainer, Type) ContainerBase.ITargetContainer.FetchContainer(Type) ContainerBase.ITargetContainer.RegisterContainer(Type, ITargetContainer) ContainerBase.ICovariantTypeIndex.AddKnownType(Type) ContainerBase.ICovariantTypeIndex.GetKnownCovariantTypes(Type) ContainerBase.ICovariantTypeIndex.GetKnownCompatibleTypes(Type) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class Container : CachingContainerBase, IContainer, IScopeFactory, IServiceProvider, IRootTargetContainer, ITargetContainer, ICovariantTypeIndex Remarks All of this class' functionality is inherited through CachingContainerBase and its base classes. Note that it doesn't implement lifetime scoping (although you can create a lifetime scope from it by calling its CreateScope() method). Also note that the class implements ITargetContainer by wrapping the Targets property inherited from ContainerBase . The reason for this is simplicity: in many applications, you'll want to simply create a new container, register services into it, and then start using it. Configuration Rezolver uses a configuration callback mechanism for pre-registering services or pre-configuring containers for certain types via the IContainerConfig interface. This is similar to the ITargetContainerConfig interface that's used by TargetContainer to provide functionality such as automatic enumerable injection out of the box, except it focuses specifically on configuring the container itself, rather than just registrations. If you don't provide a config on construction, then the DefaultConfig will be used. Constructors | Improve this Doc View Source Container(IRootTargetContainer) Constructs a new instance of the Container class using the given target container (or a new TargetContainer if not provided). No IContainerConfig will be used, leaving the deriving class free to do so. Declaration protected Container(IRootTargetContainer targets) Parameters Type Name Description IRootTargetContainer targets Optional. Contains the targets that will be used as the source of registrations for the container. If not provided, then a new TargetContainer will be created. Remarks This constructor must be used by derived types in order to avoid apply any configuration before they are initialised. In order to apply configuration, derived types must declare their own constructor which accepts an IContainerConfig , and apply it (or the DefaultConfig as a default) after performing all initialisation. | Improve this Doc View Source Container(IRootTargetContainer, IContainerConfig) Constructs a new instance of the Container class. Declaration public Container(IRootTargetContainer targets = null, IContainerConfig config = null) Parameters Type Name Description IRootTargetContainer targets Optional. The target container whose registrations will be used for dependency lookup when Resolve(IResolveContext) (and other operations) is called. If not provided, a new TargetContainer instance is constructed. This will ultimately be available to derived types, after construction, through the Rezolver.Targets property. IContainerConfig config Can be null. Configuration to apply to this container (and, potentially its Rezolver.Targets ). If not provided, then the DefaultConfig will be used. Remarks Note to inheritors - this constructor throws an InvalidOperationException if used by a derived class, because the application of configuration to the container will likely cause virtual methods to be called. Instead, you should declare your own constructor with the same signature which chains instead to the Container(IRootTargetContainer) protected constructor; and then you should apply the configuration yourself in that constructor (falling back to DefaultConfig if null). Properties | Improve this Doc View Source DefaultConfig The default container config used by all new containers. You can add/remove configurations from this collection to change the defaults which are applied to new container instances; or you can supply an explicit configuration when creating your container. Declaration public static CombinedContainerConfig DefaultConfig { get; } Property Value Type Description CombinedContainerConfig Remarks The configurations present in this collection by default will set up the expression target compiler and extend the automatic enumerable injection functionality so that the OverridingContainer class can produce enumerables which are made up of targets registered in both the overriding container and its inner container. Implements IContainer IScopeFactory IServiceProvider IRootTargetContainer ITargetContainer ICovariantTypeIndex Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.ResolveMany(IContainer, Type) ContainerResolveExtensions.ResolveMany<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo, TImplementation>(IRootTargetContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, Type>) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Type) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, Type>) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, ITarget>) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, ITarget>) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(IRootTargetContainer) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorated>(IRootTargetContainer, Func<TDecorated, TDecorated>) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorated>(IRootTargetContainer, Delegate) DecoratorTargetContainerExtensions.RegisterDecorator(IRootTargetContainer, Delegate, Type) DecoratorTargetContainerExtensions.RegisterDecorator(IRootTargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection)"
  },
  "api/Rezolver.OverridingTargetContainer.html": {
    "href": "api/Rezolver.OverridingTargetContainer.html",
    "title": "Class OverridingTargetContainer | Rezolver IOC",
    "keywords": "Class OverridingTargetContainer A version of TargetContainer which overrides and extends the registrations of another (the Parent ). Inheritance Object TargetDictionaryContainer TargetContainer OverridingTargetContainer Implements IRootTargetContainer ITargetContainer ICovariantTypeIndex Inherited Members TargetContainer.TargetRegistered TargetContainer.TargetContainerRegistered TargetContainer.ICovariantTypeIndex.AddKnownType(Type) TargetContainer.ICovariantTypeIndex.GetKnownCovariantTypes(Type) TargetContainer.ICovariantTypeIndex.GetKnownCompatibleTypes(Type) TargetContainer.DefaultConfig TargetContainer.Root TargetContainer.GetTargetContainerType(Type) TargetContainer.RegisterContainer(Type, ITargetContainer) TargetContainer.CreateContainer(Type) TargetContainer.Register(ITarget, Type) TargetDictionaryContainer.FetchContainer(Type) TargetDictionaryContainer.EnsureContainer(Type) TargetDictionaryContainer.AutoRegisterContainer(Type) TargetDictionaryContainer.CombineWith(ITargetContainer, Type) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public sealed class OverridingTargetContainer : TargetContainer, IRootTargetContainer, ITargetContainer, ICovariantTypeIndex Remarks When this class searches for an entry for a type, if it cannot find one within its own registrations, it falls back to the registrations of its ancestors (starting with its Parent ). As a result, any dependencies required by registrations in this container can be provided by any ancestor. This fallback logic in the Fetch(Type) is triggered by the UseFallback property. The FetchAll(Type) method, however, returns all targets registered directly in this container and in the parent. Constructors | Improve this Doc View Source OverridingTargetContainer(ITargetContainer, ITargetContainerConfig) Initializes a new instance of the OverridingTargetContainer class. Declaration public OverridingTargetContainer(ITargetContainer parent, ITargetContainerConfig config = null) Parameters Type Name Description ITargetContainer parent Required. The parent target container. ITargetContainerConfig config Optional. The configuration to apply to this target container. If null, then the DefaultConfig is used. Properties | Improve this Doc View Source Parent Gets the parent target container. Declaration public ITargetContainer Parent { get; } Property Value Type Description ITargetContainer The parent. Methods | Improve this Doc View Source Fetch(Type) Fetches the registered target for the given type , if found, or forwards the call to the Parent container. Declaration public override ITarget Fetch(Type type) Parameters Type Name Description Type type The type whose registration is sought. Returns Type Description ITarget The target which is registered for the given type, or null if no registration can be found. Overrides TargetDictionaryContainer.Fetch(Type) | Improve this Doc View Source FetchAll(Type) Implementation of FetchAll(Type) which returns an enumerable of targets from both the base target container and this target container. Declaration public override IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type The type whose targets are to be retrieved. Returns Type Description System.Collections.Generic.IEnumerable < ITarget > A non-null enumerable containing the targets that match the type, or an empty enumerable if the type is not registered. Overrides TargetDictionaryContainer.FetchAll(Type) Implements IRootTargetContainer ITargetContainer ICovariantTypeIndex Extension Methods RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo, TImplementation>(IRootTargetContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, Type>) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Type) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, Type>) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, ITarget>) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, ITarget>) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(IRootTargetContainer) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorated>(IRootTargetContainer, Func<TDecorated, TDecorated>) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorated>(IRootTargetContainer, Delegate) DecoratorTargetContainerExtensions.RegisterDecorator(IRootTargetContainer, Delegate, Type) DecoratorTargetContainerExtensions.RegisterDecorator(IRootTargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection) See Also TargetContainer"
  },
  "api/Rezolver.TargetContainerRegistrationExtensions.html": {
    "href": "api/Rezolver.TargetContainerRegistrationExtensions.html",
    "title": "Class TargetContainerRegistrationExtensions | Rezolver IOC",
    "keywords": "Class TargetContainerRegistrationExtensions Contains registration extensions for the ITargetContainer type Inheritance Object TargetContainerRegistrationExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public static class TargetContainerRegistrationExtensions Methods | Improve this Doc View Source RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) Registers a type by constructor alone. Declaration public static void RegisterConstructor(this ITargetContainer targets, ConstructorInfo constructor, IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description ITargetContainer targets ConstructorInfo constructor The constructor to be bound. The DeclaringType will be used as the service type to be registered against. IMemberBindingBehaviour memberBindingBehaviour Optional. If you wish to bind members on the new instance, passing a member binding behaviour here. Remarks If the constructor belongs to an open generic type, then a GenericConstructorTarget will be created and registered. | Improve this Doc View Source RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) Registers a type by constructor against the service type serviceType . Declaration public static void RegisterConstructor(this ITargetContainer targets, ConstructorInfo constructor, Type serviceType, IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description ITargetContainer targets ConstructorInfo constructor The constructor to be bound. The DeclaringType must be compatible with the serviceType otherwise an exception will occur. Type serviceType The type against which the registration will be made. IMemberBindingBehaviour memberBindingBehaviour Optional. If you wish to bind members on the new instance, passing a member binding behaviour here. Remarks If the constructor belongs to an open generic type, then a GenericConstructorTarget will be created and registered. | Improve this Doc View Source RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) Register a type by constructor (represented by the expression newExpr ). Declaration public static void RegisterConstructor<TObject>(this ITargetContainer targets, Expression<Func<TObject>> newExpr, IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description ITargetContainer targets System.Linq.Expressions.Expression < System.Func <TObject>> newExpr A lambda expression whose Body is a NewExpression which identifies the constructor that is to be used to create the instance of TObject . IMemberBindingBehaviour memberBindingBehaviour Optional. If you wish to bind members on the new instance, passing a member binding behaviour here. Type Parameters Name Description TObject Remarks Note that you can achieve a similar result by simply registering an expression which represents a call to a type's constructor. | Improve this Doc View Source RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) Register a type by constructor (represented by the expression newExpr ). Declaration public static void RegisterConstructor<TObject>(this ITargetContainer targets, Expression<Func<TObject>> newExpr, Action<IMemberBindingBehaviourBuilder<TObject>> configureMemberBinding) Parameters Type Name Description ITargetContainer targets System.Linq.Expressions.Expression < System.Func <TObject>> newExpr A lambda expression whose Body is a NewExpression which identifies the constructor that is to be used to create the instance of TObject . An exception will be thrown if the lambda does not follow this pattern. System.Action < IMemberBindingBehaviourBuilder <TObject>> configureMemberBinding A callback which configures a custom member binding via the IMemberBindingBehaviourBuilder<TInstance> interface. A new builder will be created and passed to this callback. Type Parameters Name Description TObject Remarks Note that you can achieve a similar result by simply registering an expression which represents a call to a type's constructor. Generic constructors If you wish to register an open generic type by constructor through the use of an expression, then you need to use the | Improve this Doc View Source RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) Register a type by constructor (represented by the expression newExpr ) to be created when TService is requested from the container. Declaration public static void RegisterConstructor<TObject, TService>(this ITargetContainer targets, Expression<Func<TObject>> newExpr, IMemberBindingBehaviour memberBindingBehaviour = null)where TObject : TService Parameters Type Name Description ITargetContainer targets System.Linq.Expressions.Expression < System.Func <TObject>> newExpr A lambda expression whose Body is a NewExpression which identifies the constructor that is to be used to create the instance of TObject . IMemberBindingBehaviour memberBindingBehaviour Optional. If you wish to bind members on the new instance, passing a member binding behaviour here. Type Parameters Name Description TObject The type whose constructor is to be called TService The service against which the registration is to be made. An exception will be thrown if the lambda does not follow this pattern. Remarks Note that you can achieve a similar result by simply registering an expression which represents a call to a type's constructor. | Improve this Doc View Source RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) Register a type by constructor (represented by the expression newExpr ) to be created when TService is requested from the container. Declaration public static void RegisterConstructor<TObject, TService>(this ITargetContainer targets, Expression<Func<TObject>> newExpr, Action<IMemberBindingBehaviourBuilder<TObject>> configureMemberBinding)where TObject : TService Parameters Type Name Description ITargetContainer targets System.Linq.Expressions.Expression < System.Func <TObject>> newExpr A lambda expression whose Body is a NewExpression which identifies the constructor that is to be used to create the instance of TObject . System.Action < IMemberBindingBehaviourBuilder <TObject>> configureMemberBinding A callback which configures a custom member binding via the IMemberBindingBehaviourBuilder<TInstance> interface. A new builder will be created and passed to this callback. Type Parameters Name Description TObject The type whose constructor is to be called TService The service against which the registration is to be made. An exception will be thrown if the lambda does not follow this pattern. Remarks Note that you can achieve a similar result by simply registering an expression which represents a call to a type's constructor. | Improve this Doc View Source RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) Register a generic type by constructor (represented by the model expression newExpr ). Note - a concrete generic is used as an example - the equivalent open generic constructor is located and registered against the open generic of the type you actually invoke this method for; e.g. if TObject is MyGeneric<Foo, Bar>, then a target bound to the equivalent constructor on the open generic MyGeneric&lt;,> will be what is actually registered. Declaration public static void RegisterGenericConstructor<TObject>(this ITargetContainer targets, Expression<Func<TObject>> newExpr, IMemberBindingBehaviour memberBindingBehaviour = null) Parameters Type Name Description ITargetContainer targets System.Linq.Expressions.Expression < System.Func <TObject>> newExpr A lambda expression whose Body is a NewExpression which identifies the constructor that is to be used to create the instance of TObject . IMemberBindingBehaviour memberBindingBehaviour Optional. If you wish to bind members on the new instance, passing a member binding behaviour here. Type Parameters Name Description TObject Must be a generic type. It doesn't matter what the type arguments are, however, as the target that is created will be for the generic type definition of this type. Remarks Note that you can achieve a similar result by simply registering an expression which represents a call to a type's constructor. | Improve this Doc View Source RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) Register a generic type by constructor (represented by the model expression newExpr ) as an implementation of another open generic based on TService . Note - a concrete generic is used as an example - the equivalent open generic constructor is located and registered against the open generic of the type you actually invoke this method for; e.g. if TObject is MyGeneric&lt;Foo, Bar> , then a target bound to the equivalent constructor on the open generic MyGeneric&lt;,> will be what is actually registered. Also, if TService is IMyGeneric&lt;Foo, Bar> , then the service type that the new target is registered against will be IMyGeneric&lt;,> . Declaration public static void RegisterGenericConstructor<TObject, TService>(this ITargetContainer targets, Expression<Func<TObject>> newExpr, IMemberBindingBehaviour memberBindingBehaviour = null)where TObject : TService Parameters Type Name Description ITargetContainer targets System.Linq.Expressions.Expression < System.Func <TObject>> newExpr A lambda expression whose Body is a NewExpression which identifies the constructor that is to be used to create the instance of TObject . IMemberBindingBehaviour memberBindingBehaviour Optional. If you wish to bind members on the new instance, passing a member binding behaviour here. Type Parameters Name Description TObject Must be a generic type. It doesn't matter what the type arguments are, however, as the target that is created will be for the generic type definition of this type. TService Must also be a generic type that is a base or interface of TObject Remarks Note that you can achieve a similar result by simply registering an expression which represents a call to a type's constructor."
  },
  "api/Rezolver.Compilation.Expressions.ExpressionCompileContext.html": {
    "href": "api/Rezolver.Compilation.Expressions.ExpressionCompileContext.html",
    "title": "Class ExpressionCompileContext | Rezolver IOC",
    "keywords": "Class ExpressionCompileContext An implementation of ICompileContext which is specialised for use by an IExpressionCompiler . Inheritance Object CompileContext ExpressionCompileContext Implements IExpressionCompileContext ICompileContext ITargetContainer Inherited Members CompileContext.ResolveContext CompileContext.TargetType CompileContext.ScopeBehaviourOverride CompileContext.ScopePreferenceOverride CompileContext.DependencyTargetContainer CompileContext.CompileStack CompileContext.ICompileContext.NewContext(Type, Nullable<ScopeBehaviour>, Nullable<ScopePreference>) CompileContext.ICompileContext.PushCompileStack(ITarget, Type) CompileContext.ICompileContext.PopCompileStack() CompileContext.ITargetContainer.Register(ITarget, Type) CompileContext.ITargetContainer.Fetch(Type) CompileContext.ITargetContainer.FetchAll(Type) CompileContext.ITargetContainer.CombineWith(ITargetContainer, Type) CompileContext.ITargetContainer.FetchContainer(Type) CompileContext.ITargetContainer.RegisterContainer(Type, ITargetContainer) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public class ExpressionCompileContext : CompileContext, IExpressionCompileContext, ICompileContext, ITargetContainer Constructors | Improve this Doc View Source ExpressionCompileContext(IExpressionCompileContext, Type, Boolean, Nullable<ScopeBehaviour>, Nullable<ScopePreference>) Initializes a new instance of the ExpressionCompileContext class as a child of another. Note that all the expression properties ( ResolveContextParameterExpression , ContextContainerPropertyExpression and ContextScopePropertyExpression ) are always inherited from the source context to ensure consistency across all expressions being built during a particular compilation chain. Declaration protected ExpressionCompileContext(IExpressionCompileContext sourceContext, Type targetType = null, bool useParentSharedExpressions = true, ScopeBehaviour? scopeBehaviourOverride = default (ScopeBehaviour? ), ScopePreference? scopePreferenceOverride = default (ScopePreference? )) Parameters Type Name Description IExpressionCompileContext sourceContext The source context. Type targetType If not null, the type for which expressions are to be compiled. If null, then the sourceContext 's TargetType will be inherited. Boolean useParentSharedExpressions If true then the SharedExpressions of the sourceContext will be reused by this new context. If false , then this context will start with a new empty set of shared expressions. System.Nullable < ScopeBehaviour > scopeBehaviourOverride Override the scope behaviour to be used for the target that is compiled with this context. System.Nullable < ScopePreference > scopePreferenceOverride Allows you to override the scope preference for any target being compiled in this context - if not provided, then it is automatically inherited from the parent. | Improve this Doc View Source ExpressionCompileContext(IResolveContext, ITargetContainer, Type, ParameterExpression) Initializes a new instance of the ExpressionCompileContext class. Declaration protected ExpressionCompileContext(IResolveContext resolveContext, ITargetContainer dependencyTargetContainer, Type targetType = null, ParameterExpression resolveContextExpression = null) Parameters Type Name Description IResolveContext resolveContext Required. The container for which the compilation is being performed. When compiling in response to a call to Resolve(IResolveContext) , the container which first receives the call should be the one passed here. ITargetContainer dependencyTargetContainer Required - target container used for dependency lookups. As with the base class this is actually wrapped in a new OverridingTargetContainer and used as this class' implementation of ITargetContainer . Type targetType Optional. Will be set into the TargetType property. If null, then any ITarget that is compiled should be compiled for its own DeclaredType . ParameterExpression resolveContextExpression Optional, mapped to ResolveContextParameterExpression - the default for this (i.e. when you leave it as null) is to use the static DefaultResolveContextParameterExpression and generally it should always be left as that. The ExpressionCompiler , when building expressions to turn into compiled lambdas, uses this as the main parameter on the lambda itself. See Also CompileContext(IResolveContext, ITargetContainer, Type) Properties | Improve this Doc View Source ContextContainerPropertyExpression Gets an expression for reading the Container property of the IResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration public MemberExpression ContextContainerPropertyExpression { get; } Property Value Type Description MemberExpression The context container property expression. | Improve this Doc View Source ContextScopePropertyExpression Gets an expression for reading the Scope property of the IResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration public MemberExpression ContextScopePropertyExpression { get; } Property Value Type Description MemberExpression The context scope property expression. | Improve this Doc View Source CurrentContainerExpression Gets an expression which gives a reference to the IContainer for this context - i.e. the one on the ResolveContext property. Declaration public Expression CurrentContainerExpression { get; } Property Value Type Description Expression The container expression. Remarks Note that this is not the same as ContextContainerPropertyExpression - but is provided to allow expressions to be compiled which compare the container supplied at compile time to the one from the Container at resolve-time. | Improve this Doc View Source DefaultResolveContextParameterExpression The default IResolveContext parameter expression used by the expression-based code generators defined in this library, although it's not used directly for that purpose - instead, the ResolveContextParameterExpression of new contexts is initialised to this if not explicitly provided on construction and when not being inherited from another context. Declaration public static ParameterExpression DefaultResolveContextParameterExpression { get; } Property Value Type Description ParameterExpression | Improve this Doc View Source ParentContext Gets the parent context. Declaration public IExpressionCompileContext ParentContext { get; } Property Value Type Description IExpressionCompileContext Remarks Note that this property hides the inherited ParentContext property, since an IExpressionCompileContext can only be a child of another IExpressionCompileContext . | Improve this Doc View Source ResolveContextParameterExpression This is the parameter expression which represents the IResolveContext that is passed to the ICompiledTarget at resolve-time. The other expressions - ContextContainerPropertyExpression and ContextScopePropertyExpression are both built from this too. Declaration public ParameterExpression ResolveContextParameterExpression { get; } Property Value Type Description ParameterExpression The resolve context expression. Remarks If the code produced by the IExpressionBuilder for a given target needs to read or use the IResolveContext that was originally passed to the Resolve(IResolveContext) method, then it does it by using this expression, which will be set as the only parameter on the lambda expression which is eventually compiled (in the case of the default expression compiler, ExpressionCompiler . | Improve this Doc View Source SharedExpressions Gets a read-only enumerable of all the shared expressions that have been inherited from any parent context and/or added via calls to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) or GetOrAddSharedLocal(Type, String, Type) . Declaration public IEnumerable<Expression> SharedExpressions { get; } Property Value Type Description System.Collections.Generic.IEnumerable < Expression > Methods | Improve this Doc View Source GetOrAddSharedExpression(Type, String, Func<Expression>, Type) Gets or adds a shared expression (created by the expressionFactory if it's not already cached) with the given name, type, optionally for the given requestingType . Declaration public Expression GetOrAddSharedExpression(Type type, string name, Func<Expression> expressionFactory, Type requestingType = null) Parameters Type Name Description Type type The runtime type of the Expression. String name The runtime name of the Expression - and also the name used to retrieve it later. System.Func < Expression > expressionFactory The factory method to use to construct the shared expression from scratch, if it's not already cached. Type requestingType Optional - to avoid naming clashes with shared expressions created by other targets, you can pass a type here (usually the runtime type of your ITarget implementation). Returns Type Description Expression Expression. | Improve this Doc View Source GetOrAddSharedLocal(Type, String, Type) Similar to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) , except this is used when expression builders want to use local variables in block expressions to store the result of some operation in the expression tree built for a particular target. Reusing one local variable is more efficient than declaring the same local multiple times. Declaration public ParameterExpression GetOrAddSharedLocal(Type type, string name, Type requestingType = null) Parameters Type Name Description Type type The type. String name The name. Type requestingType Optional - the type of the object requesting this shared expression. If this is provided, then the search for an existing shared expression will only work if the same requesting type was passed previously. Returns Type Description ParameterExpression Remarks When multiple expression trees from multiple targets are brought together into one lambda, there will often be many duplicate variables which could be shared. So, if an IExpressionBuilder needs a local variable for a block, instead of simply declaring it directly through the System.Linq.Expressions.Expression.Parameter(System.Type, System.String) function, it can use this function instead, which will return a previously created one if available. Exceptions Type Condition InvalidOperationException Cannot add ParameterExpression: A shared expression of a different type has already been added with the same type and name. | Improve this Doc View Source NewContext(Type, Nullable<ScopeBehaviour>, Nullable<ScopePreference>) Used by the explicit implementation of NewContext(Type, Nullable<ScopeBehaviour>, Nullable<ScopePreference>) . This is overriden to ensure that the correct type of context is created when created directly through the ICompileContext interface. Declaration protected override ICompileContext NewContext(Type targetType = null, ScopeBehaviour? scopeBehaviourOverride = default (ScopeBehaviour? ), ScopePreference? scopePreferenceOverride = default (ScopePreference? )) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . System.Nullable < ScopeBehaviour > scopeBehaviourOverride Override the ScopeBehaviourOverride to be used for the target that is compiled with the new context. This is never inherited automatically from one context to another. System.Nullable < ScopePreference > scopePreferenceOverride Sets the ScopePreferenceOverride . As soon as this is set on one context, it is automatically inherited by all its child contexts (i.e. you cannot null it) Returns Type Description ICompileContext Overrides CompileContext.NewContext(Type, Nullable<ScopeBehaviour>, Nullable<ScopePreference>) Remarks Note all child contexts created through this virtual method will always inherit the parent context's shared expressions. | Improve this Doc View Source RegisterExpressionTargets() Registers some additional targets into the compile context to support compilation. Declaration protected void RegisterExpressionTargets() Explicit Interface Implementations | Improve this Doc View Source IExpressionCompileContext.NewContext(Type, Boolean, Nullable<ScopeBehaviour>, Nullable<ScopePreference>) Creates a new IExpressionCompileContext using this one as a seed. This function is identical to NewContext(Type, Nullable<ScopeBehaviour>, Nullable<ScopePreference>) but allows you to control whether the SharedExpressions are inherited (the default); and is more convenient because it returns another IExpressionCompileContext . Declaration IExpressionCompileContext IExpressionCompileContext.NewContext(Type targetType, bool useParentSharedExpressions, ScopeBehaviour? scopeBehaviourOverride, ScopePreference? scopePreferenceOverride) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Boolean useParentSharedExpressions If true then the shared expressions in this context will be inherited by the new context by reference. That is, when the new context goes out of scope, any new shared expressions it created will still be available. If false, then the new context will get a brand new, empty, set of shared expressions. System.Nullable < ScopeBehaviour > scopeBehaviourOverride Override the ScopeBehaviourOverride to be used for the target that is compiled with the new context. This is never inherited automatically from one context to another. System.Nullable < ScopePreference > scopePreferenceOverride Sets the ScopePreferenceOverride . As soon as this is set on one context, it is automatically inherited by all its child contexts (i.e. you cannot null it) Returns Type Description IExpressionCompileContext Implements IExpressionCompileContext ICompileContext ITargetContainer Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection) See Also CompileContext"
  },
  "api/Rezolver.IRootTargetContainer.html": {
    "href": "api/Rezolver.IRootTargetContainer.html",
    "title": "Interface IRootTargetContainer | Rezolver IOC",
    "keywords": "Interface IRootTargetContainer Interface for the root-most target container, which typically 'owns' all the top-level registrations required by an application. This builds on the ITargetContainer interface by adding the ICovariantTypeIndex interface too, as well as events which allow an application to listen for target and target container registrations within the root. Inherited Members ITargetContainer.Register(ITarget, Type) ITargetContainer.Fetch(Type) ITargetContainer.FetchAll(Type) ITargetContainer.CombineWith(ITargetContainer, Type) ITargetContainer.FetchContainer(Type) ITargetContainer.RegisterContainer(Type, ITargetContainer) ICovariantTypeIndex.AddKnownType(Type) ICovariantTypeIndex.GetKnownCovariantTypes(Type) ICovariantTypeIndex.GetKnownCompatibleTypes(Type) Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface IRootTargetContainer : ITargetContainer, ICovariantTypeIndex Events | Improve this Doc View Source TargetContainerRegistered Raised when a child target container (e.g. a DecoratingTargetContainer ) is registered in this root container. Declaration event EventHandler<TargetContainerRegisteredEventArgs> TargetContainerRegistered Event Type Type Description System.EventHandler < TargetContainerRegisteredEventArgs > | Improve this Doc View Source TargetRegistered Raised when a target has been registered to this root container. Declaration event EventHandler<TargetRegisteredEventArgs> TargetRegistered Event Type Type Description System.EventHandler < TargetRegisteredEventArgs > Extension Methods RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo, TImplementation>(IRootTargetContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, Type>) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Type) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, Type>) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, ITarget>) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, ITarget>) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(IRootTargetContainer) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorated>(IRootTargetContainer, Func<TDecorated, TDecorated>) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorated>(IRootTargetContainer, Delegate) DecoratorTargetContainerExtensions.RegisterDecorator(IRootTargetContainer, Delegate, Type) DecoratorTargetContainerExtensions.RegisterDecorator(IRootTargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection)"
  },
  "api/Rezolver.html": {
    "href": "api/Rezolver.html",
    "title": "Namespace Rezolver | Rezolver IOC",
    "keywords": "Namespace Rezolver Classes AliasTargetContainerExtensions Contains extension methods for ITargetContainer to create targets which alias others by different types. BindAllMembersBehaviour This implementation of IMemberBindingBehaviour binds all publicly writable properties and public fields to values obtained from the container. BindNoMembersBehaviour This is the default IMemberBindingBehaviour which doesn't bind any members. It's a singleton accessible only via the BindNone static property. BindPublicFieldsBehaviour An IMemberBindingBehaviour which binds all public instance fields on new instances to services from the container. BindPublicPropertiesBehaviour An IMemberBindingBehaviour which binds all non-indexer publicly writeable instance properties on new instances to services from the container. BindSpecificMembersBehaviour CachingContainerBase Builds on the ContainerBase base class to introduce thread-safe caching of compiled targets so they are only compiled once per requested type. Only creatable through inheritance. CombinedContainerConfig An IContainerConfig which contains zero or or more other IContainerConfig objects. Behaviours can depend on other behaviours, and this collection ensures that they are applied in the correct order. CombinedContainerConfigExtensions Contains extension methods for the CombinedContainerConfig class which simplify the process of adding and replacing IContainerConfig objects which set options and register well-known container services. CombinedTargetContainerConfig An ITargetContainerConfig which contains zero or or more other ITargetContainerConfig objects. Configurations can depend on others, and this collection ensures that they are applied in the correct order. CombinedTargetContainerConfigExtensions Extensions for pre-configuring options in an ITargetContainer via a CombinedContainerConfig , such as the one exposed by DefaultConfig . ConstructorBinding Represents a binding specifically to a class constructor, optionally with an additional set of MemberBindings to be used to initialise a new instance's properties or fields directly. Container The standard IOC container class in Rezolver. ContainerBase Starting point for implementations of IContainer - only creatable through inheritance. ContainerResolveExtensions Extension methods for IContainer which provide shortcuts for the Resolve(IResolveContext) operation. ContainerScope Standard implementation of the IContainerScope interface. ContainerScopeExtensions Standard extensions for the IContainerScope ContainerScopeResolveExtensions Extensions for IContainerScope so that instances of that interface present a similar set of functionality to IContainer . CovariantTypeIndex Implementation of ICovariantTypeIndex used internally by TargetContainer and OverridingTargetContainer in their implementation of the same interface. DecoratingTargetContainer Implements service decoration in an ITargetContainer , producing instances of the DecoratorTarget when Fetch(Type) or FetchAll(Type) are called. The best way to add a decorator to your target container is to use the extension methods in DecoratorTargetContainerExtensions - which provide simple shortcuts for creating decoration registrations. DecoratorTargetContainerExtensions Extensions for ITargetContainer which simplify the registration of decorators (via the DecoratingTargetContainer pseudo-target) DelegateTargetContainerExtensions Extension methods for ITargetContainer designed to simplify the registration of DelegateTarget and its numerous generic variants. ExpressionFunctions This type is only used when using expressions as targets(via the ExpressionTarget type) - it's functions serve no actual purpose other than to act as hooks to create specific ITarget objects in place of static code. All the functions will throw a NotImplementedException if called at runtime. ExpressionTargetContainerExtensions Extensions for to simplify registering expressions in an ITargetContainer . GenericTargetContainer A special type of ITargetContainer which stores targets (and potentially other containers) which are specifically keyed either to a particular open generic type or a closed generic built from it. ListMemberBinding Represents a binding (i.e. like that produced by IMemberBindingBehaviour ) to a property via dynamic collection initialiser. MemberBinding Represents the binding of an ITarget to a property or field of a given type. Not to be confused with the type of the same name from the System.Linq.Expressions namespace, although they are technically equivalent. MemberBindingBehaviour Static accessor for the common member binding behaviours provided by Rezolver, also provides an entry point to build custom binding behaviours using the fluent API exposed by IMemberBindingBehaviourBuilder<TInstance> and MemberBindingBuilder<TInstance, TMember> - via the For<TInstance>() method. MemberBindingBehaviourBuilder<TInstance> Class for building custom IMemberBindingBehaviour for instances of TInstance , default implementation of IMemberBindingBehaviourBuilder<TInstance> . MemberBindingBuilder<TInstance, TMember> Builds individual MemberBinding objects for the MemberBindingBehaviourBuilder<TInstance> class. Created through the Bind<TMember>(Expression<Func<TInstance, TMember>>) . MethodBinding Represents a binding to a method whose arguments will be supplied by ITarget instances. MSDIITargetContainerExtensions Provides the Populate(ITargetContainer, IServiceCollection) extension method which allows easy importing of all registrations in an IServiceCollection from Microsoft.Extensions.DependencyInjection into a Rezolver ITargetContainer . MultipleTargetContainerExtensions Extensions for registering multiple targets individually and against the same type ObjectTargetContainerExtensions Extensions for ITargetContainer relating to registering concrete instances via the ObjectTarget target. OptionsTargetContainerExtensions Contains extension methods for getting and setting container options which are used to control the behaviour, chiefly, of the various well-known ITargetContainer implementations. OverridingContainer An IContainer which can override the resolve operations of another. This is useful when you have a core application-wide container, with some objects being customised based on some ambient information, e.g. configuration, MVC Area/Controller, Brand (in a multi-tenant application for example) or more. OverridingTargetContainer A version of TargetContainer which overrides and extends the registrations of another (the Parent ). ParameterBinding Represents a binding between a method parameter and an ITarget ProjectionTargetContainer Implements projections of IEnumerables from one type to another Effectively, this daisy chains one enumerable into another via something similar to a Linq Select. RegisterTypeTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for the simplest cases of registering ConstructorTarget and GenericConstructorTarget targets. ResolveContext Standard implementation of IResolveContext RezolverOptions Options for using Rezolver as the DI container for Asp.Net Core web applications. RootTargetContainerExtensions ScopedContainer Extends the Container to implement lifetime implicit scoping through the Scope that's created along with it. Implementation of the IScopedContainer interface. ScopedTargetContainerExtensions Extensions for ITargetContainer to provide shortcuts for registering constructor-injected types whose lifetimes are slaved to that of a parent IScopedContainer . All of the extension methods ultimately create a ScopedTarget SingletonTargetContainerExtensions Extension methods for the ITargetContainer interface which simplify the registration of singletons. Target Provides static factory methods (including extension methods) for creating numerous types of targets from the Rezolver.Targets namespace. TargetContainer Root container for ITarget s that can be used as the backing for the standard IContainer classes - Container and ScopedContainer . Stores and retrieves registrations of ITarget s, is also Generic type aware, unlike its base class - TargetDictionaryContainer . TargetContainerRegistrationExtensions Contains registration extensions for the ITargetContainer type TargetDictionaryContainer An ITargetContainer implementation that stores and retrieves ITarget and ITargetContainer by service type. TargetListContainer An ITargetContainer that stores multiple targets in a list. This is not a type that you would typically use directly in your code, unless you are writing custom logic/behaviour for ITarget registration. TargetTypeSelector Given a type, this produces an enumerable of all types to be sought from an ITargetContainer whose targets might produce a compatible instance. In particular, this class is responsible for handling generic type matching, including variance. UnresolvedICompiledTargetExtensions Contains an extension to test the validity of ICompiledTarget objects. Interfaces ICompiledTarget Provides an abstraction for creating objects based on a given IResolveContext - this is the ultimate target of all Resolve(IResolveContext) calls in the standard container implementations within the Rezolver framework. IContainer The primary IOC container interface in the Rezolver framework. IContainerConfig A configuration callback for instances of IContainer (which also use ITargetContainer as the source of their registrations). IContainerConfig<T> Marker interface for an ITargetContainerConfig which is responsible for configuring a specific type of object/behaviour/service/option for IContainer instances. (Determined by T ). IContainerScope This is an IContainer -like object (resolving functionality is provided through the extension methods in the ContainerScopeResolveExtensions class) which provides lifetime scoping for disposable objects, and scoped singleton functionality for any object. Implementations of this interface must, in their implementation of IScopeFactory , create a child scope of this scope. ICovariantTypeIndex For any type T , there exists a list of zero or more other types with which it is compatible when covariance is supported. This index provides the mechanism by which Rezolver can perform this reverse lookup. IMemberBindingBehaviour Describes a type which discovers and creates property/field bindings, typically for use when creating a new instance. IMemberBindingBehaviourBuilder<TInstance> IOptionForAnyGeneric Used as a marker service type for GetOption when a service type is any generic. Allows options to be defined for any generic type instead of specific generics. IResolveContext Captures the state for a call to Resolve(IResolveContext) (or TryResolve(IResolveContext, out Object) ), including the container on which the operation is invoked, any IScopedContainer that might be active for the call (if different), and the type that is being resolved from the IContainer . IRootTargetContainer Interface for the root-most target container, which typically 'owns' all the top-level registrations required by an application. This builds on the ITargetContainer interface by adding the ICovariantTypeIndex interface too, as well as events which allow an application to listen for target and target container registrations within the root. IScopedContainer An IContainer that also has a Scope attached to it. Many applications will use such a container as the root container to use as anchors for things like scoped singletons. IScopeFactory Represents an object from which a scope can be created ITarget Represents an action to be performed in order to obtain an object to satisfy a call to Resolve(IResolveContext) , when the standard implementations of IContainer are used (e.g. Container ). ITargetContainer Stores and retrieves ITarget instances, keyed by the type of service that the targets are registered against. This is where all your service registrations will ultimately go. ITargetContainerConfig A configuration callback for instances of IRootTargetContainer . ITargetContainerConfig<T> Marker interface for an ITargetContainerConfig which is responsible for configuring a specific type of object/behaviour/service/option. (Determined by T ). ITargetContainerEventHandler<TEvent> Interface for an object which handles an event of a particular type ( TEvent ) raised from an ITargetContainer . ITargetContainerFactory A target container option used by TargetContainer to create a new instance of an ITargetContainer to store target registrations for a specific type (or types relating to a specific type). ITargetContainerTypeResolver An interface used by TargetContainer (via the options API) to identify the container type for targets with a specific DeclaredType . Enums ScopeBehaviour Describes different ways in which objeects interact with scopes. ScopePreference Specifies the scope that the object produced by a target should be tracked within."
  },
  "api/Rezolver.Compilation.Expressions.IExpressionCompileContext.html": {
    "href": "api/Rezolver.Compilation.Expressions.IExpressionCompileContext.html",
    "title": "Interface IExpressionCompileContext | Rezolver IOC",
    "keywords": "Interface IExpressionCompileContext Extension to the ICompileContext interface which provides additional state and functionality for the IExpressionCompiler and the IExpressionBuilder implementations which are used by the default expression compiler, the ExpressionCompiler class. Inherited Members ICompileContext.ScopeBehaviourOverride ICompileContext.ScopePreferenceOverride ICompileContext.TargetType ICompileContext.CompileStack ICompileContext.ResolveContext ICompileContext.NewContext(Type, Nullable<ScopeBehaviour>, Nullable<ScopePreference>) ICompileContext.PopCompileStack() ICompileContext.PushCompileStack(ITarget, Type) ITargetContainer.Register(ITarget, Type) ITargetContainer.Fetch(Type) ITargetContainer.FetchAll(Type) ITargetContainer.CombineWith(ITargetContainer, Type) ITargetContainer.FetchContainer(Type) ITargetContainer.RegisterContainer(Type, ITargetContainer) Namespace : Rezolver.Compilation.Expressions Assembly : Rezolver.dll Syntax public interface IExpressionCompileContext : ICompileContext, ITargetContainer Properties | Improve this Doc View Source ContextContainerPropertyExpression Gets an expression for reading the Container property of the IResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration MemberExpression ContextContainerPropertyExpression { get; } Property Value Type Description MemberExpression | Improve this Doc View Source ContextScopePropertyExpression Gets an expression for reading the Scope property of the IResolveContext that's in scope when the ICompiledTarget (which is built from the compiled expression) is executed. Declaration MemberExpression ContextScopePropertyExpression { get; } Property Value Type Description MemberExpression | Improve this Doc View Source CurrentContainerExpression Gets an expression which gives a reference to the IContainer for this context - i.e. the one on the ResolveContext property. Declaration Expression CurrentContainerExpression { get; } Property Value Type Description Expression The container expression. Remarks Note that this is not the same as ContextContainerPropertyExpression - but is provided to allow expressions to be compiled which compare the container supplied at compile time to the one from the Container at resolve-time. | Improve this Doc View Source ParentContext Gets the parent context. Declaration IExpressionCompileContext ParentContext { get; } Property Value Type Description IExpressionCompileContext Remarks Note that this property hides the inherited ParentContext property, since an IExpressionCompileContext can only be a child of another IExpressionCompileContext . | Improve this Doc View Source ResolveContextParameterExpression This is the parameter expression which represents the IResolveContext that is passed to the ICompiledTarget at resolve-time. Note, this should only be used for The other expressions - ContextContainerPropertyExpression and ContextScopePropertyExpression are both built from this too. Declaration ParameterExpression ResolveContextParameterExpression { get; } Property Value Type Description ParameterExpression Remarks If the code produced by the IExpressionBuilder for a given target needs to read or use the IResolveContext that was originally passed to the Resolve(IResolveContext) method, then it does it by using this expression, which will be set as the only parameter on the lambda expression which is eventually compiled (in the case of the default expression compiler, ExpressionCompiler . | Improve this Doc View Source SharedExpressions Gets a read-only enumerable of all the shared expressions that have been inherited from any parent context or added via calls to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) or GetOrAddSharedLocal(Type, String, Type) . Declaration IEnumerable<Expression> SharedExpressions { get; } Property Value Type Description System.Collections.Generic.IEnumerable < Expression > The shared expressions. Methods | Improve this Doc View Source GetOrAddSharedExpression(Type, String, Func<Expression>, Type) Gets or adds an expression which is potentially shared between multiple targets' expression trees. Declaration Expression GetOrAddSharedExpression(Type type, string name, Func<Expression> expressionFactory, Type requestingType = null) Parameters Type Name Description Type type Required - the type of the expression. String name Required - the caller-defined name for this expression. System.Func < Expression > expressionFactory Required - Delegate to call to create the expression if it does not already exist. Type requestingType Optional - the type of the object requesting this shared expression. If this is provided, then the search for an existing shared expression will only work if the same requesting type was passed previously. Returns Type Description Expression Remarks Using shared expressions opens the door to potentially multiple optimisations, depending on the type of expression in question. For example, conditional expressions which share the same operand and comparand can all be merged into one with all the 'true' and 'false' branches being combined into one of each, thus saving multiple identical comparisons. | Improve this Doc View Source GetOrAddSharedLocal(Type, String, Type) Similar to GetOrAddSharedExpression(Type, String, Func<Expression>, Type) , except this is used when expression builders want to use local variables in block expressions to store the result of some operation in the expression tree built for a particular target. Reusing one local variable is more efficient than declaring the same local multiple times. Declaration ParameterExpression GetOrAddSharedLocal(Type type, string name, Type requestingType = null) Parameters Type Name Description Type type The type. String name The name. Type requestingType Optional - the type of the object requesting this shared expression. If this is provided, then the search for an existing shared expression will only work if the same requesting type was passed previously. Returns Type Description ParameterExpression Remarks When multiple expression trees from multiple targets are brought together into one lambda, there will often be many duplicate variables which could be shared. So, if an IExpressionBuilder needs a local variable for a block, instead of simply declaring it directly through the System.Linq.Expressions.Expression.Parameter(System.Type, System.String) function, it can use this function instead, which will return a previously created one if available. | Improve this Doc View Source NewContext(Type, Boolean, Nullable<ScopeBehaviour>, Nullable<ScopePreference>) Creates a new IExpressionCompileContext using this one as a seed. This function is identical to NewContext(Type, Nullable<ScopeBehaviour>, Nullable<ScopePreference>) but allows you to control whether the SharedExpressions are inherited (the default); and is more convenient because it returns another IExpressionCompileContext . Declaration IExpressionCompileContext NewContext(Type targetType = null, bool inheritSharedExpressions = true, ScopeBehaviour? scopeBehaviourOverride = default (ScopeBehaviour? ), ScopePreference? scopePreferenceOverride = default (ScopePreference? )) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . Boolean inheritSharedExpressions If true then the shared expressions in this context will be inherited by the new context by reference. That is, when the new context goes out of scope, any new shared expressions it created will still be available. If false, then the new context will get a brand new, empty, set of shared expressions. System.Nullable < ScopeBehaviour > scopeBehaviourOverride Override the ScopeBehaviourOverride to be used for the target that is compiled with the new context. This is never inherited automatically from one context to another. System.Nullable < ScopePreference > scopePreferenceOverride Sets the ScopePreferenceOverride . As soon as this is set on one context, it is automatically inherited by all its child contexts (i.e. you cannot null it) Returns Type Description IExpressionCompileContext Remarks When you have a reference to an IExpressionCompileContext the compiler will favour this method to the one defined on the ICompileContext interface because it is 'closer', even if you do not explicitly provide an argument for the inheritSharedExpressions parameter. Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection) See Also ICompileContext"
  },
  "api/Rezolver.Compilation.ICompileContext.html": {
    "href": "api/Rezolver.Compilation.ICompileContext.html",
    "title": "Interface ICompileContext | Rezolver IOC",
    "keywords": "Interface ICompileContext Tracks state and provides services during the compilation phase in which ITarget targets are compiled into ICompiledTarget targets, which produce actual instances of objects. Instances of this interface are created by calling the CreateContext(IResolveContext, ITargetContainer) method of the ITargetCompiler which is registered in a container. Inherited Members ITargetContainer.Register(ITarget, Type) ITargetContainer.Fetch(Type) ITargetContainer.FetchAll(Type) ITargetContainer.CombineWith(ITargetContainer, Type) ITargetContainer.FetchContainer(Type) ITargetContainer.RegisterContainer(Type, ITargetContainer) Namespace : Rezolver.Compilation Assembly : Rezolver.dll Syntax public interface ICompileContext : ITargetContainer Remarks Implementations must also implement the ITargetContainer so the compile context can be used for dependency lookups during compilation time. Indeed, if you are developing your own compilation component (possibly for a custom ITarget implementation) and need to resolve any dependencies from an ITargetContainer during compilation, it should be done through the context's implementation of ITargetContainer. Properties | Improve this Doc View Source CompileStack Gets the stack entries for all the targets that are being compiled. Declaration IEnumerable<CompileStackEntry> CompileStack { get; } Property Value Type Description System.Collections.Generic.IEnumerable < CompileStackEntry > The compile stack. | Improve this Doc View Source ParentContext Gets the parent context from which this context was created, if applicable. Declaration ICompileContext ParentContext { get; } Property Value Type Description ICompileContext The parent context. | Improve this Doc View Source ResolveContext The context for which this compilation context was created. Provides access to the current container, scope and more besides Declaration IResolveContext ResolveContext { get; } Property Value Type Description IResolveContext | Improve this Doc View Source ScopeBehaviourOverride If not null then this overrides the ScopeBehaviour of the ITarget that's currently being compiled. Note that this is not automatically inherited from one context to another Declaration ScopeBehaviour? ScopeBehaviourOverride { get; } Property Value Type Description System.Nullable < ScopeBehaviour > | Improve this Doc View Source ScopePreferenceOverride Same as ScopeBehaviourOverride but this is used to override currently compiling target's ScopePreference . Typically used, for example, when a singleton is compiling other targets. Declaration ScopePreference? ScopePreferenceOverride { get; } Property Value Type Description System.Nullable < ScopePreference > | Improve this Doc View Source TargetType Any ICompiledTarget built for a ITarget with this context should target this type. If null, then the DeclaredType of the target being compiled should be used. Declaration Type TargetType { get; } Property Value Type Description Type Methods | Improve this Doc View Source NewContext(Type, Nullable<ScopeBehaviour>, Nullable<ScopePreference>) Creates a new child context from this one, except the TargetType and ScopeBehaviourOverride properties can be overriden if required. Implementations must make sure that the ScopeBehaviourOverride is never inherited. Declaration ICompileContext NewContext(Type targetType = null, ScopeBehaviour? scopeBehaviourOverride = default (ScopeBehaviour? ), ScopePreference? scopePreferenceOverride = default (ScopePreference? )) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . System.Nullable < ScopeBehaviour > scopeBehaviourOverride Value for the ScopeBehaviourOverride to be used for the target that is compiled with the new context. This is never inherited automatically from one context to another. System.Nullable < ScopePreference > scopePreferenceOverride Sets the ScopePreferenceOverride . As soon as this is set on one context, it is automatically inherited by all its child contexts (i.e. you cannot null it) Returns Type Description ICompileContext A new ICompileContext . | Improve this Doc View Source PopCompileStack() Pops the compile stack, returning the entry that was popped. Declaration CompileStackEntry PopCompileStack() Returns Type Description CompileStackEntry | Improve this Doc View Source PushCompileStack(ITarget, Type) Pushes the passed target on to the compile stack if it's not already on it for the same TargetType Compilers should consult the return value and abort compilation if it's true - since that implies a cyclic dependency graph. Declaration bool PushCompileStack(ITarget toCompile, Type targetType = null) Parameters Type Name Description ITarget toCompile To compile. Type targetType The type for which the target is being compiled, if different from DeclaredType Returns Type Description Boolean Remarks Targets can appear on the compilation stack more than once for different types, since the ICompiledTarget produced for a target for one type can be different than it is for another. Ultimately, if a target does in fact have a cyclic dependency graph, then this method will detect that. Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection) See Also ITargetContainer"
  },
  "api/Rezolver.OverridingContainer.html": {
    "href": "api/Rezolver.OverridingContainer.html",
    "title": "Class OverridingContainer | Rezolver IOC",
    "keywords": "Class OverridingContainer An IContainer which can override the resolve operations of another. This is useful when you have a core application-wide container, with some objects being customised based on some ambient information, e.g. configuration, MVC Area/Controller, Brand (in a multi-tenant application for example) or more. Inheritance Object ContainerBase CachingContainerBase Container OverridingContainer Implements IContainer IScopeFactory IServiceProvider IRootTargetContainer ITargetContainer ICovariantTypeIndex Inherited Members Container.DefaultConfig CachingContainerBase.GetCompiledTargetVirtual(IResolveContext) ContainerBase.Targets ContainerBase.IRootTargetContainer.TargetRegistered ContainerBase.IRootTargetContainer.TargetContainerRegistered ContainerBase.Resolve(IResolveContext) ContainerBase.TryResolve(IResolveContext, Object) ContainerBase.CreateScope() ContainerBase.GetCompiledTarget(IResolveContext) ContainerBase.IServiceProvider.GetService(Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) ContainerBase.ITargetContainer.Fetch(Type) ContainerBase.ITargetContainer.FetchAll(Type) ContainerBase.ITargetContainer.CombineWith(ITargetContainer, Type) ContainerBase.ITargetContainer.FetchContainer(Type) ContainerBase.ITargetContainer.RegisterContainer(Type, ITargetContainer) ContainerBase.ICovariantTypeIndex.AddKnownType(Type) ContainerBase.ICovariantTypeIndex.GetKnownCovariantTypes(Type) ContainerBase.ICovariantTypeIndex.GetKnownCompatibleTypes(Type) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public sealed class OverridingContainer : Container, IContainer, IScopeFactory, IServiceProvider, IRootTargetContainer, ITargetContainer, ICovariantTypeIndex Remarks When overriding another IContainer , you are overriding the ICompiledTarget objects that will be returned when GetCompiledTarget(IResolveContext) is called on that container and, therefore, the compiled target which is executed when the Resolve(IResolveContext) method is called. This has the side effect of overriding automatically resolved arguments (bound to a ResolvedTarget ) compiled in the overridden container by virtue of the fact that the overriding container is a different reference, because the ResolvedTarget is typically compiled with a check, at resolve-time, that the Container is the same container as the one that was active when it was originally compiled. In essence, when resolving an instance as a dependency the ResolvedTarget does something like this: resolveContext.Container == compileContext.Container ? (execute compile-time target) : resolveContext.Container.Resolve(type) Behaviour of enumerables The behaviour of enumerables depends on whether enumerables are enabled via the EnableEnumerableInjection option ( true by default) and whether the OverridingEnumerables is applied to the container (which it is, also by default, via the DefaultConfig ). If so, then any request for IEnumerable<T> will result in an enumerable which combines the one resolved by the Inner container, and then by any direct registration in this container. This mirrors the behaviour of the FetchAll(Type) implementation of the OverridingTargetContainer - which produces an enumerable of targets from both the base target container and the overriding one. If the OverridingEnumerables is not applied to this container, then any IEnumerable registered (or automatically built) in this container will override that of the Inner container. Constructors | Improve this Doc View Source OverridingContainer(IContainer, IRootTargetContainer, IContainerConfig) Creates a new instance of the OverridingContainer Declaration public OverridingContainer(IContainer inner, IRootTargetContainer targets = null, IContainerConfig config = null) Parameters Type Name Description IContainer inner Required. The inner container that this one combines with. Any dependencies not served by the new combined container's own targets will be sought from this container. Equally, any targets in the base which are resolved when the overriding container is the root container for a resolve operation, will resolve their dependencies from this container. IRootTargetContainer targets Optional. Contains the targets that will be used as the source of registrations for this container (note - separate to those of the inner container). If not provided, then a new TargetContainer will be created. IContainerConfig config Can be null. A configuration to apply to this container (and, potentially its Rezolver.Targets ). If not provided, then the DefaultConfig will be used Properties | Improve this Doc View Source Inner Gets the IContainer that is overriden by this container. Declaration public IContainer Inner { get; } Property Value Type Description IContainer Methods | Improve this Doc View Source CanResolve(IResolveContext) Called to determine if this container is able to resolve the type specified in the passed context . Declaration public override bool CanResolve(IResolveContext context) Parameters Type Name Description IResolveContext context Required. The IResolveContext . Returns Type Description Boolean true if either this container or the inner container can resolve the RequestedType ; otherwise false Overrides ContainerBase.CanResolve(IResolveContext) | Improve this Doc View Source GetFallbackCompiledTarget(IResolveContext) Overrides the base implementation to pass the lookup for an ITarget to the inner container - this is how dependency chaining from this container to the inner container is achieved. Declaration protected override ICompiledTarget GetFallbackCompiledTarget(IResolveContext context) Parameters Type Name Description IResolveContext context Required. The IResolveContext . Returns Type Description ICompiledTarget Overrides ContainerBase.GetFallbackCompiledTarget(IResolveContext) Implements IContainer IScopeFactory IServiceProvider IRootTargetContainer ITargetContainer ICovariantTypeIndex Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.ResolveMany(IContainer, Type) ContainerResolveExtensions.ResolveMany<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo, TImplementation>(IRootTargetContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, Type>) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Type) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, Type>) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, ITarget>) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, ITarget>) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(IRootTargetContainer) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorated>(IRootTargetContainer, Func<TDecorated, TDecorated>) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorated>(IRootTargetContainer, Delegate) DecoratorTargetContainerExtensions.RegisterDecorator(IRootTargetContainer, Delegate, Type) DecoratorTargetContainerExtensions.RegisterDecorator(IRootTargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection)"
  },
  "api/Rezolver.TargetContainer.html": {
    "href": "api/Rezolver.TargetContainer.html",
    "title": "Class TargetContainer | Rezolver IOC",
    "keywords": "Class TargetContainer Root container for ITarget s that can be used as the backing for the standard IContainer classes - Container and ScopedContainer . Stores and retrieves registrations of ITarget s, is also Generic type aware, unlike its base class - TargetDictionaryContainer . Inheritance Object TargetDictionaryContainer TargetContainer OverridingTargetContainer Implements IRootTargetContainer ITargetContainer ICovariantTypeIndex Inherited Members TargetDictionaryContainer.Fetch(Type) TargetDictionaryContainer.FetchAll(Type) TargetDictionaryContainer.FetchContainer(Type) TargetDictionaryContainer.EnsureContainer(Type) TargetDictionaryContainer.AutoRegisterContainer(Type) TargetDictionaryContainer.CombineWith(ITargetContainer, Type) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class TargetContainer : TargetDictionaryContainer, IRootTargetContainer, ITargetContainer, ICovariantTypeIndex Remarks This is the type used by default for the Targets of all the standard containers in the core framework, e.g. Container , ScopedContainer etc, when you don't supply an instance of an ITargetContainer explicitly on construction. Although you can derive from this class to extend its functionality; it's also possible to extend it via configuration (see ITargetContainerConfig ) - which is how, for example, the framework enables automatic injection of enumerables (see InjectEnumerables ) and lists (see InjectLists ). The DefaultConfig is used for new instances which are not passed an explicit configuration. Constructors | Improve this Doc View Source TargetContainer() Creates a new instance of the TargetContainer class without attaching any ITargetContainerConfig to it. This is desirable for derived types as behaviours typically will invoke methods on this target container which are declared virtual and which are, therefore, unsafe to be called during construction. Declaration protected TargetContainer() | Improve this Doc View Source TargetContainer(ITargetContainerConfig) Constructs a new instance of the TargetContainer class. Declaration public TargetContainer(ITargetContainerConfig config = null) Parameters Type Name Description ITargetContainerConfig config Optional. The configuration to apply to this target container. If null, then the DefaultConfig is used. Remarks Note to inheritors: this constructor will throw an InvalidOperationException if called by derived classes. You must instead use the TargetContainer() constructor and apply configuration in your constructor. Properties | Improve this Doc View Source DefaultConfig The default configuration used for TargetContainer objects created via the TargetContainer(ITargetContainerConfig) constructor when no configuration is explicitly passed. Declaration public static CombinedTargetContainerConfig DefaultConfig { get; } Property Value Type Description CombinedTargetContainerConfig Remarks The simplest way to configure all target container instances is to add/remove configs to this collection. Note also that the OverridingTargetContainer class also uses this. Default configurations In addition to some internal configurations, the configurations applied by default are: InjectEnumerables InjectArrays InjectLists InjectCollections InjectResolveContext | Improve this Doc View Source Root Always returns this instance. Declaration protected override IRootTargetContainer Root { get; } Property Value Type Description IRootTargetContainer Overrides TargetDictionaryContainer.Root Methods | Improve this Doc View Source CreateContainer(Type) Overrides CreateContainer(Type) to provide special support for open generic types and to support ITargetContainerFactory options. Declaration protected override ITargetContainer CreateContainer(Type targetContainerType) Parameters Type Name Description Type targetContainerType Returns Type Description ITargetContainer Overrides TargetDictionaryContainer.CreateContainer(Type) | Improve this Doc View Source GetTargetContainerType(Type) Called to get the type that's to be used to fetch a child ITargetContainer for targets registered against a given serviceType . Declaration protected override Type GetTargetContainerType(Type serviceType) Parameters Type Name Description Type serviceType The service type - usually pulled from the DeclaredType of a ITarget that is to be registered, or the service type passed to Fetch(Type) . Returns Type Description Type The redirected type, or the serviceType if no type redirection is necessary. Overrides TargetDictionaryContainer.GetTargetContainerType(Type) | Improve this Doc View Source Register(ITarget, Type) Overrides the base method to block registration if the target does not support the serviceType (checked by calling the target's SupportsType(Type) method). Declaration public override void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target The target to be registered. Type serviceType Optional - the type against which the target is to be registered, if different from the target's DeclaredType . Overrides TargetDictionaryContainer.Register(ITarget, Type) | Improve this Doc View Source RegisterContainer(Type, ITargetContainer) Implementation of RegisterContainer(Type, ITargetContainer) , overriding the base version to extend special support for open generic types and for ITargetContainerTypeResolver options. Declaration public override void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container Overrides TargetDictionaryContainer.RegisterContainer(Type, ITargetContainer) Events | Improve this Doc View Source TargetContainerRegistered Declaration public event EventHandler<TargetContainerRegisteredEventArgs> TargetContainerRegistered Event Type Type Description System.EventHandler < TargetContainerRegisteredEventArgs > | Improve this Doc View Source TargetRegistered Declaration public event EventHandler<TargetRegisteredEventArgs> TargetRegistered Event Type Type Description System.EventHandler < TargetRegisteredEventArgs > Explicit Interface Implementations | Improve this Doc View Source ICovariantTypeIndex.AddKnownType(Type) Declaration void ICovariantTypeIndex.AddKnownType(Type serviceType) Parameters Type Name Description Type serviceType | Improve this Doc View Source ICovariantTypeIndex.GetKnownCompatibleTypes(Type) Declaration IEnumerable<Type> ICovariantTypeIndex.GetKnownCompatibleTypes(Type serviceType) Parameters Type Name Description Type serviceType Returns Type Description System.Collections.Generic.IEnumerable < Type > | Improve this Doc View Source ICovariantTypeIndex.GetKnownCovariantTypes(Type) Declaration IEnumerable<Type> ICovariantTypeIndex.GetKnownCovariantTypes(Type serviceType) Parameters Type Name Description Type serviceType Returns Type Description System.Collections.Generic.IEnumerable < Type > Implements IRootTargetContainer ITargetContainer ICovariantTypeIndex Extension Methods RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo, TImplementation>(IRootTargetContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, Type>) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Type) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, Type>) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, ITarget>) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, ITarget>) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(IRootTargetContainer) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorated>(IRootTargetContainer, Func<TDecorated, TDecorated>) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorated>(IRootTargetContainer, Delegate) DecoratorTargetContainerExtensions.RegisterDecorator(IRootTargetContainer, Delegate, Type) DecoratorTargetContainerExtensions.RegisterDecorator(IRootTargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection)"
  },
  "api/Rezolver.CachingContainerBase.html": {
    "href": "api/Rezolver.CachingContainerBase.html",
    "title": "Class CachingContainerBase | Rezolver IOC",
    "keywords": "Class CachingContainerBase Builds on the ContainerBase base class to introduce thread-safe caching of compiled targets so they are only compiled once per requested type. Only creatable through inheritance. Inheritance Object ContainerBase CachingContainerBase Container Implements IContainer IScopeFactory IServiceProvider IRootTargetContainer ITargetContainer ICovariantTypeIndex Inherited Members ContainerBase.Targets ContainerBase.IRootTargetContainer.TargetRegistered ContainerBase.IRootTargetContainer.TargetContainerRegistered ContainerBase.Resolve(IResolveContext) ContainerBase.TryResolve(IResolveContext, Object) ContainerBase.CreateScope() ContainerBase.GetCompiledTarget(IResolveContext) ContainerBase.CanResolve(IResolveContext) ContainerBase.GetFallbackCompiledTarget(IResolveContext) ContainerBase.IServiceProvider.GetService(Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) ContainerBase.ITargetContainer.Fetch(Type) ContainerBase.ITargetContainer.FetchAll(Type) ContainerBase.ITargetContainer.CombineWith(ITargetContainer, Type) ContainerBase.ITargetContainer.FetchContainer(Type) ContainerBase.ITargetContainer.RegisterContainer(Type, ITargetContainer) ContainerBase.ICovariantTypeIndex.AddKnownType(Type) ContainerBase.ICovariantTypeIndex.GetKnownCovariantTypes(Type) ContainerBase.ICovariantTypeIndex.GetKnownCompatibleTypes(Type) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class CachingContainerBase : ContainerBase, IContainer, IScopeFactory, IServiceProvider, IRootTargetContainer, ITargetContainer, ICovariantTypeIndex Remarks Internally, the class uses a ConcurrentDictionary<TKey, TValue> to store ICompiledTarget s keyed by the requested type. All the main IContainer implementations used directly in an application should ideally inherit from this class, because otherwise every Resolve(IResolveContext) operation would require a compilation phase before the object could be returned, which would be incredibly slow. It's because of this caching that registering new targets in any ITargetContainer used by this class is not recommended: because after the first request for a particular type is made, the resultant ICompiledTarget is fixed until the container is thrown away. Constructors | Improve this Doc View Source CachingContainerBase(IRootTargetContainer) Creates a new instance of the CachingContainerBase class. Declaration protected CachingContainerBase(IRootTargetContainer targets = null) Parameters Type Name Description IRootTargetContainer targets Optional. The target container whose registrations will be used for dependency lookup when Resolve(IResolveContext) (and other operations) is called. If not provided, a new TargetContainer instance is constructed. This will ultimately be available to inherited types, after construction, through the Rezolver.Targets property. Methods | Improve this Doc View Source GetCompiledTargetVirtual(IResolveContext) Obtains an ICompiledTarget for the given context . Declaration protected override ICompiledTarget GetCompiledTargetVirtual(IResolveContext context) Parameters Type Name Description IResolveContext context Returns Type Description ICompiledTarget Overrides ContainerBase.GetCompiledTargetVirtual(IResolveContext) Remarks The method is called by Resolve(IResolveContext) to get the compiled target whose GetObject(IResolveContext) method is to be used to get the instance that is to be resolved for a given request. The internal cache is examined first to see if an entry exists for the RequestedType type and, if not, then the result of the base class' GetCompiledTarget(IResolveContext) is cached and returned. Implements IContainer IScopeFactory IServiceProvider IRootTargetContainer ITargetContainer ICovariantTypeIndex Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.ResolveMany(IContainer, Type) ContainerResolveExtensions.ResolveMany<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo, TImplementation>(IRootTargetContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, Type>) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Type) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, Type>) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, ITarget>) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, ITarget>) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(IRootTargetContainer) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorated>(IRootTargetContainer, Func<TDecorated, TDecorated>) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorated>(IRootTargetContainer, Delegate) DecoratorTargetContainerExtensions.RegisterDecorator(IRootTargetContainer, Delegate, Type) DecoratorTargetContainerExtensions.RegisterDecorator(IRootTargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection)"
  },
  "api/Rezolver.ContainerBase.html": {
    "href": "api/Rezolver.ContainerBase.html",
    "title": "Class ContainerBase | Rezolver IOC",
    "keywords": "Class ContainerBase Starting point for implementations of IContainer - only creatable through inheritance. Inheritance Object ContainerBase CachingContainerBase Implements IContainer IScopeFactory IServiceProvider IRootTargetContainer ITargetContainer ICovariantTypeIndex Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class ContainerBase : IContainer, IScopeFactory, IServiceProvider, IRootTargetContainer, ITargetContainer, ICovariantTypeIndex Remarks This class also implements ITargetContainer by proxying the Targets that are provided to it on construction (or created anew if not supplied). All of those interface methods are implemented explicitly except the Register(ITarget, Type) method, which is available through the class' public API. Note: IContainer s are generally not expected to implement ITargetContainer , and the framework will never assume they do. The reason this class does is to make it easier to create a new container and to register targets into it without having to worry about managing a separate ITargetContainer instance in your application root - because all the registration extension methods defined in classes like RegisterTypeTargetContainerExtensions , SingletonTargetContainerExtensions (plus many more) will be available to developers in code which has a reference to this class, or one derived from it. Note also that calling CombineWith(ITargetContainer, Type) on an instance of this type will always cause a NotSupportedException to be thrown, thus preventing containers from being registered as sub target containers within an ITargetContainer via its RegisterContainer(Type, ITargetContainer) method. Constructors | Improve this Doc View Source ContainerBase(IRootTargetContainer) Constructs a new instance of the ContainerBase class. Declaration protected ContainerBase(IRootTargetContainer targets = null) Parameters Type Name Description IRootTargetContainer targets Optional. The target container whose registrations will be used for dependency lookup when Resolve(IResolveContext) (and other operations) is called. If not provided, a new TargetContainer instance is constructed. This will ultimately be available to inherited types, after construction, through the Targets property. Properties | Improve this Doc View Source Targets Provides the ITarget instances that will be compiled into ICompiledTarget instances. Declaration protected IRootTargetContainer Targets { get; } Property Value Type Description IRootTargetContainer Remarks This class implements the ITargetContainer interface by wrapping around this instance so that an application can create an instance of ContainerBase and directly register targets into it; rather than having to create and setup the target container first. You can add registrations to this target container at any point in the lifetime of any ContainerBase instances which are attached to it. In reality, however, if any Resolve(IResolveContext) operations have been performed prior to adding more registrations, then there's no guarantee that new dependencies will be picked up - especially if the CachingContainerBase is being used as your application's container (which it nearly always will be). Methods | Improve this Doc View Source CanResolve(IResolveContext) Implementation of the CanResolve(IResolveContext) method. Returns true if, and only if, the Targets ITargetContainer returns a non-null ITarget when the RequestedType is passed to its Fetch(Type) method. Declaration public virtual bool CanResolve(IResolveContext context) Parameters Type Name Description IResolveContext context The resolve context containing the requested type. Returns Type Description Boolean | Improve this Doc View Source CreateScope() Implementation of the CreateScope() method. The base definition creates a ContainerScope with this container passed as the scope's container. Thus, the new scope is a 'root' scope. Declaration public virtual IContainerScope CreateScope() Returns Type Description IContainerScope | Improve this Doc View Source GetCompiledTarget(IResolveContext) Base implementation of GetCompiledTarget(IResolveContext) . Note that any container already defined in the Container is ignored in favour of this container. Declaration public ICompiledTarget GetCompiledTarget(IResolveContext context) Parameters Type Name Description IResolveContext context The context containing the requested type and any scope which is currently in force. Returns Type Description ICompiledTarget Always returns a reference to a compiled target - but note that if CanResolve(IResolveContext) returns false for the same context, then the target's GetObject(IResolveContext) method will likely throw an exception - in line with the behaviour of the UnresolvedTypeCompiledTarget class. | Improve this Doc View Source GetCompiledTargetVirtual(IResolveContext) The main workhorse of the resolve process - obtains an ICompiledTarget for the given context by looking up an ITarget from the Targets target container, then compiling it. Declaration protected virtual ICompiledTarget GetCompiledTargetVirtual(IResolveContext context) Parameters Type Name Description IResolveContext context The current resolve context Returns Type Description ICompiledTarget Remarks The specifics of how this process works are not important if you simply want to use the container, but if you are looking to extend it, then it's essential you understand the different steps that the process goes through: Locating the target If the Fetch(Type) method of the Targets target container returns a null ITarget , or one which has its UseFallback set to true , then the method gets an alternative compiled target by calling the GetFallbackCompiledTarget(IResolveContext) method. This fallback will be used unless the target was not null and its UseFallback is true AND the compiled target returned by the fallback method is an UnresolvedTypeCompiledTarget . To compile, or not to compile Before proceeding with compilation, the code checks whether the target can resolve the required object directly. This means that the target either implements the ICompiledTarget interface (in which case it is immediately returned) or the RequestedType is not Object and the target's type is compatible with it (in which case the target is simply embedded in a new ConstantCompiledTarget , which will later just return the target when its GetObject(IResolveContext) is called). The ObjectTarget supports the ICompiledTarget interface, therefore any objects which are directly registered through this target will always use that class' implementation of ICompiledTarget if requested through the Resolve(IResolveContext) method. Once the decision has been taken to compile the target, the container first needs a compiler ( ITargetCompiler ). This is obtained by resolving it directly from the Container of the context (since a container can be delegated to from another container which originally received the Resolve(IResolveContext) call). Attentive readers will realise at this point that this could lead to an infinite recursion - i.e. since compiling a target means resolving a compiler, which in turn must mean compiling that target. The class sidesteps this potential pitfall by requiring that a target registered for ITargetCompiler supports direct resolving, as per the description a couple of paragraphs back. Therefore, compilers and context providers are typically registered as constant services via the ObjectTarget target. Finally, a new ICompileContext is created via the CreateContext(IResolveContext, ITargetContainer) method of the resolved context provider, and then passed to the CompileTarget(ITarget, ICompileContext) method of the resolved compiler. The result of that operation is then returned to the caller. | Improve this Doc View Source GetFallbackCompiledTarget(IResolveContext) Called by GetCompiledTarget(IResolveContext) if no valid ITarget can be found for the context or if the one found has its UseFallback property set to true . Declaration protected virtual ICompiledTarget GetFallbackCompiledTarget(IResolveContext context) Parameters Type Name Description IResolveContext context Returns Type Description ICompiledTarget An ICompiledTarget to be used as the result of a Resolve(IResolveContext) operation where the search for a valid target either fails or is inconclusive (e.g. - empty enumerables). Remarks The base implementation always returns an instance of the UnresolvedTypeCompiledTarget . | Improve this Doc View Source GetService(Type) Protected virtual implementation of System.IServiceProvider.GetService(System.Type) . Uses the TryResolve(IResolveContext, out Object) method to resolve the service, returning null if the operation fails. Declaration protected virtual object GetService(Type serviceType) Parameters Type Name Description Type serviceType Type of service to be resolved. Returns Type Description Object | Improve this Doc View Source Register(ITarget, Type) Implementation of Register(ITarget, Type) - simply proxies the call to the target container referenced by the Targets property. Declaration public void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target Type serviceType Remarks Remember: registering new targets into an ITargetContainer after an IContainer has started compiling targets within it can yield unpredictable results. If you create a new container and perform all your registrations before you use it, however, then everything will work as expected. Note also the other ITargetContainer interface methods are implemented explicitly so as to hide them from the list of class members. | Improve this Doc View Source Resolve(IResolveContext) Implementation of the Resolve(IResolveContext) method. Obtains an ICompiledTarget by calling the GetCompiledTarget(IResolveContext) method, and then immediately calls its GetObject(IResolveContext) method, returning the result. Declaration public virtual object Resolve(IResolveContext context) Parameters Type Name Description IResolveContext context The context containing the type that's requested, any active scope and so on. Returns Type Description Object | Improve this Doc View Source TryResolve(IResolveContext, out Object) Implementation of the TryResolve(IResolveContext, out Object) method. Attempts to resolve the requested type (given on the context , returning a boolean indicating whether the operation was successful. If successful, then result receives a reference to the resolved object. Declaration public virtual bool TryResolve(IResolveContext context, out object result) Parameters Type Name Description IResolveContext context The context containing the type that's requested, any active scope and so on. Object result Receives a reference to the object that was resolved, if successful, or null if not. Returns Type Description Boolean A boolean indicating whether the operation completed successfully. Explicit Interface Implementations | Improve this Doc View Source ICovariantTypeIndex.AddKnownType(Type) Declaration void ICovariantTypeIndex.AddKnownType(Type serviceType) Parameters Type Name Description Type serviceType | Improve this Doc View Source ICovariantTypeIndex.GetKnownCompatibleTypes(Type) Declaration IEnumerable<Type> ICovariantTypeIndex.GetKnownCompatibleTypes(Type serviceType) Parameters Type Name Description Type serviceType Returns Type Description System.Collections.Generic.IEnumerable < Type > | Improve this Doc View Source ICovariantTypeIndex.GetKnownCovariantTypes(Type) Declaration IEnumerable<Type> ICovariantTypeIndex.GetKnownCovariantTypes(Type serviceType) Parameters Type Name Description Type serviceType Returns Type Description System.Collections.Generic.IEnumerable < Type > | Improve this Doc View Source IRootTargetContainer.TargetContainerRegistered Declaration event EventHandler<TargetContainerRegisteredEventArgs> IRootTargetContainer.TargetContainerRegistered Returns Type Description System.EventHandler < TargetContainerRegisteredEventArgs > | Improve this Doc View Source IRootTargetContainer.TargetRegistered Declaration event EventHandler<TargetRegisteredEventArgs> IRootTargetContainer.TargetRegistered Returns Type Description System.EventHandler < TargetRegisteredEventArgs > | Improve this Doc View Source ITargetContainer.CombineWith(ITargetContainer, Type) Declaration ITargetContainer ITargetContainer.CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Type type Returns Type Description ITargetContainer | Improve this Doc View Source ITargetContainer.Fetch(Type) Declaration ITarget ITargetContainer.Fetch(Type type) Parameters Type Name Description Type type Returns Type Description ITarget | Improve this Doc View Source ITargetContainer.FetchAll(Type) Declaration IEnumerable<ITarget> ITargetContainer.FetchAll(Type type) Parameters Type Name Description Type type Returns Type Description System.Collections.Generic.IEnumerable < ITarget > | Improve this Doc View Source ITargetContainer.FetchContainer(Type) Declaration ITargetContainer ITargetContainer.FetchContainer(Type type) Parameters Type Name Description Type type Returns Type Description ITargetContainer | Improve this Doc View Source ITargetContainer.RegisterContainer(Type, ITargetContainer) Declaration void ITargetContainer.RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container | Improve this Doc View Source IServiceProvider.GetService(Type) Declaration object IServiceProvider.GetService(Type serviceType) Parameters Type Name Description Type serviceType Returns Type Description Object Implements IContainer IScopeFactory IServiceProvider IRootTargetContainer ITargetContainer ICovariantTypeIndex Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.ResolveMany(IContainer, Type) ContainerResolveExtensions.ResolveMany<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo, TImplementation>(IRootTargetContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, Type>) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Type) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, Type>) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, ITarget>) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, ITarget>) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(IRootTargetContainer) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorated>(IRootTargetContainer, Func<TDecorated, TDecorated>) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorated>(IRootTargetContainer, Delegate) DecoratorTargetContainerExtensions.RegisterDecorator(IRootTargetContainer, Delegate, Type) DecoratorTargetContainerExtensions.RegisterDecorator(IRootTargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection)"
  },
  "api/Rezolver.GenericTargetContainer.html": {
    "href": "api/Rezolver.GenericTargetContainer.html",
    "title": "Class GenericTargetContainer | Rezolver IOC",
    "keywords": "Class GenericTargetContainer A special type of ITargetContainer which stores targets (and potentially other containers) which are specifically keyed either to a particular open generic type or a closed generic built from it. Inheritance Object TargetDictionaryContainer GenericTargetContainer Implements ITargetContainer Inherited Members TargetDictionaryContainer.Root TargetDictionaryContainer.FetchContainer(Type) TargetDictionaryContainer.EnsureContainer(Type) TargetDictionaryContainer.AutoRegisterContainer(Type) TargetDictionaryContainer.GetTargetContainerType(Type) TargetDictionaryContainer.CreateContainer(Type) TargetDictionaryContainer.CombineWith(ITargetContainer, Type) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class GenericTargetContainer : TargetDictionaryContainer, ITargetContainer Remarks You don't typically use this container directly - it is implicitly added to an ITargetContainer when generic types are registered. Indeed the TargetContainer and DecoratingTargetContainer both create instances of this; and the Rezolver.EnumerableTargetContainer (understandably) inherits from it. Constructors | Improve this Doc View Source GenericTargetContainer(IRootTargetContainer, Type) Initializes a new instance of the GenericTargetContainer class. Declaration public GenericTargetContainer(IRootTargetContainer root, Type genericType) Parameters Type Name Description IRootTargetContainer root Required. The root ITargetContainer in which the new generic target container will be registered. Type genericType Required. The generic type definition that all targets and subcontainers registered to the new container will have in common. Properties | Improve this Doc View Source GenericType Gets the open generic type definition which is common to all targets and containers within this container. Declaration public Type GenericType { get; } Property Value Type Description Type Methods | Improve this Doc View Source Fetch(Type) Gets the target which can be used to build an instance of type . Declaration public override ITarget Fetch(Type type) Parameters Type Name Description Type type Required. The type for which a target is to be obtained. Because of the restrictions placed on the DeclaredType of the targets that can actually be registered into this container, the function will only ever return anything if type is a closed generic type whose definition equals GenericType . Returns Type Description ITarget Overrides TargetDictionaryContainer.Fetch(Type) Remarks Targets which have been registered specifically against the exact closed generic type represented by type take precedence over any targets which have been registered against the open generic type GenericType . | Improve this Doc View Source FetchAll(Type) Implementation of FetchAll(Type) Declaration public override IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type The type whose targets are to be retrieved. Returns Type Description System.Collections.Generic.IEnumerable < ITarget > Overrides TargetDictionaryContainer.FetchAll(Type) | Improve this Doc View Source Register(ITarget, Type) Overrides the Register(ITarget, Type) method to support registering both targets against the open generic type GenericType and against specific closed versions of that open generic type. Declaration public override void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target The target to be registered Type serviceType Service type against which the registration will be made. If null, then it will be assumed to be equal to GenericType . Only types equal to GenericType or generic types whose generic type definition is equal to GenericType are supported. Overrides TargetDictionaryContainer.Register(ITarget, Type) Remarks Notes to overriders: When serviceType is a closed generic type, this function creates an ITargetContainer for that serviceType by calling the protected method AutoRegisterContainer(Type) if one doesn't exist (it calls FetchContainer(Type) to check for existence), and then chains to its Register(ITarget, Type) method. Exceptions Type Condition ArgumentException If serviceType is not equal to GenericType or is not a closed generic type whose generic type definition is GenericType . | Improve this Doc View Source RegisterContainer(Type, ITargetContainer) Override of the RegisterContainer(Type, ITargetContainer) method. Doesn't do anything different, except invalidate some internal caches. Declaration public override void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container Overrides TargetDictionaryContainer.RegisterContainer(Type, ITargetContainer) Implements ITargetContainer Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection) See Also TargetDictionaryContainer"
  },
  "api/Rezolver.ITargetContainer.html": {
    "href": "api/Rezolver.ITargetContainer.html",
    "title": "Interface ITargetContainer | Rezolver IOC",
    "keywords": "Interface ITargetContainer Stores and retrieves ITarget instances, keyed by the type of service that the targets are registered against. This is where all your service registrations will ultimately go. Namespace : Rezolver Assembly : Rezolver.dll Syntax public interface ITargetContainer Remarks You do not resolve objects from a target container, instead, it holds the ITarget s which will later be compiled to produce the objects. A target container is considered mutable for its entire lifetime, because it's only a glorified dictionary of targets from which multiple IContainer objects can be built (when using the types provided in the framework). As an example, the Container class uses this as the source of the registrations that it uses to resolve objects in its Resolve(IResolveContext) implementation. Note that there are multiple implementations of this interface in the framework, however the two you will use most commonly are TargetContainer and OverridingTargetContainer . Methods | Improve this Doc View Source CombineWith(ITargetContainer, Type) If supported by the implementation, this gets the container built from combining this container with an existing container as part of a registration inside another ITargetContainer . Declaration ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing The existing ITargetContainer instance that this instance is to be combined with Type type The type that the combined container owner will be registered under. Returns Type Description ITargetContainer Remarks Used most frequently in implementations of RegisterContainer(Type, ITargetContainer) when a container owner is already registered against the type, and a new container owner is then registered against the same type. This behaviour is used to implement open generics and decorators, and can be used to implement more besides. Exceptions Type Condition NotSupportedException If this container doesn't support being combined with another. | Improve this Doc View Source Fetch(Type) Retrieves a target for a particular type, or null if no target is registered against that type. Declaration ITarget Fetch(Type type) Parameters Type Name Description Type type Required. The type for which an ITarget is to be retrieved. Returns Type Description ITarget The target for the given type , or null if no target is found. Remarks The target you receive from this method depends entirely on the implementation. It could be the last target to be registered against the type or the first, or another target entirely. As mentioned in the documentation for the Register(ITarget, Type) method - the only guarantee is that if at least one target has been registered for the same type, then this method should return a valid target. | Improve this Doc View Source FetchAll(Type) Retrieves an enumerable of all targets that have been registered for a particular type . Declaration IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type Required. The type for which the ITarget s are to be retrieved. Returns Type Description System.Collections.Generic.IEnumerable < ITarget > An enumerable containing all the targets that have been registered against the given type , or, an empty enumerable if no targets have been registered. Remarks As with Fetch(Type) , the only guarantee is that if a target has been registered for the type through a call to Register(ITarget, Type) , then the returned enumerable will contain at least one valid target. | Improve this Doc View Source FetchContainer(Type) Retrieves an existing container registered against the given type , or null if not found. Declaration ITargetContainer FetchContainer(Type type) Parameters Type Name Description Type type Returns Type Description ITargetContainer | Improve this Doc View Source Register(ITarget, Type) Registers a target, either for the serviceType specified or, if null, the DeclaredType of the target . Declaration void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target Required. The target to be registered Type serviceType Optional. The type the target is to be registered against, if different from the DeclaredType of the target . If provided, then the target must be compatible with this type. Remarks The interface does not define the behaviour for when multiple targets are registered against the same type - although the default behaviour of the framework (via the TargetContainer class) is to allow this, with the last registered target being treated as the 'default' for that type. The only guarantee expected by the framework from implementations of this interface is that if a target is registered against a given type with this method, then a Fetch(Type) operation with the same type should return a valid target, and a FetchAll(Type) operation should return a non-empty enumerable of targets. Exceptions Type Condition ArgumentException If serviceType is non-null and the target 's SupportsType(Type) method returns false for that type. | Improve this Doc View Source RegisterContainer(Type, ITargetContainer) Registers a container against a given type . If a container already exists against this type, then the existing container's CombineWith(ITargetContainer, Type) method is called with the container as the argument, and the resulting container will replace the existing one. Declaration void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection)"
  },
  "api/Rezolver.Compilation.Expressions.html": {
    "href": "api/Rezolver.Compilation.Expressions.html",
    "title": "Namespace Rezolver.Compilation.Expressions | Rezolver IOC",
    "keywords": "Namespace Rezolver.Compilation.Expressions Classes ChangeTypeTargetBuilder Implementation of IExpressionBuilder specialised to build expressions for the ChangeTypeTarget This always produces a conversion expression (i.e. cast or box/unbox) CompiledTargetBuilder Special compiler for ITarget instances which are also ICompiledTarget instances. This build is only used when no 'better' builder is available for the target's type. So, the ObjectTargetBuilder will be used for ObjectTarget instead of this one, even though that class also implements ICompiledTarget . ConstructorTargetBuilder An IExpressionBuilder specialised for building the target ConstructorTarget DecoratorTargetBuilder Specialised builder for DecoratorTarget targets. DefaultTargetBuilder An IExpressionBuilder specialised for building the expression for the DefaultTarget target. Essentially, it just calls System.Linq.Expressions.Expression.Default(System.Type) for the DeclaredType . DelegateTargetBuilder Specialised builder for the DelegateTarget class and all its derivatives. EnumerableTargetBuilder An implementation of ExpressionBuilderBase<TTarget> specialised for the target type EnumerableTarget . ExpressionBuilderBase Abstract starting point for implementing IExpressionBuilder . Note that the interface is implemented explicitly; but exposes protected abstract or virtual methods for inheritors to extend. ExpressionBuilderBase.Methods Provides access to a set of MethodInfo objects for common functions required by code produced from ITarget s. Also contains some factory methods for building expressions which bind to those methods. ExpressionBuilderBase<TTarget> Abstract base class for implementations of IExpressionBuilder<TTarget> . Provide an implementation of Build(TTarget, IExpressionCompileContext, IExpressionCompiler) and then register an instance in an ObjectTarget in the active container. ExpressionCompileContext An implementation of ICompileContext which is specialised for use by an IExpressionCompiler . ExpressionCompiler Implementation of the ITargetCompiler interface which produces ICompiledTarget objects by building and compiling expression trees from the ITarget objects which are registered. ExpressionCompilerBuildExtensions Extensions for IExpressionCompiler . ExpressionTargetBuilder An IExpressionBuilder specialised for building the expression trees for the ExpressionTarget target type. This builder takes care of all expressions, including lambdas (where additional parameters beyond the standard IResolveContext are turned into local variables with injected values), producing an expression which can be compiled by an IExpressionCompiler after a Rezolver.Compilation.Expressions.TargetExpressionRewriter has been used to expand any targets embedded in the expression. GenericConstructorTargetBuilder An IExpressionBuilder specialised for building expressions for GenericConstructorTarget targets. ListTargetBuilder An IExpressionBuilder specialised for building expressions for the ListTarget target. ObjectTargetBuilder An IExpressionBuilder specialised to build expressions for the ObjectTarget target. OptionalParameterTargetBuilder An IExpressionBuilder specialised for building an expression for the OptionalParameterTarget target. ProjectionTargetBuilder RedundantConvertRewriter Removes unnecessary convert expressions from an expression. An unnecessary conversion is one where the target type is equal to, or a base of, the source type. Only boxing/unboxing conversions or upcasts are left intact. RezolvedTargetBuilder An IExpressionBuilder specialised for building the expression for the ResolvedTarget target. ScopedTargetBuilder An IExpressionBuilder specialised for building expressions for ScopedTarget targets. SharedExpressionKey Key for a shared expression used during expression tree generation. As a consumer of this library, you are unlikely ever to need to use it. SingletonTargetBuilder An IExpressionBuilder specialised for the building the expression for a SingletonTarget target. TargetExpression An expression which represents an ITarget , allowing a target with a particular DeclaredType to be used in place of a traditional expression. UnscopedTargetBuilder Builder for the UnscopedTarget . Interfaces IExpressionBuilder The interface for an object that produces expressions (which can be compiled to delegates) from ITarget instances. IExpressionBuilder<TTarget> Interface for an object that produces expressions from instances of TTarget . This is a generic extension to the IExpressionBuilder interface. IExpressionCompileContext Extension to the ICompileContext interface which provides additional state and functionality for the IExpressionCompiler and the IExpressionBuilder implementations which are used by the default expression compiler, the ExpressionCompiler class. IExpressionCompiler Interface for an object which is responsible for coordinating the production of expressions for targets during the compilation phase. Objects implementing this are expected to be implementations of ITargetCompiler ; this library provides the one implementation, too: ExpressionCompiler ."
  },
  "api/Rezolver.ScopedContainer.html": {
    "href": "api/Rezolver.ScopedContainer.html",
    "title": "Class ScopedContainer | Rezolver IOC",
    "keywords": "Class ScopedContainer Extends the Container to implement lifetime implicit scoping through the Scope that's created along with it. Implementation of the IScopedContainer interface. Inheritance Object ContainerBase CachingContainerBase Container ScopedContainer Implements IRootTargetContainer ITargetContainer ICovariantTypeIndex IScopedContainer IContainer IScopeFactory IServiceProvider IDisposable Inherited Members Container.DefaultConfig CachingContainerBase.GetCompiledTargetVirtual(IResolveContext) ContainerBase.Targets ContainerBase.IRootTargetContainer.TargetRegistered ContainerBase.IRootTargetContainer.TargetContainerRegistered ContainerBase.Resolve(IResolveContext) ContainerBase.TryResolve(IResolveContext, Object) ContainerBase.GetCompiledTarget(IResolveContext) ContainerBase.CanResolve(IResolveContext) ContainerBase.GetFallbackCompiledTarget(IResolveContext) ContainerBase.IServiceProvider.GetService(Type) ContainerBase.GetService(Type) ContainerBase.Register(ITarget, Type) ContainerBase.ITargetContainer.Fetch(Type) ContainerBase.ITargetContainer.FetchAll(Type) ContainerBase.ITargetContainer.CombineWith(ITargetContainer, Type) ContainerBase.ITargetContainer.FetchContainer(Type) ContainerBase.ITargetContainer.RegisterContainer(Type, ITargetContainer) ContainerBase.ICovariantTypeIndex.AddKnownType(Type) ContainerBase.ICovariantTypeIndex.GetKnownCovariantTypes(Type) ContainerBase.ICovariantTypeIndex.GetKnownCompatibleTypes(Type) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public sealed class ScopedContainer : Container, IRootTargetContainer, ITargetContainer, ICovariantTypeIndex, IScopedContainer, IContainer, IScopeFactory, IServiceProvider, IDisposable Remarks If you want your root container to act as a lifetime scope, then you should use this class instead of using Container . Note that this class does NOT implement the IContainerScope interface because the two interfaces are not actually compatible with each other, thanks to identical sets of extension methods. Constructors | Improve this Doc View Source ScopedContainer(IRootTargetContainer, IContainerConfig) Constructs a new instance of the ScopedContainer class. Declaration public ScopedContainer(IRootTargetContainer targets = null, IContainerConfig config = null) Parameters Type Name Description IRootTargetContainer targets Optional. Contains the targets that will be used as the source of registrations for the container, ultimately being passed to the Rezolver.Targets property. If not provided, then a new TargetContainer will be created. IContainerConfig config Can be null. A configuration to apply to this container (and, potentially its Rezolver.Targets ). If not provided, then the DefaultConfig will be used Properties | Improve this Doc View Source Scope Gets the scope for this scoped container. Note that this is used automatically by the container for Resolve(IResolveContext) operations where the Scope property is not already set. Declaration public IContainerScope Scope { get; } Property Value Type Description IContainerScope Methods | Improve this Doc View Source CreateScope() Overrides the base method's implementation of CreateScope() to pass the call to the Scope . Declaration public override IContainerScope CreateScope() Returns Type Description IContainerScope Overrides ContainerBase.CreateScope() | Improve this Doc View Source Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() Implements IRootTargetContainer ITargetContainer ICovariantTypeIndex IScopedContainer IContainer IScopeFactory IServiceProvider IDisposable Extension Methods ContainerResolveExtensions.Resolve(IContainer, Type) ContainerResolveExtensions.Resolve<TObject>(IContainer) ContainerResolveExtensions.ResolveMany(IContainer, Type) ContainerResolveExtensions.ResolveMany<TObject>(IContainer) ContainerResolveExtensions.TryResolve(IContainer, Type, out Object) ContainerResolveExtensions.TryResolve<TObject>(IContainer, out TObject) ContainerResolveExtensions.CanResolve(IContainer, Type) ContainerResolveExtensions.CanResolve<TObject>(IContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo, TImplementation>(IRootTargetContainer) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, Type>) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Type) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, Type>) RootTargetContainerExtensions.RegisterProjection<TFrom, TTo>(IRootTargetContainer, Func<IRootTargetContainer, ITarget, ITarget>) RootTargetContainerExtensions.RegisterProjection(IRootTargetContainer, Type, Type, Func<IRootTargetContainer, ITarget, ITarget>) AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorator, TDecorated>(IRootTargetContainer) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorated>(IRootTargetContainer, Func<TDecorated, TDecorated>) DecoratorTargetContainerExtensions.RegisterDecorator<TDecorated>(IRootTargetContainer, Delegate) DecoratorTargetContainerExtensions.RegisterDecorator(IRootTargetContainer, Delegate, Type) DecoratorTargetContainerExtensions.RegisterDecorator(IRootTargetContainer, Type, Type) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection)"
  },
  "api/Rezolver.TargetDictionaryContainer.html": {
    "href": "api/Rezolver.TargetDictionaryContainer.html",
    "title": "Class TargetDictionaryContainer | Rezolver IOC",
    "keywords": "Class TargetDictionaryContainer An ITargetContainer implementation that stores and retrieves ITarget and ITargetContainer by service type. Inheritance Object TargetDictionaryContainer GenericTargetContainer TargetContainer Implements ITargetContainer Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class TargetDictionaryContainer : ITargetContainer Remarks This class stores ITarget instances inside child ITargetContainer instances that are registered against types equal, or related, to the DeclaredType of the target. When Register(ITarget, Type) is called, an ITargetContainer is looked up which will 'own' that target. If one is not found, then one will be created and automatically registered (via EnsureContainer(Type) . With a (possibly new) child target container in hand, the registration is then delegated to that target container. Constructors | Improve this Doc View Source TargetDictionaryContainer(IRootTargetContainer) Constructs a new TargetDictionaryContainer optionally setting the Root target container. Declaration public TargetDictionaryContainer(IRootTargetContainer root) Parameters Type Name Description IRootTargetContainer root If this container belongs to one overarching root container (typically an instance of TargetContainer or OverridingTargetContainer ), then pass it here. Remarks The importance of the root target container is to enable code to be able to reach all registrations for all services rather than only those which are stored within this container, because this type is used both as a root, but also for other more specialised target containers. Properties | Improve this Doc View Source Root Never null. Returns the root target container. Declaration protected virtual IRootTargetContainer Root { get; } Property Value Type Description IRootTargetContainer If this instance is created with a root passed to the TargetDictionaryContainer(IRootTargetContainer) constructor, then it will be returned by this property. Otherwise it will return this instance. Methods | Improve this Doc View Source AutoRegisterContainer(Type) Called by Register(ITarget, Type) to create and register the container instance most suited for the passed target. The base implementation always creates a TargetListContainer , capable of storing multiple targets against a single type. Declaration protected virtual ITargetContainer AutoRegisterContainer(Type targetContainerType) Parameters Type Name Description Type targetContainerType The type that the target container is to be registered under. Note that this type will not be remapped by the GetTargetContainerType(Type) method - it will be used as-is. Returns Type Description ITargetContainer | Improve this Doc View Source CombineWith(ITargetContainer, Type) Not supported by default Declaration public virtual ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Type type Returns Type Description ITargetContainer | Improve this Doc View Source CreateContainer(Type) Called to create a new container instance which will be Declaration protected virtual ITargetContainer CreateContainer(Type targetContainerType) Parameters Type Name Description Type targetContainerType Returns Type Description ITargetContainer | Improve this Doc View Source EnsureContainer(Type) Called to make sure that an ITargetContainer has been registered which can act as owner to targets whose DeclaredType is equal to the passed serviceType so that a target or target container can be registered. Declaration protected ITargetContainer EnsureContainer(Type serviceType) Parameters Type Name Description Type serviceType Required. The service type against which a target registration is to be made (and for which a target container is required. Returns Type Description ITargetContainer A child target container into which targets, or another child target container, can be registered. Remarks An existing container is returned if FetchContainer(Type) returns it. If not, then a new container is created and registered via the AutoRegisterContainer(Type) method, and returned. Note that the serviceType will possibly be mapped to a different container type via any ITargetContainerTypeResolver that's registered via the options API. | Improve this Doc View Source Fetch(Type) Implementation of Fetch(Type) . Declaration public virtual ITarget Fetch(Type type) Parameters Type Name Description Type type The type whose default target is to be retrieved. Returns Type Description ITarget A single target representing the last target registered against the type , or, null if no target is found. Remarks Note - in scenarios where you are chaining multiple containers, then you should consult the return value's UseFallback property if the method returns non-null because, if true, then it's an instruction to use a parent container's result for the same type. | Improve this Doc View Source FetchAll(Type) Implementation of FetchAll(Type) Declaration public virtual IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type The type whose targets are to be retrieved. Returns Type Description System.Collections.Generic.IEnumerable < ITarget > A non-null enumerable containing the targets that match the type, or an empty enumerable if the type is not registered. | Improve this Doc View Source FetchContainer(Type) Obtains the child container which owns the given serviceType on behalf of this target container. Returns null if no entry is found. Declaration public virtual ITargetContainer FetchContainer(Type serviceType) Parameters Type Name Description Type serviceType The service type whose owning ITargetContainer is sought. Returns Type Description ITargetContainer The target container which manages the given service type, if one is registered - otherwise null . | Improve this Doc View Source GetTargetContainerType(Type) Called to get the type that's to be used to fetch a child ITargetContainer for targets registered against a given serviceType . Declaration protected virtual Type GetTargetContainerType(Type serviceType) Parameters Type Name Description Type serviceType The service type - usually pulled from the DeclaredType of a ITarget that is to be registered, or the service type passed to Fetch(Type) . Returns Type Description Type The base implementation always returns the serviceType | Improve this Doc View Source Register(ITarget, Type) Implementation of Register(ITarget, Type) . Declaration public virtual void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target The target to be registered Type serviceType The service type against which the target is to be registered, if different from the target's DeclaredType . Remarks This implementation creates a child ITargetContainer for the serviceType with a call to the protected method EnsureContainer(Type) if one doesn't already exist. The registration is then delegated to that child container's own implementation of Register(ITarget, Type) . | Improve this Doc View Source RegisterContainer(Type, ITargetContainer) Implementation of RegisterContainer(Type, ITargetContainer) Declaration public virtual void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container Remarks This container implementation actually stores containers against the types that targets are registered against, rather than simply storing a dictionary of targets. This method allows you to add your own containers against type (instead of the default, which is TargetListContainer ) so you can plug in some advanced behaviour into this container. For example, decorators are not actually ITarget implementations but specialised ITargetContainer instances into which the 'standard' targets are registered. Implements ITargetContainer Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection)"
  },
  "api/Rezolver.Compilation.CompileContext.html": {
    "href": "api/Rezolver.Compilation.CompileContext.html",
    "title": "Class CompileContext | Rezolver IOC",
    "keywords": "Class CompileContext Core implementation of ICompileContext . A root context (i.e. where ParentContext is null ; created via the CompileContext(IResolveContext, ITargetContainer, Type) constructor) is the starting point for all shared state, such as the Container and the compilation stack. The ITargetContainer implementation is done by decorating a new OverridingTargetContainer which wraps the actual target container which contains the targets which will be compiled, so that new registrations can be added without interfering with upstream containers. Note that many of the interface members are implemented explicitly - therefore most of your interaction with this type is through its implementation of ICompileContext and ITargetContainer . Inheritance Object CompileContext ExpressionCompileContext Implements ICompileContext ITargetContainer Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver.Compilation Assembly : Rezolver.dll Syntax public class CompileContext : ICompileContext, ITargetContainer Remarks Note that you can only create an instance of this either through inheritance, via the explicit implementation of NewContext(Type, Nullable<ScopeBehaviour>, Nullable<ScopePreference>) , or (preferably) via the CreateContext(IResolveContext, ITargetContainer) method of an ITargetCompiler resolved from an IContainer . Constructors | Improve this Doc View Source CompileContext(ICompileContext, Type, Nullable<ScopeBehaviour>, Nullable<ScopePreference>) Creates a new CompileContext as a child of another. Declaration protected CompileContext(ICompileContext parentContext, Type targetType = null, ScopeBehaviour? scopeBehaviourOverride = default (ScopeBehaviour? ), ScopePreference? scopePreferenceOverride = default (ScopePreference? )) Parameters Type Name Description ICompileContext parentContext Used to seed the compilation stack, container, dependency container (which will still be wrapped in a new OverridingTargetContainer for isolation) and, optionally, the target type (unless you pass a non-null type for targetType , which would override that). Type targetType The target type that is expected to be compiled, or null if the TargetType is to be inherited from the parentContext . System.Nullable < ScopeBehaviour > scopeBehaviourOverride Override the scope behaviour to be used for the target that is compiled with this context. System.Nullable < ScopePreference > scopePreferenceOverride Allows you to override the scope preference for any target being compiled in this context - if not provided, then it is automatically inherited from the parent. | Improve this Doc View Source CompileContext(IResolveContext, ITargetContainer, Type) Creates a new CompileContext Declaration protected CompileContext(IResolveContext resolveContext, ITargetContainer dependencyTargetContainer, Type targetType = null) Parameters Type Name Description IResolveContext resolveContext Required. The context for which compilation is being performed. ITargetContainer dependencyTargetContainer Required - An ITargetContainer that contains the ITarget s that will be required to complete compilation. Note - this argument is passed to a new OverridingTargetContainer that is created and proxied by this class' implementation of ITargetContainer . As a result, it's possible to register new targets directly into the context via its implementation of ITargetContainer , without modifying the underlying targets in the container you pass. Type targetType Optional. Will be set into the TargetType property. If null, then any ITarget that is compiled should be compiled for its own DeclaredType . Properties | Improve this Doc View Source CompileStack Gets the stack entries for all the targets that are being compiled for all contexts related to this one - both up and down the hierarchy. Declaration public IEnumerable<CompileStackEntry> CompileStack { get; } Property Value Type Description System.Collections.Generic.IEnumerable < CompileStackEntry > The compile stack. | Improve this Doc View Source DependencyTargetContainer This is the ITargetContainer through which dependencies are resolved by this context in its implementation of ITargetContainer . In essence, this class acts as a decorator for this inner target container. Declaration protected ITargetContainer DependencyTargetContainer { get; } Property Value Type Description ITargetContainer | Improve this Doc View Source ParentContext Gets the parent context from which this context was created, if applicable. Declaration public ICompileContext ParentContext { get; } Property Value Type Description ICompileContext The parent context. | Improve this Doc View Source ResolveContext Implementation of ResolveContext Declaration public IResolveContext ResolveContext { get; } Property Value Type Description IResolveContext | Improve this Doc View Source ScopeBehaviourOverride Implementation of ScopeBehaviourOverride Declaration public ScopeBehaviour? ScopeBehaviourOverride { get; } Property Value Type Description System.Nullable < ScopeBehaviour > | Improve this Doc View Source ScopePreferenceOverride Implementation of ScopePreferenceOverride Declaration public ScopePreference? ScopePreferenceOverride { get; } Property Value Type Description System.Nullable < ScopePreference > | Improve this Doc View Source TargetType Any ICompiledTarget built for a ITarget with this context should target this type. If null, then the DeclaredType of the target being compiled should be used. Declaration public Type TargetType { get; } Property Value Type Description Type Remarks Note that when creating a child context with a null targetType argument, this property will be inherited from the ParentContext . Methods | Improve this Doc View Source NewContext(Type, Nullable<ScopeBehaviour>, Nullable<ScopePreference>) Used by the explicit implementation of NewContext(Type, Nullable<ScopeBehaviour>, Nullable<ScopePreference>) . Override this in your derived class to create the correct implementation of ICompileContext . Declaration protected virtual ICompileContext NewContext(Type targetType = null, ScopeBehaviour? scopeBehaviourOverride = default (ScopeBehaviour? ), ScopePreference? scopePreferenceOverride = default (ScopePreference? )) Parameters Type Name Description Type targetType Optional. The type for which the target is to be compiled, if different from this context's TargetType . System.Nullable < ScopeBehaviour > scopeBehaviourOverride Override the scope behaviour to be used for the target that is compiled with the new context. System.Nullable < ScopePreference > scopePreferenceOverride Sets the ScopePreferenceOverride . As soon as this is set on one context, it is automatically inherited by all its child contexts (i.e. you cannot null it) Returns Type Description ICompileContext Explicit Interface Implementations | Improve this Doc View Source ICompileContext.NewContext(Type, Nullable<ScopeBehaviour>, Nullable<ScopePreference>) Declaration ICompileContext ICompileContext.NewContext(Type targetType, ScopeBehaviour? scopeBehaviourOverride, ScopePreference? scopePreferenceOverride) Parameters Type Name Description Type targetType System.Nullable < ScopeBehaviour > scopeBehaviourOverride System.Nullable < ScopePreference > scopePreferenceOverride Returns Type Description ICompileContext | Improve this Doc View Source ICompileContext.PopCompileStack() Pops a target from the stack and returns it. Note that if there are no targets on the stack, an InvalidOperationException will occur. Declaration CompileStackEntry ICompileContext.PopCompileStack() Returns Type Description CompileStackEntry The CompileStackEntry that was popped off the compilation stack. Remarks If ParentContext is not null, then the call is redirected to that context, so that the compilation stack is always shared between all contexts spawned from the same root. | Improve this Doc View Source ICompileContext.PushCompileStack(ITarget, Type) Adds the target to the compilation stack if it doesn't already exist. Declaration bool ICompileContext.PushCompileStack(ITarget toCompile, Type targetType) Parameters Type Name Description ITarget toCompile The target to be pushed Type targetType The type for which the target is being compiled, if different from DeclaredType Returns Type Description Boolean Remarks Targets can appear on the compilation stack more than once for different types, since the ICompiledTarget produced for a target for one type can be different than it is for another. Ultimately, if a target does in fact have a cyclic dependency graph, then this method will detect that. | Improve this Doc View Source ITargetContainer.CombineWith(ITargetContainer, Type) Always throws a NotSupportedException Declaration ITargetContainer ITargetContainer.CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing Ignored Type type Ignored Returns Type Description ITargetContainer Exceptions Type Condition NotSupportedException Always thrown | Improve this Doc View Source ITargetContainer.Fetch(Type) Implements Fetch(Type) by wrapping around the child target container created by this context on construction. Declaration ITarget ITargetContainer.Fetch(Type type) Parameters Type Name Description Type type See Fetch(Type) for more. Returns Type Description ITarget | Improve this Doc View Source ITargetContainer.FetchAll(Type) Implements FetchAll(Type) by wrapping around the child target container created by this context on construction. Declaration IEnumerable<ITarget> ITargetContainer.FetchAll(Type type) Parameters Type Name Description Type type See FetchAll(Type) for more Returns Type Description System.Collections.Generic.IEnumerable < ITarget > | Improve this Doc View Source ITargetContainer.FetchContainer(Type) Declaration ITargetContainer ITargetContainer.FetchContainer(Type type) Parameters Type Name Description Type type Returns Type Description ITargetContainer | Improve this Doc View Source ITargetContainer.Register(ITarget, Type) Implements Register(ITarget, Type) by wrapping around the child target container created by this context on construction. Declaration void ITargetContainer.Register(ITarget target, Type serviceType) Parameters Type Name Description ITarget target See Register(ITarget, Type) for more Type serviceType See Register(ITarget, Type) for more | Improve this Doc View Source ITargetContainer.RegisterContainer(Type, ITargetContainer) Declaration void ITargetContainer.RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type ITargetContainer container Implements ICompileContext ITargetContainer Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection) See Also ICompileContext ITargetContainer"
  },
  "api/Rezolver.DecoratingTargetContainer.html": {
    "href": "api/Rezolver.DecoratingTargetContainer.html",
    "title": "Class DecoratingTargetContainer | Rezolver IOC",
    "keywords": "Class DecoratingTargetContainer Implements service decoration in an ITargetContainer , producing instances of the DecoratorTarget when Fetch(Type) or FetchAll(Type) are called. The best way to add a decorator to your target container is to use the extension methods in DecoratorTargetContainerExtensions - which provide simple shortcuts for creating decoration registrations. Inheritance Object DecoratingTargetContainer Implements ITargetContainer Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : Rezolver Assembly : Rezolver.dll Syntax public class DecoratingTargetContainer : ITargetContainer Remarks This class does not implement ITarget , rather it's an ITargetContainer into which other targets can be added, and when Fetch(Type) or FetchAll(Type) are called, a temporary DecoratorTarget is created which wraps around the targets that have been registered within and which will ultimately execute the decoration. Currently, it is possible to decorate with: An auto-injected instance of a decorator type A decorator delegate which both receives and returns an instance of the decorated type. Constructors | Improve this Doc View Source DecoratingTargetContainer(IRootTargetContainer, ITarget, Type) Create a new instance of the DecoratingTargetContainer class to decorate instances of decoratedType with instances produced by the decoratorTarget . Declaration public DecoratingTargetContainer(IRootTargetContainer root, ITarget decoratorTarget, Type decoratedType) Parameters Type Name Description IRootTargetContainer root Required. The root ITargetContainer to which this decorating container will be registered. ITarget decoratorTarget Type decoratedType | Improve this Doc View Source DecoratingTargetContainer(IRootTargetContainer, Type, Type) Initializes a new instance of the DecoratingTargetContainer class to decorate instances of decoratedType with new instances of decoratorType which are created via constructor injection. Declaration public DecoratingTargetContainer(IRootTargetContainer root, Type decoratorType, Type decoratedType) Parameters Type Name Description IRootTargetContainer root Required. The root ITargetContainer to which this decorating container will be registered. Type decoratorType Type of the decorator. Type decoratedType Type being decorated. Properties | Improve this Doc View Source DecoratedType Gets the type that's being decorated - is also the type under which this decorating container is registered in the Rezolver.DecoratingTargetContainer.Root Declaration public Type DecoratedType { get; } Property Value Type Description Type Methods | Improve this Doc View Source CombineWith(ITargetContainer, Type) Implements CombineWith(ITargetContainer, Type) by wrapping the existing container and returning itself. This allows decorators to be applied on top of decorators; and decorators to be added after types have begun to be registered in another target container. Declaration public ITargetContainer CombineWith(ITargetContainer existing, Type type) Parameters Type Name Description ITargetContainer existing The existing ITargetContainer instance that this instance is to be combined with Type type The type that the combined container owner will be registered under. Returns Type Description ITargetContainer Exceptions Type Condition InvalidOperationException If this target container is already decorating another container | Improve this Doc View Source Fetch(Type) Implementation of Fetch(Type) - wraps a special target around the target returned by the target container that's decorated by this one. Declaration public ITarget Fetch(Type type) Parameters Type Name Description Type type Required. The type for which an ITarget is to be retrieved. Returns Type Description ITarget Remarks If the inner container returns null, then so does this one. | Improve this Doc View Source FetchAll(Type) Implementation of FetchAll(Type) - passes the call on to the inner container that's decorated by this one, and then wraps each of those targets in a DecoratorTarget which represents the decoration logic for each instance. Declaration public IEnumerable<ITarget> FetchAll(Type type) Parameters Type Name Description Type type Required. The type for which the ITarget instances are to be retrieved. Returns Type Description System.Collections.Generic.IEnumerable < ITarget > | Improve this Doc View Source FetchContainer(Type) Retrieves an existing container registered against the given type , or null if not found. Declaration public ITargetContainer FetchContainer(Type type) Parameters Type Name Description Type type The type. Returns Type Description ITargetContainer Remarks This is an implementation of FetchContainer(Type) which wraps around the inner target container and passes the call on to that. | Improve this Doc View Source Register(ITarget, Type) Registers a target, either for the serviceType specified or, if null, the DeclaredType of the target . Implementation of Register(ITarget, Type) . Declaration public void Register(ITarget target, Type serviceType = null) Parameters Type Name Description ITarget target Required. The target to be registered Type serviceType Optional. The type the target is to be registered against, if different from the DeclaredType of the target . If provided, then the target must be compatible with this type. Remarks The decorator target does not accept registrations directly; rather it passes the call on to its inner container which could be a TargetListContainer , or GenericTargetContainer in the most basic cases; or it could be another DecoratingTargetContainer in situations where a type has had multiple decorators registered against it. | Improve this Doc View Source RegisterContainer(Type, ITargetContainer) Implementation of RegisterContainer(Type, ITargetContainer) - the call is automatically forwarded on to the inner target container that's being decorated, since decorator targets don't support direct registration of targets or containers. Declaration public void RegisterContainer(Type type, ITargetContainer container) Parameters Type Name Description Type type The type. ITargetContainer container The container. Implements ITargetContainer Extension Methods AliasTargetContainerExtensions.RegisterAlias<TAlias, TOriginal>(ITargetContainer) AliasTargetContainerExtensions.RegisterAlias(ITargetContainer, Type, Type) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor(ITargetContainer, ConstructorInfo, Type, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, Action<IMemberBindingBehaviourBuilder<TObject>>) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) TargetContainerRegistrationExtensions.RegisterGenericConstructor<TObject, TService>(ITargetContainer, Expression<Func<TObject>>, IMemberBindingBehaviour) DelegateTargetContainerExtensions.RegisterDelegate(ITargetContainer, Delegate, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<TResult>(ITargetContainer, Func<IResolveContext, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, TResult>(ITargetContainer, Func<T1, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, TResult>(ITargetContainer, Func<T1, T2, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, TResult>(ITargetContainer, Func<T1, T2, T3, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, TResult>(ITargetContainer, Func<T1, T2, T3, T4, TResult>, Type, ScopeBehaviour) DelegateTargetContainerExtensions.RegisterDelegate<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Func<T1, T2, T3, T4, T5, TResult>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<TResult>(ITargetContainer, Expression<Func<IResolveContext, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, TResult>(ITargetContainer, Expression<Func<T1, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, TResult>(ITargetContainer, Expression<Func<T1, T2, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, TResult>>, Type, ScopeBehaviour) ExpressionTargetContainerExtensions.RegisterExpression<T1, T2, T3, T4, T5, TResult>(ITargetContainer, Expression<Func<T1, T2, T3, T4, T5, TResult>>, Type, ScopeBehaviour) MultipleTargetContainerExtensions.RegisterMultiple(ITargetContainer, IEnumerable<ITarget>, Type) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, IEnumerable<ITarget>) MultipleTargetContainerExtensions.RegisterAll(ITargetContainer, ITarget[]) ObjectTargetContainerExtensions.RegisterObject<T>(ITargetContainer, T, Type, Type, ScopeBehaviour) ObjectTargetContainerExtensions.RegisterObject(ITargetContainer, Object, Type, Type, ScopeBehaviour) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.SetOption<TOption>(ITargetContainer, TOption, Type) OptionsTargetContainerExtensions.SetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOption<TOption>(ITargetContainer, Type, TOption) OptionsTargetContainerExtensions.GetOption<TOption, TService>(ITargetContainer, TOption) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer) OptionsTargetContainerExtensions.GetOptions<TOption>(ITargetContainer, Type) OptionsTargetContainerExtensions.GetOptions<TOption, TService>(ITargetContainer) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType(ITargetContainer, Type, Type, IMemberBindingBehaviour) RegisterTypeTargetContainerExtensions.RegisterType<TObject>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) RegisterTypeTargetContainerExtensions.RegisterType<TObject, TService>(ITargetContainer, Action<IMemberBindingBehaviourBuilder<TObject>>) ScopedTargetContainerExtensions.RegisterScoped<TObject>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) ScopedTargetContainerExtensions.RegisterScoped(ITargetContainer, Type, Type, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton<TObject, TService>(ITargetContainer, IMemberBindingBehaviour) SingletonTargetContainerExtensions.RegisterSingleton(ITargetContainer, Type, Type, IMemberBindingBehaviour) MSDIITargetContainerExtensions.Populate(ITargetContainer, IServiceCollection)"
  }
}