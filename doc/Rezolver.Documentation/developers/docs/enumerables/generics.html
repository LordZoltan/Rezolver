<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
  	<meta charset="utf-8">
  	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  	<title>Enumerables of Generics | Rezolver IOC </title>
  	<meta name="viewport" content="width=device-width">
  	<meta name="title" content="Enumerables of Generics | Rezolver IOC ">
  	<meta name="generator" content="docfx 2.24.0.0">
  	<meta name="description" content="Rezolver is the portable open-source IOC container framework for .Net - built from the ground up for .Net Core, Asp.Net Core, and also optimised for the 'full .Net' :)">
  	<link rel="shortcut icon" href="../../favicon.ico">
  	<link rel="stylesheet" href="../../styles/docfx.vendor.css">
  	<link rel="stylesheet" href="../../styles/docfx.css">
  	<link rel="stylesheet" href="../../styles/main.css">
  	<meta property="docfx:navrel" content="../../toc.html">
  	<meta property="docfx:tocrel" content="../toc.html">
  	<meta property="docfx:rel" content="../../">
  	
  		<link rel="apple-touch-icon" sizes="57x57" href="../../../apple-touch-icon-57x57.png">
  		<link rel="apple-touch-icon" sizes="60x60" href="../../../apple-touch-icon-60x60.png">
  		<link rel="apple-touch-icon" sizes="72x72" href="../../../apple-touch-icon-72x72.png">
  		<link rel="apple-touch-icon" sizes="76x76" href="../../../apple-touch-icon-76x76.png">
  		<link rel="apple-touch-icon" sizes="114x114" href="../../../apple-touch-icon-114x114.png">
  		<link rel="apple-touch-icon" sizes="120x120" href="../../../apple-touch-icon-120x120.png">
  		<link rel="apple-touch-icon" sizes="144x144" href="../../../apple-touch-icon-144x144.png">
  		<link rel="apple-touch-icon" sizes="152x152" href="../../../apple-touch-icon-152x152.png">
  		<link rel="apple-touch-icon" sizes="180x180" href="../../../apple-touch-icon-180x180.png">
  		<link rel="icon" type="image/png" href="../../../favicon-32x32.png" sizes="32x32">
  		<link rel="icon" type="image/png" href="../../../android-chrome-192x192.png" sizes="192x192">
  		<link rel="icon" type="image/png" href="../../../favicon-96x96.png" sizes="96x96">
  		<link rel="icon" type="image/png" href="../../../favicon-16x16.png" sizes="16x16">
  		<link rel="manifest" href="../../../manifest.json">
  		<link rel="mask-icon" href="../../../safari-pinned-tab.svg" color="#5bbad5">
  		<meta name="msapplication-TileColor" content="#da532c">
  		<meta name="msapplication-TileImage" content="../../../mstile-144x144.png">
  		<meta name="theme-color" content="#ffffff">
  	<script>
  	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  	  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  	
  	  ga('create', 'UA-92764222-1', 'auto');
  	  ga('send', 'pageview');
  	
  	</script></head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../../content/rz_square_white_on_orange_48x48.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
        		<p class="navbar-text navbar-right github-link"><a href="http://github.com/ZolutionSoftware/Rezolver" target="_blank" title="See this project on Github"><span class="fa fa-github"></span></a></p>
        		<form class="navbar-form navbar-right" role="search" id="search">
        		<div class="form-group">
        			<input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
        		</div>
        		</form>
        		<p class="navbar-text navbar-right">
        			<a href="https://www.nuget.org/packages/Rezolver" target="_blank"><img src="//img.shields.io/nuget/v/Rezolver.svg?style=plastic&amp;maxage=480" title="Get the Nuget Package"></a>
        			<a href="http://waffle.io/ZolutionSoftware/Rezolver" title="Open the Waffleboard for this project" target="_blank"><img alt="Work in Progress" src="https://badge.waffle.io/ZolutionSoftware/Rezolver.png?label=in%20progress&title=In%20Progress"></a>
        			<!-- <a href="http://waffle.io/ZolutionSoftware/Rezolver" title="Open the Waffleboard for this project" target="_blank"><img alt="Work prepared" src="https://badge.waffle.io/ZolutionSoftware/Rezolver.png?label=ready&title=Ready"></img></a> -->
        		</p>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="enumerables-of-generics">Enumerables of Generics</h1>

<p>Now you&#39;ve seen how Rezolver&#39;s <a href="../enumerables.html">automatic enumerable injection works</a>, let&#39;s move on to how 
generics work in the context of enumerable injection.</p>
<h2 id="open-generics">Open Generics</h2>
<p>You can register multiple open generics of the same type (e.g. <code>IFoo&lt;&gt;</code>), resolve an enumerable of 
<code>IFoo&lt;Bar&gt;</code>, and the container will create an enumerable containing an object for each open generic registration:</p>
<pre><code class="lang-csharp" name="UsesAnyService.cs">public interface IUsesAnyService&lt;TAnyService&gt;
{
    void UseTheService(TAnyService service);
}

public class UsesAnyService&lt;TAnyService&gt; : IUsesAnyService&lt;TAnyService&gt;
{
    public void UseTheService(TAnyService service)
    {
        throw new NotImplementedException();
    }
}

public class UsesAnyService2&lt;TAnyService&gt; : IUsesAnyService&lt;TAnyService&gt;
{
    public void UseTheService(TAnyService service)
    {
        throw new NotImplementedException();
    }
}
</code></pre><pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
container.RegisterType(typeof(UsesAnyService&lt;&gt;), typeof(IUsesAnyService&lt;&gt;));
container.RegisterType(typeof(UsesAnyService2&lt;&gt;), typeof(IUsesAnyService&lt;&gt;));

var result = container.ResolveMany&lt;IUsesAnyService&lt;IMyService&gt;&gt;().ToArray();

Assert.Equal(2, result.Length);
Assert.IsType&lt;UsesAnyService&lt;IMyService&gt;&gt;(result[0]);
Assert.IsType&lt;UsesAnyService2&lt;IMyService&gt;&gt;(result[1]);
</code></pre><hr>
<h2 id="constrained-generics">Constrained Generics</h2>
<p>When one or more constrained open generic types are registered against an open generic type, Rezolver will only
include results from registrations whose target type&#39;s constraints are met.</p>
<pre><code class="lang-csharp" name="ConstrainedGenerics.cs">public interface IGeneric&lt;T&gt;
{
    
}

public class GenericAny&lt;T&gt; : IGeneric&lt;T&gt;
{

}

public class GenericAnyIMyService&lt;T&gt; : IGeneric&lt;T&gt;
    where T: IMyService
{

}

public class GenericAnyMyService1&lt;T&gt; : IGeneric&lt;T&gt;
    where T: MyService1
{

}

/// &lt;summary&gt;
/// Note - used in the per-service &#39;best match only&#39; example
/// &lt;/summary&gt;
public class GenericMyService2 : IGeneric&lt;MyService2&gt;
{

}
</code></pre><pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
container.RegisterType(typeof(GenericAny&lt;&gt;), typeof(IGeneric&lt;&gt;));
container.RegisterType(typeof(GenericAnyIMyService&lt;&gt;), typeof(IGeneric&lt;&gt;));
container.RegisterType(typeof(GenericAnyMyService1&lt;&gt;), typeof(IGeneric&lt;&gt;));

var anyResult = container.ResolveMany&lt;IGeneric&lt;string&gt;&gt;().ToArray();
var myServiceResult = container.ResolveMany&lt;IGeneric&lt;MyService&gt;&gt;().ToArray();
var myService1Result = container.ResolveMany&lt;IGeneric&lt;MyService1&gt;&gt;().ToArray();

// only the first registration matches IGeneric&lt;string&gt;
Assert.Equal(1, anyResult.Length);
Assert.IsType&lt;GenericAny&lt;string&gt;&gt;(anyResult[0]);

// First and second registrations match IGeneric&lt;MyService&gt;
// Note the order: both registrations were IGeneric&lt;&gt; so the constrained generic
// appears after the non-constrained one.
Assert.Equal(2, myServiceResult.Length);
Assert.IsType&lt;GenericAny&lt;MyService&gt;&gt;(myServiceResult[0]);
Assert.IsType&lt;GenericAnyIMyService&lt;MyService&gt;&gt;(myServiceResult[1]);

// All registrations match and, again, all are returned in order.
Assert.Equal(3, myService1Result.Length);
Assert.IsType&lt;GenericAny&lt;MyService1&gt;&gt;(myService1Result[0]);
Assert.IsType&lt;GenericAnyIMyService&lt;MyService1&gt;&gt;(myService1Result[1]);
Assert.IsType&lt;GenericAnyMyService1&lt;MyService1&gt;&gt;(myService1Result[2]);
</code></pre><hr>
<h2 id="mixing-openclosed-generics">Mixing open/closed generics</h2>
<p>In many applications which use DI and generics, you often have &#39;common&#39; open generic registrations, such as
those in the <a href="#open-generics">first example above</a>, and then specific registrations for one or more 
well-known <em>closed</em> generics.</p>
<p>When resolving a single instance for a given generic, Rezolver will of course select the newest <em>most specific</em> 
registration it can find.  This means that if you have registrations for both <code>IFoo&lt;&gt;</code> and <code>IFoo&lt;Bar&gt;</code> and 
request an instance of <code>IFoo&lt;Bar&gt;</code>, then the second registration is used.</p>
<div class="TIP"><h5>Tip</h5><p>Rezolver&#39;s generic type matching works on an inside-out basis, so if you request <code>IGeneric&lt;IFoo&lt;IBar&gt;&gt;</code> from
the container, it searches for registrations for the following types, in this order:</p>
<ul>
<li><code>IGeneric&lt;IFoo&lt;IBar&gt;&gt;</code></li>
<li><code>IGeneric&lt;IFoo&lt;&gt;&gt;</code></li>
<li><code>IGeneric&lt;&gt;</code></li>
</ul>
<p>This search order is the same regardless of the order the registrations are made.  So, if an 
<code>IGeneric&lt;IFoo&lt;IBar&gt;&gt;</code> was the last to be added to the target container, it&#39;s still returned first.</p>
</div>
<p>If, however, you request an <code>IEnumerable&lt;IFoo&lt;Bar&gt;&gt;</code>, what should Rezolver return?</p>
<p>The answer is: it depends on your specific need.  Sometimes you might want all applicable objects to be returned
(the default behaviour), and sometimes you might only want the best-matched registrations (i.e. the first batch
of registrations found for one of the generic types being searched, as per the above Tip callout) to be used.</p>
<p>The good news is that it&#39;s easy to tell Rezolver which of the behaviours you want it to use - both globally and
on a per-service basis.</p>
<h3 id="all-possible-generics">All possible generics</h3>
<div class="NOTE"><h5>Note</h5><p>The new default functionality described here represents a breaking change from 1.2.</p>
<p>The old behaviour can be re-enabled by setting the <a class="xref" href="../../api/Rezolver.Options.FetchAllMatchingGenerics.html">FetchAllMatchingGenerics</a> option 
to <code>false</code>, as shown in the next example.</p>
</div>
<p>Let&#39;s say that we have one open generic registration for <code>IUsesAnyService&lt;&gt;</code> to be used as a catch-all, but that
we also have specific implementations we want to use for <code>IUsesAnyService&lt;IMyService&gt;</code> in addition to the catch-all.</p>
<p>In this case, we simply need to add one or more registration(s) for the <strong><em>concrete</em></strong> generic type in addition
to the open generic registrations, and Rezolver will intelligently select all the generics that apply when 
building its enumerable.</p>
<p>So, given these extra generic types:</p>
<pre><code class="lang-csharp" name="UsesIMyService.cs">public class UsesIMyService : IUsesAnyService&lt;IMyService&gt;
{
    public void UseTheService(IMyService service)
    {
        throw new NotImplementedException();
    }
}
public class UsesIMyService2 : IUsesAnyService&lt;IMyService&gt;
{
    public void UseTheService(IMyService service)
    {
        throw new NotImplementedException();
    }
}
</code></pre><p>We can do this:</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
container.RegisterType(typeof(UsesAnyService&lt;&gt;), typeof(IUsesAnyService&lt;&gt;));
container.RegisterType&lt;UsesIMyService, IUsesAnyService&lt;IMyService&gt;&gt;();
container.RegisterType&lt;UsesIMyService2, IUsesAnyService&lt;IMyService&gt;&gt;();

var result = container.ResolveMany&lt;IUsesAnyService&lt;IMyService&gt;&gt;().ToArray();
var result2 = container.ResolveMany&lt;IUsesAnyService&lt;MyService&gt;&gt;().ToArray();

//Note - enumerable is in registration order, regardless of open/closed generic
Assert.Equal(3, result.Length);
Assert.IsType&lt;UsesAnyService&lt;IMyService&gt;&gt;(result[0]);
Assert.IsType&lt;UsesIMyService&gt;(result[1]);
Assert.IsType&lt;UsesIMyService2&gt;(result[2]);

Assert.Equal(1, result2.Length);
Assert.IsType&lt;UsesAnyService&lt;MyService&gt;&gt;(result2[0]);
</code></pre><p>In the simplest terms, what we&#39;re seeing here is the container walking through all the possible generic service types
that could apply for the requested type, and returning all the instances produced by all those registrations, in
the order that those registrations were made.  So, if an open generic registration is made after a series of closed 
generic registrations, the open registration will still be last in the enumerable.</p>
<div class="NOTE"><h5>Note</h5><p>This is not the same as when resolving a single instance - which will return the last, best-matched registration
for the generic type.  So if one or more closed generic registrations exist for the exact type requested, then 
the one that was added last will be used for the single instance.</p>
<hr>
<p>Also note that <strong>Constrained</strong> generic implementations are <em>not</em> equal to closed generic registrations. So an 
explicit registration against <code>IFoo&lt;Bar&gt;</code> will always beat a constrained generic implementation such as
<code>MyFoo&lt;T&gt; : IFoo&lt;T&gt; where T : Bar</code> (see further down).</p>
</div>
<hr>
<h3 id="best-match-only-global">Best match <em>only</em> (global)</h3>
<p>Sometimes, you might only want objects in your enumerable which were registered against the best-matched generic, so, if you
have two open generic registrations for <code>IFoo&lt;&gt;</code> but a specific registration for <code>IFoo&lt;Bar&gt;</code>.  When requesting an 
enumerable of <code>IFoo&lt;Baz&gt;</code>, you want the two objects registered against the open generic.  However, when you request
an enumerable of <code>IFoo&lt;Bar&gt;</code>, you only want one object - from the specific <code>IFoo&lt;Bar&gt;</code> registration.</p>
<p>As mentioned in the note in the previous example, to do this, we use the <a class="xref" href="../../api/Rezolver.Options.FetchAllMatchingGenerics.html">FetchAllMatchingGenerics</a> option
to control this globally for a container:</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
// same test - we&#39;re just setting an option on the container
// which changes how generics are matched for the FetchAll() call
// which sits behind the automatic enumerable resolving behaviour.
container.SetOption&lt;Options.FetchAllMatchingGenerics&gt;(false);

container.RegisterType(typeof(UsesAnyService&lt;&gt;), typeof(IUsesAnyService&lt;&gt;));
container.RegisterType&lt;UsesIMyService, IUsesAnyService&lt;IMyService&gt;&gt;();
container.RegisterType&lt;UsesIMyService2, IUsesAnyService&lt;IMyService&gt;&gt;();

// This time, this will only match the second two registrations which 
// specialise for IUsesAnyService&lt;IMyService&gt;
var result = container.ResolveMany&lt;IUsesAnyService&lt;IMyService&gt;&gt;().ToArray();

Assert.Equal(2, result.Length);
Assert.IsType&lt;UsesIMyService&gt;(result[0]);
Assert.IsType&lt;UsesIMyService2&gt;(result[1]);
</code></pre><hr>
<h3 id="best-match-only-per-service">Best match <em>only</em> (per-service)</h3>
<p>We can also control this on a per-service basis - simply set the <a class="xref" href="../../api/Rezolver.Options.FetchAllMatchingGenerics.html">FetchAllMatchingGenerics</a> option to
<code>false</code> for a given service type.</p>
<p>Here, we&#39;re using the same types that we introduced for the <a href="#constrained-generics">constrained generics example</a>, 
and disabling the &#39;fetch all&#39; behaviour for a specific closed generic:</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
// set this option for the IGeneric&lt;MyService2&gt; service ONLY
container.SetOption&lt;Options.FetchAllMatchingGenerics&gt;(false, typeof(IGeneric&lt;MyService2&gt;));

// same registrations as our constrained generics example plus an 
// extra for IGeneric&lt;MyService2&gt; which will &#39;win&#39;.
container.RegisterType(typeof(GenericAny&lt;&gt;), typeof(IGeneric&lt;&gt;));
container.RegisterType(typeof(GenericAnyIMyService&lt;&gt;), typeof(IGeneric&lt;&gt;));
container.RegisterType(typeof(GenericAnyMyService1&lt;&gt;), typeof(IGeneric&lt;&gt;));
container.RegisterType(typeof(GenericMyService2), typeof(IGeneric&lt;MyService2&gt;));

// will get two as before
var myServiceResult = container.ResolveMany&lt;IGeneric&lt;MyService&gt;&gt;().ToArray();
// would normally get three (via 1st, 2nd and 4th registrations), but will only
// get one.
var myService2Result = container.ResolveMany&lt;IGeneric&lt;MyService2&gt;&gt;().ToArray();

Assert.Equal(2, myServiceResult.Length);
Assert.Equal(1, myService2Result.Length);
</code></pre><p>You can also set this against an open generic - which then has the same effect but for all generics based on the same
open generic (here we&#39;re disabling it for <code>IGeneric&lt;&gt;</code>)</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
container.SetOption&lt;Options.FetchAllMatchingGenerics&gt;(false, typeof(IGeneric&lt;&gt;));

// similar to the constraints example and the previous one, except this time we
// only have one open generic registration, and the other two that we have are closed
// (for IGeneric&lt;MyService1&gt; and IGeneric&lt;MyService2&gt;)
container.RegisterType(typeof(GenericAny&lt;&gt;), typeof(IGeneric&lt;&gt;));
// just reusing this open generic as a closed generic
container.RegisterType(typeof(GenericAnyMyService1&lt;MyService1&gt;), typeof(IGeneric&lt;MyService1&gt;));
container.RegisterType(typeof(GenericMyService2), typeof(IGeneric&lt;MyService2&gt;));

// ordinarily, both of these would return two results because of the IGeneric&lt;&gt; open
// registration.  But because the FetchAll behaviour has been disabled for all IGeneric&lt;&gt;
// types, both only get one result.
var myService1Result = container.ResolveMany&lt;IGeneric&lt;MyService1&gt;&gt;().ToArray();
var myService2Result = container.ResolveMany&lt;IGeneric&lt;MyService2&gt;&gt;().ToArray();

Assert.Equal(1, myService1Result.Length);
Assert.Equal(1, myService2Result.Length);
Assert.NotEqual(myService1Result[0].GetType(), myService2Result[0].GetType());
</code></pre><hr>
<h1 id="generic-variance">Generic Variance</h1>
<p>Rezolver&#39;s support for <a href="../variance/index.html">generic variance</a> means that enumerables of generics will 
automatically include all concrete-generic registrations (i.e. <code>T&lt;A&gt;</code> as opposed to <code>T&lt;&gt;</code>) which are 
reference compatible with the element type of the enumerable by way of generic covariance or contravariance.</p>
<h2 id="covariance">Covariance</h2>
<p>Say you have a series of <code>Func&lt;out T&gt;</code> registrations for concrete types - e.g. <code>Func&lt;Foo1&gt;</code>, <code>Func&lt;Foo2&gt;</code> and 
so on, with <code>Foo1</code> and <code>Foo2</code> and the rest all supporting the <code>IFoo</code> interface.</p>
<p>Rezolver will automatically be able to resolve an <code>IEnumerable&lt;Func&lt;IFoo&gt;&gt;</code> containing <em>all</em> matching 
registrations, since each of those registrations is compatible with <code>Func&lt;IFoo&gt;</code> via generic covariance:</p>
<pre><code class="lang-cs">interface IFoo {}

class Foo1 : IFoo {}
class Foo2 : IFoo {}

// ...

container.RegisterObject&lt;Func&lt;Foo1&gt;&gt;(() =&gt; new Foo1());
container.RegisterObject&lt;Func&lt;Foo2&gt;&gt;(() =&gt; new Foo2());

var funcs = container.ResolveMany&lt;Func&lt;IFoo&gt;&gt;();
// will contain the two delegates registered above
</code></pre><p>You can read more about this, including examples, in the 
<a href="../variance/covariance.html#enumerables">dedicated section on covariance</a>.</p>
<h3 id="disabling-enumerable-covariance">Disabling Enumerable Covariance</h3>
<p>As with much of Rezolver&#39;s functionality, you can control whether the automatically generated enumerables
handle covariance as described above with a simple option - the <a class="xref" href="../../api/Rezolver.Options.EnableEnumerableCovariance.html">EnableEnumerableCovariance</a>
option.</p>
<p>It can be used to disable enumerable covariance for all enumerables, or for enumerables of specific types:</p>
<div class="TIP"><h5>Tip</h5><p>Both these snippets assume the <code>Rezolver.Options</code> namespace has been imported into the current file via
a <code>using</code> directive (<code>imports</code> in VB).</p>
</div>
<pre><code class="lang-cs">container.SetOption&lt;EnableEnumerableCovariance&gt;(false);
</code></pre><p>Disables it globally, while:</p>
<pre><code class="lang-cs">container.SetOption&lt;EnableEnumerableCovariance, IFoo&gt;(false);
</code></pre><p>Disables it only for enumerables of the type <code>IFoo</code>.</p>
<h2 id="contravariance">Contravariance</h2>
<p>Generic types which are compatible with each other via contravariance will also be included in any 
<code>IEnumerable&lt;T&gt;</code> with which they&#39;d usually be compatible.  For example:</p>
<pre><code class="lang-cs">container.RegisterObject&lt;Action&lt;IFoo&gt;&gt;(o =&gt; Console.WriteLine(&quot;interface&quot;));
container.RegisterObject&lt;Action&lt;object&gt;&gt;(o =&gt; Console.WriteLine(&quot;object&quot;));

var actions = container.ResolveMany&lt;Action&lt;Foo1&gt;&gt;();
// will contain the two delegates registered above
</code></pre><p>Again, this is covered in more depth in the <a href="../variance/covariance.html#enumerables">section on covariance</a>.</p>
<hr>
<h1 id="next-steps">Next steps</h1>
<ul>
<li>Learn about Rezolver&#39;s support for <a href="lazy-vs-eager.html">lazy and eager enumerables</a> (note: all auto-generated enumerables are lazily 
evaluated by default)</li>
<li>The <a href="../variance/covariance.html">covariance</a> section includes examples of how covariance works within Rezolver&#39;s
enumerable support.</li>
<li>By default, also, Rezolver handles contravariant generic type parameters - see this in action with enumerables 
<a href="../variance/contravariance.html">in the section dedicated to generic contravariance</a></li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/ZolutionSoftware/Rezolver/blob/xamarin-forms-example/doc/Rezolver.Documentation/_docfx_proj/docs/enumerables/generics.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>Copyright &copy;2014 onwards <a href="http://www.zolution.co.uk" target="_blank">Zolution Software Ltd</a><br>Generated by <a href="https://dotnet.github.io/docfx/" target="_blank">DocFX</a>, with the Rezolver theme</span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
