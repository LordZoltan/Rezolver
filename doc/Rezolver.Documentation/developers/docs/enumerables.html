<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
  	<meta charset="utf-8">
  	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  	<title>Enumerables | Rezolver IOC Framework (prerelease) </title>
  	<meta name="viewport" content="width=device-width">
  	<meta name="title" content="Enumerables | Rezolver IOC Framework (prerelease) ">
  	<meta name="generator" content="docfx 2.16.2.2">
  	<meta name="description" content="Rezolver is the portable open-source IOC container framework for .Net - built from the ground up for .Net Core, Asp.Net Core, and also optimised for the 'full .Net' :)">
  	<link rel="shortcut icon" href="../favicon.ico">
  	<link rel="stylesheet" href="../styles/docfx.vendor.css">
  	<link rel="stylesheet" href="../styles/docfx.css">
  	<link rel="stylesheet" href="../styles/main.css">
  	<meta property="docfx:navrel" content="../toc.html">
  	<meta property="docfx:tocrel" content="toc.html">
  	<meta property="docfx:rel" content="../">
  	
  		<link rel="apple-touch-icon" sizes="57x57" href="../../apple-touch-icon-57x57.png">
  		<link rel="apple-touch-icon" sizes="60x60" href="../../apple-touch-icon-60x60.png">
  		<link rel="apple-touch-icon" sizes="72x72" href="../../apple-touch-icon-72x72.png">
  		<link rel="apple-touch-icon" sizes="76x76" href="../../apple-touch-icon-76x76.png">
  		<link rel="apple-touch-icon" sizes="114x114" href="../../apple-touch-icon-114x114.png">
  		<link rel="apple-touch-icon" sizes="120x120" href="../../apple-touch-icon-120x120.png">
  		<link rel="apple-touch-icon" sizes="144x144" href="../../apple-touch-icon-144x144.png">
  		<link rel="apple-touch-icon" sizes="152x152" href="../../apple-touch-icon-152x152.png">
  		<link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon-180x180.png">
  		<link rel="icon" type="image/png" href="../../favicon-32x32.png" sizes="32x32">
  		<link rel="icon" type="image/png" href="../../android-chrome-192x192.png" sizes="192x192">
  		<link rel="icon" type="image/png" href="../../favicon-96x96.png" sizes="96x96">
  		<link rel="icon" type="image/png" href="../../favicon-16x16.png" sizes="16x16">
  		<link rel="manifest" href="../../manifest.json">
  		<link rel="mask-icon" href="../../safari-pinned-tab.svg" color="#5bbad5">
  		<meta name="msapplication-TileColor" content="#da532c">
  		<meta name="msapplication-TileImage" content="../../mstile-144x144.png">
  		<meta name="theme-color" content="#ffffff">
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../../content/rz_square_white_on_orange_48x48.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
        		<p class="navbar-text navbar-right github-link"><a href="http://github.com/ZolutionSoftware/Rezolver" target="_blank" title="See this project on Github"><span class="fa fa-github"></span></a></p>
        		<form class="navbar-form navbar-right" role="search" id="search">
        		<div class="form-group">
        			<input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
        		</div>
        		</form>
        		<p class="navbar-text navbar-right">
        			<a href="https://www.nuget.org/packages/Rezolver" target="_blank"><img src="//img.shields.io/nuget/vpre/Rezolver.svg?style=plastic&amp;maxage=480" title="Get the Nuget Package"></a>
        			<a href="http://waffle.io/ZolutionSoftware/Rezolver" title="Open the Waffleboard for this project" target="_blank"><img alt="Work in Progress" src="https://badge.waffle.io/ZolutionSoftware/Rezolver.png?label=in%20progress&title=In%20Progress"></a>
        			<!-- <a href="http://waffle.io/ZolutionSoftware/Rezolver" title="Open the Waffleboard for this project" target="_blank"><img alt="Work prepared" src="https://badge.waffle.io/ZolutionSoftware/Rezolver.png?label=ready&title=Ready"></img></a> -->
        		</p>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
              <h1 id="enumerables">Enumerables</h1>
              
<p>By default, a <a class="xref" href="../api/Rezolver.TargetContainer.html">TargetContainer</a> (the default <a class="xref" href="../api/Rezolver.ITargetContainer.html">ITargetContainer</a> used by all containers in the 
Rezolver framework) comes with a behaviour enabled which allows any <a class="xref" href="../api/Rezolver.ContainerBase.html">ContainerBase</a> derivative to resolve
an <code>IEnumerable&lt;Service&gt;</code>.</p>
<p>The contents of this enumerable will depend on how many times the <a class="xref" href="../api/Rezolver.ITargetContainer.html#Rezolver_ITargetContainer_Register_">Register</a>
method has been called against the target type <code>Service</code>:</p>
<ul>
<li>If no target has been registered against the type, then the enumerable will be empty</li>
<li>Otherwise, the enumerable will contain instances obtained from each <a class="xref" href="../api/Rezolver.ITarget.html">ITarget</a> that was registered
against that type, in the order they were registered.</li>
</ul>
<div class="NOTE"><h5>Note</h5><p>Automatic resolving of enumerables is a configurable behaviour which can currently be disabled when creating 
a <a class="xref" href="../api/Rezolver.TargetContainer.html">TargetContainer</a> via its constructor.  It can also be explicitly opted-in (if it has been disabled)
by calling the <a class="xref" href="../api/Rezolver.EnumerableTargetBuilderExtensions.html#Rezolver_EnumerableTargetBuilderExtensions_EnableEnumerableResolving_">EnableEnumerableResolving</a> extension method.</p>
<p>Disabling the behaviour through the constructor might be removed in a future version, as we intend to move to a 
configuration callback-based mechanism for configuring containers.</p>
</div>
<p>You are not restricted in the targets you use to produce instances for an enumerable, and each one can have its
own lifetime (scoped/singleton etc).</p>
<h2 id="empty-enumerable">Empty enumerable</h2>
<p>Here&#39;s an example where we only register the service we&#39;re going to create, which has a single constructor that requires
an <code>IEnumerable&lt;IMyService&gt;</code>.</p>
<p>First, the type <code>RequiresEnumerableOfServices</code>:</p>
<pre><code class="lang-csharp" name="RequiresEnumerableOfServices.cs">public class RequiresEnumerableOfServices
{
    public IEnumerable&lt;IMyService&gt; Services { get; }
    public RequiresEnumerableOfServices(IEnumerable&lt;IMyService&gt; services)
    {
        Services = services;
    }
}
</code></pre><p>And then the test:</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
container.RegisterType&lt;RequiresEnumerableOfServices&gt;();

var result = container.Resolve&lt;RequiresEnumerableOfServices&gt;();
Assert.Empty(result.Services);
</code></pre><h2 id="same-itarget-type">Same <code>ITarget</code> type</h2>
<p>Here, we register each type one after another:</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
var expectedTypes = new[] {
    typeof(MyService1), typeof(MyService2), typeof(MyService3)
};
foreach (var t in expectedTypes)
{
    container.RegisterType(t, typeof(IMyService));
}
container.RegisterType&lt;RequiresEnumerableOfServices&gt;();

var result = container.Resolve&lt;RequiresEnumerableOfServices&gt;();
Assert.Equal(3, result.Services.Count());
Assert.All(
    result.Services.Zip(
        expectedTypes,
        (s, t) =&gt; (service: s, expectedType: t)
    ),
    t =&gt; Assert.IsType(t.expectedType, t.service));
</code></pre><h2 id="mixed-itarget-types">Mixed <code>ITarget</code> types</h2>
<p>This time, we&#39;re mixing it up a bit by registering multiple different target types (a constructor target, a delegate
target and an object target), <em>and</em> we&#39;re also using a delegate to create the <code>RequiresEnumerableOfServices</code> just
to show that the enumerable can be injected into a delegate as you&#39;d expect:</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
container.RegisterType&lt;MyService1, IMyService&gt;();
container.RegisterDelegate&lt;IMyService&gt;(() =&gt; new MyService2());
container.RegisterObject&lt;IMyService&gt;(new MyService3());

// shows also that injection of IEnumerables holds wherever injection
// is normally supported - such as here, with delegate argument injection
container.RegisterDelegate((IEnumerable&lt;IMyService&gt; services) =&gt;
{
    // if MyService4 is missing, add it to the enumerable
    if (!services.OfType&lt;MyService4&gt;().Any())
        services = services.Concat(new[] { new MyService4() });
    return new RequiresEnumerableOfServices(services);
});

var result = container.Resolve&lt;RequiresEnumerableOfServices&gt;();

Assert.Equal(4, result.Services.Count());
// just check they&#39;re all different types this time.
Assert.Equal(4, result.Services.Select(s =&gt; s.GetType()).Distinct().Count());
</code></pre><h2 id="mixed-lifetimes">Mixed lifetimes</h2>
<p>When registering targets, you have three lifetimes at your disposal:</p>
<ul>
<li>Transient (a new object created for every <a class="xref" href="../api/Rezolver.IContainer.html#Rezolver_IContainer_Resolve_">Resolve</a> call)</li>
<li>Singleton (only one object is ever created)</li>
<li>Scoped (one object created per <a class="xref" href="../api/Rezolver.IContainerScope.html">IContainerScope</a>)</li>
</ul>
<div class="NOTE"><h5>Note</h5><p>Of course, the <a class="xref" href="../api/Rezolver.Targets.ObjectTarget.html">ObjectTarget</a> (see <a href="objects.html">objects as services</a>) is technically a singleton, also,
but that&#39;s because it wraps a constant reference supplied by you.</p>
</div>
<p>If you register multiple targets for the same type, <strong><em>and</em></strong> those targets have different lifetimes, then those lifetimes are
honoured if the container injects an <code>IEnumerable&lt;&gt;</code>.</p>
<p>The following example registers three implementations for <code>IMyService</code> again which will appear in the enumerables in the 
following positions:</p>
<ul>
<li><code>[0]</code>: A singleton </li>
<li><code>[1]</code>: A scoped object</li>
<li><code>[2]</code>: A transient</li>
</ul>
<p>It then resolves <code>IEnumerable&lt;IMyService&gt;</code> multiple times - twice from the root container (which
is a <a class="xref" href="../api/Rezolver.ScopedContainer.html">ScopedContainer</a> so that the scoped <code>MyService2</code> registration has a scope to &#39;live&#39; in) and then
twice again from a child scope:</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">// since we&#39;re using a scoped registration here,
// we&#39;ll use the ScopedContainer, which establishes
// a root scope.
var container = new ScopedContainer();

container.RegisterSingleton&lt;MyService1, IMyService&gt;();
container.RegisterScoped&lt;MyService2, IMyService&gt;();
container.RegisterType&lt;MyService3, IMyService&gt;();

// So - each enumerable will contain, in order:
// 1) Singleton IMyService
// 2) Scoped IMyService
// 3) Transient IMyService

var fromRoot1 = container.Resolve&lt;IEnumerable&lt;IMyService&gt;&gt;().ToArray();
var fromRoot2 = container.Resolve&lt;IEnumerable&lt;IMyService&gt;&gt;().ToArray();

Assert.Same(fromRoot1[0], fromRoot2[0]);
// both scoped objects should be the same because we&#39;ve resolved
// from the root scope
Assert.Same(fromRoot1[1], fromRoot2[1]);
Assert.NotSame(fromRoot1[2], fromRoot2[2]);

using (var childScope = container.CreateScope())
{
    var fromChildScope1 = childScope.Resolve&lt;IEnumerable&lt;IMyService&gt;&gt;().ToArray();
    // singleton should be the same as before, but 
    // the scoped object will be different
    Assert.Same(fromRoot1[0], fromChildScope1[0]);
    Assert.NotSame(fromRoot1[1], fromChildScope1[1]);
    Assert.NotSame(fromRoot1[2], fromChildScope1[2]);

    var fromChildScope2 = childScope.Resolve&lt;IEnumerable&lt;IMyService&gt;&gt;().ToArray();
    // the scoped object will be the same as above
    Assert.Same(fromChildScope1[0], fromChildScope2[0]);
    Assert.Same(fromChildScope1[1], fromChildScope2[1]);
    Assert.NotSame(fromChildScope1[2], fromChildScope2[2]);
}
</code></pre><p>To summarise:</p>
<ul>
<li><code>[0]</code> is <em>always</em> the same reference</li>
<li><code>[1]</code> is created once per enclosing scope (remember - the container itself is a scope in this example)</li>
<li><code>[2]</code> is created once per call</li>
</ul>
<hr>
<h1 id="advanced-examples">Advanced examples</h1>
<p>On to generics and decorators, now...</p>
<h2 id="enumerables-of-open-generics">Enumerables of open generics</h2>
<p>You can also register multiple open generics of the same type (e.g. <code>IFoo&lt;&gt;</code>) and then resolve an enumerable of 
<code>IFoo&lt;Bar&gt;</code>, and the container will create an enumerable containing an object for each open generic registration:</p>
<pre><code class="lang-csharp" name="UsesAnyService.cs">public interface IUsesAnyService&lt;TAnyService&gt;
{
    void UseTheService(TAnyService service);
}

public class UsesAnyService&lt;TAnyService&gt; : IUsesAnyService&lt;TAnyService&gt;
{
    public void UseTheService(TAnyService service)
    {
        throw new NotImplementedException();
    }
}

public class UsesAnyService2&lt;TAnyService&gt; : IUsesAnyService&lt;TAnyService&gt;
{
    public void UseTheService(TAnyService service)
    {
        throw new NotImplementedException();
    }
}
</code></pre><pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
container.RegisterType(typeof(UsesAnyService&lt;&gt;), typeof(IUsesAnyService&lt;&gt;));
container.RegisterType(typeof(UsesAnyService2&lt;&gt;), typeof(IUsesAnyService&lt;&gt;));

var result = container.Resolve&lt;IEnumerable&lt;IUsesAnyService&lt;IMyService&gt;&gt;&gt;().ToArray();

Assert.Equal(2, result.Length);
Assert.IsType&lt;UsesAnyService&lt;IMyService&gt;&gt;(result[0]);
Assert.IsType&lt;UsesAnyService2&lt;IMyService&gt;&gt;(result[1]);
</code></pre><div class="NOTE"><h5>Note</h5><p>When working with generics, the enumerable handler searches for the first generic registration which has least
one <a class="xref" href="../api/Rezolver.ITarget.html">ITarget</a> whose <a class="xref" href="../api/Rezolver.ITarget.html#Rezolver_ITarget_UseFallback">UseFallback</a> is <code>false</code> - searching from least generic to most
generic (e.g. <code>Foo&lt;Bar&gt;</code> is less generic than <code>Foo&lt;&gt;</code>).</p>
<p>So if you request an <code>IEnumerable&lt;Foo&lt;Bar&gt;&gt;</code>, targets are first sought for <code>Foo&lt;Bar&gt;</code> and, if none are found,
it then searches for <code>Foo&lt;&gt;</code>.  The side effect of this is that your enumerable will always only contain objects
produced from targets registered against the most-specific generic type that&#39;s applicable for the type requested.  The
next example expands on this.</p>
</div>
<h2 id="mixing-openclosed-generics">Mixing open/closed generics</h2>
<p>Let&#39;s say that we have one open generic registration for <code>IUsesAnyService&lt;&gt;</code> to be used as a catch-all, but that
when <code>IMyService</code> is used, we have two types that we want to use instead.</p>
<p>In this case, we still have an open generic registration, but we want it to be superseded for certain generic types by two
specialised registrations where the inner generic type argument is known.</p>
<p>Given these extra generic types:</p>
<pre><code class="lang-csharp" name="UsesIMyService.cs">public class UsesIMyService : IUsesAnyService&lt;IMyService&gt;
{
    public void UseTheService(IMyService service)
    {
        throw new NotImplementedException();
    }
}
public class UsesIMyService2 : IUsesAnyService&lt;IMyService&gt;
{
    public void UseTheService(IMyService service)
    {
        throw new NotImplementedException();
    }
}
</code></pre><p>We can do this:</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
// register our open generic
container.RegisterType(typeof(UsesAnyService&lt;&gt;), typeof(IUsesAnyService&lt;&gt;));
// register our two specialisations for IMyService
container.RegisterType&lt;UsesIMyService, IUsesAnyService&lt;IMyService&gt;&gt;();
container.RegisterType&lt;UsesIMyService2, IUsesAnyService&lt;IMyService&gt;&gt;();

// will use the UsesIMyService and UsesIMyService2 specialised registrations
var result = container.Resolve&lt;IEnumerable&lt;IUsesAnyService&lt;IMyService&gt;&gt;&gt;().ToArray();
// will use the open generic registration - array of one
var result2 = container.Resolve&lt;IEnumerable&lt;IUsesAnyService&lt;MyService&gt;&gt;&gt;().ToArray();

Assert.Equal(2, result.Length);
Assert.IsType&lt;UsesIMyService&gt;(result[0]);
Assert.IsType&lt;UsesIMyService2&gt;(result[1]);

Assert.Equal(1, result2.Length);
Assert.IsType&lt;UsesAnyService&lt;MyService&gt;&gt;(result2[0]);
</code></pre><p>So, as soon as we want an <code>IEnumerable&lt;IUsesAnyService&lt;IMyService&gt;&gt;</code>, the enumerable will use <em>only</em> the
two explicit registrations made against the closed generic type <code>IUsesAnyService&lt;IMyService&gt;</code>, but if we
request any other type, we only get items produced by registrations against the open generic <code>IUsesAnyService&lt;&gt;</code>.</p>
<div class="WARNING"><h5>Warning</h5><p>There is currently <em>no</em> way to fall back on an open generic registration for given generic once you make a 
registration for a closed generic.  The framework might, however, be extended to allow you to make an explicit 
registration which instructs the container to fall back to a more generic registration and include any results from
that in the enumerable.</p>
</div>
<p>It doesn&#39;t matter what order you register the open generics and closed generics - the logic is applied on a type-by-type
basis; but the order of an individual enumerable of a given type is, however, governed by the order of registration.</p>
<h2 id="decorators-and-enumerables">Decorators and Enumerables</h2>
<div class="NOTE"><h5>Note</h5><p>At the time of writing, the <a href="decorators.html">decorators topic</a> has not been written, so this is preview of how to 
use decorators as well as how they work in enumerables.</p>
</div>
<p>Decorators that have been registered against the element type of an enumerable will be applied to all instances 
that the container produces for the enumerable.  This also applies to stacked decorators (where multiple decorators are
applied on top of one other).</p>
<p>So, we have two decorator types for <code>IMyService</code>:</p>
<pre><code class="lang-csharp" name="MyServiceDecorators.cs">public class MyServiceDecorator1 : IMyService
{
    public IMyService Inner { get; }
    public MyServiceDecorator1(IMyService inner)
    {
        Inner = inner;
    }
}

public class MyServiceDecorator2 : IMyService
{
    public IMyService Inner { get; }
    public MyServiceDecorator2(IMyService inner)
    {
        Inner = inner;
    }
}
</code></pre><p>And in this example we&#39;ll have one of those decorators being used to decorate three registrations:</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
// register the decorator up front.  Note - it doesn&#39;t actually matter when it&#39;s registered
container.RegisterDecorator&lt;MyServiceDecorator1, IMyService&gt;();
container.RegisterType&lt;MyService, IMyService&gt;();
container.RegisterType&lt;MyService2, IMyService&gt;();
container.RegisterType&lt;MyService3, IMyService&gt;();

// create the container with these targets
var result = container.Resolve&lt;IEnumerable&lt;IMyService&gt;&gt;().ToArray();

// make sure each item in the enumerable is an instance of our decorator.
// then make sure the decorated services are correct.
Assert.All(result, r =&gt; Assert.IsType&lt;MyServiceDecorator1&gt;(r));
Assert.IsType&lt;MyService&gt;(((MyServiceDecorator1)result[0]).Inner);
Assert.IsType&lt;MyService2&gt;(((MyServiceDecorator1)result[1]).Inner);
Assert.IsType&lt;MyService3&gt;(((MyServiceDecorator1)result[2]).Inner);
</code></pre><p>If more decorators were added, of course - then each element would be &#39;re-decorated&#39; accordingly.</p>
<h2 id="explicit-ienumerablet-registrations">Explicit <code>IEnumerable&lt;T&gt;</code> registrations</h2>
<p>Although you get <code>IEnumerable&lt;T&gt;</code> handling automatically, it doesn&#39;t prevent you from manually adding registrations
which override the default behaviour.</p>
<p>For example, let&#39;s say that you have two registrations for services which share a common interface, but they have only
been registered against their concrete type (perhaps it&#39;s historical code you can&#39;t risk changing). Your code 
now wants an enumerable of that common interface.  Well, assuming you know what the specific registrations are - you can
use delegate registrations (note, there are <em>lots</em> of ways, this is just the most illustrative):</p>
<pre><code class="lang-csharp" name="EnumerableExamples.cs">var container = new Container();
container.RegisterType&lt;MyService1&gt;();
container.RegisterType&lt;MyService2&gt;();
container.RegisterDelegate&lt;IEnumerable&lt;IMyService&gt;&gt;(
    rc =&gt; new IMyService[] { rc.Resolve&lt;MyService1&gt;(), rc.Resolve&lt;MyService2&gt;()
});

var result = container.Resolve&lt;IEnumerable&lt;IMyService&gt;&gt;().ToArray();

Assert.Equal(2, result.Length);
Assert.IsType&lt;MyService1&gt;(result[0]);
Assert.IsType&lt;MyService2&gt;(result[1]);
</code></pre><hr>
<h1 id="next-steps">Next steps</h1>
<ul>
<li>Recommend going to take (another) look at <a href="decorators.html">decorators</a> - although, at the time of writing it might 
not be written yet!</li>
<li>The <a href="constructor-injection/generics.html">generic constructor injection</a> documentation contains more useful guidance 
about open generics etc.</li>
</ul>

            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/ZolutionSoftware/Rezolver/blob/dev/doc/Rezolver.Documentation/_docfx_proj/docs/enumerables.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>Copyright &copy;2014 onwards <a href="http://www.zolution.co.uk" target="_blank">Zolution Software Ltd</a><br>Generated by <a href="https://dotnet.github.io/docfx/" target="_blank">DocFX</a>, with the Rezolver theme</span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
