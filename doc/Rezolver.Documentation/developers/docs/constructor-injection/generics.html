<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
  	<meta charset="utf-8">
  	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  	<title>Generic Constructor Injection | Rezolver IOC Framework </title>
  	<meta name="viewport" content="width=device-width">
  	<meta name="title" content="Generic Constructor Injection | Rezolver IOC Framework ">
  	<meta name="generator" content="docfx 2.13.1.0">
  	<meta name="description" content="Rezolver is the portable open-source IOC container framework for .Net - built from the ground up for .Net Core, Asp.Net Core, and also optimised for the 'full .Net' :)">
  	<link rel="shortcut icon" href="../../favicon.ico">
  	<link rel="stylesheet" href="../../styles/docfx.vendor.css">
  	<link rel="stylesheet" href="../../styles/docfx.css">
  	<link rel="stylesheet" href="../../styles/main.css">
  	<meta property="docfx:navrel" content="../../toc.html">
  	<meta property="docfx:tocrel" content="../toc.html">
  	<meta property="docfx:rel" content="../../">
  	
  		<link rel="apple-touch-icon" sizes="57x57" href="../../../apple-touch-icon-57x57.png">
  		<link rel="apple-touch-icon" sizes="60x60" href="../../../apple-touch-icon-60x60.png">
  		<link rel="apple-touch-icon" sizes="72x72" href="../../../apple-touch-icon-72x72.png">
  		<link rel="apple-touch-icon" sizes="76x76" href="../../../apple-touch-icon-76x76.png">
  		<link rel="apple-touch-icon" sizes="114x114" href="../../../apple-touch-icon-114x114.png">
  		<link rel="apple-touch-icon" sizes="120x120" href="../../../apple-touch-icon-120x120.png">
  		<link rel="apple-touch-icon" sizes="144x144" href="../../../apple-touch-icon-144x144.png">
  		<link rel="apple-touch-icon" sizes="152x152" href="../../../apple-touch-icon-152x152.png">
  		<link rel="apple-touch-icon" sizes="180x180" href="../../../apple-touch-icon-180x180.png">
  		<link rel="icon" type="image/png" href="../../../favicon-32x32.png" sizes="32x32">
  		<link rel="icon" type="image/png" href="../../../android-chrome-192x192.png" sizes="192x192">
  		<link rel="icon" type="image/png" href="../../../favicon-96x96.png" sizes="96x96">
  		<link rel="icon" type="image/png" href="../../../favicon-16x16.png" sizes="16x16">
  		<link rel="manifest" href="../../../manifest.json">
  		<link rel="mask-icon" href="../../../safari-pinned-tab.svg" color="#5bbad5">
  		<meta name="msapplication-TileColor" content="#da532c">
  		<meta name="msapplication-TileImage" content="../../../mstile-144x144.png">
  		<meta name="theme-color" content="#ffffff">
  	<script>
  	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  	  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  	
  	  ga('create', 'UA-92764222-1', 'auto');
  	  ga('send', 'pageview');
  	
  	</script></head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../../content/rz_square_white_on_orange_48x48.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
        		<p class="navbar-text navbar-right github-link"><a href="http://github.com/zolutionsoftware/rezolver" title="See this project on Github"><span class="fa fa-github"></span></a></p>
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
              <h1 id="generic-constructor-injection">Generic Constructor Injection</h1>
              
<div class="TIP"><h5>Tip</h5><p>Before reading this you should read through the section on <a href="index.html">construction injection</a></p>
<p>Also, generic types - especially in IOC-world - are an advanced concept that&#39;s easy to get very confused over, so if this is entirely new to you
and you find you don&#39;t understand it fully, then don&#39;t worry: this isn&#39;t easy!</p>
<p>It&#39;s probably a good idea to read the MSDN documentation about the <a class="xref" href="https://msdn.microsoft.com/en-us/library/ms131514(v=vs.110).aspx">IsGenericType</a> property on <a class="xref" href="https://msdn.microsoft.com/en-us/library/system.type(v=vs.110).aspx">Type</a> for more about &#39;open&#39; 
generics.</p>
</div>
<p>In Rezolver, binding open generic types, such as <code>IFoo&lt;T&gt;</code> or <code>IBar&lt;T, U, V&gt;</code>, to constructors of generics, e.g. <code>Foo&lt;T&gt;</code> or <code>Bar&lt;T, U, V&gt;</code>
is done via the <a class="xref" href="../../api/Rezolver.Targets.GenericConstructorTarget.html">GenericConstructorTarget</a> type.</p>
<p>This class knows how to map to a closed generic - i.e.
<code>Foo&lt;IMyService&gt;</code> or <code>IBar&lt;MyService1, MyService2, MyService3&gt;</code> - from an open generic and then subsequently bind
to the constructor of the closed version of that generic when requested from the container.</p>
<h2 id="best-match-only-for-now">&#39;Best-match&#39; only for now</h2>
<p>The <a href="index.html#best-match-examples">best-match algorithm</a> described in the <a href="index.html">constructor injection</a> is the only option currently available
to you when using <a class="xref" href="../../api/Rezolver.Targets.GenericConstructorTarget.html">GenericConstructorTarget</a>.  Theoretically, it&#39;s possible to specify the <code>ConstructorInfo</code> for the constructor you
want bound on the concrete generic type that Rezolver eventually decides to build for you, but we have not implemented that functionality yet.</p>
<p>You also cannot provide named arguments to help in the best-match search - to do so would be incredibly difficult, since if the type of a constructor 
argument is dependant upon a type argument, then there&#39;s no way you could supply a binding for it up-front to satisfy all possible types that 
might be passed to it.</p>
<h2 id="creatingregistering-xrefrezolvertargetsgenericconstructortargets">Creating/registering <a class="xref" href="../../api/Rezolver.Targets.GenericConstructorTarget.html">GenericConstructorTarget</a>s</h2>
<p>You can, of course, simply use the constructors to build a new instance of this target - e.g: <code>new GenericConstructorTarget(typeof(Foo&lt;&gt;))</code>.</p>
<p>However, the non-generic versions of the <a class="xref" href="../../api/Rezolver.RegisterTypeTargetContainerExtensions.html#Rezolver_RegisterTypeTargetContainerExtensions_RegisterType_">RegisterType</a> method that we&#39;ve been using elsewhere to 
register &#39;simple&#39; types in our target containers are also generic type-aware.  So, if you specify an open generic type as the implementing type, 
then those functions automatically create a <a class="xref" href="../../api/Rezolver.Targets.GenericConstructorTarget.html">GenericConstructorTarget</a> for you and register it.  </p>
<p>So, <code>container.RegisterType(typeof(MyGeneric&lt;&gt;))</code> will register <code>MyGeneric&lt;&gt;</code> for all variants of itself, and 
<code>container.RegisterType(typeof(MyGeneric&lt;&gt;), typeof(IMyGeneric&lt;&gt;))</code> will register <code>MyGeneric&lt;&gt;</code> for all variants of <code>IMyGeneric&lt;&gt;</code>.</p>
<p>Lets get on with some examples, the first few of which use these types:</p>
<pre><code class="lang-csharp" name="IDataFormatter`1.cs">public interface IDataFormatter&lt;TData&gt;
{
	string FormatData(TData data);
}
</code></pre><pre><code class="lang-csharp" name="DataFormatter`1.cs">public class DataFormatter&lt;TData&gt; : IDataFormatter&lt;TData&gt;
{
	public string FormatData(TData data)
	{
		return data.ToString();
	}
}
</code></pre><hr>
<h1 id="basic-examples">Basic examples</h1>
<h2 id="direct-no-baseinterface">Direct (no base/interface)</h2>
<p>Similar to the examples for &#39;normal&#39; constructor injection, we&#39;ll start by looking at registering without worrying about bases or interfaces, 
registering <code>DataFormatter&lt;&gt;</code> and fetching a few different closed variants of that generic:</p>
<pre><code class="lang-csharp" name="Example.cs">var container = new Container();
container.RegisterType(typeof(DataFormatter&lt;&gt;));

Assert.NotNull(container.Resolve&lt;DataFormatter&lt;int&gt;&gt;());
Assert.NotNull(container.Resolve&lt;DataFormatter&lt;string&gt;&gt;());
Assert.NotNull(container.Resolve&lt;DataFormatter&lt;IMyService&gt;&gt;());
</code></pre><hr>
<h2 id="by-interface">By Interface</h2>
<p>And again, except this time we&#39;ll register and resolve against the <code>IDataFormatter&lt;&gt;</code> interface:</p>
<pre><code class="lang-csharp" name="Example.cs">// Same as above, just requesting via interface
var container = new Container();
container.RegisterType(typeof(DataFormatter&lt;&gt;), typeof(IDataFormatter&lt;&gt;));

Assert.NotNull(container.Resolve&lt;IDataFormatter&lt;int&gt;&gt;());
Assert.NotNull(container.Resolve&lt;IDataFormatter&lt;string&gt;&gt;());
Assert.NotNull(container.Resolve&lt;IDataFormatter&lt;IMyService&gt;&gt;());
</code></pre><hr>
<h2 id="generic-dependency">Generic Dependency</h2>
<p>This time, we have a generic type that has a dependency on another generic type whose generic argument is derived from the dependant&#39;s
generic argument:</p>
<pre><code class="lang-csharp" name="RequiresIDataFormatter`1.cs">public class RequiresIDataFormatter&lt;T&gt;
{
	public IDataFormatter&lt;T&gt; Formatter { get; }

	public RequiresIDataFormatter(IDataFormatter&lt;T&gt; formatter)
	{
		Formatter = formatter;
	}
}
</code></pre><pre><code class="lang-csharp" name="Example.cs">var container = new Container();
container.RegisterType(typeof(RequiresIDataFormatter&lt;&gt;));
container.RegisterType(typeof(DataFormatter&lt;&gt;), typeof(IDataFormatter&lt;&gt;));

Assert.NotNull(container.Resolve&lt;RequiresIDataFormatter&lt;int&gt;&gt;().Formatter);
Assert.NotNull(container.Resolve&lt;RequiresIDataFormatter&lt;string&gt;&gt;().Formatter);
Assert.NotNull(container.Resolve&lt;RequiresIDataFormatter&lt;IMyService&gt;&gt;().Formatter);
</code></pre><hr>
<h1 id="advanced---complex-hierarchies">Advanced - Complex Hierarchies</h1>
<p>The previous examples showed how we can resolve an instance when the type requested is simply a closed version of the open generic against which
we registered a target; or when it&#39;s a direct base or interface of it.</p>
<p>Naturally, real-world type hierarchies do not always work like that - and sometimes you&#39;ll want to implement a type where the implementation is perhaps
more &#39;distant&#39;, in inheritance terms, from the base or interface.  With generics, this can get particularly complicated as the type parameters do not
always remain consistent - consider the following hierarchy:</p>
<pre><code class="lang-csharp" name="ComplexGenerics.cs">//these types are just used as easy-to-read type arguments
public class T1 { }
public class T2 { }
public class T3 { }

public class BaseGeneric&lt;T, U, V&gt; { }

public class MidGeneric&lt;T, U, V&gt; : BaseGeneric&lt;V, U, T&gt; { }

public class FinalGeneric&lt;T, U, V&gt; : MidGeneric&lt;U, T, V&gt; { }

// This type &#39;closes&#39; over one type parameter
public class ClosingGeneric&lt;T, U&gt; : FinalGeneric&lt;T, U, string&gt; { }
</code></pre><p>Notice how on the three first generic types, the order of the type arguments is changing as we move through <code>BaseGeneric&lt;,,&gt;</code>, <code>MidGeneric&lt;,,&gt;</code> and
<code>FinalGeneric&lt;,,&gt;</code>.</p>
<p>The last generic actually fixes one of the type parameters passed to <code>FinalGeneric&lt;,,&gt;</code> - which introduces a different problem for our container, which
we&#39;ll get to after looking at the others.</p>
<p><em>We apologise in advance for the complexity of this argument jumbling - but we accept no liability for any headaches you suffer!</em></p>
<hr>
<h2 id="base-of-a-base-with-jumbled-args">Base of a Base with Jumbled Args</h2>
<p>So, yes - this is a deeply contrived example, but it&#39;s worth seeing:</p>
<pre><code class="lang-csharp" name="Example.cs">var container = new Container();
container.RegisterType(typeof(FinalGeneric&lt;,,&gt;), typeof(BaseGeneric&lt;,,&gt;));

// Type arguments should be transformed as follows:
// - BaseGeneric&lt;T1, T2, T3&gt; is a base of
// - MidGeneric&lt;T3, T2, T1&gt;, which is a base of
// - FinalGeneric&lt;T2, T3, T1&gt;
// Which is what the container should give us

var result = Assert.IsType&lt;FinalGeneric&lt;T2, T3, T1&gt;&gt;(
    container.Resolve&lt;BaseGeneric&lt;T1, T2, T3&gt;&gt;()
);
</code></pre><p>In order to do this, the container must walk the inheritance chain of the <a class="xref" href="../../api/Rezolver.ITarget.html#Rezolver_ITarget_DeclaredType">DeclaredType</a> of the <a class="xref" href="../../api/Rezolver.Targets.GenericConstructorTarget.html">GenericConstructorTarget</a>
to create a map of the type arguments which must be fed to <code>FinalGeneric&lt;,,&gt;</code> in order to create an instance of <code>BaseGeneric&lt;,,&gt;</code>.</p>
<hr>
<h2 id="partially-closed-generic">Partially Closed Generic</h2>
<div class="NOTE"><h5>Note</h5><p>The term &#39;Partially Closed&#39; is a term only used here - it merely describes a generic type where <em>some</em> of the type arguments supplied to
a generic type&#39;s parameters are concrete types.</p>
</div>
<p>Now we take a look at the <code>ClosingGeneric&lt;T, U&gt;</code> type - it&#39;s here we start getting into one of the murkier areas of generic types in 
Rezolver and, indeed, in general.</p>
<p>In this case, we now have a type which can <em>only ever</em> be used
to implement a <em>subset</em> of all the possible variants of <code>BaseGeneric&lt;T, U, V&gt;</code>, because, whatever its own <code>T</code> and <code>U</code> arguments are, its base will
always be <code>BaseGeneric&lt;string, T, U&gt;</code>.</p>
<p>Rezolver is happy to work with this, as the next test shows:</p>
<pre><code class="lang-csharp" name="Example.cs">var container = new Container();
container.RegisterType(typeof(ClosingGeneric&lt;,&gt;), typeof(BaseGeneric&lt;,,&gt;));

var result = Assert.IsType&lt;ClosingGeneric&lt;T2, T3&gt;&gt;(
    container.Resolve&lt;BaseGeneric&lt;string, T2, T3&gt;&gt;()
);
</code></pre><div class="NOTE"><h5>Note</h5><p>If we were to try to resolve <code>BaseGeneric&lt;T1, T2, T3&gt;</code> as we did before, then the container will <em>correctly</em> tell us that it cannot - and
that the registered target is not compatible with that type.  Which leads us on to our problem...</p>
</div>
<h3 id="the-problem-with-partially-closed-generics">The problem with partially closed generics</h3>
<p>With our container configured as above, it is now <em>impossible</em> to resolve <code>BaseGeneric&lt;T1, T2, T3&gt;</code> because the only implementation we have for 
<code>BaseGeneric&lt;,,&gt;</code> is one where the first type argument <strong><em>must</em></strong> be <code>string</code>.  If we were to register another, more general, type for 
<code>BaseGeneric&lt;,,&gt;</code> it would overwrite our specialised version, wiping it out.</p>
<p>It&#39;s also impossible for us to specify the type <code>BaseGeneric&lt;string,,&gt;</code> either in a <code>typeof</code>, or via the <a class="xref" href="https://msdn.microsoft.com/en-us/library/ms131508(v=vs.110).aspx">MakeGenericType</a> API, so we&#39;re
stuck.</p>
<h3 id="were-working-on-it">We&#39;re working on it!</h3>
<p>This is a limitation of Rezolver right now, but there are plans to implement partially specialised registrations, so that the container would, when
<code>ClosingGeneric&lt;T, U&gt;</code> is registered, realise that it should <em>only</em> be used if the first type parameter on <code>BaseGeneric&lt;,,&gt;</code> is <code>string</code>.</p>
<p>This would then allow the container to accept a more general registration against <code>BaseGeneric&lt;,,&gt;</code> to be registered side-by-side and used for 
all other variants of <code>BaseGeneric&lt;,,&gt;</code>.</p>
<p>Implementation of this feature would also simplify the scenarios covered in the next section.</p>
<hr>
<h1 id="advanced---nested-generics">Advanced - Nested Generics</h1>
<p>Rezolver also supports generics where type arguments are passed to an interface or base nested within other generics - take these types:</p>
<pre><code class="lang-csharp" name="NestedGenerics.cs">public interface IGenericService&lt;T&gt;
{

}
public class GenericEnumerableService&lt;T&gt;
	: IGenericService&lt;IEnumerable&lt;T&gt;&gt;
{

}

public class GenericEnumerableNullableService&lt;T&gt;
	: IGenericService&lt;IEnumerable&lt;Nullable&lt;T&gt;&gt;&gt;
	where T : struct
{

}
</code></pre><h2 id="singly-nested-generic-argument">Singly nested generic argument</h2>
<pre><code class="lang-csharp" name="Example.cs">var container = new Container();


container.RegisterType(
    typeof(GenericEnumerableService&lt;&gt;),
    typeof(IGenericService&lt;&gt;).MakeGenericType(typeof(IEnumerable&lt;&gt;))
);

var result = Assert.IsType&lt;GenericEnumerableService&lt;string&gt;&gt;(
    container.Resolve&lt;IGenericService&lt;IEnumerable&lt;string&gt;&gt;&gt;()
);
</code></pre><div class="NOTE"><h5>Note</h5><p>As with our <code>ClosingGeneric&lt;,&gt;</code> from before, we <em>could</em> perform
this registration against <code>IGenericService&lt;&gt;</code>, but if we do, then we wipe out
the possibility of being able to register other services - so, we
register against <code>IGenericService&lt;IEnumerable&lt;&gt;&gt;</code>, which requires some 
<a class="xref" href="https://msdn.microsoft.com/en-us/library/ms131508(v=vs.110).aspx">MakeGenericType</a> jiggery pokery.  When we&#39;ve got partially closed generics
working, you will be able to register against <code>IGenericService&lt;&gt;</code>.</p>
</div>
<hr>
<h2 id="doubly-nested-generic-argument">Doubly nested generic argument</h2>
<p>Rezolver doesn&#39;t care how far it has to go to work out how a type argument on a base is nested from the implementing type:</p>
<pre><code class="lang-csharp" name="Example.cs">var container = new Container();

// Even more .MakeGenericType jiggery pokery required here
container.RegisterType(
    typeof(GenericEnumerableNullableService&lt;&gt;),
    typeof(IGenericService&lt;&gt;).MakeGenericType(
        typeof(IEnumerable&lt;&gt;).MakeGenericType(
            typeof(Nullable&lt;&gt;)
        )
    )
);

var result = Assert.IsType&lt;GenericEnumerableNullableService&lt;int&gt;&gt;(
    container.Resolve&lt;IGenericService&lt;IEnumerable&lt;Nullable&lt;int&gt;&gt;&gt;&gt;()
);
</code></pre><hr>
<h1 id="using-member-bindings">Using Member Bindings</h1>
<p>The same techniques that are shown in our <a href="member-binding.html">member binding documentation</a> also work for generic types - if you supply an
<a class="xref" href="../../api/Rezolver.IMemberBindingBehaviour.html">IMemberBindingBehaviour</a> to the <a class="xref" href="../../api/Rezolver.Targets.GenericConstructorTarget.html">GenericConstructorTarget</a> when it is created (either by the constructors or the 
aforementioned factory methods), then that behaviour will be used when the constructor is bound.</p>
<p>Refer to the topic for detailed examples on how to use member binding.</p>
<hr>
<h1 id="next-steps">Next Steps</h1>
<p>Assuming you&#39;ve read the previous topics on <a href="index.html">constructor injection</a> and <a href="member-binding.html">member binding</a>,
then that&#39;s it for constructor injection for now.</p>
<div class="NOTE"><h5>Note</h5><p>A separate topic will be added in the future regarding Generic Specialisation in the container, but that covers all target types, 
not just the <a class="xref" href="../../api/Rezolver.Targets.GenericConstructorTarget.html">GenericConstructorTarget</a> - so that will go elsewhere.</p>
</div>
<p>Feel free to explore the table of contents or <a href="../service-registration.html">head back to the main service registration overview</a> to explore 
more features of Rezolver.</p>

            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/ZolutionSoftware/Rezolver/blob/1.1.71702.100/doc/Rezolver.Documentation/_docfx_proj/docs/constructor-injection/generics.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
      	<div class="container packageDetails"><span class="pull-right">This documentation is for package version 1.1.71702.500</span></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>Copyright &copy;2014 onwards <a href="http://www.zolution.co.uk" target="_blank">Zolution Software Ltd</a><br>Generated by <a href="https://dotnet.github.io/docfx/" target="_blank">DocFX</a>, with the Rezolver theme</span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
