<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
  	<meta charset="utf-8">
  	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  	<title>Object lifetimes </title>
  	<meta name="viewport" content="width=device-width">
  	<meta name="title" content="Object lifetimes ">
  	<meta name="generator" content="docfx 2.12.1.0">
  	
  	<link rel="shortcut icon" href="../favicon.ico">
  	<link rel="stylesheet" href="../styles/docfx.vendor.css">
  	<link rel="stylesheet" href="../styles/docfx.css">
  	<link rel="stylesheet" href="../styles/main.css">
  	<meta property="docfx:navrel" content="../toc.html">
  	<meta property="docfx:tocrel" content="toc.html">
  	<meta property="docfx:rel" content="../">
  	
  		<link rel="apple-touch-icon" sizes="57x57" href="../../apple-touch-icon-57x57.png">
  		<link rel="apple-touch-icon" sizes="60x60" href="../../apple-touch-icon-60x60.png">
  		<link rel="apple-touch-icon" sizes="72x72" href="../../apple-touch-icon-72x72.png">
  		<link rel="apple-touch-icon" sizes="76x76" href="../../apple-touch-icon-76x76.png">
  		<link rel="apple-touch-icon" sizes="114x114" href="../../apple-touch-icon-114x114.png">
  		<link rel="apple-touch-icon" sizes="120x120" href="../../apple-touch-icon-120x120.png">
  		<link rel="apple-touch-icon" sizes="144x144" href="../../apple-touch-icon-144x144.png">
  		<link rel="apple-touch-icon" sizes="152x152" href="../../apple-touch-icon-152x152.png">
  		<link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon-180x180.png">
  		<link rel="icon" type="image/png" href="../../favicon-32x32.png" sizes="32x32">
  		<link rel="icon" type="image/png" href="../../android-chrome-192x192.png" sizes="192x192">
  		<link rel="icon" type="image/png" href="../../favicon-96x96.png" sizes="96x96">
  		<link rel="icon" type="image/png" href="../../favicon-16x16.png" sizes="16x16">
  		<link rel="manifest" href="../../manifest.json">
  		<link rel="mask-icon" href="../../safari-pinned-tab.svg" color="#5bbad5">
  		<meta name="msapplication-TileColor" content="#da532c">
  		<meta name="msapplication-TileImage" content="../../mstile-144x144.png">
  		<meta name="theme-color" content="#ffffff">
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../../content/rz_square_white_on_orange_48x48.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
              <h1 id="object-lifetimes">Object lifetimes</h1>
              
<div class="TIP"><h5>Tip</h5><p>Read <a href="create-and-use-a-container.html">Creating and using a container</a> if you haven&#39;t already done so.</p>
</div>
<p>As with any IOC container, Rezolver understands the concept of object lifetimes, which are implemented
as different <a class="xref" href="../api/Rezolver.ITarget.html">ITarget</a> implementations that can be registered in an <a class="xref" href="../api/Rezolver.ITargetContainer.html">ITargetContainer</a>.</p>
<p>Before we take a look at how you actually use these lifetimes when working with Rezolver, we&#39;ll first take
a look at exactly what these lifetimes are.</p>
<div class="TIP"><h5>Tip</h5><p>If you&#39;re already a seasoned IOC god - then you can skip this section and head straight to 
the <a href="lifetimes-in-rezolver.md">Object lifetimes (in Rezolver)</a> section for some
examples from the <code>Rezolver.Tests.Examples</code> project.</p>
</div>
<h2 id="what-is-a-lifetime">What is a lifetime?</h2>
<p>No, this is not a philosophical question ;)</p>
<p>In a crude sense, an object lifetime describes when a new object is created and whether a previously 
created object is subsequently returned from a container&#39;s <a class="xref" href="../api/Rezolver.IContainer.html#Rezolver_IContainer_Resolve_">Resolve</a> method.</p>
<div class="NOTE"><h5>Note</h5><p>In practise, it&#39;s not that simple - because an IOC container&#39;s understanding of a lifetime does not
strictly map to whether a new instance is actually created at all.</p>
<p>It&#39;s more accurate to say that the lifetime determines <strong>when</strong> the
<strong><em>action</em></strong> that&#39;s been associated with a given service type is actually <strong><em>executed</em></strong>.</p>
</div>
<p>Rezolver understands three main lifetimes, which should be familiar to anyone who&#39;s used an IOC
container before:</p>
<h3 id="transient">Transient</h3>
<p>In <em>general</em>, a transient object is simply one which is created when needed; and thrown 
away when it&#39;s fulfilled its purpose.</p>
<p>This typically translates to calling the <code>new</code> operator with the constructor of a particular type, 
when you want an object, and then allowing that object to go out of scope, as in this snippet:</p>
<pre><code class="lang-cs">// Factory method always creates a new instance
static MyObject CreateObject()
{
    return new MyObject();
}

static MyObject _transient = CreateObject();

void Test()
{
    var transient1 = CreateObject();
    var transient2 = CreateObject();
    //note - using XUnit nomenclature here
    Assert.NotSame(transient1, transient2);
    Assert.NotSame(_transient, transient1);
    Assert.NotSame(_transient, transient2);
}
</code></pre><p>This idea of transience is encompassed by the following targets in the <a class="xref" href="../api/Rezolver.Targets.html">Rezolver.Targets</a> namespace:</p>
<ul>
<li><a class="xref" href="../api/Rezolver.Targets.ConstructorTarget.html">ConstructorTarget</a></li>
<li><a class="xref" href="../api/Rezolver.Targets.DecoratorTarget.html">DecoratorTarget</a></li>
<li><a class="xref" href="../api/Rezolver.Targets.DelegateTarget.html">DelegateTarget</a> <em>(see below)</em></li>
<li><a class="xref" href="../api/Rezolver.Targets.ExpressionTarget.html">ExpressionTarget</a> <em>(see below)</em></li>
<li><a class="xref" href="../api/Rezolver.Targets.GenericConstructorTarget.html">GenericConstructorTarget</a></li>
<li><a class="xref" href="../api/Rezolver.Targets.ListTarget.html">ListTarget</a></li>
</ul>
<p>Remember that a target in Rezolver is an instruction to perform an <em>action</em> when the associated service
type is resolved by the container.  In the case of the above list, for all but two we can <em>definitely</em> say that 
a new object will be created if that target is registered against a type that&#39;s requested.</p>
<p>So, the <a class="xref" href="../api/Rezolver.Targets.ConstructorTarget.html">ConstructorTarget</a> will always result in a type&#39;s constructor being called; the 
<a class="xref" href="../api/Rezolver.Targets.ListTarget.html">ListTarget</a> will always result in a new <code>Array</code> or <code>List&lt;T&gt;</code> being created, and so on.</p>
<p>In the case of the <a class="xref" href="../api/Rezolver.Targets.DelegateTarget.html">DelegateTarget</a> and <a class="xref" href="../api/Rezolver.Targets.ExpressionTarget.html">ExpressionTarget</a> targets, however,
all we can say about those is that the <strong><em>action</em></strong> they represent will be executed <em>every time</em> the container 
resolves them.</p>
<p>That&#39;s the same as if we were to change the definition of <code>CreateObject</code> in our earlier code example as 
follows:</p>
<pre><code class="lang-cs">private static IMyObjectService _service = new MyObjectService();

static MyObject CreateObject()
{
    return _service.GetObject();
}
</code></pre><p>The point here being that we can no longer <strong>guarantee</strong> the transience of the object that is produced by the
<code>CreateObject</code> method because we no longer know how the service is producing that object.  All we can 
say is that we <em>definitely</em> execute the service&#39;s <code>GetObject</code> method every time we call <code>CreateObject</code>.</p>
<p>We will go into more depth about using delegates and expressions (and indeed custom targets) as we delve deeper
into the Rezolver framework - but for now it&#39;s important to know that some targets produce inherently transient
results, whereas some <em>might</em> do, but they equally might <strong><em>not</em></strong>.</p>
<h3 id="singleton">Singleton</h3>
<p>Every developer should know what a singleton is.  Okay - any <em>reasonably experienced</em> developer should know what
a singleton is!</p>
<p>In short, a singleton is exactly as the name suggests: a type for which there is <strong>guaranteed</strong> to be only one 
instance.</p>
<p>Here&#39;s a simple implementation (note: please don&#39;t take this as the best, or <em>only</em>, way to implement one - it&#39;s
just an example!):</p>
<pre><code class="lang-cs">public class MySingleton
{
    public MySingleton Instance { get; } = new MySingleton();

    private MySingleton()
    {

    }
}
</code></pre><p>An application wishing to use the <code>MySingleton</code> object must do so through the <code>Instance</code> property, which is
the only instance of that type for the entire <code>AppDomain</code>.</p>
<p>Equally, if the singleton object implements an interface or base, then it can be passed to code which requires
an instance of that interface or base without knowing that the underlying object itself is always the same 
reference.</p>
<div class="NOTE"><h5>Note</h5><p>Different IOC containers have differing understandings of what a singleton really is.
In some cases it&#39;s one instance per-AppDomain (as with the above code snippet) and in other cases it&#39;s
one instance per-container.</p>
<p>In yet more cases, it&#39;s configurable or, indeed, extensible.</p>
<p>Rezolver currently supports one instance per-AppDomain, but in future it will also support one per-container 
and possibly more besides.</p>
</div>
<h3 id="scoped">Scoped</h3>
<p>Scoping has two flavours, and also often relates specifically to objects which implement the <code>IDisposable</code> interface
from the .Net framework (although it doesn&#39;t have to).  In order for the idea of a scoped object to make any sense,
however, you need a scope within which the object will exist.</p>
<p>A scope can be thought of as being a &#39;bag&#39; for objects which the application wants to create and keep alive for a specific
period of time and, when it no longer needs those objects, it throws the bag away - or, disposes of it.</p>
<p>Scopes can also contain other, &#39;child&#39; scopes. When a parent scope is disposed it also triggers the disposal
of any child scopes it contains, and all their children, and so on.</p>
<p>The reason why this pattern is usually applied to disposable objects is because you don&#39;t typically need to worry 
about telling the runtime that you&#39;re done with a non-disposable transient object - you simply allow it to go out 
of scope and, eventually, the garbage collector will reclaim the memory that object occupied.<br>A disposable object, on the other hand, is disposable typically because it contains resources which the framework 
cannot free automatically when the object falls out of scope - e.g. database connections, or unmanaged memory - 
and so any container which takes charge of creating objects for us should also provide a way for us to dispose 
of them in those cases where that is needed.</p>
<p>That said, there are scenarios why you might wish to explicitly restrict an otherwise transient object to one-per-scope,
so that&#39;s why scoped objects do not have to be disposable.</p>
<p>One feature which is consistent, however, is that the scope <strong>itself</strong> is disposable.</p>
<h4 id="implicit-scoping">Implicit scoping</h4>
<p>Implicit scoping applies only to <code>IDisposable</code> objects and affects when the object is disposed, not when it&#39;s 
created.</p>
<p>A simple demonstration of this, if you were writing something like it by hand, would be as follows (<em>please note 
the implementation of <code>IDisposable</code> shown here is <strong>not</strong> recommended!</em>):</p>
<pre><code class="lang-cs">public class Scope : IDisposable
{
    private List&lt;IDisposable&gt; _scopeObjects = new List&lt;IDisposable&gt;();
    public void Dispose()
    {
        //dispose all our tracked disposables
        foreach(var obj in _scopeObjects)
        {
            obj.Dispose();
        }
    }

    public T CreateObject&lt;T&gt;()
    {
        //this bit is merely to take the place of a generic 
        //factory/service/IOC container which knows how to build things.  
        T result;
        if(typeof(T) == typeof(MyDisposable))
            result = (T)(object)new MyDisposable();
        else
            throw new InvalidOperationException($&quot;Don&#39;t know how to create { typeof(T) }&quot;);

        //if the object is disposable - track it
        if(result is IDisposable)
            _scopeObjects.Add((IDisposable)result);

        return result;
    }
}

public class MyDisposable : IDisposable
{
    public bool Disposed { get; private set; }
    public void Dispose()
    {
        Disposed = true;
    }
}

public class XUnitTest
{
    [Fact]
    public void ShouldDispose()
    {
        MyDisposable obj;
        using(var scope = new Scope())
        {
            obj = scope.CreateObject&lt;MyDisposable&gt;();
        }
        Assert.True(obj.Disposed);
    }
}
</code></pre><p>In the test, we create a new scope in a <code>using</code> block, create an object from it, and then check whether that object is 
disposed just after the <code>using</code> block is left.  At this point, the scope should be disposed and, because the object we
requested from the scope was <code>IDisposable</code> it, too, should be disposed.</p>
<p>The scope only bothers with disposables - anything else that it might produce (ignoring the fact that our little factory 
function here only knows how to create an instance of <code>MyDisposable</code>!) would pass straight through.</p>
<p>This is ultimately how implicitly scoped objects are handled in Rezolver.</p>
<h4 id="explicit-scoping">Explicit scoping</h4>
<p>Explicit scoping also does relate to <code>IDisposable</code> objects, inasmuch as disposable objects are expected to be disposed
when the scope is disposed - but it&#39;s more targeted at controlling when a new object is created <em>regardless</em> of whether
the object can be disposed.</p>
<p>Explicit scoping can be thought of as a &#39;scoped singleton&#39;.  When the developer indicates he or she wants a scoped object,
what they&#39;re actually saying is that they want one unique instance of that object per-scope.</p>
<div class="NOTE"><h5>Note</h5><p>Child scopes also get their own instance of explicitly scoped objects - child scopes do not share instances
with their parents.</p>
</div>
<p>So imagine if we were to change the implementation of the <code>Scope</code> class we defined in the previous section to this:</p>
<pre><code class="lang-cs">public class Scope : IDisposable
{
    private Dictionary&lt;Type, object&gt; _scopeObjects = new Dictionary&lt;Type, object&gt;();
    public void Dispose()
    {
        //dispose all our tracked disposables
        foreach(var obj in _scopeObjects.Values.OfType&lt;IDisposable&gt;())
        {
            obj.Dispose();
        }
    }

    public T CreateObject&lt;T&gt;()
    {
        // start with a look up to see if we have already created an instance of T
        // and, if so, return it.
        object cached;
        if(_scopeObjects.TryGetValue(typeof(T), out cached)
            return (T)cached;

        //this bit is merely to take the place of a generic 
        //factory/service/IOC container which knows how to build things.  
        T result;    
        if(typeof(T) == typeof(MyDisposable))
            result = (T)(object)new MyDisposable();
        else
            throw new InvalidOperationException($&quot;Don&#39;t know how to create { typeof(T) }&quot;);

        _scopeObjects[typeof(T)] = result;
        return result;
    }
}
</code></pre><p>With a scope implemented like this (and, again, we have to imagine that <code>CreateObject&lt;T&gt;</code> is implemented properly), we 
will only ever get one instance of a given type from that scope.</p>
<p>Explicitly scoped objects, then, treat their scopes as if they behave like this. </p>
<h4 id="singletons-in-scopes">Singletons in scopes</h4>
<p>To make things slightly more confusing - the singleton objects discussed earlier also have a special behaviour when 
materialised in a scope.</p>
<p>The singleton is supposed to guarantee a single instance to the whole application, but at the same time, they are typically
<em>implicitly scoped</em>, so what happens when you materalise that singleton via a scope, and the singleton is also disposable?</p>
<p>Following the definitions of lifetimes we&#39;ve talked about so far: when
the first scope in which we resolve that singleton is disposed, the singleton will also be - rendering it useless.</p>
<p>To get around this problem, singletons will actively seek out the <strong>root</strong> scope of the tree of scopes that it is being
materialised within, and ensure that it is tracked for disposal only in that root scope - even if the current scope is a
great great granchild - ensuring that it will only be disposed when the rootmost scope is disposed.</p>
<div class="TIP"><h5>Tip</h5><p>If your application requires a singleton which you also want to be automatically disposed, then you should ensure that
your root container is the <a class="xref" href="../api/Rezolver.ScopedContainer.html">ScopedContainer</a> - which contains its own scope that will be the ultimate root for
any child scopes it creates.</p>
</div>
<hr>
<p>The next step is take a look at how you can <a href="lifetimes-in-rezolver.md">work with lifetimes when registering targets in Rezolver</a>.</p>

            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/ZolutionSoftware/Rezolver/blob/dev/doc/Rezolver.Documentation/_docfx_proj/docs/object-lifetimes.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
      	<div class="container packageDetails"><span class="pull-right">This documentation is for package version 1.1.71702.100</span></div>
      
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>Copyright &copy;2015 onwards <a href="http://www.zolution.co.uk" target="_blank">Zolution Software Ltd</a><br>Generated by <a href="https://dotnet.github.io/docfx/" target="_blank">DocFX</a>, with the Rezolver theme</span>
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
