// Copyright (c) Zolution Software Ltd. All rights reserved.
// Licensed under the MIT License, see LICENSE.txt in the solution root for license information


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;

namespace Rezolver.Logging
{
	/// <summary>
	/// The root tracker class and the starting point for any custom implementations of the <see cref="ICallTracker"/> interface.
	/// 
	/// This class contains the logic required to create a graph of all calls to objects as they happen.
	/// </summary>
	/// <remarks>
	/// For logging purposes it's only really useful on its own if you use it to get a report of all calls that have happened
	/// up to a given point.  For that purpose, you can use the  <see cref="GetCompletedCalls"/> method, which returns an 
	/// enumerable of <see cref="TrackedCallGraph"/> objects representing all the method calls which have been tracked by this tracker.
	/// 
	/// If, however, you want to see all the calls and logging messages as they occur you can use the <see cref="DelegatingCallTracker"/>.
	/// 
	/// The <see cref="DelegatingCallTracker.Default"/> wraps around this class' <see cref="Default"/> tracker to provide a source for real-time
	/// logging whilst also preserving this class' behaviour.
	/// 
	/// Although, note that the <see cref="Default"/> tracker does not retain completed call information after the call has finished.  This
	/// can be controlled by setting <see cref="RetainCompletedCalls"/> to true.</remarks>
	public class CallTracker : ICallTracker
	{
		private static readonly Lazy<CallTracker> _default = new Lazy<CallTracker>(() => new CallTracker());

		/// <summary>
		/// The default CallTracker instance - used for application-wide container tracking.
		/// </summary>
		public static CallTracker Default
		{
			get
			{
				return _default.Value;
			}
		}

		private long _nextCallID = 1;

		/// <summary>
		/// acts as our indexed set of completed calls
		/// </summary>
		ConcurrentDictionary<long, TrackedCall> _calls = new ConcurrentDictionary<long, TrackedCall>();
		/// <summary>
		/// ongoing calls are kept in here, then migrated when they're completed
		/// </summary>
		ConcurrentDictionary<long, TrackedCall> _callsInProgress = new ConcurrentDictionary<long, TrackedCall>();
		ConcurrentBag<string> _messages = new ConcurrentBag<string>();

		/// <summary>
		/// Controls whether calls that are completed are retained after they are finished (and therefore available from the <see cref="GetCompletedCalls"/>
		/// method).  Can only be initialised on construction.
		/// 
		/// The default in the constructor is <c>false</c>, which ensures that call tracking can be enabled without placing a potentially large memory overhead
		/// on the application.
		/// 
		/// When false, the <see cref="GetCompletedCalls"/> method will always return nothing.
		/// </summary>
		public bool RetainCompletedCalls { get; }

		/// <summary>
		/// Gets a value which sets the message type to be used for low-level trace messages generated by this CallTracker for
		/// call start and end messages in <see cref="TrackedCall"/> instances.  If null, then no call start/end messages will be generated,
		/// otherwise, the given message type will be used.
		/// 
		/// Can only be initialised on construction.
		/// </summary>
		/// <remarks>By default (when this property is <c>null</c>, the only messages to be added to <see cref="TrackedCall"/> instances are
		/// those which are added by callers of this class through the <see cref="Message(long, string, MessageType)"/> function.
		/// 
		/// If not null, then the <see cref="CallStart(object, object, string)"/>, <see cref="CallEnd(long)"/>, <see cref="CallResult{TResult}(long, TResult)"/>
		/// and <see cref="Exception(long, System.Exception)"/> functions will <see cref="TrackedCall"/> but will inject formatted messages detailing those 
		/// events and add them to the <see cref="TrackedCall"/> via the <see cref="AddMessageToCall(TrackedCall, string, MessageType)"/>
		/// protected virtual function.</remarks>
		public MessageType? CallEventsMessageType { get; }

		/// <summary>
		/// A thread-static stack of <see cref="TrackedCall"/> instances representing the current thread's call stack within tracked objects.
		/// </summary>
		[ThreadStatic]
		Stack<TrackedCall> _currentCallStack = new Stack<TrackedCall>();

		/// <summary>
		/// Initializes a new instance of the <see cref="CallTracker"/> class.
		/// </summary>
		/// <param name="retainCompletedCalls">Sets the initial value of the <see cref="RetainCompletedCalls"/> property, which controls whether this
		/// tracker will retain all calls in memory after they're completed.  This is useful if you wish to interrogate tracked calls on an ad-hoc basis.
		/// 
		/// If you're using real-time logging which derives from this class, then you should leave this as false because the memory overhead could be
		/// quite severe.</param>
		/// <param name="callEventsMessageType">If set to <c>true</c> then this tracker will add messages to all <see cref="TrackedCall"/> instances via
		/// .</param>
		public CallTracker(bool retainCompletedCalls = false, MessageType? callEventsMessageType = null)
		{
			RetainCompletedCalls = retainCompletedCalls;
			CallEventsMessageType = callEventsMessageType;
		}

		/// <summary>
		/// removes a call from the in-progress dictionary and, if the 
		/// call is a root call (no parent), then imports the call and all its
		/// children into the 'completed' dictionary.
		/// </summary>
		/// <param name="completed"></param>
		private void CallComplete(TrackedCall completed)
		{
			int counter = 5;
			TrackedCall removed = null;
			while (counter-- > 0)
			{
				if (_callsInProgress.TryRemove(completed.ID, out removed))
					break;
			}

			if (RetainCompletedCalls && removed != null && completed.Parent == null)
			{
				counter = 5;
				while (counter-- > 0)
				{
					if (_calls.TryAdd(completed.ID, completed))
						break;
				}
			}
		}

		private TrackedCall PopOrGetIncompleteCall(long callID)
		{
			var current = _currentCallStack.Count != 0 ? _currentCallStack.Peek() : null;
			if (current != null && current.ID == callID)
			{
				_currentCallStack.Pop();
			}
			else
			{
				_callsInProgress.TryGetValue(callID, out current);
			}

			return current;
		}

		public TrackedCall GetCall(long callID)
		{
			TrackedCall call = null;
			if (!_callsInProgress.TryGetValue(callID, out call))
				_calls.TryGetValue(callID, out call);
			return call;
		}

		protected virtual string FormatCallStartMessage(TrackedCall call)
		{
			return $"{call.Method} called with args({ string.Join(", ", call.Arguments.Select(kvp => $"{kvp.Key}: {kvp.Value}")) }) on {call.Callee}";
		}

		protected virtual string FormatCallEndWithResultMessage(TrackedCall call)
		{
			return $"{call.Method} completed in { (call.Duration ?? TimeSpan.FromMilliseconds(-1)).TotalMilliseconds }ms with result: { call.Result }";
		}

		protected virtual string FormatCallEndWithNoResultMessage(TrackedCall call)
		{
			return $"{call.Method} completed in { (call.Duration ?? TimeSpan.FromMilliseconds(-1)).TotalMilliseconds }ms";
		}

		protected virtual string FormatCallEndWithExceptionMessage(TrackedCall call)
		{
			return $"{call.Method} failed after { (call.Duration ?? TimeSpan.FromMilliseconds(-1)).TotalMilliseconds }ms. { call.Exception }";
		}

		private void AddCallStartMessage(TrackedCall call)
		{
			if (CallEventsMessageType == null)
				return;
			AddMessageToCall(call, FormatCallStartMessage(call), MessageType.Trace);
		}

		private void AddCallEndMessage(TrackedCall call)
		{
			if (CallEventsMessageType == null)
				return;
			if (call.Completed == null)
				return;

			if (call.HasResult)
				AddMessageToCall(call, FormatCallEndWithResultMessage(call), MessageType.Trace);
			else if (call.Exception != null)
				AddMessageToCall(call, FormatCallEndWithExceptionMessage(call), MessageType.Error);
			else
				AddMessageToCall(call, FormatCallEndWithNoResultMessage(call), MessageType.Trace);
		}

		public virtual long CallStart(object callee, object arguments, [CallerMemberName] string method = null)
		{
			long callID = _nextCallID++;
			var newCall = CreateNewCall(callID, callee, method, arguments, _currentCallStack.Count != 0 ? _currentCallStack.Peek() : null);				
			_callsInProgress.TryAdd(callID, newCall);  //should think about handling when it can't
			_currentCallStack.Push(newCall);
			AddCallStartMessage(newCall);
			return callID;
		}

		/// <summary>
		/// Called by the the <see cref="CallStart(object, object, string)"/> function to get a new <see cref="TrackedCall"/> instance to be used
		/// to record a particular function call.
		/// </summary>
		/// <param name="callID">A unique call identifier to use for the new <see cref="TrackedCall"/>.  Unique to this instance.</param>
		/// <param name="callee">The callee : the object on which the function was called.  See <see cref="ICallTracker.CallStart(object, object, string)"/> </param>
		/// <param name="method">The name of the method that was called - see <see cref="ICallTracker.CallStart(object, object, string)"/></param>
		/// <param name="arguments">Arguments that were passed to the method - see <see cref="ICallTracker.CallStart(object, object, string)"/> for more.</param>
		/// <param name="parent">The parent call in this thread from which this call originates.  Note that there might be additional calls to other
		/// objects which aren't tracked; and equally from other threads.</param>
		/// <returns>A new <see cref="TrackedCall"/> instance that will ultimately be stored while its onngoing, and possibly for the lifetime of this
		/// call tracker if <see cref="RetainCompletedCalls"/> is <c>true</c>.</returns>
		protected virtual TrackedCall CreateNewCall(long callID, object callee, string method, object arguments, TrackedCall parent)
		{
			return new TrackedCall(callID, callee, arguments, method, parent);
		}

		public virtual void CallEnd(long callID)
		{
			//this call should be on the stack
			TrackedCall call = PopOrGetIncompleteCall(callID);

			if (call != null)
			{
				call.Ended();
				AddCallEndMessage(call);
				CallComplete(call);
			}
		}

		

		public virtual void CallResult<TResult>(long callID, TResult result)
		{
			var call = PopOrGetIncompleteCall(callID);
			if (call != null)
			{
				call.Ended(result, true);
				AddCallEndMessage(call);
				CallComplete(call);
			}
		}

		public virtual void Exception(long callID, Exception ex)
		{
			var call = PopOrGetIncompleteCall(callID);
			if (call != null)
			{
				call.EndedWithException(ex);
				AddCallEndMessage(call);
				CallComplete(call);
			}
		}

		/// <summary>
		/// Used to log messages to a <see cref="TrackedCall"/> given its <paramref name="callID"/>.
		/// 
		/// Implememtation of <see cref="ICallTracker.Message(long, string, MessageType)"/>.
		/// </summary>
		/// <param name="callID">The call identifier.</param>
		/// <param name="message">The message.</param>
		/// <param name="messageType">The type of message in <paramref name="message" />.  In logging-type scenarios, can be used
		/// to filter out messages below a certain level.</param>
		/// <returns>The <see cref="TrackedCallMessage"/> that was created for the call identified by <paramref name="callID"/> if successful,
		/// <c>null</c> if a call couldn't be found with the given <paramref name="callID"/></returns>
		public TrackedCallMessage Message(long callID, string message, MessageType messageType = MessageType.Information)
		{
			var call = GetCall(callID);
			if (call != null)
				AddMessageToCall(call, message, messageType: messageType);

			return null;
		}

		/// <summary>
		/// Adds the message to the passed call.
		/// 
		/// The base implementation simply forwards the call directly on to the <paramref name="call" />'s <see cref="TrackedCall.AddMessage(string, MessageType, DateTime?)" />
		/// function, returning its result.
		/// </summary>
		/// <param name="call">The call to which the message is to be added.</param>
		/// <param name="message">The message string.</param>
		/// <param name="messageType">Type of the message.</param>
		/// <returns>The <see cref="TrackedCallMessage"/> which was created for the message.</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="call"/> is null</exception>
		/// <remarks>All the functions in this class which generate messages wiil ultimately call this method (including the <see cref="Message(long, string, MessageType)"/>
		/// function).  You can override this method, say, if you wish to customise the string that's logged; or perhaps if you wish to perform real-time logging of messages
		/// as they occur.
		/// 
		/// If you are looking to override the <see cref="Message(long, string, MessageType)"/> function, then you should instead override this.
		/// </remarks>
		protected virtual TrackedCallMessage AddMessageToCall(TrackedCall call, string message, MessageType messageType)
		{
			if (call == null) throw new ArgumentNullException(nameof(call));
			return call.AddMessage(message, messageType);
		}

		/// <summary>
		/// Clears the completed calls history.
		/// </summary>
		public void ClearCompletedCalls()
		{
			_calls.Clear();
		}

		/// <summary>
		/// If <see cref="RetainCompletedCalls"/> is <c>true</c>, then this function returns a (potentially very large) <see cref="TrackedCallGraph"/> containing all the
		/// function calls that have been tracked by this tracker since it was created, or since <see cref="ClearCompletedCalls"/> was last called.
		/// </summary>
		public TrackedCallGraph GetCompletedCalls()
		{
			var all = _calls.ToArray();
			return new TrackedCallGraph(all.Select(k => k.Value).OrderBy(c => c.Timestamp));
		}
	}
}
