// Copyright (c) Zolution Software Ltd. All rights reserved.
// Licensed under the MIT License, see LICENSE.txt in the solution root for license information


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;

namespace Rezolver.Logging
{
	/// <summary>
	/// The root tracker class and the starting point for any custom implementations of the <see cref="ICallTracker"/> interface.
	/// 
	/// This class contains the logic required to create a graph of all calls to objects as they happen.
	/// </summary>
	/// <remarks>
	/// For logging purposes it's only really useful on its own if you use it to get a report of all calls that have happened
	/// up to a given point.  For that purpose, you can use the  <see cref="GetCompletedCalls"/> method, which returns an 
	/// enumerable of <see cref="TrackedCallGraph"/> objects representing all the method calls which have been tracked by this tracker.
	/// 
	/// If, however, you want to see all the calls and logging messages as they occur you can use the <see cref="DelegatingCallTracker"/>.
	/// 
	/// The <see cref="DelegatingCallTracker.Default"/> wraps around this class' <see cref="Default"/> tracker to provide a source for real-time
	/// logging whilst also preserving this class' behaviour.
	/// 
	/// Although, note that the <see cref="Default"/> tracker does not retain completed call information after the call has finished.  This
	/// can be controlled by setting <see cref="RetainCompletedCalls"/> to true.</remarks>
	public class CallTracker : ICallTracker
	{
		private static readonly Lazy<CallTracker> _default = new Lazy<CallTracker>(() => new CallTracker());

		/// <summary>
		/// The default CallTracker instance - used for application-wide container tracking.
		/// </summary>
		public static CallTracker Default
		{
			get
			{
				return _default.Value;
			}
		}

		private long _nextCallID = 1;

		/// <summary>
		/// acts as our indexed set of completed calls
		/// </summary>
		ConcurrentDictionary<long, TrackedCall> _calls = new ConcurrentDictionary<long, TrackedCall>();
		/// <summary>
		/// ongoing calls are kept in here, then migrated when they're completed
		/// </summary>
		ConcurrentDictionary<long, TrackedCall> _callsInProgress = new ConcurrentDictionary<long, TrackedCall>();
		ConcurrentBag<string> _messages = new ConcurrentBag<string>();

		public LoggingFormatterCollection MessageFormatter { get; }

		/// <summary>
		/// Controls whether calls that are completed are retained after they are finished (and therefore available from the <see cref="GetCompletedCalls"/>
		/// method).  Can only be initialised on construction.
		/// 
		/// The default in the constructor is <c>false</c>, which ensures that call tracking can be enabled without placing a potentially large memory overhead
		/// on the application.
		/// 
		/// When false, the <see cref="GetCompletedCalls"/> method will always return nothing.
		/// </summary>
		public bool RetainCompletedCalls { get; }

		/// <summary>
		/// Gets a value which sets the message type to be used for low-level trace messages generated by this CallTracker for
		/// call start and end messages in <see cref="TrackedCall"/> instances.  If null, then no call start/end messages will be generated,
		/// otherwise, the given message type will be used.
		/// 
		/// Can only be initialised on construction.
		/// </summary>
		/// <remarks>By default (when this property is <c>null</c>, the only messages to be added to <see cref="TrackedCall"/> instances are
		/// those which are added by callers of this class through the <see cref="Message(long, MessageType, string)"/> function.
		/// 
		/// If not null, then the <see cref="CallStart(object, object, string)"/>, <see cref="CallEnd(long)"/>, <see cref="CallResult{TResult}(long, TResult)"/>
		/// and <see cref="Exception(long, System.Exception)"/> functions will <see cref="TrackedCall"/> but will inject formatted messages detailing those 
		/// events and add them to the <see cref="TrackedCall"/> via the <see cref="AddMessageToCall(TrackedCall, string, MessageType)"/>
		/// protected virtual function.</remarks>
		public MessageType? CallEventsMessageType { get; }

		/// <summary>
		/// A thread-static stack of <see cref="TrackedCall"/> instances representing the current thread's call stack within tracked objects.
		/// </summary>
		[ThreadStatic]
		Stack<TrackedCall> _currentCallStack = new Stack<TrackedCall>();

		/// <summary>
		/// Initializes a new instance of the <see cref="CallTracker" /> class.
		/// </summary>
		/// <param name="retainCompletedCalls">Sets the initial value of the <see cref="RetainCompletedCalls" /> property, which controls whether this
		/// tracker will retain all calls in memory after they're completed.  This is useful if you wish to interrogate tracked calls on an ad-hoc basis.
		/// If you're using real-time logging which derives from this class, then you should leave this as false because the memory overhead could be
		/// quite severe.</param>
		/// <param name="callEventsMessageType">If set to <c>true</c> then this tracker will add messages to all <see cref="TrackedCall" /> instances via
		/// .</param>
		/// <param name="messageFormatter">The message formatter to be used in converting objects (return values, callees, argument strings, exceptions etc)
		/// into strings which will ultimately be logged as messages or properties on <see cref="TrackedCall"/> objects.</param>
		public CallTracker(bool retainCompletedCalls = false, MessageType? callEventsMessageType = null, LoggingFormatterCollection messageFormatter = null)
		{
			RetainCompletedCalls = retainCompletedCalls;
			CallEventsMessageType = callEventsMessageType;
			//create a new, independent message formatter which extends the formatter passed, or the default collection
			MessageFormatter = new Logging.LoggingFormatterCollection(messageFormatter ?? LoggingFormatterCollection.Default);
		}

		/// <summary>
		/// removes a call from the in-progress dictionary and, if the 
		/// call is a root call (no parent), then imports the call and all its
		/// children into the 'completed' dictionary.
		/// </summary>
		/// <param name="completed"></param>
		private void CallComplete(TrackedCall completed)
		{
			int counter = 5;
			TrackedCall removed = null;
			while (counter-- > 0)
			{
				if (_callsInProgress.TryRemove(completed.ID, out removed))
					break;
			}

			if (RetainCompletedCalls && removed != null && completed.Parent == null)
			{
				counter = 5;
				while (counter-- > 0)
				{
					if (_calls.TryAdd(completed.ID, completed))
						break;
				}
			}
		}

		private TrackedCall PopOrGetIncompleteCall(long callID)
		{
			var current = _currentCallStack.Count != 0 ? _currentCallStack.Peek() : null;
			if (current != null && current.ID == callID)
			{
				_currentCallStack.Pop();
			}
			else
			{
				_callsInProgress.TryGetValue(callID, out current);
			}

			return current;
		}

		public TrackedCall GetCall(long callID)
		{
			TrackedCall call = null;
			if (!_callsInProgress.TryGetValue(callID, out call))
				_calls.TryGetValue(callID, out call);
			return call;
		}

		protected virtual IFormattable FormatCallStartMessage(TrackedCall call)
		{
			return $"{call.Method} called with args({ string.Join(", ", call.Arguments.Select(kvp => $"{kvp.Key}: {kvp.Value}")) }) on {call.Callee}";
		}

		protected virtual IFormattable FormatCallEndWithResultMessage(TrackedCall call)
		{
			return $"{call.Method} completed in { (call.Duration ?? TimeSpan.FromMilliseconds(-1)).TotalMilliseconds }ms with result: { call.Result }";
		}

		protected virtual IFormattable FormatCallEndWithNoResultMessage(TrackedCall call)
		{
			return $"{call.Method} completed in { (call.Duration ?? TimeSpan.FromMilliseconds(-1)).TotalMilliseconds }ms";
		}

		protected virtual IFormattable FormatCallEndWithExceptionMessage(TrackedCall call)
		{
			return $"{call.Method} failed after { (call.Duration ?? TimeSpan.FromMilliseconds(-1)).TotalMilliseconds }ms. { call.Exception }";
		}

		private void AddCallStartMessage(TrackedCall call)
		{
			if (CallEventsMessageType == null)
				return;
			call.AddMessage(CallEventsMessageType.Value, FormatCallStartMessage(call));
		}

		private void AddCallEndMessage(TrackedCall call)
		{
			if (CallEventsMessageType == null)
				return;
			if (call.Completed == null)
				return;
			IFormattable message = null;
			MessageType messageType = CallEventsMessageType.Value;
			if (call.HasResult)
				message = FormatCallEndWithResultMessage(call);
			else if (call.Exception != null)
			{
				message = FormatCallEndWithExceptionMessage(call);
				messageType = MessageType.Error;
			}
			else
				message = FormatCallEndWithNoResultMessage(call);

			if (message != null)
				call.AddMessage(messageType, message);
		}

		public virtual long CallStart(object callee, object arguments, [CallerMemberName] string method = null, object data = null)
		{
			long callID = _nextCallID++;
			var newCall = CreateAndInitialiseCall(callID, callee, method, arguments, _currentCallStack.Count != 0 ? _currentCallStack.Peek() : null, data);
			_callsInProgress.TryAdd(callID, newCall);  //should think about handling when it can't
			_currentCallStack.Push(newCall);
			AddCallStartMessage(newCall);
			return callID;
		}

		protected TrackedCall CreateAndInitialiseCall(long callID, object callee, string method, object arguments, TrackedCall parent, object data)
		{
			var newCall = CreateNewCall(callID, parent);
			newCall.Init(callee, arguments, method, data);
			return newCall;
		}

		/// <summary>
		/// Called by the the <see cref="CallStart(object, object, string)"/> function to get a new <see cref="TrackedCall"/> instance to be used
		/// to record a particular function call.
		/// </summary>
		/// <param name="callID">A unique call identifier to use for the new <see cref="TrackedCall"/>.  Unique to this instance.</param>
		/// <param name="callee">The callee : the object on which the function was called.  See <see cref="ICallTracker.CallStart(object, object, string)"/> </param>
		/// <param name="method">The name of the method that was called - see <see cref="ICallTracker.CallStart(object, object, string)"/></param>
		/// <param name="arguments">Arguments that were passed to the method - see <see cref="ICallTracker.CallStart(object, object, string)"/> for more.</param>
		/// <param name="parent">The parent call in this thread from which this call originates.  Note that there might be additional calls to other
		/// objects which aren't tracked; and equally from other threads.</param>
		/// <returns>A new <see cref="TrackedCall"/> instance that will ultimately be stored while its onngoing, and possibly for the lifetime of this
		/// call tracker if <see cref="RetainCompletedCalls"/> is <c>true</c>.</returns>
		protected virtual TrackedCall CreateNewCall(long callID, TrackedCall parent)
		{
			return new TrackedCall(callID, parent, MessageFormatter);
		}

		public virtual void CallEnd(long callID)
		{
			//this call should be on the stack
			TrackedCall call = PopOrGetIncompleteCall(callID);

			if (call != null)
			{
				call.Ended();
				AddCallEndMessage(call);
				CallComplete(call);
			}
		}



		public virtual void CallResult<TResult>(long callID, TResult result)
		{
			var call = PopOrGetIncompleteCall(callID);
			if (call != null)
			{
				call.Ended(result, true);
				AddCallEndMessage(call);
				CallComplete(call);
			}
		}

		public virtual void Exception(long callID, Exception ex)
		{
			var call = PopOrGetIncompleteCall(callID);
			if (call != null)
			{
				call.EndedWithException(ex);
				AddCallEndMessage(call);
				CallComplete(call);
			}
		}

		/// <summary>
		/// Used to format log messages into the call identified by <paramref name="callID" /> (which was previously returned by
		/// <see cref="CallStart(object, object, string)" />).
		/// </summary>
		/// <param name="callID">ID of the <see cref="TrackedCall" /> to which the message will be added.</param>
		/// <param name="messageType">The type of message.  In logging-type scenarios, can be used to filter out messages below a certain level.</param>
		/// <param name="messageFormat">A simple string or a format string which can optionally be formatted with the arguments passed in <paramref name="formatArgs" />.</param>
		/// <param name="formatArgs">Values to be used when formatting <paramref name="messageFormat" />, if it contains format placeholders.</param>
		/// <returns>TrackedCallMessage.</returns>
		public TrackedCallMessage Message(long callID, MessageType messageType, string messageFormat, params object[] formatArgs)
		{
			var call = GetCall(callID);
			if (call != null)
				return call.AddMessage(messageType, messageFormat, formatArgs);
			return null;
		}

		/// <summary>
		/// Like <see cref="Message(long, MessageType, string, object[])" />, except this adds a message whose text is obtained by formatting an <see cref="IFormattable" /> object.
		/// Use this for interpolated strings if you want the <see cref="MessageFormatter" /> to format your messages for you.
		/// </summary>
		/// <param name="callID">The call identifier.</param>
		/// <param name="messageType">Type of the message.</param>
		/// <param name="format">The format.</param>
		/// <returns>TrackedCallMessage.</returns>
		/// <remarks>You'll primarily use this overload is if you regularly build messages from interpolated strings.
		/// The core implementation of this interface (<see cref="CallTracker" />) utlises a <see cref="LoggingFormatterCollection" /> object to provide
		/// advanced formatting functionality for objects into the strings that are ultimately stored on <see cref="TrackedCall" /> objects.
		/// If you target this overload with your interpolated string, then this advanced formatting will automatically be used to produce the eventual
		/// message, instead of the default .Net string formatting functionality.
		/// In order to target the overload for interpolated strings, either capture it first into an <see cref="IFormattable" /> (or <see cref="FormattableString" />)
		/// and pass that, or you can pass the interpolated string as the <paramref name="format" /> by name.  See <see cref="LoggingFormatterCollection.Format(IFormattable)" />
		/// for more.</remarks>
		public TrackedCallMessage Message(long callID, MessageType messageType, IFormattable format)
		{
			var call = GetCall(callID);
			if (call != null)
				return call.AddMessage(messageType, format);
			return null;
		}

		/// <summary>
		/// Clears the completed calls history.
		/// </summary>
		public void ClearCompletedCalls()
		{
			_calls.Clear();
		}

		/// <summary>
		/// If <see cref="RetainCompletedCalls"/> is <c>true</c>, then this function returns a (potentially very large) <see cref="TrackedCallGraph"/> containing all the
		/// function calls that have been tracked by this tracker since it was created, or since <see cref="ClearCompletedCalls"/> was last called.
		/// </summary>
		public TrackedCallGraph GetCompletedCalls()
		{
			var all = _calls.ToArray();
			return new TrackedCallGraph(all.Select(k => k.Value).OrderBy(c => c.Timestamp));
		}
	}
}
