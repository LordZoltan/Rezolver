<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ output extension="cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
// Generated by test.tt
<#@ include file="..\genericgenerator.t4" #>
<#
var specs = new []{
	new GenericSpec { 
		Args = "TResult", 
		Signatures = new[] { null, "ResolveContext, TResult" } 
	},
	new GenericSpec {
		Args = "T1, TResult",
		Signatures = new[] { null, "ResolveContext, T1, TResult" }
	},
	new GenericSpec {
		Args = "T1, T2, TResult",
		Signatures = new[] { null, "ResolveContext, T1, T2, TResult" }
	},
	new GenericSpec {
		Args = "T1, T2, T3, TResult",
		Signatures = new[] { null, "ResolveContext, T1, T2, T3, TResult" }
	},
	new GenericSpec {
		Args = "T1, T2, T3, T4, TResult",
		Signatures = new[] { null, "ResolveContext, T1, T2, T3, T4, TResult" }
	},
	new GenericSpec {
		Args = "T1, T2, T3, T4, T5, TResult",
		Signatures = new[] { null, "ResolveContext, T1, T2, T3, T4, T5, TResult" }
	}
};
	// If we need more, I can add them - but having all the func types covered just looks silly.
	// Developers can still use any delegate type they want - these classes are all about 
	// convenience when creating them directly without having to use 'new Func<blah>' in the
	// constructor.
#>

namespace Rezolver.TargetsTemp
{
	using System;
	using Rezolver.Targets;
<#
ForSpecs(specs, Class);
#>

} // namespace Rezolver.TargetsTemp

namespace RezolverTemp
{
	using System;
	using Rezolver;
	using Rezolver.Targets;

	public static partial class DelegateTargetContainerExtensions
	{
	<#
		ForSpecs(specs, RegisterTargetGroup);
	#>
	}
}

<#+
void Class(GenericSpec spec)
{#>
	/// <summary>Specialisation of the <see cref="DelegateTarget" /> type for strongly typed delegates
	/// with <#= spec.ArgCount - 1 #> or <#= spec.ArgCount #> parameters</summary>
<#+
	ForArgs(spec, TypeParamRef); 
#>
	/// <remarks>Note - this class exists purely to provide a simpler way to pass inline delegates to a new instance.
	/// the static factory methods also provide the same ability, as does the RegisterDelegate extension method</remarks>
	public class DelegateTarget<<#= spec.Args #>> : DelegateTarget
	{
<#+	ForSpecSignatures(spec, Constructor); #>
	}

<#+
}

void TypeParamRef(GenericSpecArg arg)
{#>
	/// <typeparam name="<#= arg.Name #>"><#+ if(arg.Name != "TResult")
	{#>Type of parameter <#= arg.Pos + 1 #> or <#= arg.Pos + 2 #> of the delegate<#+}
	else{#>The type of the object produced by the factory.<#+}#></typeparam>
<#+
}

void Constructor(GenericSpec spec, string sig)
{#>
		/// <summary>Constructs a new instance from the passed strongly typed delegate</summary>
		/// <param name="factory">The delegate that is to be called if the container resolves to this target.</param>
		/// <param name="declaredType">Optional - the <see cref="ITarget.DeclaredType" /> of the new target, if different
		/// from <typeparamref name="TResult" />.</param>
		public DelegateTarget(Func<<#= sig #>> factory, Type declaredType = null)
			: base(factory, declaredType)
		{

		}
<#+
}

void RegisterTargetGroup(GenericSpec spec)
{
	//generates both RegisterTarget extension methods which apply to this generic spec
	ForSpecSignatures(spec, RegisterTarget);
}

void RegisterTarget(GenericSpec spec, string sig)
{#>
	/// <summary>Creates a <see cref="Rezolver.Targets.DelegateTarget" /> for the given delegate and registers it in the target container</summary>
<#+
	ForArgs(spec, TypeParamRef);
#>
	public static void RegisterDelegate<<#= spec.Args #>>(this ITargetContainer targets, Func<<#= sig #>> factory, Type declaredType = null)
	{
		targets.RegisterDelegate((Delegate)factory, declaredType);
	}
<#+
}
#>
