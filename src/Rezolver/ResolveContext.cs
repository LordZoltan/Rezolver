// Copyright (c) Zolution Software Ltd. All rights reserved.
// Licensed under the MIT License, see LICENSE.txt in the solution root for license information


using System;
using System.Collections;
using System.Collections.Generic;

namespace Rezolver
{
    /// <summary>
    /// Captures the context of a resolve operation.  Publicly, only the <see cref="RequestedType"/>
    /// is captured; however, internally, it captures both the original <see cref="Rezolver.Container"/>
    /// and <see cref="ContainerScope"/>.
    /// </summary>
    /// <remarks>Every resolve operation that your code produces (and many internally generated ones) rely
    /// on this type.  The code generated by the expression compiler will also reference the current context,
    /// particularly to ensure that the correct scope is used for tracking instances for the current operation.
    /// 
    /// When <see cref="Configuration.InjectResolveContext"/> is enabled (which it is by default in the 
    /// <see cref="TargetContainer.DefaultConfig"/>) this type then also becomes available for 
    /// injection so that your code can perform further resolve operations should it need to.
    /// </remarks>
    public sealed class ResolveContext : IServiceProvider, IEquatable<ResolveContext>
    {
        private readonly ContainerScope _scope;

        /// <summary>
        /// Gets the type being requested from the container.
        /// </summary>
        public Type RequestedType { get; private set; }

        internal Container Container => _scope.Container;

        /// <summary>
        /// Initializes a new instance of the <see cref="ResolveContext"/> class.
        /// </summary>
        /// <param name="container">The container.</param>
        /// <param name="requestedType">The type of object to be resolved from the container.</param>
        public ResolveContext(Container container, Type requestedType)
        {
            _scope = container._scope;
            RequestedType = requestedType;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ResolveContext"/> class from the given scope.
        ///
        /// The <see cref="Container"/> is inherited from the scope's <see cref="ContainerScope.Container"/>.
        /// </summary>
        /// <param name="scope">The scope.</param>
        /// <param name="requestedType">The of object to be resolved from the container.</param>
        public ResolveContext(ContainerScope scope, Type requestedType)
        {
            _scope = scope;
            RequestedType = requestedType;
        }

        /*****
         * Resolve operations on the ResolveContext don't allow for changing the scope.
         * You can request a different type, optionally from a different container, but
         * the scope is fixed.
         *****/

        /// <summary>
        /// Resolves a new instance of a different type from the same scope and container as this context.
        /// </summary>
        /// <typeparam name="TService">Type of service to be resolved.</typeparam>
        public TService Resolve<TService>()
        {
            return _scope.Resolve<TService>();
        }

        /// <summary>
        /// Resolves a new instance of a different type from the passed <paramref name="newContainer"/>, 
        /// fixing the scope to be the one from this context.
        /// </summary>
        /// <typeparam name="TService">Type of service to be resolved.</typeparam>
        /// <param name="newContainer">The container from which the service is to be resolved - note,
        /// even if this has its own scope, the scope which is captured by this context will be used.</param>
        public TService Resolve<TService>(Container newContainer)
        {
            return newContainer.ResolveInternal<TService>(ChangeContainer(newContainer));
        }

        /// <summary>
        /// Resolves a new instance of a different type from the same scope and container as this context.
        /// </summary>
        /// <param name="serviceType">Type of service to be resolved.</param>
        public object Resolve(Type serviceType)
        {
            return _scope.Resolve(serviceType);
        }

        /// <summary>
        /// Resolves a new instance of a different type from the passed <paramref name="newContainer"/>, 
        /// fixing the scope to be the one from this context.
        /// </summary>
        /// <param name="serviceType">Type of service to be resolved.</param>
        /// <param name="newContainer">The container from which the service is to be resolved - note,
        /// even if this has its own scope, the scope which is captured by this context will be used.</param>
        /// <returns></returns>
        public object Resolve(Type serviceType, Container newContainer)
        {
            // switching contains means creating a scope proxy which creates a temporary association between the 
            // scope and the new container.
            return newContainer.Resolve(new ResolveContext(new ContainerScopeProxy(_scope, newContainer), serviceType));
        }

        /// <summary>
        /// Resolves an enumerable of <paramref name="serviceType"/> from the current container.
        /// </summary>
        /// <param name="serviceType">The type of services required.</param>
        public IEnumerable ResolveMany(Type serviceType)
        {
            return (IEnumerable)_scope.Resolve(typeof(IEnumerable<>).MakeGenericType(serviceType));
        }

        /// <summary>
        /// Resolves an enumerable of <typeparamref name="TService"/> from the current container.
        /// </summary>
        /// <typeparam name="TService">Type of services required.</typeparam>
        /// <returns></returns>
        public IEnumerable<TService> ResolveMany<TService>()
        {
            return _scope.Resolve<IEnumerable<TService>>();
        }

        /// <summary>
        /// Creates a new <see cref="ResolveContext"/> with the same container/scope, but with a new
        /// <see cref="RequestedType"/>
        /// </summary>
        /// <param name="serviceType">The new service type</param>
        public ResolveContext ChangeRequestedType(Type serviceType)
        {
            if (serviceType != RequestedType)
                return new ResolveContext(_scope, serviceType);

            return this;
        }

        /// <summary>
        /// Creates a new context with the same <see cref="RequestedType"/> but switches to a new container,
        /// but keeping the current scope.
        /// </summary>
        /// <param name="newContainer">The container from which the service is to be resolved - note,
        /// even if this has its own scope, the scope which is captured by this context will be used.</param>
        public ResolveContext ChangeContainer(Container newContainer)
        {
            // we have to create a new 'fake' scope which proxies the current one,
            // but with a different container.
            if (newContainer != Container)
                return new ResolveContext(new ContainerScopeProxy(_scope, newContainer), RequestedType);

            return this;
        }

        /// <summary>
        /// Creates a new scope
        /// </summary>
        public ContainerScope CreateScope() => _scope.CreateScope();

        /// <summary>
        /// Implements the <see cref="object.GetHashCode"/> method using the hash code of
        /// the <see cref="RequestedType"/>
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode() => RequestedType.GetHashCode();

        /// <summary>
        /// Returns a <see cref="string" /> that represents this instance.
        /// </summary>
        public override string ToString()
        {
            return $"(Type: {RequestedType}, Scope: {_scope})";
        }

        object IServiceProvider.GetService(Type serviceType)
        {
            return ((IServiceProvider)_scope).GetService(serviceType);
        }

        bool IEquatable<ResolveContext>.Equals(ResolveContext other)
        {
            // two contexts are equal if their requested type is the same
            return RequestedType == other.RequestedType;
        }

        internal T ActivateImplicit_ThisScope<T>(T instance)
        {
            if (!_scope._canActivate)
                return instance;
            return _scope.ActivateImplicit(instance);
        }

        internal T ActivateImplicit_RootScope<T>(T instance)
        {
            if (!_scope._root._canActivate)
                return instance;
            return _scope._root.ActivateImplicit(instance);
        }

        internal T ActivateExplicit_ThisScope<T>(int targetId, Func<ResolveContext, T> instanceFactory)
        {
            if (!_scope._canActivate)
                throw new NotSupportedException("No scope explicitly created; either resolve from a new scope; or use ScopedContainer");
            return _scope.ActivateExplicit(this, targetId, instanceFactory);
        }

        internal T ActivateExplicit_RootScope<T>(int targetId, Func<ResolveContext, T> instanceFactory)
        {
            if (!_scope._root._canActivate)
                throw new NotSupportedException("Root scope cannot track instances; either resolve from a new scope; or use ScopedContainer");
            return _scope._root.ActivateExplicit(this, targetId, instanceFactory);
        }
    }
}
