// Copyright (c) Zolution Software Ltd. All rights reserved.
// Licensed under the MIT License, see LICENSE.txt in the solution root for license information


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Rezolver
{
	/// <summary>
	/// Contains extension methods for the <see cref="IScopedContainer" /> interface which provide some additional
	/// shortucts for getting or adding objects from/to scopes.
	/// </summary>
	public static partial class ScopedContainerScopeExtensions
	{
		/// <summary>
		/// Retrieves a single instance that was previously added to the scope (or,
		/// optionally parent scopes) through a call to <see cref="IScopedContainer.AddToScope"/> 
		/// with a ResolveContext matching the one passed.
		/// 
		/// Note - if multiple matches are found in a single scope, an InvalidOperationException will be thrown.
		/// </summary>
		/// <param name="scope">Required.  The scope to be searched and optionally whose parent scopes
		/// are to be searched.</param>
		/// <param name="context">Required.  The context whose properties will be used to find the
		/// matching disposable.</param>
		public static object GetSingleFromScope(this IScopedContainer scope, ResolveContext context)
		{
			scope.MustNotBeNull("scope");
			context.MustNotBeNull("context");
			//this method is written in such a way as to avoid realising the enumerable to get the count
			//of items found.
			object result = null;

			var enumerable = scope.GetFromScope(context);
			var enumerator = enumerable.GetEnumerator();

			if (enumerator.MoveNext())
			{
				result = enumerator.Current;
				if (enumerator.MoveNext())
					throw new InvalidOperationException(ExceptionResources.MoreThanOneObjectFoundInScope);
			}

			return result;
		}

		/// <summary>
		/// As the name suggests - this grabs the root scope for the scope on which this method is invoked.
		/// </summary>
		/// <param name="scope">The scope whose root scope is sought.  If null, then the method also returns null.</param>
		/// <returns>An <see cref="IScopedContainer"/> reference representing the top-level (root) scope
		/// for the passed scope.</returns>
		public static IScopedContainer GetScopeRoot(this IScopedContainer scope)
		{
			if (scope == null)
				return null;

			while (scope.ParentScope != null)
			{
				scope = scope.ParentScope;
			}

			return scope;
		}


		/// <summary>
		/// Retrieves an object from scope or adds it (by calling the <paramref name="factory"/> before returning it.
		/// </summary>
		/// <typeparam name="T">Type of object being created and/or retrieved from the scope.</typeparam>
		/// <param name="scope">The scope.</param>
		/// <param name="context">The context.</param>
		/// <param name="factory">The factory.</param>
		/// <param name="disposableOnly">if set to <c>true</c> then object only gets added to the scope if it's
		/// has the IDisposable interface..</param>
		public static T GetOrAdd<T>(this IScopedContainer scope, ResolveContext context, Func<ResolveContext, T> factory, bool disposableOnly = true)
		{
			//this is a temporary implementation of this method for the time being which is not entirely thread-safe.
			//I'll make it part of the Interface and implement it properly eventually

			if (disposableOnly && !TypeHelpers.AreCompatible(typeof(T), typeof(IDisposable)))
				return factory(context);

			var obj = scope.GetSingleFromScope(context);
			if (obj == null)
				scope.AddToScope(obj = factory(context), context);

			return (T)obj;
		}

		/// <summary>
		/// Retrieves an object from scope or adds it (by calling the <paramref name="factory"/> before returning it.
		/// </summary>
		/// <param name="scope">The scope.</param>
		/// <param name="context">The context.</param>
		/// <param name="factory">The factory.</param>
		/// <param name="disposableOnly">if set to <c>true</c> then object only gets added to the scope if it's
		/// has the IDisposable interface..</param>
		public static object GetOrAdd(this IScopedContainer scope, ResolveContext context, Func<ResolveContext, object> factory, bool disposableOnly = true)
		{
			//this is a temporary implementation of this method for the time being which is not entirely thread-safe.
			//I'll make it part of the Interface and implement it properly eventually
			if (disposableOnly && !TypeHelpers.AreCompatible(context.RequestedType, typeof(IDisposable)))
				return factory(context);

			var obj = scope.GetSingleFromScope(context);
			if (obj == null)
				scope.AddToScope(obj = factory(context), context);

			return obj;
		}

		/// <summary>
		/// This is primarily used by the dynamic code generated by RezolveTargetBase - if the scope is non-null
		/// and the instance is an IDiposable, then the object will be added to the scope.
		/// 
		/// The <paramref name="instance"/>, either way, is returned to simplify the function's use in dynamic code 
		/// produced from expression trees.
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="scope"></param>
		/// <param name="instance"></param>
		/// <returns></returns>
		public static T TrackIfScopedAndDisposableAndReturn<T>(this IScopedContainer scope, T instance)
		{
			if (scope != null && instance is IDisposable)
				scope.AddToScope(instance);

			return instance;
		}
	}
}
