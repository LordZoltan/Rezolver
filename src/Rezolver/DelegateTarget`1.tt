<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ output extension="cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
// Copyright (c) Zolution Software Ltd. All rights reserved.
// Licensed under the MIT License, see LICENSE.txt in the solution root for license information

using System;

namespace Rezolver
{
<#  
	var nthParamDescriptors = new[] { "st", "nd", "rd", "th" };
  	string[] typeParamStrings = new string[16];
	NameAndDescriptor[][] allTypeNamesAndDescriptors= new NameAndDescriptor[16][];
	string typeParamsString;
	NameAndDescriptor[] typeNamesAndDescriptors;

	for(var f = 0; f<16; f++)
	{ 
		var typeParamNames = (f == 1 ? new[] {"T"} : Enumerable.Range(1, f).Select(i => $"T{i}")).Concat(new[] { "TResult" }).ToArray();
		var typeParamDescriptors = typeParamNames.Select((s, i) => s != "TResult" ? string.Format("{0}{1}", i+1, i < nthParamDescriptors.Length ? nthParamDescriptors[i] : nthParamDescriptors[nthParamDescriptors.Length - 1 ]) : "").ToArray();
		typeParamsString = typeParamStrings[f] = string.Join(", ", typeParamNames);
		typeNamesAndDescriptors = allTypeNamesAndDescriptors[f] = typeParamNames.Zip(typeParamDescriptors, (n,d) => new NameAndDescriptor() { Name=n, Descriptor=d }).Where(tp => tp.Name!="TResult").ToArray();
#>

	/// <summary>
	/// Extension of the <see cref="DelegateTarget"/> class which provides strong typing for the generic Func delegate type.
	/// </summary>
<#
		foreach(var typeNameAndDescriptor in typeNamesAndDescriptors){
#>	/// <typeparam name="<#= typeNameAndDescriptor.Name #>"><#= string.Format("The type of the {0} delegate parameter (will be resolved automatically)", typeNameAndDescriptor.Descriptor) #></typeparam>
<#		
		} #>
	/// <typeparam name="TResult">The type of object produced by the delegate.</typeparam>
	/// <remarks>
	/// This class and its other generic cousins exist purely to simplify the creation of a <see cref="DelegateTarget"/>
	/// with a delegate expressed as a lambda expression.
	/// 
	/// e.g. <code>new DelegateTarget&lt;IMyservice&gt;(() =&gt; new MyService());</code>
	/// 
	/// With the <see cref="DelegateTarget"/> it is not possible to do this - you need a delegate variable.
	/// 
	/// Ultimately, however, all functionality beyond construction is provided by the base class.
	/// </remarks>
	public class DelegateTarget<<#= typeParamsString #>> : DelegateTarget
	{
		/// <summary>
		/// Initializes a new instance of the <see cref="DelegateTarget{<#= typeParamsString #>}"/> class.
		/// </summary>
		/// <param name="factory">The factory.</param>
		/// <param name="declaredType">Type of the declared.</param>
		public DelegateTarget(Func<<#= typeParamsString #>> factory, Type declaredType = null)
			: base(factory, declaredType)
		{

		}
	}	
<#	} #>
	
	// extension of partial class found in ITargetContainer.DelegateExtensions
	public static partial class DelegateTargetContainerExtensions
	{ 
<#
	for(int f = 0; f<16; f++) 
	{ 
		typeParamsString = typeParamStrings[f];
		typeNamesAndDescriptors = allTypeNamesAndDescriptors[f]; 

#>		
		/// <summary>Creates a <see cref="DelegateTarget{ <#= typeParamsString #> }" /> and registers it in the given
		/// <paramref name="targetContainer" />, optionally with the given <paramref name="declaredType" /> as its
        /// <see cref="ITarget.DeclaredType" /></summary>
<#
		foreach(var typeNameAndDescriptor in typeNamesAndDescriptors){
#>		/// <typeparam name="<#= typeNameAndDescriptor.Name #>"><#= string.Format("The type of the {0} delegate parameter (will be resolved automatically)", typeNameAndDescriptor.Descriptor) #></typeparam>
<#		
		} #>
		/// <typeparam name="TResult">The type of object produced by the delegate.</typeparam>
		/// <remarks>This is one of many generic extension methods that exist purely to simplify registering a 
		/// <see cref="DelegateTarget" /> with a delegate expressed as a lambda expression.
		/// Each of these generic overloads simply calls the non-generic 
		/// <see cref="DelegateTargetContainerExtensions.RegisterDelegate" /> extension method.</remarks>
		public static void RegisterDelegate<<#=	typeParamsString #>>(this ITargetContainer targetContainer, Func<<#= typeParamsString #>> factory, Type declaredType = null)
		{
			targetContainer.RegisterDelegate((Delegate)factory, declaredType);
		}
<#	} 
#>	}
}
<#+
				private class NameAndDescriptor {
								public string Name { get; set; }
								public string Descriptor { get; set; }
				}
#>