using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

namespace Rezolver
{
	/// <summary>
	/// Abstract base class, suggested as a starting point for implementations of <see cref="ITarget"/>.
	/// </summary>
	public abstract class TargetBase : ITarget
	{
		private class RezolveTargetExpressionRewriter : ExpressionVisitor
		{
			readonly CompileContext _sourceCompileContext;

			public RezolveTargetExpressionRewriter(CompileContext context)
			{
				_sourceCompileContext = context;
			}
			public override Expression Visit(Expression node)
			{
				if (node != null)
				{
					if (node.NodeType == ExpressionType.Extension)
					{
						RezolveTargetExpression re = node as RezolveTargetExpression;
						if (re != null)
						{
							return re.Target.CreateExpression(_sourceCompileContext.New(re.Type));
						}
						RezolveContextPlaceholderExpression pe = node as RezolveContextPlaceholderExpression;
						if (pe != null)
							return _sourceCompileContext.RezolveContextParameter;
					}
				}
				return base.Visit(node);
			}
		}

		/// <summary>
		/// Required for the scope tracking wrapping code.
		/// </summary>
		private static readonly MethodInfo ILifetimeScopeRezolver_AddObject = MethodCallExtractor.ExtractCalledMethod((IScopedContainer s) => s.AddToScope(null, null));
		private static readonly MethodInfo ILifetimeScopeRezolver_TrackIfScopedAndDisposableAndReturnGeneric =
				MethodCallExtractor.ExtractCalledMethod(() => LifetimeScopeRezolverExtensions.TrackIfScopedAndDisposableAndReturn<object>(null, null)).GetGenericMethodDefinition();

		/// <summary>
		/// If false (the default) then any expression produced by <see cref="CreateExpressionBase(CompileContext)"/> will be automatically 
		/// wrapped in a block of boilerplate code that will push the return value into the <see cref="IScopedContainer"/> that is 
		/// in scope.
		/// 
		/// Override this in your target and return true to strip this automatic behaviour - either if the objects produced by the code generated by 
		/// your target is not suitable for scoping in this way, or if you handle the scoping manually.
		/// 
		/// Note - you can still call the <see cref="CreateScopeTrackingExpression(CompileContext, Expression)"/> method if the expression
		/// it generates is suitable for your use, just not where it would usually place it.
		/// </summary>
		protected virtual bool SuppressScopeTracking
		{
			get
			{
				return false;
			}
		}

		public virtual bool UseFallback
		{
			get { return false; }
		}

		/// <summary>
		/// Abstract method called to create the expression - this is called by <see cref="CreateExpression"/> after the
		/// target type has been validated, if provided.
		/// 
		/// Note - if your implementation needs to support dynamic Resolve operations from the rezolver that is passed
		/// to an IRezolver's Resolve method, you can use the <see cref="ExpressionHelper.DynamicRezolverParam"/> property,
		/// all the default implementations of this class (and others) use that by default.
		/// </summary>
		/// <param name="context">The current compile context</param>
		/// <returns></returns>
		protected abstract Expression CreateExpressionBase(CompileContext context);

		/// <summary>
		/// This is called by <see cref="CreateExpression(CompileContext)"/> after the derived class generates its expression
		/// via a call to <see cref="CreateExpressionBase(CompileContext)"/> - unless <see cref="SuppressScopeTracking"/> is true either 
		/// on this object, or on the passed <paramref name="context"/>.
		/// 
		/// The purpose is to generate the code that will ensure that any instance produced will be tracked in a lifetime scope,
		/// if required.
		/// </summary>
		/// <param name="context">The current compile context.</param>
		/// <param name="expression">The code generated from the <see cref="CreateExpressionBase(CompileContext)"/> method, albeit
		/// possibly rewritten and optimised.</param>
		/// <remarks>
		/// By default, if there is a lifetime scope, then its <see cref="IScopedContainer.AddToScope(object, RezolveContext)"/> 
		/// method is called with the object that's produced by the target, before the object is returned.  If there is no scope, then 
		/// no tracking is performed.
		/// 
		/// Note that, also, by default, an object will only be tracked in the scope if it's <see cref="IDisposable"/>.
		/// 
		/// As mentioned in the summary, if you need to disable the automatic generation of this scope tracking code, then you
		/// can override the <see cref="SuppressScopeTracking"/> property, and return false.  It can also be suppressed on a per-compilation
		/// basis by setting the <see cref="CompileContext.SuppressScopeTracking"/> property of the <paramref name="context"/> to true.
		/// 
		/// This is something that the <see cref="ScopedTarget"/> does on its nested target, since by definition it generates
		/// its own explicit scope tracking code.
		/// 
		/// If the target simply needs to select a different scope from the current (at the time <see cref="IContainer.Resolve(RezolveContext)"/> 
		/// is called), then it can override the <see cref="CreateScopeSelectionExpression(CompileContext, Expression)"/> method.
		/// </remarks>
		/// <returns></returns>
		protected virtual Expression CreateScopeTrackingExpression(CompileContext context, Expression expression)
		{
			return Expression.Call(ILifetimeScopeRezolver_TrackIfScopedAndDisposableAndReturnGeneric.MakeGenericMethod(expression.Type),
					CreateScopeSelectionExpression(context, expression), expression);
		}

		/// <summary>
		/// Called to generate the expression that represents the argument that'll be passed to the 
		/// <see cref="IScopedContainer.AddToScope(object, RezolveContext)"/> method when an object is being tracked in a lifetime scope.  
		/// By default, the base implementation generates an expression that represents null - because usually there really is little point in 
		/// adding a specific context along with the object being tracked, unless you're also grabbing instances back out of the scope which isn't
		/// done by the base class behaviour by default.
		/// </summary>
		/// <param name="context"></param>
		/// <param name="expression"></param>
		/// <returns></returns>
		protected virtual Expression CreateRezolveContextExpressionForScopeAddCall(CompileContext context, Expression expression)
		{
			return Expression.Default(typeof(RezolveContext));
		}

		/// <summary>
		/// Called by <see cref="CreateScopeTrackingExpression(CompileContext, Expression)"/> to generate the code that selects the correct 
		/// scope instance that is to be used for scope tracking for the object produced by the code generated by 
		/// <see cref="CreateExpressionBase(CompileContext)"/>.
		/// </summary>
		/// <param name="context"></param>
		/// <param name="expression"></param>
		/// <returns></returns>
		protected virtual Expression CreateScopeSelectionExpression(CompileContext context, Expression expression)
		{
			return context.ContextScopePropertyExpression;
		}

		/// <summary>
		/// Called to check whether a target can create an expression that builds an instance of the given <paramref name="type" />.
		/// </summary>
		/// <param name="type">Required</param>
		/// <returns><c>true</c> if this target supports the given type, <c>false</c> otherwise.</returns>
		public virtual bool SupportsType(Type type)
		{
			type.MustNotBeNull("type");
			return TypeHelpers.AreCompatible(DeclaredType, type);
		}

		/// <summary>
		/// Virtual method implementing IRezolveTarget.CreateExpression.  Rather than overriding this method,
		/// your starting point is to implement the abstract method <see cref="CreateExpressionBase"/>.
		/// </summary>
		/// <param name="context">The current compile context</param>
		/// <returns></returns>
		public virtual Expression CreateExpression(CompileContext context)
		{
			if (context.TargetType != null && !SupportsType(context.TargetType))
				throw new ArgumentException(String.Format(ExceptionResources.TargetDoesntSupportType_Format, context.TargetType),
					"targetType");

			if (!context.PushCompileStack(this))
				throw new InvalidOperationException(string.Format(ExceptionResources.CyclicDependencyDetectedInTargetFormat, GetType(), DeclaredType));

			try
			{
				var result = CreateExpressionBase(context);
				Type convertType = context.TargetType ?? DeclaredType;

				if (convertType == typeof(object) && TypeHelpers.IsValueType(result.Type)
					|| !TypeHelpers.IsAssignableFrom(convertType, DeclaredType)
					|| !TypeHelpers.IsAssignableFrom(convertType, result.Type))
					return Expression.Convert(result, convertType);

				result = new RezolveTargetExpressionRewriter(context).Visit(result);
				//if scope tracking isn't disabled, either by this target or at the compile context level, then we 
				//add the boilerplate to add this object produced to the current scope.
				if (!SuppressScopeTracking && !context.SuppressScopeTracking)
				{
					result = CreateScopeTrackingExpression(context, result);
				}

				return result;
			}
			finally
			{
				context.PopCompileStack();
			}
		}

		/// <summary>
		/// Gets the declared type of object that is constructed by this target.  This will be the return type of
		/// any expression built by <see cref="CreateExpression"/> unless otherwise instructed to build a different type.
		/// </summary>
		public abstract Type DeclaredType
		{
			get;
		}
	}
}
