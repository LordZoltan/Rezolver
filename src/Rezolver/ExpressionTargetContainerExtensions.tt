<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ output extension="cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
// Copyright (c) Zolution Software Ltd. All rights reserved.
// Licensed under the MIT License, see LICENSE.txt in the solution root for license information

using System;
using System.Linq.Expressions;

namespace Rezolver
{
<#  
	int next = 0;
	var nthParamDescriptors = new[] { "st", "nd", "rd", "th" };
  	string[] typeParamStrings = new string[31];
	string[] exprTypeParamStrings = new string[31];
	NameAndDescriptor[][] allTypeNamesAndDescriptors= new NameAndDescriptor[31][];
	string typeParamsString;
	string exprTypeParamsString;
	NameAndDescriptor[] typeNamesAndDescriptors;

	for(var f = 0; f<16; f++)
	{ 
		var typeParamNames = (f == 1 ? new[] {"T"} : Enumerable.Range(1, f).Select(i => $"T{i}")).Concat(new[] { "TResult" }).ToArray();
		var typeParamDescriptors = typeParamNames.Select((s, i) => s != "TResult" ? string.Format("{0}{1}", i+1, i < nthParamDescriptors.Length ? nthParamDescriptors[i] : nthParamDescriptors[nthParamDescriptors.Length - 1 ]) : "").ToArray();
		
		typeParamStrings[next] = exprTypeParamStrings[next] = string.Join(", ", typeParamNames);
		allTypeNamesAndDescriptors[next] = typeParamNames.Zip(typeParamDescriptors, (n,d) => new NameAndDescriptor() { Name=n, Descriptor=d }).Where(tp => tp.Name!="TResult").ToArray();
		next++;

		//when f <15, then we create a second version of the parameter strings which fix the first parameter to RezolveContext
		if(f<15){
			//keep the second parameter as T2, and so on.  So RezolveContext takes the place of T or T1
			typeParamNames = (f == 1 ? new[] {"T"} : Enumerable.Range(2, f).Select(i => $"T{i}")).Concat(new[] { "TResult" }).ToArray();
			typeParamDescriptors = typeParamNames.Select((s, i) => s != "TResult" ? string.Format("{0}{1}", i+2, (i+1) < nthParamDescriptors.Length ? nthParamDescriptors[i+1] : nthParamDescriptors[nthParamDescriptors.Length - 1 ]) : "").ToArray();
			typeParamStrings[next] = string.Join(", ", typeParamNames);
			allTypeNamesAndDescriptors[next] = typeParamNames.Zip(typeParamDescriptors, (n,d) => new NameAndDescriptor() { Name=n, Descriptor=d }).Where(tp => tp.Name!="TResult").ToArray();
			exprTypeParamStrings[next] = "ResolveContext, " + typeParamStrings[next];
			next++;
		}
	}
#>
	
	/// <summary>
	/// Contains numerous generic overloads of the RegisterExpression extension method for <see cref="ITargetContainer" />
	/// All of these extensions act as proxies for the 
	/// <see cref="ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type)"/> extension
	/// method. 
	/// </summary>
	public static partial class ExpressionTargetContainerExtensions
	{ 
<#
	for(int f = 0; f<typeParamStrings.Length; f++) 
	{ 
		typeParamsString = typeParamStrings[f];
		exprTypeParamsString = exprTypeParamStrings[f];
		typeNamesAndDescriptors = allTypeNamesAndDescriptors[f]; 

#>		
		/// <summary>Creates a target from the lambda expression and registers it in the 
		/// <paramref name="targetContainer" />, optionally against the given <paramref name="type" />.</summary>
<#
		foreach(var typeNameAndDescriptor in typeNamesAndDescriptors){
#>		/// <typeparam name="<#= typeNameAndDescriptor.Name #>"><#= string.Format("The type of the {0} lambda parameter (will be resolved automatically)", typeNameAndDescriptor.Descriptor) #></typeparam>
<#		
		} #>
		/// <typeparam name="TResult">The type of object produced by the lambda expression.</typeparam>
		/// <param name="targetContainer">The container which will receive the registration</param>
		/// <param name="expression">The lambda expression that is to be converted into a target and registered</param>
		/// <param name="type">The type for which the registration will be made, if different from the expression's type</param>
		/// <remarks>This function ultimately forwards the call through to the non generic extension method
		/// <see cref="ExpressionTargetContainerExtensions.RegisterExpression(ITargetContainer, Expression, Type)"/>, which 
		/// simply wraps the expression into an <see cref="ExpressionTarget"/> and then registers it against either 
		/// the passed <paramref name="type" />, or the created target's <see cref="ITarget.DeclaredType" /> if not provided.
		/// </remarks>
		public static void RegisterExpression<<#= typeParamsString #>>(this ITargetContainer targetContainer, Expression<Func<<#= exprTypeParamsString #>>> expression, Type type = null)
		{
			targetContainer.RegisterExpression((Expression)expression, type);
		}
<#	} 
#>	}
}
<#+
				private class NameAndDescriptor {
								public string Name { get; set; }
								public string Descriptor { get; set; }
				}
#>